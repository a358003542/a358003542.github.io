Date: 20220328


[TOC]

## 注重实效的程序员
实时不断地批判思考你的工作。

### 负责
提供各种选项，不要找借口。

- 原型
- 重构
- 易于测试的代码
- 自动化
- 无情的测试

### 软件的熵
不要留着低劣的设计，错误的决策，糟糕的代码不修理，发现一个修一个，如果没有足够的时间，则要标记出来。一个整洁的运行良好的系统，就是因为这些小问题而最终腐烂变成大型垃圾堆。

- 重构
- 注重实效的团队

### 你的知识资产
如同管理金融资产一样，经营好你的知识资产。

- 每年至少学习一种新的语言
- 每季度阅读一本技术书籍
- 也要阅读一些非技术书籍
- 试验不同的环境
- 不时上网了解新的技术

### 交流

### 不要重复你自己
除了一些必要的重复【一般来说这些所谓的必要重复大多是因为针对不同的信息接受者，所以需要重复。比如代码里面的注释和文档是针对不同的信息接受者的；再比如即使是程序员编写的代码还可以细分，有面向本模块开发人员和面向本模块外部使用者这两个信息接受者的不同，这个时候针对不同的受众发生一些必要的信息重复也是可以接受的。】，其他情况程序员都应该遵守DRY原则，即相同的知识信息表述不应该出现两次。

### 去耦合
编写组件去耦合的正交系统，有两个好处：

#### 提高生产率 
- 改动得以局部化，所以开发的时间和测试的时间得以降低。
- 组件的去耦合促进组件的复用
- 对去耦合的组件再进行组合，生产率会有所提高。

#### 降低风险
- 正交的系统可以更好地测试
- 有问题的代码被隔离开来，整个系统更健壮。

#### 编码去耦合实践
- 编写代码保持解耦
- 避免使用全局数据，推荐采用语境传入模块的方式【当然这里的全局数据指的是全局变量，全局常数不在这里的讨论范围之内。】。全局数据会因为多线程多进程的情况而带来麻烦。设计模式中的单例模式一般会将其做成全局变量，在某些情况下这可能不是一个好的实现方案。
- 避免编写相似的函数

### 可撤销性
尽可能让你的项目设计采用更灵活的架构和编码，比如关系型数据库的切换，客户-服务器模型到单机版的切换等等，你目前的项目当然会做出决策对某个技术组件进行了选择，但不要让这个选择成为了所谓的最终决策，你的项目的组件具有可撤销性，你可能会额外付出一点小小的劳动，但不会太多，就能完成你的项目的组件技术类型切换。

### 善用原型进行学习
应制作原型的事物：
- 架构
- 已有系统的新功能
- 外部数据的结构或内容
- 第三方工具和组件
- 性能问题
- 用户界面设计

要为了学习而制作原型，对于程序员来说原型也不单指代码，纸上绘制的原型设计同样也很好。对于编码上的原型来说一般是推荐使用高级编程语言。


### 靠近问题领域编程
让你的项目更靠近问题领域，在更高的抽象层面编码，刚开始代码不必要是可运行的，留下TODO标识等待后续去实现语言细节，好让你能够 **面向问题领域编程** 。

从问题领域语言到你的编程语言，你可能需要去实现一个小型的语言来实现这种转换。

## 工具
程序员工具的重要性不言而喻。

编辑器，shell命令，版本控制，调试工具等等，程序员应该经营好自己的工具库和磨练好自己的工具技能。

调试第一切记：Don‘t Panic 不要恐慌。 

调试第一步：重现bug。调试第二步：打印出来。调试第三步：跟踪确诊。

### 代码生成器
程序员应该试着编写能够生成代码的代码生成器。这里所谓的代码生成器不一定是很复杂的东西；这些所谓的生成代码不单指编程语言，代码内部使用的HTML，纯文本等内容都在考虑范围内。

## 你不可能写出完美的程序
### 按照合约设计函数或者方法
函数有文档记载要做什么事，那么就不多不少做那些事。

调用者满足函数约定的前条件，则可以执行该函数。函数应该保证在其完成时，所有后条件和不变项为真。

后条件是函数退出时的条件，不变项是从调用者角度来看，这些不变项总应该为真。如果不变项失效则认为合约失效，应该立即抛出异常或终止程序。



### 早崩溃
当你的代码遇到某些不可能的事情正在发生时，程序应当立即崩溃，而不是让坏程序继续运行下去制造破坏。

### 断言式编程
如果它不可能发生，那么用断言确保它不可能发生。

不要用断言代替异常等其他错误处理手段，断言的潜台词是这绝不应该发生。

让断言开着，所谓的测试完之后完美的程序并不存在。可以适当因为性能问题注释掉某些断言语句。

### 适时使用异常
你的程序在面对正常情况时是不应该触发异常或者进入异常语句，否则你可能滥用异常语句了，一般来说异常只对于那些异常情况才会触发。

### 资源的分配
那个函数内部申请了某个资源（事务，内存，文件，线程等），那么它就应该负责该资源的释放工作。

那个函数内部申请了多个资源，那么它应该以相反的次序释放哪些资源。

异常情况下资源也应该得到合理的释放。

python的with语句对于资源的管理是一个不错的实践。





## 解耦再解耦
使模块之间的耦合减至最小。

否则你将发现你的项目正走在一条通往脆弱不灵活的未来的道路上，或者根本没有未来。
### 元程序设计
为一般情况编写程序，将具体的情况放在代码之外。

将抽象放进代码，细节放进元数据。元数据是关于数据的数据，比如数据库的schema或数据词典。要用元数据来描述应用的配置。

对于长时间运行的服务器进程，你可能需要实现在程序运行过程中重新读取和应用元数据。


### 总是为并发进行设计
通常人思考问题的方式总是线性的，表现为代码中的逻辑是依次进行的，这会无形中造成你的代码逻辑具有时间上的耦合性。我们应该容许并发，从而实现你的项目在一定程序上的时间解耦。

如果你的项目程序中的某个任务不依赖于其他任务，那么应该将这个任务实现时间解耦。对于那些解耦出来的任务，推荐用队列来管理。

因为并发的设计引入使得你的项目对每一个引入的全局变量都会持一种慎重的态度。



### 模型和视图解耦
模型和视图分离在某些领域已经是实践规范了，不过模型和视图分离的底层软件架构逻辑是，软件的各个组件模块解耦之后的沟通，最好采用事件驱动的方式来进行。

具体各个组件分为消息订阅者和消息发布者，消息发布者有消息时逐个调用消息订阅者的接口。

模型和视图解耦不单单指桌面应用上的开发，具体到软件架构各个组件各个模块，甚至是各个函数之间，都可以实现这种解耦。所谓模型层即数据层，其对应的就是消息的发布者，所谓视图层即数据的接受者，消息的订阅者。

### 消息发布者和订阅者的进一步解耦
消息发布者和订阅者之间还可以进一步解耦，原消息发布者是知道订阅者的，它们之间还可以进一步解耦，通过维护一个共同的数据空间，各自根据数据空间上的变化来决定自己的行为。


## 编码实践
### 不要靠巧合编程
- 不要使用你不熟悉的技术，希望靠着巧合程序运行起来。
- 对于编程中出现的任何假定条件都应该在文档中说明，然后按照合约编程。测试也不光要测试你的代码，也要测试你的假定。程序中包含任何隐含的假定条件都是指望程序靠着巧合运行起来。
- 不要做历史的奴隶，时刻准备好重构。

### 估算算法速率
对于程序的时间和空间开销时刻进行好估算工作。这种估算不是为了让你的程序的每一行代码都以最快的方式运行，而是提防那些时间或空间开销极大的代码。【程序员编写的大部分代码应该都在处理输入集很小的情况，这个时候不是最快的写法但是是程序员最容易看懂的写法反而是最好的写法。】

### 早重构常重构
以下是一些你需要进行重构工作的场景：
- 重复的代码
- 发现可以让代码更加去耦合
- 过时的知识
- 性能问题

只要发现程序中的代码有需要重构的部分，立刻就要开始着手进行重构，否则等肿瘤扩大甚至恶化之后则代价更高后果更严重。

重构行动需要遵守以下规则：
- 重构只负责重构，不要试着在重构的时候进行增加功能或者其他代码修改工作。
- 重构之前经过了良好的测试，重构之后确保能正常运行这些测试。
- 如果是某个特别复杂的重构，可能还需要将重构工作分成几个小步骤逐渐测试进行。

### 单元测试
单元测试的价值和重要性现在程序界已经基本上是公理般的存在了，即使是那些一行单元测试代码也不会写的程序员也是很认同单元测试的价值的，这点让我感到很欣慰。




