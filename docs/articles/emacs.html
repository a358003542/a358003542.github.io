<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta name="msvalidate.01" content="55CB117A61A6F8286173763FB18D9625" />

    <meta name="author" content="wanze" />
    <meta name="copyright" content="wanze" />

    <meta name="description"
        content="前言
其实在你打开emacs开始输入文本的那一刻起，你就已经入门了。emacs说到底只是一个功能特别强大的文本编辑器，它主要的角色还是文本编辑器，一切都是围绕这个来展开的。
基本术语

frame: emacs的图形界面或终端界面
menu: frame上方的菜单栏
tool: 菜单栏下面的工..." />


<meta name="keywords" content=", archived, " />

<title>emacs  -
    万泽的博客</title>

    <link href="https://a358003542.github.io/theme/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://a358003542.github.io/theme/bootstrap-icons/font/bootstrap-icons.css" rel="stylesheet">

    <link href="https://a358003542.github.io/theme/css/base.css" rel="stylesheet">

<link rel="stylesheet" href="https://a358003542.github.io/theme/css/pygments.css">
<link rel="stylesheet" href="https://a358003542.github.io/theme/css/article.css">
</head>

<body>
    <div class="flex-wrapper">
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <div class="container-fluid">
                <a class="navbar-brand" href="https://a358003542.github.io/">网站首页</a>

                <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse"
                    data-bs-target="#navbarContent" aria-controls="navbarContent" aria-expanded="false"
                    aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>


                <div class="navbar-collapse collapse" id="navbarContent">
                    <form action="https://a358003542.github.io/search.html" onsubmit="return validateForm(this.elements['q'].value);"
                        class="d-flex me-auto">

                        <input type="search" name="q" id="tipue_search_input" class="form-control me-2"
                            placeholder="Search..." aria-label="Search">

                        <button class="btn btn-outline-primary text-nowrap" type="submit">搜索</button>
                        
                    </form>


                    <ul class="navbar-nav mb-lg-0">

                        <li class="nav-item ">
                            <a class="nav-link "
                                href="/archives.html">所有博文</a>
                        </li>

                        <li class="nav-item ">
                            <a class="nav-link "
                                href="/categories.html">博文分类</a>
                        </li>

                        <li class="nav-item">
                            <a class="nav-link  " href="https://a358003542.github.io/about.html">关于本网站</a>
                        </li>
                    </ul>


                </div>
            </div>
        </nav>

        
        <main>
<div class="container-xxl mt-3">
    <div class="row">
        <div class="col-md-4 col-lg-3"></div>
        <header class="col-sm-12 col-md-8 col-lg-8 page-header">
            <h1><a href="https://a358003542.github.io/articles/emacs.html"> emacs  </a></h1>
        </header>
    </div>

    <div class="row">
        <div class="col-sm-12 col-md-4 col-lg-3">
            <div class="p-3 bg-white small">
                <div style="font-size:1.2rem;">目录</div>
                <div class="toc">
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#基本术语">基本术语</a></li>
<li><a href="#基本的快捷键操作">基本的快捷键操作</a><ul>
<li><a href="#文件操作">文件操作</a></li>
<li><a href="#emacs文件放在那里">.emacs文件放在那里</a></li>
<li><a href="#buffer操作">buffer操作</a></li>
<li><a href="#查找和替换">查找和替换</a></li>
</ul>
</li>
<li><a href="#lisp语法简介">lisp语法简介</a><ul>
<li><a href="#设置变量">设置变量</a></li>
<li><a href="#定义函数">定义函数</a></li>
</ul>
</li>
<li><a href="#一些配置简介">一些配置简介</a><ul>
<li><a href="#窗口最大化">窗口最大化</a></li>
<li><a href="#复制粘贴快捷键">复制粘贴快捷键</a></li>
</ul>
</li>
<li><a href="#自定义命令">自定义命令</a></li>
<li><a href="#clisp开发环境搭建">CLISP开发环境搭建</a><ul>
<li><a href="#利用quicklisp安装cl-project">利用quicklisp安装cl-project</a></li>
<li><a href="#加载自己编写的项目">加载自己编写的项目</a></li>
</ul>
</li>
<li><a href="#加入smex插件">加入smex插件</a><ul>
<li><a href="#自定义按键配置">自定义按键配置</a></li>
</ul>
</li>
<li><a href="#tab都自动换成space">tab都自动换成space</a></li>
<li><a href="#80列规则">80列规则</a></li>
<li><a href="#python模式">python模式</a><ul>
<li><a href="#分窗口控制">分窗口控制</a></li>
</ul>
</li>
<li><a href="#快速启动emacs">快速启动emacs</a><ul>
<li><a href="#关闭frame和以前的不同了">关闭frame和以前的不同了</a></li>
<li><a href="#字体问题">字体问题</a></li>
</ul>
</li>
<li><a href="#左侧文件树面板">左侧文件树面板</a><ul>
<li><a href="#pdf文件打开卡住问题">pdf文件打开卡住问题</a></li>
<li><a href="#可能的其他问题">可能的其他问题</a></li>
</ul>
</li>
<li><a href="#多个窗口之间的编号切换">多个窗口之间的编号切换</a></li>
<li><a href="#markdown模式">markdown模式</a></li>
<li><a href="#markdown实时预览">markdown实时预览</a></li>
<li><a href="#文字模式下的emacs操作">文字模式下的emacs操作</a><ul>
<li><a href="#移动光标">移动光标</a></li>
<li><a href="#切换窗口焦点">切换窗口焦点</a></li>
</ul>
</li>
</ul>
</div>

                <div class="p-1">首发于：<time pubdate="pubdate" datetime="2018-04-08T00:00:00+08:00">2018年 4月 8日 </time>
                </div>

                <div class="p-1">最近更新于：<time datetime="2023-10-13T14:58:09.747471+08:00">2023年 10月 13日 </time>
                </div>


                <div class="p-1">分类：
                <a class="category-link" href="https://a358003542.github.io/categories.html#archived-ref">archived</a>
                </div>
            </div>
        </div>

        <div class="col-sm-12 col-md-8 col-lg-8">
            <div class="article-content">
                
<h2 id="前言">前言</h2>
<p>其实在你打开emacs开始输入文本的那一刻起，你就已经入门了。emacs说到底只是一个功能特别强大的文本编辑器，它主要的角色还是文本编辑器，一切都是围绕这个来展开的。</p>
<h2 id="基本术语">基本术语</h2>
<ul>
<li><strong>frame:</strong> emacs的图形界面或终端界面</li>
<li><strong>menu:</strong> frame上方的菜单栏</li>
<li><strong>tool:</strong> 菜单栏下面的工具栏</li>
<li><strong>echo:</strong> 主编辑窗口下面的响应信息，minibuffer也在这里显示。</li>
<li><strong>window:</strong> tool下面echo上面的主区域就是window区域，emacs可以分出很多个window出来，任何时候指的window是当前选中的那个window，同样emacs可以有很多buffer，当前选中的window对应的buffer为current buffer。</li>
<li><strong>buffer:</strong> 每一个window具体编辑的就是一个buffer</li>
<li><strong>scroll bar:</strong> window的一边有一个scroll bar</li>
<li><strong>mode line:</strong> window的下面有一行mode line 格式如下:</li>
<li><strong>point:</strong> 当前window下cursor的位置叫做point，具体emacs光标或覆盖在frob的o上，那么point的位置是在r和o之间。</li>
</ul>
<h2 id="基本的快捷键操作">基本的快捷键操作</h2>
<p>快捷键用的最多的是C和M这两个字母，其中C是Control键，而M一般是Alt键吧。然后 <code>C-w</code> 表示同时按下Control键和w字母。然后 <code>C-x C-c</code> 中间有个空格，表示先按Ctrl+字母x，再停顿一下，然后再按Ctrl+字母c——这是退出emacs的命令。</p>
<p>S表示Shift键，小写s表示Super键这个了解下，然后 <code>C-x 0</code> 表示关闭当前窗口， <code>C-x 1</code> 表示只留当前一个窗口， <code>C-x 2</code> 表示下面新开一个窗口， <code>C-x 3</code> 表示右边新开一个窗口。</p>
<p><code>M+x</code> 执行emacs lisp的内部命令， <code>C-g</code> 取消你在minibuff中一般的输入，这些都是很基本的了，读者请记住。</p>
<p><code>M+x shell</code> 进入shell，你可能同时需要在shell里面输入某些命令。</p>
<h3 id="文件操作">文件操作</h3>
<ul>
<li><code>C-x C-f</code>  新建一个文件</li>
<li><code>C-x C-s</code> 保存当前文件</li>
</ul>
<h3 id="emacs文件放在那里">.emacs文件放在那里</h3>
<p>其实你可以利用上面的新建文件保存文件操作来大概揣测到你当前的emacs系统【比如<strong>Portacle</strong> 里面的emacs配置文件在哪里】，就新建一个 <code>~/test.txt</code> 即可。 </p>
<h3 id="buffer操作">buffer操作</h3>
<p><code>C-x k</code> 关闭当前buffer</p>
<h3 id="查找和替换">查找和替换</h3>
<p>查找和替换操作经常用到，所以快捷键最好也记住。向后查找的按键是 <code>C-s</code> ，你看快捷键这么简短，就说明这是一个很重要的快捷键。然后向前查找是 <code>C-r</code> 。继续向前或向后查找就是继续按 <code>C-s</code> 和 <code>C-r</code> 。</p>
<p>替换操作的按键是 <code>M-%</code> ,先要输入匹配的字符串，然后输入要替换成为什么，然后接下来 按键 <strong>y</strong> 表示替换，按键 <strong>n</strong> 表示不替换，按键 <strong>!</strong> 表示全部替换。</p>
<h2 id="lisp语法简介">lisp语法简介</h2>
<p>在进入接下来的讨论之前，先简单介绍下lisp的语法，这里不是要让读者学会lisp语言了，而是为了让你对接下来要接触的最基本的emacs lisp语法不会感到恐惧。</p>
<p>以下例子读者如果有兴趣可以进入elisp的交互环境试验一下，具体按键是：</p>
<div class="highlight"><pre><span></span><code>M-x ielm
</code></pre></div>
<p>lisp语言的一大特色就是里面的程序和数据都是列表，如</p>
<div class="highlight"><pre><span></span><code>'(1, 2, 3)
</code></pre></div>
<p>这样的形式。</p>
<p>这个引号很关键，因为你输入给lisp的字符串都会被eval一次，然后前面加个引号，那么里面的东西eval一次之后就成(1, 2, 3)这样的形式了（即去掉引号），也就是列表数据了。</p>
<p>那么下面这个是什么呢？</p>
<div class="highlight"><pre><span></span><code>x
'x
</code></pre></div>
<p>上面的x如果被送入eval的话，将会发生寻址操作，也就是成变量了；而第二个x加上引号，eval之后，去掉引号，就是x这样的形式了，我们可以把这个x看作字符串，当然如果我们要将其送入eval，那么你可以认为这个x字符串又变成变量了。</p>
<p>然后lisp中程序的结构就是一系列和数学结构类似的括号，学过数学括号结构的都知道，先算里面的再算外面的…….，直到最终算成这样的形式</p>
<div class="highlight"><pre><span></span><code>(+ 1 1)
</code></pre></div>
<p>lisp实际上也是类似的这样运算的，上面的(+ 1 1)送入lisp运算就会得到2。lisp处理这样的结构有一个原则，总认为这样的括号的第一个元素是一个函数，如果不是，将会发生错误。然后后面的东西都是一系列管他什么的参数。</p>
<p>然后再来讲讲设置变量和定义函数。</p>
<h3 id="设置变量">设置变量</h3>
<p>设置变量有两个方法，一般为了方便使用的是setq吧。</p>
<div class="highlight"><pre><span></span><code>(set 'x 1)
(setq x 1)
</code></pre></div>
<p>set和setq的区别就在那个引号，setq不需要加上那个引号，第一个元素的字符形式总被视作变量。</p>
<h3 id="定义函数">定义函数</h3>
<p>最简单的形式如下所示：</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">add</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">))</span>
</code></pre></div>
<p>这样你就定义了一个add函数，然后(add x y)实际上就是执行的是(+ x y )。</p>
<p>最简单的lisp语法简介就是这么多了，后面还会接触一些，当然要深入起来里面内容还很丰富的，但目前已经够我们继续探索下去了。</p>
<h2 id="一些配置简介">一些配置简介</h2>
<p>在 <code>.emacs</code> 里面可以如下通过一些elisp语句来进行emacs的一些配置。然后 <strong>protacle</strong> 配置推荐在 <code>C:\Users\wz-game\portacle\config\user.el</code> 哪里配置。</p>
<ul>
<li><strong>set-default-font:</strong> 设置默认字体</li>
<li><strong>set-frame-attribute:</strong> 设置默认字体大小</li>
</ul>
<p>以上两个命令一般放入.emacs文件中，如下配置成为全局配置。</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">set-default-font</span><span class="w"> </span><span class="s">"DejaVu Sans Mono"</span><span class="p">)</span><span class="c1">;设置默认字体</span>
<span class="p">(</span><span class="nv">set-frame-attribute</span><span class="w"> </span><span class="ss">'default</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="ss">:height</span><span class="w"> </span><span class="mi">110</span><span class="p">)</span><span class="c1">;设置默认字体大小11pt</span>
</code></pre></div>
<h3 id="窗口最大化">窗口最大化</h3>
<p><strong>toggle-frame-maximized:</strong> 窗口最大化</p>
<p>你可以将其加入.emacs文件让你的emacs一打开就窗口最大化。 <em>注意本命令只适用于emacs24.4+的版本。</em> </p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">toggle-frame-maximized</span><span class="p">)</span>
</code></pre></div>
<p>如果是emacs24.4之前的版本你想启动之后就窗口最大化，参考 <a href="http://emacs.stackexchange.com/questions/2999/how-to-maximize-my-emacs-frame-on-start-up">这个网站</a> ，在你的emacs初始化脚本上加上这么一句即可：</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">add-to-list</span><span class="w"> </span><span class="ss">'default-frame-alist</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nv">fullscreen</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">maximized</span><span class="p">))</span>
</code></pre></div>
<h3 id="复制粘贴快捷键">复制粘贴快捷键</h3>
<p>复制粘贴快捷键改成常见的 Ctrl+C 和 Ctrl+V 快捷键：</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">cua-mode</span><span class="w"> </span><span class="no">t</span><span class="p">)</span>
</code></pre></div>
<p>更多信息参见emacs的 <a href="https://www.emacswiki.org/emacs/CuaMode">CUA模式</a> 。</p>
<ul>
<li><strong>global-visual-line-mode:</strong> 显示的段落自动换行</li>
</ul>
<p>如下加入.emacs文件中你可以让你的emacs显示的文件段落会自动换行。</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">global-visual-line-mode</span><span class="w"> </span><span class="no">t</span><span class="p">)</span>
</code></pre></div>
<ul>
<li>
<p><strong>help-with-tutorial:</strong> 默认按键"C-h t"，打开新手教程</p>
</li>
<li>
<p><strong>describe-key:</strong> 默认按键是"C-h k"，描述某个按键</p>
</li>
<li><strong>describe-function:</strong> 默认按键"C-h f"， 描述某个函数</li>
<li><strong>describe-variable:</strong> 默认按键"C-h v"，描述某个变量</li>
</ul>
<p>通过以上三个函数你能够学习到emacs lisp的很多内部知识，是一条不错的获取信息的来源<sup><a class="footref" href="#fn.1" id="fnr.1">1</a></sup>。</p>
<p>比如之前的"C-x 1"等等按键对应的命令如下：</p>
<ul>
<li><strong>delete-other-windows:</strong> 默认按键"C-x 1"，关闭其他窗口</li>
<li><strong>split-window-below:</strong> 默认按键"C-x 2"，下面新开一个窗口</li>
<li><strong>split-window-right:</strong> 默认按键"C-x 3"，右边新开一个窗口</li>
<li>
<p><strong>delete-window:</strong> 默认按键"C-x 0"，删除当前窗口</p>
</li>
<li>
<p><strong>global-linum-mode:</strong> 左侧显示行号 【portacle那边不推荐了】</p>
</li>
</ul>
<p>如下加入.emacs文件中你可以让你的emacs左侧永远显示行号，参考了 <a href="http://stackoverflow.com/questions/2034470/how-do-i-enable-line-numbers-on-the-left-everytime-i-open-emacs">这个网页</a> 。</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">global-linum-mode</span><span class="w"> </span><span class="no">t</span><span class="p">)</span>
</code></pre></div>
<h2 id="自定义命令">自定义命令</h2>
<p>下面这几个命令也很常用，我们可以将其定义为更加简短一点的命令</p>
<ul>
<li><strong>kill-buffer:</strong> 默认按键"C-x k"，关闭当前buffer。</li>
<li><strong>switch-to-buffer:</strong> 默认按键"C-x b"，切换buffer。</li>
<li><strong>find-file:</strong> 默认按键"C-x C-f"，打开文件</li>
<li><strong>save-buffer:</strong> 默认按键"C-x C-s"，保存某个buffer，或者说通常意义上的保存文件。</li>
<li><strong>save-some-buffers:</strong> 默认按键"C-x s"，保存所有buffer，或者说保存所有文件。</li>
<li><strong>save-buffers-kill-terminal:</strong> 默认按键"C-x C-c"，退出emacs。</li>
</ul>
<p>你可以通过defun来定义新的函数，这里采用一种简单的机制defalias来给原函数取一个新的名字：</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">defalias</span><span class="w"> </span><span class="ss">'open</span><span class="w"> </span><span class="ss">'find-file</span><span class="p">)</span>
<span class="p">(</span><span class="nv">defalias</span><span class="w"> </span><span class="ss">'save</span><span class="w"> </span><span class="ss">'save-buffer</span><span class="p">)</span>
<span class="p">(</span><span class="nv">defalias</span><span class="w"> </span><span class="ss">'saveall</span><span class="w"> </span><span class="ss">'save-some-buffers</span><span class="p">)</span>
<span class="p">(</span><span class="nv">defalias</span><span class="w"> </span><span class="ss">'kill</span><span class="w"> </span><span class="ss">'kill-buffer</span><span class="p">)</span>
<span class="p">(</span><span class="nv">defalias</span><span class="w"> </span><span class="ss">'buffer</span><span class="w"> </span><span class="ss">'switch-to-buffer</span><span class="p">)</span>
</code></pre></div>
<p>然后我们再进入emacs，我们发现smex里面多了一个open命令，之前没有的，然后原有的find-file命令也还在。</p>
<h2 id="clisp开发环境搭建">CLISP开发环境搭建</h2>
<p>推荐使用 <strong>protacle</strong> 。</p>
<h3 id="利用quicklisp安装cl-project">利用quicklisp安装cl-project</h3>
<p>在slime-repl里面输入：</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">ql:quickload</span><span class="w"> </span><span class="ss">:quickproject</span><span class="p">)</span>
<span class="p">(</span><span class="nv">quickproject:make-project</span><span class="w"> </span><span class="s">"wanze_clisp_project"</span><span class="p">)</span>
</code></pre></div>
<p>这就是一个快速创建lisp项目的模板项目，参考一下即可。</p>
<p>quicklisp 大概有这些操作：</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">ql:quickload</span><span class="w"> </span><span class="s">"vecto"</span><span class="p">)</span><span class="w"> </span>
<span class="p">(</span><span class="nv">ql:uninstall</span><span class="w"> </span><span class="nv">system-name</span><span class="p">)</span>
</code></pre></div>
<h3 id="加载自己编写的项目">加载自己编写的项目</h3>
<p>新建的项目移动到 protacle 安装目录的 projects那个文件夹下，然后就可以调用：</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">ql:quickload</span><span class="w"> </span><span class="s">"wanze_clisp_project"</span><span class="p">)</span><span class="w"> </span>
</code></pre></div>
<p>但是这样加载之后还什么东西都没有，package.lisp 下如要加上如下内容：</p>
<div class="highlight"><pre><span></span><code><span class="c1">;;;; package.lisp</span>

<span class="p">(</span><span class="nb">defpackage</span><span class="w"> </span><span class="ss">#:wanze_clisp_project</span>
<span class="w">  </span><span class="p">(</span><span class="ss">:use</span><span class="w"> </span><span class="ss">#:cl</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="ss">:export</span><span class="w"> </span><span class="ss">#:hello</span>
<span class="w">  </span><span class="p">))</span>

<span class="p">(</span><span class="nb">in-package</span><span class="w"> </span><span class="nv">wanze_clisp_project</span><span class="p">)</span>
</code></pre></div>
<p>然后把那个hello函数加到 <code>wanze_clisp_project.lisp</code> 文件里面去。</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">hello</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="s">"hello"</span><span class="p">))</span>
</code></pre></div>
<p>现在在slime repr 哪里你可以这样做了：</p>
<div class="highlight"><pre><span></span><code>CL-USER&gt; (ql:quickload :wanze_clisp_project)
To load "wanze_clisp_project":
  Load 1 ASDF system:
    wanze_clisp_project
; Loading "wanze_clisp_project"

(:WANZE_CLISP_PROJECT)
CL-USER&gt; (wanze_clisp_project:hello)

"hello" 
"hello"
CL-USER&gt; 
</code></pre></div>
<p>这是一种做法，此外你还可以在emacs打开文件，一边编写函数一边在slime repr哪里测试。</p>
<p>具体就是首先在slime repr哪里加载目标项目，然后运行：</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">in-package</span><span class="w"> </span><span class="nv">wanze_clisp_project</span><span class="p">)</span>
</code></pre></div>
<p>现在你可以在slime repr哪里直接运行：</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">hello</span><span class="p">)</span>
</code></pre></div>
<p>然后你打开主lisp文件编写函数，然后光标放在那个函数哪里，然后执行 <code>Ctrl+c Ctrl+c</code> ，重新编译该函数。</p>
<p>然后再到slime repr 哪里运行 </p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">hello</span><span class="p">)</span>
</code></pre></div>
<p>你会发现函数新的修改立马生效了。</p>
<hr/>
<p><strong>下面的部分读者根据情况来阅读之。</strong></p>
<hr/>
<h2 id="加入smex插件">加入smex插件</h2>
<p>那么smex插件具体有什么用处了，现在我们重新打开emacs，然后按下M-x，这个时候我们会看到很多选项，这正是smex插件的功能，跟输入法一样基本，所以很有用的。</p>
<p>common-lisp现在流行的集成开发环境 <strong>protacle</strong> 里面的emacs似乎已经有了命令行提示功能了，所以不需要安装了smex插件了，不过下面一些讨论还是有参考学习价值的。</p>
<p>smex的官方github站在 <a href="https://github.com/nonsequitur/smex/">这里</a> ,不过看了我下面的介绍大致也差不多了。</p>
<p>首先当然是git clone下来，很小的一个文件，就单独下载那个smex.el文件也是可以的，然后你将这个文件放在一个你喜欢的地方上，我放在"~/工作空间/emacs/"里面的。</p>
<p>然后在.emacs文件中加入如下代码：</p>
<div class="highlight"><pre><span></span><code><span class="c1">;smex插件设置</span>
<span class="c1">;加入新的搜索路径</span>
<span class="p">(</span><span class="nv">add-to-list</span><span class="w"> </span><span class="ss">'load-path</span><span class="w"> </span><span class="s">"~/工作空间/emacs/smex"</span><span class="p">)</span>
<span class="p">(</span><span class="nb">require</span><span class="w"> </span><span class="ss">'smex</span><span class="p">)</span><span class="c1">;加载某个模块</span>
<span class="p">(</span><span class="nv">global-set-key</span><span class="w"> </span><span class="p">(</span><span class="nv">kbd</span><span class="w"> </span><span class="s">"M-x"</span><span class="p">)</span><span class="w"> </span><span class="ss">'smex</span><span class="p">)</span>
<span class="p">(</span><span class="nv">global-set-key</span><span class="w"> </span><span class="p">(</span><span class="nv">kbd</span><span class="w"> </span><span class="s">"M-X"</span><span class="p">)</span><span class="w"> </span><span class="ss">'smex-major-mode-commands</span><span class="p">)</span>
<span class="c1">;; This is your old M-x.</span>
<span class="p">(</span><span class="nv">global-set-key</span><span class="w"> </span><span class="p">(</span><span class="nv">kbd</span><span class="w"> </span><span class="s">"C-c C-c M-x"</span><span class="p">)</span><span class="w"> </span><span class="ss">'execute-extended-command</span><span class="p">)</span>
</code></pre></div>
<p>下面详细讲解之。 <strong>add-to-list</strong> 是一个函数，其接受一个列表变量，然后将后面的一个元素加入该列表中。
请看下面的例子，其中 <strong>nil</strong> 是一个空列表的意思：</p>
<div class="highlight"><pre><span></span><code><span class="nv">ELISP&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="ss">'x</span><span class="w"> </span><span class="no">nil</span><span class="p">)</span>
<span class="no">nil</span>
<span class="nv">ELISP&gt;</span><span class="w"> </span><span class="nv">x</span>
<span class="no">nil</span>
<span class="nv">ELISP&gt;</span><span class="w"> </span><span class="p">(</span><span class="nv">add-to-list</span><span class="w"> </span><span class="ss">'x</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="nv">ELISP&gt;</span><span class="w"> </span><span class="p">(</span><span class="nv">add-to-list</span><span class="w"> </span><span class="ss">'x</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="nv">ELISP&gt;</span><span class="w"> </span><span class="p">(</span><span class="nv">add-to-list</span><span class="w"> </span><span class="ss">'x</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>
<p>这里的 <strong>load-path</strong> 变量放着的就是emacs加载插件时的搜索路径，这里把一个新的smex插件所在的路径加进来了，注意路径的下面就应该放着目标el文件。</p>
<p>以后你要加载新的插件"what"，大致也是类似的配置语句：</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">add-to-list</span><span class="w"> </span><span class="ss">'load-path</span><span class="w"> </span><span class="s">"~/工作空间/emacs/what"</span><span class="p">)</span>
</code></pre></div>
<p>把what.el放入emacs文件夹里的what文件夹里面即可。</p>
<p>然后接下来就是实际的加载这个插件了：</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">require</span><span class="w"> </span><span class="ss">'smex</span><span class="p">)</span><span class="c1">;加载某个模块</span>
</code></pre></div>
<p><strong>require</strong> 函数后面跟着插件的名字，对应的就是那个smex.el文件。</p>
<h3 id="自定义按键配置">自定义按键配置</h3>
<p>接下来是进一步的按键配置：</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">global-set-key</span><span class="w"> </span><span class="p">(</span><span class="nv">kbd</span><span class="w"> </span><span class="s">"M-x"</span><span class="p">)</span><span class="w"> </span><span class="ss">'smex</span><span class="p">)</span>
<span class="p">(</span><span class="nv">global-set-key</span><span class="w"> </span><span class="p">(</span><span class="nv">kbd</span><span class="w"> </span><span class="s">"M-X"</span><span class="p">)</span><span class="w"> </span><span class="ss">'smex-major-mode-commands</span><span class="p">)</span>
<span class="c1">;; This is your old M-x.</span>
<span class="p">(</span><span class="nv">global-set-key</span><span class="w"> </span><span class="p">(</span><span class="nv">kbd</span><span class="w"> </span><span class="s">"C-c C-c M-x"</span><span class="p">)</span><span class="w"> </span><span class="ss">'execute-extended-command</span><span class="p">)</span>
</code></pre></div>
<p>这种自定义按键配置方式以后我们可以用来随意的配置后面学到的命令。</p>
<p><strong>global-set-key</strong> 函数后面跟着 <strong>kbd</strong> 函数对按键字符的封装，可以把第一个元素看作具体的按键，第二个元素看作具体调用的命令。</p>
<p>这里第一个命令的意思是，如果你按下了Alt+x按键，那么将会触发smex命令。然后之前谈及Alt+x对应的命令实际上就是 <strong>execute-extended-command</strong> ，而经过这样的配置之后，以后就需要通过这么复杂的按键才能激活了，等于打入冷宫了。</p>
<h2 id="tab都自动换成space">tab都自动换成space</h2>
<p>参考网页：<a href="http://www.emacswiki.org/emacs/NoTabs">NoTabs</a> </p>
<p>在.emacs文件里加入如下代码：</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">setq-default</span><span class="w"> </span><span class="nv">indent-tabs-mode</span><span class="w"> </span><span class="no">nil</span><span class="p">)</span>
</code></pre></div>
<h2 id="80列规则">80列规则</h2>
<p>控制你的代码不超过80列是一个非常好的习惯，不仅可以起到控制自己写出缩进过于复杂的代码的冲动，而且这样写出来的代码直接复制粘贴就能很好地在网页或pdf文档上显示。</p>
<p>下面是具体的配置文件：</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">add-to-list</span><span class="w"> </span><span class="ss">'load-path</span><span class="w"> </span><span class="s">"~/工作空间/myemacs/fill-column-indicator"</span><span class="p">)</span>
<span class="p">(</span><span class="nb">require</span><span class="w"> </span><span class="ss">'fill-column-indicator</span><span class="p">)</span>
<span class="p">(</span><span class="nb">define-globalized-minor-mode</span><span class="w"> </span><span class="nv">global-fci-mode</span><span class="w"> </span><span class="nv">fci-mode</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="nb">lambda</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nv">fci-mode</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">global-fci-mode</span><span class="w"> </span><span class="no">t</span><span class="p">)</span>
<span class="p">(</span><span class="k">setq</span><span class="w"> </span><span class="nv">fci-rule-column</span><span class="w"> </span><span class="mi">80</span><span class="p">)</span>
<span class="p">(</span><span class="k">setq</span><span class="w"> </span><span class="nv">fci-rule-color</span><span class="w"> </span><span class="s">"light green"</span><span class="p">)</span>
</code></pre></div>
<p>该宏包的github地址在 <a href="https://github.com/alpaker/Fill-Column-Indicator">这里</a> ，该宏包的emacswiki地址在 <a href="http://www.emacswiki.org/emacs/FillColumnIndicator">这里</a> 。上面代码第五行是设置列宽80，然后第六行是设置竖线颜色。</p>
<p>第三行第四行这样配置之后所有的模式下都会显示竖线，这个看各人的作业文档主要是什么了，如果主要是python脚本等编程语言，那么这样设置也没什么不妥的。如果你的作业文档主要是非编程语言或者有时是org模式之类的，推荐还是如下单独设置。</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">add-hook</span><span class="w"> </span><span class="ss">'c-mode-hook</span><span class="w"> </span><span class="ss">'fci-mode</span><span class="p">)</span>
<span class="p">(</span><span class="nv">add-hook</span><span class="w"> </span><span class="ss">'c++-mode-hook</span><span class="w"> </span><span class="ss">'fci-mode</span><span class="p">)</span>
<span class="p">(</span><span class="nv">add-hook</span><span class="w"> </span><span class="ss">'python-mode-hook</span><span class="w"> </span><span class="ss">'fci-mode</span><span class="p">)</span>
<span class="p">(</span><span class="nv">add-hook</span><span class="w"> </span><span class="ss">'emacs-lisp-mode-hook</span><span class="w"> </span><span class="ss">'fci-mode</span><span class="p">)</span>
</code></pre></div>
<h2 id="python模式">python模式</h2>
<p>python模式推荐还是使用 <strong>python-mode</strong> 宏包而不是内置的 <code>python.el</code> 。宏包的下载在 <a href="http://melpa.org/#/python-mode">这里</a> ，如下简单设置之后使用 <code>C-c C-c</code> 就运行该python文件并进入交互模式，很是方便。这次默认的就是python3，我很满意了。我不清楚是不是我的python文件第一行总是有 <code>#!/usr/bin/env python3</code> 所以python-mode.el猜到了，还是只是现在就是简单的默认是调用python3了。如果你需要设置将其设置为python2，该宏包的github地址在 <a href="https://github.com/klen/python-mode">这里</a> ，然后再结合网络搜索找寻答案吧。</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">add-to-list</span><span class="w"> </span><span class="ss">'load-path</span><span class="w"> </span><span class="s">"~/工作空间/myemacs/python-mode"</span><span class="p">)</span><span class="c1">;加入新的搜索路径</span>
<span class="p">(</span><span class="nb">require</span><span class="w"> </span><span class="ss">'python-mode</span><span class="p">)</span>
</code></pre></div>
<h3 id="分窗口控制">分窗口控制</h3>
<p>参考了 <a href="http://stackoverflow.com/questions/24119221/customize-window-splitting-in-emacs-python-mode">这个网页</a> ，如果你希望在运行 <code>C-c C-c</code> 之后，弹出的窗口是左右平行的模式，而不是上下模式，可以如下设置:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">setq-default</span><span class="w"> </span><span class="nv">py-split-windows-on-execute-function</span><span class="w"> </span><span class="ss">'split-window-horizontally</span><span class="p">)</span>
</code></pre></div>
<p>这样具体效果如下图所示:</p>
<p><img alt="img" src="https://a358003542.github.io/images/emacs/平行分出一个窗口.png"/></p>
<h2 id="快速启动emacs">快速启动emacs</h2>
<p>先用</p>
<div class="highlight"><pre><span></span><code>emacs --daemon
</code></pre></div>
<p>命令启动一个后台服务器，这个命令可以考虑加入.bashrc文件中每次启动自动运行一次。</p>
<p>然后把系统的desktop文件（你可以在 <code>/usr/share/applications</code> 那里找到它，你也可以在用户主文件夹的 <code>.local/share/applications</code> 那里再另外新建一个。 ）修改一下:</p>
<div class="highlight"><pre><span></span><code>Exec=/usr/bin/emacsclient -c -a ""  %F
</code></pre></div>
<p>本来是 <code>emacs %F</code> ，改为emacsclient，这里的 <code>-c</code> 参数是启动图形界面。然后-a参数设置为空字符串，这样即使你前面没有建立一个emacs后台服务器，其也会自动创建一个。这样你双击对应emacs关联的文件就自动快速用emacsclient打开了。读者可以尝试一下，这样emacs打开文件确实很快了，但也带来了一些问题。</p>
<h3 id="关闭frame和以前的不同了">关闭frame和以前的不同了</h3>
<p>emacs daemon是一个后台进程，你可以用 <code>ps aux |grep emacs</code> 来查看一下，哪怕你把所有的emacsclient建立的frame窗口都关闭了，emacs的后台daemon仍然存在。</p>
<p>然后就是emacsclient编辑一个文件之后，不管你保存了没有没有任何提示就直接关闭了，这其实没什么，因为你用emacsclient打开的所有buffer都还是在的，所以你的编辑内容并没有丢失，但这很不符合用户的习惯。</p>
<p>首先通过查看进程号然后kill相应的emacs daemon进程的做法最好不要用，在emacs里面可以输入命令 <code>kill-emacs</code> 来关闭emacs的后台服务进程，这个方法最好也不要用。总之手工kill emacs后台服务进程这个操作最好不要使用，如果你需要调试，就用以前的 <code>emacs test.org</code> 方式来启动另外一个完成的meacs进程来进行调试。</p>
<p>然后如果你觉得接下来应该不需要使用emacs了，那么正确关闭emacs做法是使用快捷键 <code>C-x C-c</code> ，其对应的函数是 <code>save-buffers-kill-terminal</code> ，这个快捷键以前我已经接触过了，在一个完整emacs进程中，其就是退出emacs命令，其将确保所有的buffer都保存了，然后退出。值得一提的是这个函数并没有关闭emacs后台服务进程，实际上在熟悉emacsclient操作之后，最好不要去管emacs daemon这个概念，就认为这个 <code>C-x C-c</code> 就是正常退出emacs的命令即可。</p>
<p>最后是关闭buffer操作，如果你只是简单点击窗口的关闭图标，那么只是关闭frame，buffer还是在那里。如果你编辑完了想要关闭这个buffer，那么执行 <code>kill-buffer</code> 即可，文档没有保存其会提示你的，并且最后还会提示你是否关闭本frame。</p>
<h3 id="字体问题">字体问题</h3>
<p>因为emacs daemon在启动的时候是没有图形界面的，所以之前的字体设置失效了，你需要如下设置<sup><a class="footref" href="#fn.2" id="fnr.2">2</a></sup>:</p>
<div class="highlight"><pre><span></span><code><span class="c1">;; 解决client模式下的字体问题</span>
<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">myfontset</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="p">(</span><span class="k">interactive</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">set-default-font</span><span class="w"> </span><span class="s">"DejaVu Sans Mono"</span><span class="p">)</span><span class="c1">;设置默认字体</span>
<span class="w">  </span><span class="p">(</span><span class="nv">set-face-attribute</span><span class="w"> </span><span class="ss">'default</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="nb">:height</span><span class="w"> </span><span class="mi">110</span><span class="p">)</span><span class="c1">;设置默认字体大小11pt</span>
<span class="p">)</span>

<span class="p">(</span><span class="nv">add-hook</span><span class="w"> </span><span class="ss">'after-make-frame-functions</span>
<span class="w">         </span><span class="p">(</span><span class="nb">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">frame</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nf">select-frame</span><span class="w"> </span><span class="nv">frame</span><span class="p">)</span><span class="c1">;</span>
<span class="w">               </span><span class="p">(</span><span class="nv">myfontset</span><span class="p">)))</span>
</code></pre></div>
<p>这里的思路就是等frame加载完成之后再加载之前的那些字体配置。</p>
<h2 id="左侧文件树面板">左侧文件树面板</h2>
<p>一般现代IDE最大的一个特色就是左侧有一个文件树面板，方便快速切换文件，这个emacs下的neotree宏包可以实现类似的功能。该项目的github地址在 <a href="https://github.com/jaypei/emacs-neotree">这里</a> 。</p>
<p>具体使用很简单，就是常规的加载:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">add-to-list</span><span class="w"> </span><span class="ss">'load-path</span><span class="w"> </span><span class="s">"/some/path/neotree"</span><span class="p">)</span>
<span class="p">(</span><span class="nb">require</span><span class="w"> </span><span class="ss">'neotree</span><span class="p">)</span>
<span class="p">(</span><span class="nv">global-set-key</span><span class="w"> </span><span class="nv">[f8]</span><span class="w"> </span><span class="ss">'neotree-toggle</span><span class="p">)</span>
</code></pre></div>
<p>这样你就可以按下F8来快速切换到文件树面板了。</p>
<h3 id="pdf文件打开卡住问题">pdf文件打开卡住问题</h3>
<p>emacs的docview功能可以直接看pdf文件，这有时会带来很大的便利，不过现在打开pdf文件有点卡，这可以通过将 <code>doc-view-continuous</code> 设置为nil来稍微缓和一下。</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">custom-set-variables</span>
<span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nv">doc-view-continuous</span><span class="w"> </span><span class="no">nil</span><span class="p">)</span>
<span class="w"> </span><span class="p">)</span>
</code></pre></div>
<h3 id="可能的其他问题">可能的其他问题</h3>
<p>neotree这个项目看得出来还有很多地方可以进一步完善，比如说emacsclient模式下似乎根目录读取有问题。</p>
<h2 id="多个窗口之间的编号切换">多个窗口之间的编号切换</h2>
<p>window-numbering这个宏包不错，其github项目地址在 <a href="https://github.com/nschum/window-numbering.el">这里</a> 。该宏包实现了对各个窗口进行编号，使得你通过按 <code>M-1</code> 之类的就能快速切换各个窗口焦点。</p>
<p>官方推荐的一个配置如下所示:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">setq</span><span class="w"> </span><span class="nv">window-numbering-assign-func</span>
<span class="w">      </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">equal</span><span class="w"> </span><span class="p">(</span><span class="nv">buffer-name</span><span class="p">)</span><span class="w"> </span><span class="s">"*Calculator*"</span><span class="p">)</span><span class="w"> </span><span class="mi">9</span><span class="p">)))</span>
</code></pre></div>
<p>然后还需要加上一句:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">window-numbering-mode</span><span class="p">)</span>
</code></pre></div>
<p>实际开启编号模式，具体效果如下图所示:</p>
<p><img alt="img" src="https://a358003542.github.io/images/emacs/窗口编号方便快速切换.png"/></p>
<p>更多窗口操作知识请参看 <a href="http://blog.binchen.org/posts/emacs-zhong-de-wan-mei-duo-chuang-kou-cao-zuo.html">这个网页</a> ，介绍的挺好的。</p>
<h2 id="markdown模式">markdown模式</h2>
<p>markdown-mode这个宏包给emacs加入了markdown的渲染，还有类似org模式的折叠等等功能。其github项目地址在 <a href="https://github.com/defunkt/markdown-mode">这里</a> 。</p>
<p>就这样简单配置一下即可:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">add-to-list</span><span class="w"> </span><span class="ss">'load-path</span><span class="w"> </span><span class="s">"~/工作空间/myemacs/markdown-mode"</span><span class="p">)</span>
<span class="p">(</span><span class="nv">autoload</span><span class="w"> </span><span class="ss">'markdown-mode</span><span class="w"> </span><span class="s">"markdown-mode"</span>
<span class="w">   </span><span class="s">"Major mode for editing Markdown files"</span><span class="w"> </span><span class="no">t</span><span class="p">)</span>
<span class="p">(</span><span class="nv">add-to-list</span><span class="w"> </span><span class="ss">'auto-mode-alist</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="s">"\\.text\\'"</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">markdown-mode</span><span class="p">))</span>
<span class="p">(</span><span class="nv">add-to-list</span><span class="w"> </span><span class="ss">'auto-mode-alist</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="s">"\\.markdown\\'"</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">markdown-mode</span><span class="p">))</span>
<span class="p">(</span><span class="nv">add-to-list</span><span class="w"> </span><span class="ss">'auto-mode-alist</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="s">"\\.md\\'"</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">markdown-mode</span><span class="p">))</span>
</code></pre></div>
<p>里面的用法除了Tab折叠功能外，其他再慢慢了解，有些可能会用不到，下面介绍重头戏，markdowon的实时预览功能实现。</p>
<h2 id="markdown实时预览">markdown实时预览</h2>
<p>emacs-livedown这个宏包其是利用nodejs里面的livedown模块的功能，将markdown文档实时显示在网页端。其github项目地址在 <a href="https://github.com/shime/emacs-livedown">这里</a> 。</p>
<p>首先你需要安装npm，然后通过npm安装livedown。</p>
<div class="highlight"><pre><span></span><code><span class="nv">sudo</span><span class="w"> </span><span class="nv">npm</span><span class="w"> </span><span class="nv">install</span><span class="w"> </span><span class="nv">livedown</span>
</code></pre></div>
<p>然后做如下配置:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nv">custom-set-variables</span>
<span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nv">livedown:autostart</span><span class="w"> </span><span class="no">t</span><span class="p">)</span><span class="w"> </span><span class="c1">; automatically open preview when opening markdown files</span>
<span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nv">livedown:port</span><span class="w"> </span><span class="mi">1337</span><span class="p">))</span><span class="w">    </span><span class="c1">; port for livedown server ;一般nodejs的服务用这个端口</span>
<span class="p">(</span><span class="nv">add-to-list</span><span class="w"> </span><span class="ss">'load-path</span><span class="w">  </span><span class="s">"~/工作空间/myemacs/emacs-livedown"</span><span class="p">)</span>
<span class="p">(</span><span class="nb">require</span><span class="w"> </span><span class="ss">'livedown</span><span class="p">)</span>
</code></pre></div>
<p>你就可以用emacs双击一个md文件，然后在网页端就显示渲染好的网页了，而且livedown本身就支持实时根据md文件实时更新。上图片吧:</p>
<p><img alt="img" src="https://a358003542.github.io/images/emacs/emacs的markdown模式.png" title="emacs的markdown模式"/></p>
<p><img alt="img" src="https://a358003542.github.io/images/emacs/md文件对应的网页显示.png" title="md文件对应的网页显示"/></p>
<p>然后在emacsclient下另外开启一个frame还需要执行一下命令 <code>livedown:preview</code> 网页才会切换到这个md的预览。</p>
<h2 id="文字模式下的emacs操作">文字模式下的emacs操作</h2>
<p>通过ssh在远程主机上用emacs编辑文件，那就必须在文字模块下操作emacs，这带来了一些新的问题。</p>
<h3 id="移动光标">移动光标</h3>
<p>参考了 <a href="http://dsec.pku.edu.cn/~jinlong/emacs/emacs.html">这个网页</a> 。</p>
<p>一般通过键盘上的方向键移动辅助搜索跳转还是很快的，但有时不知怎么方向键移动也会出问题。这是只好借助下面这些快捷键了。</p>
<div class="highlight"><pre><span></span><code>C-f    前进一个字符
C-b    后退一个字符
C-p    上移一行
C-n    下移一行

M-f    前进一个单词
M-b    后退一个单词

C-a    行首
C-e    行尾
</code></pre></div>
<h3 id="切换窗口焦点">切换窗口焦点</h3>
<p>这个前面也提过了，但在这里显然是一个重要问题，需要再次强调一下。 <code>C-x o</code> 进行切换各个窗口操作。</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<div class="footdef"><sup><a class="footnum" href="#fnr.1" id="fn.1">1</a></sup> <div class="footpara">参考了 <a href="https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-zh.org">mastering-emacs-in-one-year-guide</a></div></div>
<div class="footdef"><sup><a class="footnum" href="#fnr.2" id="fn.2">2</a></sup> <div class="footpara">参考了 <a href="http://floss.zoomquiet.io/data/20120229104733/index.html">这个网页</a> 。</div></div>
</div>
</div>
            </div>
        </div>

    </div>
</div>
        </main>
        
        <footer class="footer">
            <ul class="nav justify-content-center">
                <li class="nav-item">
                    <span class="nav-link text-muted px-2">Created by Wanze & Companion with</span></li>
                <li class="nav-item">
                    <a class="nav-link text-muted px-2" href="https://python.org/">Python</a></li>
                <li class="nav-item">
                    <a class="nav-link text-muted px-2" href="http://getpelican.com/">Pelican</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link text-muted px-2" href="https://github.com/Python-Markdown/markdown">Markdown</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link text-muted px-2" href="http://oncrashreboot.com/pelican-elegant">Elegant</a></li>
                <li class="nav-item">
                    <a class="nav-link text-muted px-2" href="https://www.javascript.com/">Javascript</a></li>
                <li class="nav-item">
                    <a class="nav-link text-muted px-2" href="https://www.mathjax.org/">Mathjax</a>
                </li>
                <li class="nav-item">
                    <span class="nav-link text-muted px-2">etc...</span></li>
            </ul>
        </footer>
    </div>

    <script src="https://a358003542.github.io/theme/lodash/js/lodash.min.js"></script>
    <script src="https://a358003542.github.io/theme/bootstrap/js/bootstrap.bundle.min.js"></script>
    <script src="https://a358003542.github.io/theme/js/base.js"></script>

<script src="https://a358003542.github.io/theme/js/article.js"></script>


</body>

</html>