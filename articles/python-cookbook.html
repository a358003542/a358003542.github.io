<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="msvalidate.01" content="55CB117A61A6F8286173763FB18D9625"/>
    <meta name="google-site-verification" content="r5HyVvY-ZSgf7ctpcpK1aWIaEfKJ0dvAE3E9kW3vXgI" />
    <script data-ad-client="ca-pub-5644206261254049" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
        <meta name="author" content="wanze"/>
        <meta name="copyright" content="wanze"/>

        <meta name="description"
              content="前言 本文列出笔者学习和实践python中接触到的各个小技巧，小知识点，在这里汇总并整理之。 核心内置 利用int函数进行进位转换 int函数用于强制类型转换的时候，可以将一个类数值字符串变成integer，但这个函数还隐藏了一个强大的功能，那就是其还有第二个可选参数，进位制。 &gt;&gt..."/>

        <meta property="og:type" content="article"/>
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="python, python_language, " />

<meta property="og:title" content="python语言学习之cookbook "/>
<meta property="og:url" content="https://a358003542.github.io/articles/python-cookbook.html" />
<meta property="og:description" content="前言 本文列出笔者学习和实践python中接触到的各个小技巧，小知识点，在这里汇总并整理之。 核心内置 利用int函数进行进位转换 int函数用于强制类型转换的时候，可以将一个类数值字符串变成integer，但这个函数还隐藏了一个强大的功能，那就是其还有第二个可选参数，进位制。 &gt;&gt..." />
<meta property="og:site_name" content="万泽的博客" />
<meta property="og:article:author" content="wanze" />
<meta property="og:article:published_time" content="2021-10-28T00:00:00+08:00" />
<meta name="twitter:title" content="python语言学习之cookbook ">
<meta name="twitter:description" content="前言 本文列出笔者学习和实践python中接触到的各个小技巧，小知识点，在这里汇总并整理之。 核心内置 利用int函数进行进位转换 int函数用于强制类型转换的时候，可以将一个类数值字符串变成integer，但这个函数还隐藏了一个强大的功能，那就是其还有第二个可选参数，进位制。 &gt;&gt...">


    <title>python语言学习之cookbook  · 万泽的博客
</title>

        <link href="https://a358003542.github.io/theme/css/font-awesome.css" rel="stylesheet"
              media="screen">
        <link href="https://a358003542.github.io/theme/css/bootstrap.min.css" rel="stylesheet"
              media="screen">

        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/pygments.css" media="screen">
        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/elegant.css" media="screen">
        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/base.css" media="screen">




</head>
<body>

<nav class="navbar">
    <div class="navbar navbar-default" role="navigation">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed"
                    data-toggle="collapse" data-target=".navbar-collapse"
                    aria-expanded="false">
                <span class="sr-only">Navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <a class="navbar-brand" href="https://a358003542.github.io/"><span
                    class=site-name>网站首页</span></a>
        </div>


        <div class="navbar-collapse collapse">
            <form action="https://a358003542.github.io/search.html"
                  onsubmit="return validateForm(this.elements['q'].value);"
                  class="navbar-form navbar-left">
                <div class="form-group">
                    <input type="text" name="q" id="tipue_search_input"
                           class="form-control" placeholder="Search..."
                           style="width:430px;">
                </div>
                <button class="btn btn-default" type="submit">搜索</button>
            </form>


            <ul class="nav navbar-nav nav-pills navbar-right">
                <li >
                    <a  href="/archives.html">所有文章</a></li>

                <li ><a href="/categories.html">文章分类</a></li>
                <li ><a href="/tags.html">文章标签</a></li>


                        <li >
                            <a href="https://a358003542.github.io/about.html">关于本网站</a>
                        </li>
            </ul>


        </div>
    </div>
</nav>


<div class="container-fluid">
    <div class="col-md-1 col-md-1-left"></div>
    <div class="col-md-10">
<article>
<div class="row">
    <header class="page-header col-md-10 col-md-offset-2">
    <h1><a href="https://a358003542.github.io/articles/python-cookbook.html"> python语言学习之cookbook  </a></h1>
    </header>
</div>

<div class="row">
    <div class="col-md-2 table-of-content">
        <nav>
        <h4>目录</h4>
        <div class="toc">
<ul>
<li><a href="#_1">前言</a></li>
<li><a href="#_2">核心内置</a><ul>
<li><a href="#int">利用int函数进行进位转换</a></li>
<li><a href="#assert">assert语句</a></li>
<li><a href="#localsglobals">locals和globals</a></li>
<li><a href="#and-or-not">and or not的运算优先级</a></li>
<li><a href="#allany">all和any关键词</a></li>
<li><a href="#_3">三元运算符</a></li>
<li><a href="#_4">属性管理的函数</a></li>
<li><a href="#__name__-__file__">__name__ 和 __file__</a></li>
<li><a href="#__missing__">__missing__方法</a></li>
<li><a href="#python">python中类继承的顺序</a></li>
<li><a href="#_5">字符串比较大小</a><ul>
<li><a href="#_6">中文比较大小？</a></li>
<li><a href="#ordchr">ord和chr函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_7">字符串</a><ul>
<li><a href="#format">format函数</a><ul>
<li><a href="#_8">等宽数字</a></li>
<li><a href="#_9">花括号的问题</a></li>
</ul>
</li>
<li><a href="#f-string">f-string</a></li>
</ul>
</li>
<li><a href="#_10">字典</a><ul>
<li><a href="#_11">深入理解字典的寻址</a></li>
</ul>
</li>
<li><a href="#_12">文件</a><ul>
<li><a href="#_13">读取文件推荐方式</a></li>
</ul>
</li>
<li><a href="#_14">模块</a><ul>
<li><a href="#_15">获取本模块对象</a></li>
<li><a href="#_16">根据字符串获取模块对象</a></li>
<li><a href="#_17">检查某个变量是不是模块对象</a></li>
</ul>
</li>
<li><a href="#_18">有用的内置模块</a><ul>
<li><a href="#flatten">可迭代对象flatten操作</a></li>
<li><a href="#abc">利用abc模块来实现抽象基类</a></li>
<li><a href="#loggingpprint">在logging中使用pprint</a></li>
<li><a href="#astliteral_eveleval">利用ast模块的literal_evel函数来更安全的eval</a></li>
<li><a href="#itertoolsproduct">利用itertools模块的product函数来遍历组合</a></li>
<li><a href="#collectionsdeque">利用collections模块的deque数据结构</a></li>
<li><a href="#_19">查找多个最大最小元素的情况</a></li>
<li><a href="#collectionsorderdict">利用collections模块的Orderdict类</a></li>
</ul>
</li>
<li><a href="#counter">Counter类</a><ul>
<li><a href="#collectionsnamedtuple">利用collections模块的namedtuple</a></li>
<li><a href="#dataclass">构建一个dataclass类</a></li>
<li><a href="#configparse">configparse处理特殊字符</a></li>
<li><a href="#collectionschainmap">利用collections模块的ChainMap定义搜索过程</a></li>
<li><a href="#typingnamedtuple">typing.NamedTuple</a></li>
<li><a href="#queuepriorityqueue">queue.PriorityQueue</a></li>
<li><a href="#queuequeue">queue.Queue</a></li>
<li><a href="#queuelifoqueue">queue.LifoQueue</a></li>
<li><a href="#multiprocessingqueue">multiprocessing.Queue</a></li>
</ul>
</li>
<li><a href="#_20">有用的第三方模块</a><ul>
<li><a href="#_21">获取一个月最后的一天</a></li>
</ul>
</li>
<li><a href="#_22">附录</a><ul>
<li><a href="#_23">给某个对象动态加载一个方法</a></li>
</ul>
</li>
</ul>
</div>
        </nav>
    </div>
    <div class="col-md-8 article-content">

            
<h2 id="_1">前言</h2>
<p>本文列出笔者学习和实践python中接触到的各个小技巧，小知识点，在这里汇总并整理之。</p>
<h2 id="_2">核心内置</h2>
<h3 id="int">利用int函数进行进位转换</h3>
<p>int函数用于强制类型转换的时候，可以将一个类数值字符串变成integer，但这个函数还隐藏了一个强大的功能，那就是其还有第二个可选参数，进位制。</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="mi">10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="s1">'0xa'</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="mi">10</span>
</pre></div>
<p>上面的效果就是将一个十六进制的字符按照十六进制输出一个十进制的数值。有相同需求的地方别用eval了。</p>
<h3 id="assert">assert语句</h3>
<p>assert语句简单的理解就是 <code>assert True</code> ，正常刷过去，而 <code>assert False</code> 将抛出<code>AssertionError</code> 。</p>
<p>assert语句实际上是非常重要的一个语句，程序员在编码的时候需要形成一种防御型编码风格，注意这不是所谓的编码规范，而是重要性更高一等级的编码风格，是一种思维方式。</p>
<p>那么什么是防御型编码风格，简言之就是你在编码的时候，你对于你即将面对的各个数据类型的预期。比如说 <code>is_even</code> 函数是一个判断输入的整数是否是偶数的函数，那么你预期输入的数值就是一个整数，这个时候你就可以加上<code>assert  isinstance(x, int)</code> ，来防御输入的x参数类型。那么假如程序运行过程中抛出了这个地方的assert异常，这个函数实际上在说，不是我的问题，是你给我的参数出问题了，是调用我的那个方法出了问题。</p>
<p>防御型编码风格就是一种去耦合思维，它和你编写各个函数的去耦合思维是一致的，所以不要把防御型编码风格当成某种规范，当作某种额外的约束工作，它就是和你正在编写各种函数时候的思维方式是一致的。如果你去观察那些没有防御型编码风格的初学者，你会发现他们的函数分离工作做得很不好，经常看到大段的代码，各个参数全局变量局部变量都乱七八糟的，整个代码文件混乱不堪。而他们还会嬉笑道，不就是防御型编码吗，我知道，我学过。</p>
<p>assert语句和相关条件判断等抛异常语句片段都属于防御型编码风格，那么什么时候用assert语句，什么时候抛出异常呢。实际上assert语句也是在抛异常，但assert语句和抛异常语句有一个很大的不同：<strong>那就是assert语句可以通过设置python编译器来全局跳过，这个需要注意下。所以对于那些必须要做的校验，是应该使用异常语句的。</strong> 所以一般来说项目早期的话可以写上很多assert语句，但后面时间充裕了很多assert语句是要替换为抛异常语句的。</p>
<h3 id="localsglobals">locals和globals</h3>
<p>python的 <code>locals()</code> 返回本函数内的局部变量字典值，而 <code>globals()</code> 则返回本模块文件的全局变量。 <code>locals</code> 是只读的，而 <code>globals()</code> 不是，我们可以利用<code>globals()</code> 对脚本文件玩出一些新花样。</p>
<h3 id="and-or-not">and or not的运算优先级</h3>
<p>一般是推荐用括号清晰表达，然后not我们知道优先级是最高的。我们再看下面这个例子:</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; True or True and False
True
</pre></div>
<p>这个例子很好地说明了and和or的优先级顺序，具体就是 and的优先级比or的要高 。</p>
<h3 id="allany">all和any关键词</h3>
<p>这是python语言里面的关键词函数，源码很简单，下面列出来，看一下就清楚了:</p>
<div class="highlight"><pre><span></span>def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True

def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
</pre></div>
<p>如果用语言表述的话是:</p>
<ul>
<li>all，都是True，则返回True，否则返回False</li>
<li>any，只要有一个True则返回True，否则返回False。</li>
</ul>
<h3 id="_3">三元运算符</h3>
<p>也就是类似这样的结构:</p>
<div class="highlight"><pre><span></span>loop = loop if loop is not None else get_event_loop()
</pre></div>
<p>通常我们在处理函数的入口参数实现默认值的情况的时候会用到，比如上面一般函数参数那里写着 <code>loop=None</code> ，用上面这种一行形式更简洁一些。而我们不直接在函数定义的那里采用默认值可能有两种情况，一是该默认值并不方便作为默认值，而最好默认为None；还有一种情况是默认值是需要通过某个函数等运算得到的。</p>
<h3 id="_4">属性管理的函数</h3>
<p>hasattr，setattr，getattr，delattr，这些函数都属于关于python中各个对象的属性管理函数，其都是内置函数。</p>
<p>其中hasattr(object, name)检测某个对象有没有某个属性。其实际调用的还是getattr方法，然后稍作封装。</p>
<p>setattr(object, name, value)用于设置某个对象的某个属性为某个值，<code>setattr(x,a,3)</code> 对应 <code>x.a = 3</code> 这样的语法。</p>
<p>getattr(object, name[, default])用于取某个对象的某个属性的值，对应 <code>object.name</code> 这样的语法。</p>
<p>delattr(object,name)用于删除某个对象的某个属性，对应 <code>del object.name</code> 这样的语法。</p>
<h3 id="__name__-__file__"><code>__name__</code> 和 <code>__file__</code></h3>
<p>这里所谓脚本被引入是指用import或者from语句被另外一个脚本引入进去，而这里所谓的脚本被执行是指直接如 <code>python test.py</code> 这样的形式执行该py脚本。</p>
<p>这两种形式很有一些区别，下面慢慢谈论:</p>
<ul>
<li><code>__name__</code> 的区别。这个大家应该很熟悉了。如果脚本是被引入的，<code>__name__</code> 的值是该引入的脚本文件名，比如引入的是 <code>test.py</code> ，那么该脚本被引入，对于这个test.py文件来说，其内的 <code>__name__</code> 的值就是 <code>test</code> ，也就是 <strong>模块名</strong>  ；而如果是作为脚本被执行，则该 <code>__name__</code> 是 <code>__main__</code> 。</li>
<li><code>__file__</code> 的区别。如果脚本是被执行的，假设该脚本文件是 <code>hello.py</code> ，那么在这个被执行脚本中， <code>__file__</code> 的值是 <code>hello.py</code> ，也就是 <strong>文件名</strong> 。如果是被引用的，那么对于那个被引入的脚本来说， <code>__file__</code> 的值是该被引入脚本相对系统来说的 <strong>完整文件名</strong> ，比如是 <code>/home/wanze/桌面/hello.py</code> 。</li>
</ul>
<h3 id="__missing__"><code>__missing__</code>方法</h3>
<p>对于字典或者字典的子类，你可以通过定义 <code>__missing__</code> 方法来回避找不到键值而抛出的 <code>KeyError</code> ，参考了 <a href="http://stackoverflow.com/questions/635483/what-is-the-best-way-to-implement-nested-dictionaries-in-python">这个网页</a> 。如下所示:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NestedDict</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">UserDict</span><span class="p">):</span>
    <span class="sd">'''</span>
<span class="sd">Implement this data structure:</span>
<span class="sd">{"section":{},</span>
<span class="sd">}</span>
<span class="sd">'''</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">update_in_section</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">section</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_in_section</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">section</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delete_in_section</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">section</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">section</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set_in_section</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">section</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">section</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>
<p>如果找不到该key，则该类会自动赋值一个新的 dict()并作为该key的值。你可能希望使用 <code>type(self)()</code> ，但这种风格对json的兼容性不太好，推荐还是都用dict类。</p>
<h3 id="python">python中类继承的顺序</h3>
<p>我们知道python中类的搜索顺序是从左到右的，比如：</p>
<div class="highlight"><pre><span></span>class D(A,B): pass
</pre></div>
<p>D的属性是先从A找，然后再从B找。但从类的继承概念上来说，如果A类和B类之间没有层次关系，那么他们顺序随便都没问题，但如果B类是更底层的Base类，那么其是应该放在最右边的。这在关于Mixin类中写法是要严格如下所示的：</p>
<div class="highlight"><pre><span></span>class MyClass(Mixin2, Mixin1, BaseClass):
    pass
</pre></div>
<h3 id="_5">字符串比较大小</h3>
<p>读者可以实验一下python中字符串之间是可以比较大小的：</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; 'abc' &gt; 'ab'
True
&gt;&gt;&gt; 'fabc' &gt; 'abc'
True
&gt;&gt;&gt; '3.04' &gt; '3'
True
</pre></div>
<p>这个特性有的时候很有用的，具体是如何比较大小的呢？按照python官方文档的描述，采用的是词典编纂顺序。具体描述信息如下：</p>
<blockquote>
<p>序列之间比较大小是，首先两个序列各自的第一个元素开始比较，如果它们相同，则进行下一个比较，直到任何一个序列被穷尽。如果两个序列各自比较的类型都是相同的，那么整个过程将一直进行下去。如果两个序列是相等的则认为它们是相等的，如果某一个序列是另外一个序列的子序列，则那个短的序列认为比长的序列要小。具体到每一个元素的大小比较，是按照ASCII顺序对其进行比较的。</p>
</blockquote>
<h4 id="_6">中文比较大小？</h4>
<p>读者这时会想到，既然python中字符串都默认是unicode编码（utf-8），那么中文应该也是能够比较大小的吧，事实确实如此：</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; '章' &gt; '张'
True
&gt;&gt;&gt; '章' &lt; '张'
False
&gt;&gt;&gt; ord('章')
31456
&gt;&gt;&gt; ord('张')
24352
</pre></div>
<p>感兴趣的读者可以打开字符映射表看一下，'张'对应的unicode编号是U+5F20，你输入0x5f20，返回的正是24352。如果你输入hex(24352)，返回的就是'0x5f20'。</p>
<h4 id="ordchr">ord和chr函数</h4>
<p>ord函数接受 一个字符，然后返回其unicode编码，十进制的。chr函数是ord函数的反向，比如你输入24352这个十进制uniocde，就返回了对应的字符。</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; chr(24352)
'张'
</pre></div>
<p>所以我们可以总结到，python3的字符串比较大小，是基于utf-8编码的。</p>
<h2 id="_7">字符串</h2>
<h3 id="format">format函数</h3>
<p>format函数或者说字符串的format方法，一般的使用还是很简单的，但是有的时候有些特殊的高级需求，下面渐渐收集之。</p>
<p>更多关于python中format函数使用的信息请参考 <a href="https://pyformat.info/">pyformat.info</a> 。</p>
<h4 id="_8">等宽数字</h4>
<div class="highlight"><pre><span></span> {:0&gt;2d} 
</pre></div>
<p>目标数字宽度为两位，左边填充0 ， <code>&gt;</code> 表示左边填充， <code>0&gt;</code> 表示左边填充0，此外还有 <code>&gt;</code> 表示右边填充。</p>
<h4 id="_9">花括号的问题</h4>
<p>花括号因为是特殊字符，要显示花括号，需要如下输入两次：</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; print(f'{{----}}')
{----}
</pre></div>
<h3 id="f-string">f-string</h3>
<p>python3.6加入进来的特性。基本情况如下：</p>
<p>python新的format字符串</p>
<div class="highlight"><pre><span></span>f"hello. {name}"
</pre></div>
<p>等价于</p>
<div class="highlight"><pre><span></span>"hello. {name}".format(name=name)
</pre></div>
<p>一个变量还好，多个变量的时候这种f-string的写法的好处就很明显了，当时环境下你前面已经定义好的变量名是可以直接使用的，我只能用一句话来形容，太好用了，用上了你就会停不下来。</p>
<h2 id="_10">字典</h2>
<h3 id="_11">深入理解字典的寻址</h3>
<div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="p">{</span><span class="kc">True</span><span class="p">:</span> <span class="s1">'yes'</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">'no'</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">:</span> <span class="s1">'maybe'</span><span class="p">}</span>
<span class="n">t</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="p">{</span><span class="kc">True</span><span class="p">:</span> <span class="s1">'maybe'</span><span class="p">}</span>
</pre></div>
<p>造成这样的结果首先是python的字典的key相同的判断机制，比如是 值相同 而且是 hash 值相同 才认为是 key相同。</p>
<p>其次是认为key相同key就不做改变了，而值是取最新的。也正是因为这样，下面的字典更新语句写法是可行的：</p>
<div class="highlight"><pre><span></span>x = {'a':1, 'b':2}
y = {'b':3}
z = {**x, **y}
</pre></div>
<div class="highlight"><pre><span></span>z
Out[8]: {'a': 1, 'b': 3}
</pre></div>
<p>而且这也是最快的字典更新方式。</p>
<h2 id="_12">文件</h2>
<h3 id="_13">读取文件推荐方式</h3>
<p>因为文件对象本身是可迭代的，我们简单迭代文件对象就可以对文件的一行行内容进行一些操作。比如：</p>
<div class="highlight"><pre><span></span>f = open('removeduplicate.py')

for line in f:
    print(line,end='')
</pre></div>
<p>这个代码就将打印这个文件，其中end="的意思是取消<code>\n</code>，因为原来的行里面已经有<code>\n</code>了。</p>
<p>然后代码稍作修改就可以在每一行之前加上<code>&gt;&gt;&gt;</code>这个符号了。</p>
<div class="highlight"><pre><span></span>f = open('removeduplicate.py')

for line in f:
    print('&gt;&gt;&gt;',line,end='')
</pre></div>
<p>什么？这个输出只是在终端，没有到某个文件里面去，行，加上file参数。然后代码变成如下：</p>
<div class="highlight"><pre><span></span>import sys

f = open('removeduplicate.py')
pyout=open(sys.argv[1] ,"w")

for line in f:
    print('&gt;&gt;&gt;',line,end='',file=pyout)

pyout.close()
f.close()
</pre></div>
<p>python的列表解析（迭代）效率是很高的，我们应该多用列表解析模式。</p>
<p>文件对象有一个readlines方法，能够一次性把整个文件的所有行字符串装入到一个列表中。然后我们再对这个列表进行解析操作就可以直接对整个文件的内容做出一些修改了。不过不推荐使用readlines方法了，这样将整个文件装入内存的方法具有内存爆炸风险，而迭代版本更好一点。</p>
<h2 id="_14">模块</h2>
<h3 id="_15">获取本模块对象</h3>
<p>如下所示，可以获取本模块内的变量。</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">current_module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span>

<span class="n">old_module_dict</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">current_module</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>


<span class="c1"># for k, v in old_module_dict.items():</span>
<span class="c1">#     if k == 'case_base':</span>
<span class="c1">#         pass</span>
<span class="c1">#     elif k.startswith('case_'):</span>
<span class="c1">#         if issubclass(v, case_base):</span>
<span class="c1">#             URL_CASES.append(v)</span>
</pre></div>
<h3 id="_16">根据字符串获取模块对象</h3>
<div class="highlight"><pre><span></span>import importlib
importlib.import_module('what.what')
</pre></div>
<h3 id="_17">检查某个变量是不是模块对象</h3>
<p>参考了 <a href="https://stackoverflow.com/questions/865503/how-to-isinstancex-module">这个网页</a></p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">types</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">)</span>
<span class="kc">True</span>
</pre></div>
<h2 id="_18">有用的内置模块</h2>
<h3 id="flatten">可迭代对象flatten操作</h3>
<div class="highlight"><pre><span></span>a_list = [[1, 2], [3, 4], [5, 6]]
print(list(itertools.chain.from_iterable(a_list)))
# Output: [1, 2, 3, 4, 5, 6]

# or
print(list(itertools.chain(*a_list)))
# Output: [1, 2, 3, 4, 5, 6]
</pre></div>
<h3 id="abc">利用abc模块来实现抽象基类</h3>
<p>abc模块帮助你实现抽象基类，有点类似于java中抽象类的概念。</p>
<p>具体实现如下所示：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span> 

<span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    一般图</span>
<span class="sd">    """</span>
    <span class="n">DIRECTED</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        :return:</span>
<span class="sd">        """</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"Not Implement nodes methods"</span><span class="p">)</span>
</pre></div>
<p>抽象类不可实例化，实例化将会报错。继承于它的类，如果如上定义了抽象方法，那么继承它的类必须定义好对应方法的实现，否则将会报错。</p>
<p>抽象类里面也可以定义不是抽象方法的其他实际动作的方法。</p>
<p>抽象类里面还可以定义抽象属性。</p>
<h3 id="loggingpprint">在logging中使用pprint</h3>
<p>参考了 <a href="https://stackoverflow.com/questions/11093236/use-logging-print-the-output-of-pprint">这个网页</a> 。</p>
<p>有的时候logging的输出我们希望调用pprint从而输出打印更加美观些，可以调用pformat函数来达到这个效果：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">pformat</span>
<span class="n">ds</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">'hello'</span><span class="p">:</span> <span class="s1">'there'</span><span class="p">}]</span>
<span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">pformat</span><span class="p">(</span><span class="n">ds</span><span class="p">))</span>
</pre></div>
<h3 id="astliteral_eveleval">利用ast模块的literal_evel函数来更安全的eval</h3>
<p><code>literal_eval</code>函数是一个非常有用的函数，其可用于将某个短小的python字符串转化成python
object。如下所示:</p>
<div class="highlight"><pre><span></span>import ast
def str2pyobj(val):
    '''str to python obj or not changed'''
    try:
        val = ast.literal_eval(val)
    except Exception:###
        pass
    return val
</pre></div>
<p>支持的python object有: strings, bytes, numbers, tuples, lists, dicts,
sets, booleans, and None.</p>
<p>所以一般的字符串如 \"1\" \"3.14\" \"[1,2,3]\" 将其分别转化成为integer
float
和list是小菜一碟。当然最好建立异常捕捉，如果转化失败，则原样返回字符串即可。</p>
<h3 id="itertoolsproduct">利用itertools模块的product函数来遍历组合</h3>
<p>product函数在 <code>itertools</code> 模块里面，按照官方文档的说明是product(A, B)返回值等价于((x,y) for x in A for y in B)，也就是各种可能的组合情况（类似于笛卡尔积的概念）:</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; list(product(['a','b'],['c']))
[('a', 'c'), ('b', 'c')]
</pre></div>
<p>此外单一迭代加上 <code>repeat</code> 参数也会生成一些很有意思的结果:</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; list(product(['True','False'],repeat=len('abc')))
[('True', 'True', 'True'), ('True', 'True', 'False'), ('True', 'False', 'True'), ('True', 'False', 'False'), ('False', 'True', 'True'), ('False', 'True', 'False'), ('False', 'False', 'True'), ('False', 'False', 'False')]
</pre></div>
<p>这可以看作:</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; list(product(['True','False'],['True','False'],['True','False']))
[('True', 'True', 'True'), ('True', 'True', 'False'), ('True', 'False', 'True'), ('True', 'False', 'False'), ('False', 'True', 'True'), ('False', 'True', 'False'), ('False', 'False', 'True'), ('False', 'False', 'False')]
</pre></div>
<h3 id="collectionsdeque">利用collections模块的deque数据结构</h3>
<p>本小节主要参考了 <a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p03_keep_last_n_items.html">这个网页</a> 。</p>
<p>我想读者可能已经接触过queue结构了吧，queue结构是一端进data，然后另一端出data，这样形成了先进先出的数据流。而deque结构两端都可以进两端都可以出，这看上有点古怪，如果你只使用一端的话，那么其好像一个堆栈结构，是先进后出的；而如果一端只是进，另一端只是出，其又好像一个queue结构。那么其有什么优势呢？deque结构最大的优势，也就是我们需要使用它的原因是: 其两端插入元素和删除元素的时间复杂度是O(1)，是一个常数级，而列表开头插入或删除元素的时间复杂度是O(N)，所以如果我们需要一个类似列表的数据存储结构，而这个数据结构中，开头的几个元素和末尾的几个元素都比较重要，经常被访问，那么就应该使用deque结构。</p>
<p>上面的网页介绍了这么一个函数，用来返回一个文件最后的几行:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">def</span> <span class="nf">tail</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="s1">'Return the last n lines of a file'</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">deque</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
<p>其是利用了deque还有一个size定长的概念，输入的队列进入deque时较老的元素会被丢弃。我不太清楚这种做法效率如何，不过这种写法还是很优雅的。</p>
<h3 id="_19">查找多个最大最小元素的情况</h3>
<p>如果只是想要获知某些数据的一个最大值或者一个最小值，那么当然用 <code>max</code> 或 <code>min</code> 方法就可以了。这里讨论的情况是如果你想要获知某些数据的多个最大值或多个最小值。一般想到的就是先对这些数据进行排序，然后进行切片操作。参考资料2的第一章第四节讨论的方法实际上是利用最小堆结构进行堆排序然后提出最大或最小的那个几个元素。</p>
<p>大体过程就是:</p>
<div class="highlight"><pre><span></span>lst = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
import heapq
heapq.heapify(lst)
heapq.nlargest(3,lst)
heapq.nsmallest(3,lst)
</pre></div>
<h3 id="collectionsorderdict">利用collections模块的Orderdict类</h3>
<p>字典一般没有排序的需求吧，就是有也可以输出的时候再排序，再说OrderedDict和一般字典比较起来存储开销大了一倍，能不用就不用吧。不过在某些情况下，用这个类确实能带来一些便利。我第一次遇到这种情况大体是在bilibili的api对接那里，其计算密钥需要将所有参数排序然后urlencode为字符串然后再基于这个字符串进行一些计算。</p>
<div class="highlight"><pre><span></span>    params = OrderedDict(sorted(params.items(), key=lambda t: t[0]))
    string = urlencode(params)
</pre></div>
<p>大体在某些情况下，总是要求某个字典值变量按照某个顺序输出，那么用OrderedDict还是很便利的。其顺序就是按照其插入顺序来的，所以进入之前我们还是要做字典排序工作，所以我们可以看作这是一个自动进行了某种操作的便捷对象吧。</p>
<h2 id="counter">Counter类</h2>
<p>Counter类是真有用，而且还不是一般的好用。下面的例子来自参考资料2，不多说，看看代码大体就了解了:</p>
<div class="highlight"><pre><span></span>    words = [
        'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
        'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
        'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into',
        'my', 'eyes', "you're", 'under'
    ]
    from collections import Counter
    word_counts = Counter(words)
    # 出现频率最高的3个单词
    top_three = word_counts.most_common(3)
    print(top_three)
    # Outputs [('eyes', 8), ('the', 5), ('look', 4)]
</pre></div>
<p>Counter 对象是字典的子类，所以字典的一般方法它都有，下面就不赘述了。然后 <code>update</code> 方法我们应该理解为同key之间的加法， 此外还有 <code>subtract</code> 方法可以看作同key之间的减法。此外你还可以做:</p>
<p>这种加减运算和上面提及的 update 方法和 subtract 方法还是有点区别的，加法大体类似，主要是减法将会自动去掉计数小于等于零的项，而 <code>subtract</code> 方法不会。</p>
<div class="highlight"><pre><span></span>    &gt;&gt;&gt; a = Counter(words)
    &gt;&gt;&gt; b = Counter(morewords)
    &gt;&gt;&gt; a
    Counter({'eyes': 8, 'the': 5, 'look': 4, 'into': 3, 'my': 3, 'around': 2,
    "you're": 1, "don't": 1, 'under': 1, 'not': 1})
    &gt;&gt;&gt; b
    Counter({'eyes': 1, 'looking': 1, 'are': 1, 'in': 1, 'not': 1, 'you': 1,
    'my': 1, 'why': 1})
    &gt;&gt;&gt; # Combine counts
    &gt;&gt;&gt; c = a + b
    &gt;&gt;&gt; c
    Counter({'eyes': 9, 'the': 5, 'look': 4, 'my': 4, 'into': 3, 'not': 2,
    'around': 2, "you're": 1, "don't": 1, 'in': 1, 'why': 1,
    'looking': 1, 'are': 1, 'under': 1, 'you': 1})
    &gt;&gt;&gt; # Subtract counts
    &gt;&gt;&gt; d = a - b
    &gt;&gt;&gt; d
    Counter({'eyes': 7, 'the': 5, 'look': 4, 'into': 3, 'my': 2, 'around': 2,
    "you're": 1, "don't": 1, 'under': 1})
    &gt;&gt;&gt;
</pre></div>
<p>这个数据结构最为人们数值的统计频数了，通过调用 <code>most_common(n)</code> 方法，n是排行榜的前n名。</p>
<h3 id="collectionsnamedtuple">利用collections模块的namedtuple</h3>
<p>collections模块里面的namedtuple函数将会产生一个有名字的数组的类（有名数组），通过这个类可以新建类似的实例。比如：</p>
<div class="highlight"><pre><span></span>from collections import namedtuple

Point3d=namedtuple('Point3d',['x','y','z'])
p1=Point3d(0,1,2)
print(p1)
print(p1[0],p1.z)

Point3d(x=0, y=1, z=2)
0 2
</pre></div>
<h3 id="dataclass">构建一个dataclass类</h3>
<p>python3.7新加入的dataclass类是一个很有用的特性，对于代码中的某些函数之间彼此传输的特定数据，可以如下构建一个dataclass类：</p>
<div class="highlight"><pre><span></span>@dataclass
class InventoryItem:
    '''Class for keeping track of an item in inventory.'''
    name: str
    unit_price: float
    quantity_on_hand: int = 0
</pre></div>
<p>其大致效果等于：</p>
<div class="highlight"><pre><span></span>def __init__(self, name: str, unit_price: float, quantity_on_hand: int=0):
    self.name = name
    self.unit_price = unit_price
    self.quantity_on_hand = quantity_on_hand
</pre></div>
<p>编写这样的dataclass类主要是让你的项目代码数据定义更加清晰化。</p>
<h3 id="configparse">configparse处理特殊字符</h3>
<p>configparse对于某些特殊字符可能会报错，参考了 <a href="https://stackoverflow.com/questions/14340366/configparser-and-string-with">这个问题</a> ，推荐使用 <code>RawConfigParser</code> ，这样就可以解决问题。</p>
<h3 id="collectionschainmap">利用collections模块的ChainMap定义搜索过程</h3>
<p>将多个字典组合成为一个map字典，想到的一个应用就是配置字典流，利用ChainMap定义搜索路径流，先搜索到的配置优先取用。</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">ChainMap</span>
<span class="n">d1</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'a'</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s1">'b'</span><span class="p">:</span><span class="mi">2</span><span class="p">}</span>
<span class="n">d2</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'a'</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="s1">'d'</span><span class="p">:</span><span class="mi">3</span><span class="p">}</span>
<span class="n">d3</span> <span class="o">=</span> <span class="n">ChainMap</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
</pre></div>
<h3 id="typingnamedtuple">typing.NamedTuple</h3>
<p>这个类添加于python3.6，与 collections.namedtuple 非常类似。</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NamedTuple</span>
<span class="k">class</span> <span class="nc">Car</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">color</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">mileage</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">automatic</span><span class="p">:</span> <span class="nb">bool</span>
<span class="n">car1</span> <span class="o">=</span> <span class="n">Car</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">'red'</span><span class="p">,</span><span class="n">mileage</span><span class="o">=</span><span class="mf">3512.5</span><span class="p">,</span> <span class="n">automatic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">car1</span><span class="o">.</span><span class="n">color</span>
</pre></div>
<p>总的说来我不赞同达恩·巴德尔的观点——推荐使用typing.NamedTuple ，因为namedtuple有比较优势和区分的是相对于字典，其有两个特点：一，key不可变；二，轻量级。在某些情况下使用namedtuple优于字典。但是如果采用类的写法，那么就换了一个情景了，我认为在这个情境下，NamedTuple和dict都不太合适，而类应该成为第一公民。</p>
<h3 id="queuepriorityqueue">queue.PriorityQueue</h3>
<p>queue.PriorityQueue 内部实现是基于heapq堆排序的，只是额外做了一些处理，从而保证操作是线程安全的。一般来说如果要实现一个优先级队列，推荐使用 PriorityQueue：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">PriorityQueue</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">()</span>
<span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'code'</span><span class="p">))</span>
<span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'eat'</span><span class="p">))</span>
<span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'sleep'</span><span class="p">))</span> 
<span class="k">while</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
</pre></div>
<div class="highlight"><pre><span></span>(1, 'eat')
(2, 'code')
(3, 'sleep')
</pre></div>
<h3 id="queuequeue">queue.Queue</h3>
<p>这个是线程安全的先进先出【队列操作】数据结构。</p>
<div class="highlight"><pre><span></span>from queue import Queue
q = Queue()
q.put('a')
q.put('c')
print(q.get())
print(q.get())
</pre></div>
<div class="highlight"><pre><span></span>a
c
</pre></div>
<h3 id="queuelifoqueue">queue.LifoQueue</h3>
<p>这个是线程安全的后进先出【栈操作】的数据结构。</p>
<div class="highlight"><pre><span></span>from queue import LifoQueue
q = LifoQueue()
q.put('a')
q.put('c')
print(q.get())
print(q.get())
</pre></div>
<div class="highlight"><pre><span></span>c
a
</pre></div>
<h3 id="multiprocessingqueue">multiprocessing.Queue</h3>
<p>跨进程的先进先出队列数据结构：</p>
<div class="highlight"><pre><span></span>from multiprocessing import Queue
q = Queue()
q.put('a')
q.put('c')
print(q.get())
print(q.get())
</pre></div>
<div class="highlight"><pre><span></span>a
c
</pre></div>
<h2 id="_20">有用的第三方模块</h2>
<h3 id="_21">获取一个月最后的一天</h3>
<p>首先要说的是利用python的datetime和timedelta对于 <code>days</code> 的加减操作是能够很好地支持跨月问题的:</p>
<div class="highlight"><pre><span></span>    &gt;&gt;&gt; from datetime import datetime
    &gt;&gt;&gt; d = datetime.now()
    &gt;&gt;&gt; d
    datetime.datetime(2016, 5, 29, 8, 50, 20, 337204)
    &gt;&gt;&gt; from datetime import timedelta
    &gt;&gt;&gt; d - timedelta(days = 29)
    datetime.datetime(2016, 4, 30, 8, 50, 20, 337204)
    &gt;&gt;&gt; d - timedelta(days = 28)
    datetime.datetime(2016, 5, 1, 8, 50, 20, 337204)
</pre></div>
<p>但是有的时候你就是需要直接获知某个月份的最后一天是30还是31等等，然后利用replace来获得一个月的最后一天。这个时候你需要利用 calendar 的 <code>monthrange</code> 函数。参考了 <a href="http://stackoverflow.com/questions/42950/get-last-day-of-the-month-in-python">这个网页</a> 。</p>
<div class="highlight"><pre><span></span>    &gt;&gt;&gt; d.replace(year = 2016,month=4,day = monthrange(2016,4)[-1])
    datetime.datetime(2016, 4, 30, 8, 50, 20, 337204)
</pre></div>
<h2 id="_22">附录</h2>
<p><strong>下面列出的技巧可能并不是那么重要。</strong></p>
<h3 id="_23">给某个对象动态加载一个方法</h3>
<p>这里主要参考了 <a href="http://stackoverflow.com/questions/962962/python-changing-methods-and-attributes-at-runtime">这个网页</a> 。</p>
<p>具体原理还是很简单的，那就是构建一个函数对象，然后将这个对象赋值给某个对象。但这里的函数对象如果要接受self参数的话，其作为类的方法还是需要一些特殊的处理的。</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Test</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="n">test</span> <span class="o">=</span> <span class="n">Test</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"hello"</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">types</span>
<span class="n">test</span><span class="o">.</span><span class="n">hello</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">hello</span><span class="p">,</span><span class="n">Test</span><span class="p">)</span>

<span class="n">test</span><span class="o">.</span><span class="n">hello</span><span class="p">()</span>
</pre></div>
<p>上面的types.MethodType是用来构建一个类的方法的，其第一个参数是具体的函数对象，第二个参数是对应的类或实例。</p>
<p>然后上面的例子继续优化就是如下的形式:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">types</span>

<span class="k">class</span> <span class="nc">Test</span><span class="p">():</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">removeVariable</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">delattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">addMethod</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">func</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span><span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="bp">cls</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"hello"</span><span class="p">)</span>

<span class="n">test</span> <span class="o">=</span> <span class="n">Test</span><span class="p">()</span>

<span class="n">Test</span><span class="o">.</span><span class="n">addMethod</span><span class="p">(</span><span class="n">hello</span><span class="p">)</span>

<span class="n">test</span><span class="o">.</span><span class="n">hello</span><span class="p">()</span>
</pre></div>
<p>你看到了这里的addMethod是作用于本类的，当然你也可以选择作用于本实例:</p>
<div class="highlight"><pre><span></span>import types

class Test():
    @classmethod
    def removeVariable(cls,name):
        return delattr(cls,name)

    @classmethod
    def addMethod(cls,func):
        return setattr(cls,func.__name__,types.MethodType(func,cls))

    def addMethod2(self,func):
        return setattr(self,func.__name__,types.MethodType(func,self))

def hello(self):
    print("hello")

test = Test()

test.addMethod2(hello)

test.hello()
</pre></div>
<p>这样这个函数就只加在本实例上面了，这用处不太大。</p>

            <section>
<div class="panel-group" id="accordion2">
    <div class="panel panel-default">
        <div class="panel-heading">
            <a class="accordion-toggle disqus-comment-count" data-toggle="collapse" data-parent="#accordion2"
                href="https://a358003542.github.io/articles/python-cookbook.html#disqus_thread">
                Comments
            </a>
        </div>
        <div id="disqus_thread" class="panel-collapse collapse">
            <div class="panel-body">
                <div class="comments">
                    <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'cdwanzes-blog';
        var disqus_identifier = 'https://a358003542.github.io/articles/python-cookbook.html';
    var disqus_url = 'https://a358003542.github.io/articles/python-cookbook.html';

    (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

                </div>
            </div>
        </div>
    </div>
</div>
</section>

            <hr/>

        </div>
        <section>
        <div class="col-md-2" style="float:right;font-size:0.9em;">
            <h4>首发于：</h4>
            <time pubdate="pubdate" datetime="2021-10-28T00:00:00+08:00">2021年 10月 28日 </time>

            <h4>分类：</h4>
            <a class="category-link" href="https://a358003542.github.io/categories.html#python_language-ref">python_language</a>
            <h4>标签：</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="https://a358003542.github.io/tags.html#python-ref">python
                    <span>26</span>
</a></li>
            </ul>

        </div>
        </section>
</div>
</article>
    </div>
    <div class="col-md-1"></div>

</div>


<div id="push"></div>
<button id="gotop" type="button" class="btn btn-default">
    <span class="glyphicon glyphicon-arrow-up" aria-hidden="true"></span>
</button>

<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a> and updated by <a href="https://github.com/a358003542" title="wanze Home Page">wanze</a></li>
    </ul>
</div>
</footer>

        <script src="https://a358003542.github.io/theme/js/jquery.min.js"></script>
    <script src="https://a358003542.github.io/theme/js/bootstrap.min.js"></script>

    <script src="https://a358003542.github.io/theme/js/moment.min.js"></script>

    <script src="https://a358003542.github.io/theme/js/base.js"></script>

            <script type="text/javascript">
var disqus_shortname = 'cdwanzes-blog';
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>
<script  language="javascript" type="text/javascript">
function uncollapse() {
    if (window.location.hash.match(/^#comment-\d+$/)) {
        $('#disqus_thread').collapse('show');
    }
}
</script>
<script type="text/javascript" language="JavaScript">
uncollapse();
window.onhashchange=function(){
    if (window.location.hash.match(/^#comment-\d+$/))
        window.location.reload(true);
}
</script>
<script>
$('#disqus_thread').on('shown', function () {
    var link = document.getElementsByClassName('accordion-toggle');
    var old_innerHTML = link[0].innerHTML;
    $(link[0]).fadeOut(500, function() {
        $(this).text('Click here to hide comments').fadeIn(500);
    });
    $('#disqus_thread').on('hidden', function () {
        $(link[0]).fadeOut(500, function() {
            $(this).text(old_innerHTML).fadeIn(500);
        });
    })
})
</script>




</body>
</html>