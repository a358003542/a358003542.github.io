<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="msvalidate.01" content="55CB117A61A6F8286173763FB18D9625"/>
    <meta name="google-site-verification" content="r5HyVvY-ZSgf7ctpcpK1aWIaEfKJ0dvAE3E9kW3vXgI" />
    <script data-ad-client="ca-pub-5644206261254049" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
        <meta name="author" content="wanze"/>
        <meta name="copyright" content="wanze"/>

        <meta name="description"
              content="简介 C# 程序运行在.net平台上的，在介绍C#语言之前需要介绍下.net平台。对于.net平台内部的细节和微软的设计雄心之类的我们没必要去深究，简单来说.net平台提供了一个运行时，在这个运行时之下你可以运行.net应用。.net应用五花八门并可以跨多个平台，然后开发.net应用的程序员还..."/>


<meta name="keywords" content=", archived, " />

    <title>学习C#编程  · 万泽的博客
</title>

        <link href="https://a358003542.github.io/theme/css/font-awesome.css" rel="stylesheet"
              media="screen">
        <link href="https://a358003542.github.io/theme/css/bootstrap.min.css" rel="stylesheet"
              media="screen">

        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/pygments.css" media="screen">
        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/elegant.css" media="screen">
        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/base.css" media="screen">




</head>
<body>

<nav class="navbar">
    <div class="navbar navbar-default" role="navigation">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed"
                    data-toggle="collapse" data-target=".navbar-collapse"
                    aria-expanded="false">
                <span class="sr-only">Navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <a class="navbar-brand" href="https://a358003542.github.io/"><span
                    class=site-name>网站首页</span></a>
        </div>


        <div class="navbar-collapse collapse">
            <form action="https://a358003542.github.io/search.html"
                  onsubmit="return validateForm(this.elements['q'].value);"
                  class="navbar-form navbar-left">
                <div class="form-group">
                    <input type="text" name="q" id="tipue_search_input"
                           class="form-control" placeholder="Search..."
                           style="width:430px;">
                </div>
                <button class="btn btn-default" type="submit">搜索</button>
            </form>


            <ul class="nav navbar-nav nav-pills navbar-right">

                <li >
                    <a  href="/archives.html">存档博文</a></li>

                <li><a target="_blank" href="https://github.com/a358003542">我的Github</a></li>
    

                        <li >
                            <a href="https://a358003542.github.io/about.html">关于本网站</a>
                        </li>
            </ul>


        </div>
    </div>
</nav>


<div class="container-fluid">
    <div class="col-md-1 col-md-1-left"></div>
    <div class="col-md-10">
<article>
<div class="row">
    <header class="page-header col-md-10 col-md-offset-2">
    <h1><a href="https://a358003542.github.io/articles/xue-xi-cbian-cheng.html"> 学习C#编程  </a></h1>
    </header>
</div>

<div class="row">
    <div class="col-md-2 table-of-content">
        <nav>
        <h4>目录</h4>
        <div class="toc">
<ul>
<li><a href="#_1">简介</a></li>
<li><a href="#helloworld">helloworld</a></li>
<li><a href="#_2">第二个例子</a><ul>
<li><a href="#_3">声明变量</a></li>
<li><a href="#_4">基本的运算符</a></li>
<li><a href="#_5">注释</a></li>
<li><a href="#_6">强制类型转换</a></li>
</ul>
</li>
<li><a href="#_7">类型系统</a><ul>
<li><a href="#value-type">value type</a><ul>
<li><a href="#_8">简单类型</a></li>
<li><a href="#_9">枚举类型</a></li>
<li><a href="#_10">结构体类型</a></li>
<li><a href="#null">null</a></li>
<li><a href="#tuple">Tuple</a></li>
</ul>
</li>
<li><a href="#reference-type">reference type</a><ul>
<li><a href="#class">class</a></li>
<li><a href="#string">string</a></li>
<li><a href="#object">object</a></li>
<li><a href="#interface">interface</a></li>
<li><a href="#array">array</a></li>
<li><a href="#delegate">delegate</a></li>
</ul>
</li>
<li><a href="#_11">隐式类型声明</a></li>
<li><a href="#_12">变量名命名规范</a></li>
<li><a href="#_13">变量的作用域</a></li>
</ul>
</li>
<li><a href="#_14">访问权限控制</a></li>
<li><a href="#_15">编写方法</a><ul>
<li><a href="#_16">可选参数</a></li>
<li><a href="#_17">按照参数名字赋值</a></li>
<li><a href="#_18">不定参数</a></li>
</ul>
</li>
<li><a href="#_19">程序结构</a><ul>
<li><a href="#switch">switch语句</a></li>
<li><a href="#foreach">foreach语句</a></li>
<li><a href="#lambda">lambda表达式</a></li>
<li><a href="#_20">异常捕捉</a></li>
</ul>
</li>
<li><a href="#class_1">class面向对象编程</a><ul>
<li><a href="#this">this</a></li>
<li><a href="#getset">属性值的get和set写法</a></li>
<li><a href="#static">static</a></li>
<li><a href="#_21">静态构造方法</a></li>
<li><a href="#refinout">ref和in和out</a></li>
<li><a href="#_22">继承</a><ul>
<li><a href="#interface_1">interface</a></li>
<li><a href="#abstractsealed">abstract和sealed</a></li>
</ul>
</li>
<li><a href="#_23">多态</a><ul>
<li><a href="#_24">运算符重载</a></li>
</ul>
</li>
<li><a href="#_25">做点练习题温习下</a></li>
</ul>
</li>
<li><a href="#generic">generic泛型编程</a></li>
<li><a href="#collection">Collection库</a><ul>
<li><a href="#list">List</a></li>
<li><a href="#dictionary">Dictionary</a></li>
</ul>
</li>
<li><a href="#_26">其他</a><ul>
<li><a href="#_27">表达式形式定义</a></li>
</ul>
</li>
<li><a href="#_28">参考资料</a></li>
</ul>
</div>
        </nav>
    </div>
    <div class="col-md-8 article-content">

            
<h2 id="_1">简介</h2>
<p>C# 程序运行在.net平台上的，在介绍C#语言之前需要介绍下.net平台。对于.net平台内部的细节和微软的设计雄心之类的我们没必要去深究，简单来说.net平台提供了一个运行时，在这个运行时之下你可以运行.net应用。.net应用五花八门并可以跨多个平台，然后开发.net应用的程序员还需要下载.net sdk。熟悉JAVA语言的对这个运行时和SDK的概念不会很陌生，所不同的是.net平台还封装了一个中间语言层，然后才是上面具体的语言的编译器，也就是.net平台是支持多个编程语言的，当然包括这里谈论的C#语言。</p>
<p>Unity游戏开发就是构建在.net平台之上的，这也是笔者学习C#语言的原因。</p>
<p>笔者还是推荐安装visual studio，然后通过visual studio来安装.net开发环境。具体就是 <code>.NET桌面开发</code> 工作负载。有时间和精力的可以折腾dotnet命令行来编译</p>
<h2 id="helloworld">helloworld</h2>
<p>学习任何一门新的编程语言，必然先从打印一串hello world字符串开始。</p>
<ol>
<li>创建新项目</li>
<li>选择控制台应用(.net core)【.net core就是上面谈及的.net平台的运行时，此外还有.net framwork等。.net framework只支持windows系统，.net core支持多个操作系统，微软对.net framework处于待遗弃状态，visual studio2019，C#8 ，.net core3.0 这几个关键词需要了解下，它们是同一时间发布的。以后微软计划将各个.net平台运行时合并为一个——.net5。】</li>
<li>生成-&gt;生成解决方案</li>
<li>调试-&gt;开始调试</li>
</ol>
<div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">ConsoleApp1</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<ul>
<li><code>using</code> 导入某个命名空间，如果你熟悉python语言的话，这里做的事情有点类似于<code>from what import *</code> ；如果你熟悉C++的话那么这里的概念大体类似于C++的命名空间。或者简单来说命名空间就是将变量名放在某个空间之下，然后你在外面要引用的话需要额外加上该命名空间的名字前缀，除非你用using导入那个命名空间。</li>
<li><code>namespace</code> 定义了一个命名空间</li>
<li><code>class</code> 声明一个类</li>
<li><code>static void Main...</code> 这是定义一个类的方法，Main方法比较特殊，为本程序的入口方法</li>
<li><code>string[] args</code> 这是该方法接受的一个参数，该参数是一个string类型的数组。</li>
<li><code>Console.WriteLine</code> 调用打印方法 【完整的变量名是 System.Console.WriteLine，该变量名是一个方法，因为你之前使用了using System，所以这里可以省略System的命名空间前缀了。】</li>
</ul>
<h2 id="_2">第二个例子</h2>
<p>一般学习一门新的编程语言在hello world之后，第二个例子就是学习该编程语言怎么声明一个变量以及其他一些基本的东西。请看下面这个练习题：</p>
<ol>
<li>定义一个常数 double pi</li>
<li>定义半径 double r</li>
<li>计算该半径的面积并报告结果。</li>
</ol>
<p>下面请读者结合下面的内容知识点讲解然后将这个题目做出来。</p>
<h3 id="_3">声明变量</h3>
<div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">double</span> <span class="n">pi</span> <span class="p">=</span> <span class="m">3.14</span><span class="p">;</span>
</pre></div>
<p>这是声明了一个常量，常量之后不可修改。</p>
<div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">x</span> <span class="p">=</span> <span class="m">5.0</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="n">y</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
</pre></div>
<p>这是声明了一个变量。</p>
<p>常见的变量类型有：</p>
<ul>
<li>string 字符串 <code>string x = "abc";</code></li>
<li>char 单字符型 <code>char x = 'a';</code></li>
<li>int 整型 <code>int x = 1;</code></li>
<li>double 浮点型 <code>double x = 1.0;</code></li>
</ul>
<h3 id="_4">基本的运算符</h3>
<p>C#在基本的运算符这块和C++或者说和大部分编程语言来说都差别不大的，下面简单将这些运算符列出来然后大家按照数学常识或者编程常识去使用即可：</p>
<div class="highlight"><pre><span></span>+ 加
- 减
* 乘
/ 除
% 取模
++ 自增
-- 自减
== 是否等于
!= 是否不等于
&gt; 是否大于
&lt; 是否小于
&gt;= 是否大于等于
&lt;= 是否小于等于
&amp;&amp; 逻辑与
|| 逻辑或
! 逻辑非
&amp; 按位与
| 按位或
^ 按位异或
&lt;&lt; 按位左移
&gt;&gt; 按位右移
+= 即运算后赋值，这类还有 -= /= 等等就不赘述了
condition ? yes-statement : no-statement 即三元运算符
</pre></div>
<h3 id="_5">注释</h3>
<p>C#的注释单行是 <code>//</code> ，多行是 <code>/*...*/</code> 。</p>
<h3 id="_6">强制类型转换</h3>
<p>低精度到高精度可以自动转没问题，高精度到低精度需要明确强制类型转换：</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">y</span> <span class="p">=</span> <span class="m">3.0</span><span class="p">;</span>
<span class="n">x</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">y</span><span class="p">;</span>
</pre></div>
<h2 id="_7">类型系统</h2>
<p>下面进入学习一门新编程语言最核心的一个环节，详细熟悉该编程语言的类型系统。这块各个编程语言或多或少都有些差异的。</p>
<h3 id="value-type">value type</h3>
<p>C#有两种变量类型，value type直接存储变量的值，reference type存储的是对目标数据的引用。value type是存储在stack堆栈里面的，reference type是存储在heap堆里面的，具体这个后面再细说。</p>
<p><u>C#的所有变量都是有默认值的</u>，比如reference type变量的默认值是null，比如bool类型默认值是false。虽然如此但个人建议对于布尔值还是明确确定初始值会好一些。其他的数值一般默认值为0字符串默认为空字符串等这些都符合大家的心理预期。</p>
<p>value type变量赋值给另外一个变量，其值是copy过去的。比如说</p>
<div class="highlight"><pre><span></span>int a = 50;
int b = a;
a = 20; //这个时候a是20而b则是50
</pre></div>
<h4 id="_8">简单类型</h4>
<p>基本类型即使是在所谓的动态高级语言里面也是看得到的。</p>
<ul>
<li>sbyte short <strong>int</strong> <strong>long</strong></li>
<li><strong>byte</strong> ushort unit ulong</li>
<li><strong>char</strong></li>
<li><strong>float</strong> <strong>double</strong> </li>
<li><strong>decimal</strong> 比double存储位数更多的浮点型，这个在某些编程语言里面可能没有，但其仍然属于浮点型，别误以为其是某种表示精确小数的类型。decimal主要用于金融领域的应用。</li>
<li><strong>bool</strong></li>
</ul>
<p>C#的数值二进制表示可以写成这样的形式：<code>0b_0010_1010</code> ，常见的 <code>0b00101010</code> 写法也是支持的，新增这种对人类友好格式的写法的支持还是值得肯定的。</p>
<h4 id="_9">枚举类型</h4>
<p>C#的枚举类型和C++的enum class有点接近，但在使用上略有差异。</p>
<p>比如C++的下面语句：</p>
<div class="highlight"><pre><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
<span class="n">Color</span> <span class="n">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">blue</span><span class="p">;</span>
</pre></div>
<p>转成C#应该是：</p>
<div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
<span class="n">Color</span> <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">blue</span><span class="p">;</span>
</pre></div>
<p>具体到枚举类型的内部细节，和C语言的枚举类型应该是一脉相承。</p>
<h4 id="_10">结构体类型</h4>
<p>C#里面的结构体和C++里面的结构体差异巨大，C++里面的结构体概念和C语言的结构体区别不大，只是一种比数组略灵活点的变量类型，专门用来存储呈现一定结构特征的数据用的。而C#里面struct则更接近于class这个概念，有一些小的使用上的区别，其他都大同小异，其中最大的一个区别是struct是类型是value type，而class的类型是reference type。</p>
<p>比如下面这个例子，C#里面的struct一样也可以有自己的构造方法：</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Coordinate</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Coordinate</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Coordinate</span> <span class="n">point</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Coordinate</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">);</span>
</pre></div>
<p>但需要注意的是<strong>C#的struct不能再定义无参构造方法</strong>，因为它默认已经有了。当然struct没有继承关系。</p>
<p>完整的struct不能class能的清单如下：</p>
<ul>
<li>You can't declare a parameterless constructor. Every structure type already provides an implicit parameterless constructor that produces the <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values">default value</a> of the type.</li>
<li>You can't initialize an instance field or property at its declaration. However, you can initialize a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/static">static</a> or <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/const">const</a> field or a static property at its declaration.</li>
<li>A constructor of a structure type must initialize all instance fields of the type.</li>
<li>A structure type can't inherit from other class or structure type and it can't be the base of a class. However, a structure type can implement <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface">interfaces</a>.</li>
<li>You can't declare a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/destructors">finalizer</a> within a structure type.</li>
</ul>
<h4 id="null">null</h4>
<p>reference type变量的默认值就是null。</p>
<h4 id="tuple">Tuple</h4>
<p>tuple基本使用如下：</p>
<div class="highlight"><pre><span></span>            <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="kt">float</span><span class="p">)</span> <span class="n">t1</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="s">"t1"</span><span class="p">,</span> <span class="m">3.14f</span><span class="p">);</span>

            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">$</span><span class="s">"{t1.Item1} , {t1.Item2}, {t1.Item3}"</span><span class="p">);</span>

            <span class="kt">var</span> <span class="n">t2</span> <span class="p">=</span> <span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="s">"t2"</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">$</span><span class="s">"{t2.Item1} , {t2.Item2}"</span><span class="p">);</span>
</pre></div>
<p>其一个经常使用场景就是一个tuple作为方法的返回值。</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">)</span> <span class="n">FindMinMax</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">input</span><span class="p">){</span>
    <span class="c1">//</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<h3 id="reference-type">reference type</h3>
<p>reference type变量赋值给另外一个变量，它们两个都是指向的同一数据对象。但string情况略有不同，因为string是不可变的，所以string发生变化实际上是又新建了一个string。</p>
<h4 id="class">class</h4>
<p>用户自定义一个类，关于面向对象这块更多内容在后面讨论。</p>
<h4 id="string">string</h4>
<p>字符串，不可变的reference type类型。值得一提的是C#的字符串不需要以<code>\0</code> 结尾。</p>
<p>字符串内插和常用的字符串方法有：</p>
<div class="highlight"><pre><span></span><span class="err">$</span><span class="s">"hello {name}"</span><span class="p">;</span>
</pre></div>
<p>或者使用字符串对象的Format方法：</p>
<div class="highlight"><pre><span></span>string.Format("{0} + {1} = {2}", a, b, a+b);
</pre></div>
<p>此外你还可以使用 <code>"abc" + "def"</code> 加法来组合字符串。</p>
<ul>
<li>Length 属性 返回字符串长度</li>
<li>TrimStart 方法 去除字符串前面的空格</li>
<li>TrimEnd 方法 去除字符串后面的空格</li>
<li>Replace 方法 子字符串替换动作</li>
<li>ToUpper 方法  英文字母都转成大写</li>
<li>ToLower 方法 英文字母都转成小写</li>
<li>Contains 方法 查看某个子字符串是否存在</li>
<li>StartsWith 方法 字符串是否以某个子字符串开始</li>
<li>EndsWith 方法 字符串是否以某个子字符串结束</li>
</ul>
<h4 id="object">object</h4>
<p>C# 采用 <strong>统一的类型系统</strong>。 所有 C# 类型（包括 <code>int</code> 和 <code>double</code> 等基元类型）均直接或间接继承自一个根 <code>object</code> 类型。</p>
<p>读者可能会问int不是value type吗，其继承自object，而object则是reference type，这怎么回事。这涉及到 Boxing and Unboxing 的概念。</p>
<p>将一个object转成value type称之为unboxing过程，反之是boxing过程。value type存储在堆栈stack里面的，reference type存储在堆heap里面的。boxing过程先需要将value type里的value取出存入heap，然后获得heap的reference指向。而unboxing过程是从heap里面将对应值取出来然后存放入stack。</p>
<p>下面是boxing过程：</p>
<div class="highlight"><pre><span></span>int i = 123;
object o = i;
</pre></div>
<p>下面是unboxing过程：</p>
<div class="highlight"><pre><span></span>o = 123;
i = (int)o;  
</pre></div>
<p>下面列出一些方法，这些方法是object上定义的，也就是C#的所有对象都可以调用这些方法。</p>
<ul>
<li>ToString() 将目标对象转成字符串。</li>
<li>GetType() 获得目标对象的类型</li>
<li>Equals() 检查两个对象是否是同一对象【对于value type是检查值相等，对于reference type是检查在heap上的引用指向是否相等】</li>
</ul>
<h4 id="interface">interface</h4>
<p>interface主要用来给类提供一些方法或说接口上的规范。C#的interface命名上有个约定是以大写字母I开头。</p>
<p>下面是一个演示例子：</p>
<div class="highlight"><pre><span></span><span class="k">interface</span> <span class="n">IEquatable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="n">T</span> <span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Car</span> <span class="p">:</span> <span class="n">IEquatable</span><span class="p">&lt;</span><span class="n">Car</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Make</span> <span class="p">{</span><span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Model</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Year</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// Implementation of IEquatable&lt;T&gt; interface</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="n">Car</span> <span class="n">car</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Make</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">Model</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">Year</span><span class="p">)</span> <span class="p">==</span>
            <span class="p">(</span><span class="n">car</span><span class="p">.</span><span class="n">Make</span><span class="p">,</span> <span class="n">car</span><span class="p">.</span><span class="n">Model</span><span class="p">,</span> <span class="n">car</span><span class="p">.</span><span class="n">Year</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h4 id="array">array</h4>
<p>C#的Array不能对比为C语言或C++的数组，和C++的array类有点类似：</p>
<p>在C++里有：</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">a2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
</pre></div>
<p>上面的写法转成C#是：</p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[]</span> <span class="n">a2</span> <span class="p">=</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">};</span>
</pre></div>
<p>但也只是类似，就底层实现细节可以按照传统概念上的数组来思考理解，而就具体程序上来说其是一个对象，还有很多额外的方法支持。</p>
<p>声明一个array如下所示：</p>
<div class="highlight"><pre><span></span>elementType[] name = new elementType[numberOfElements];
</pre></div>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[]</span> <span class="n">arr1</span><span class="p">;</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">arr2</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">6</span><span class="p">];</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">arr3</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[]</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">};</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">arr4</span> <span class="p">=</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">};</span>
</pre></div>
<p>array一旦初始化长度是不可变的，如果你需要可变的array，可以考虑List类。</p>
<h4 id="delegate">delegate</h4>
<p>delegeta的应用场景主要在函数作为函数的参数这块，在这块C++我们知道是通过函数指针来做的，然后因为函数的进出参数类型有时很复杂，是的这块处理不是很优雅，一个勉强可行的做法就是通过typedef来做。</p>
<p>下面是C++对于这个问题的一个演示例子：</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">typedef</span> <span class="nf">double</span><span class="p">(</span><span class="o">*</span><span class="n">test_func_type</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">estimate</span><span class="p">(</span><span class="kt">int</span> <span class="p">,</span> <span class="n">test_func_type</span><span class="p">);</span>
<span class="kt">double</span> <span class="nf">test_func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>


<span class="kt">double</span> <span class="nf">test_func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="mf">3.14</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" * 3.14 = "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">estimate</span><span class="p">(</span><span class="kt">int</span> <span class="n">repeat</span><span class="p">,</span> <span class="n">test_func_type</span> <span class="n">pf</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">repeat</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="mi">3</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">estimate</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">test_func</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>对于上面的程序写出C#版本：</p>
<div class="highlight"><pre><span></span>  <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">delegate</span> <span class="kt">double</span> <span class="nf">DMethod</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
        <span class="k">public</span> <span class="k">static</span> <span class="kt">double</span> <span class="nf">TestFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">double</span> <span class="n">b</span><span class="p">;</span>
            <span class="n">b</span> <span class="p">=</span> <span class="n">a</span> <span class="p">*</span> <span class="m">3.14</span><span class="p">;</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">$</span><span class="s">"{a} * 3.14 = {b}"</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Estimate</span><span class="p">(</span><span class="kt">int</span> <span class="n">repeat</span><span class="p">,</span> <span class="n">DMethod</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">repeat</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">m</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">DMethod</span> <span class="n">handler</span> <span class="p">=</span> <span class="n">TestFunc</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="m">3</span><span class="p">;</span>
            <span class="n">Estimate</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
<p>delegate的作用就是定义了这样的方法委托或者更直白点就是C#这边的函数指针类似实现。</p>
<h3 id="_11">隐式类型声明</h3>
<div class="highlight"><pre><span></span>var x = 1;
</pre></div>
<p>C#是强类型语言，上面的语句只是说让编译器来决定该变量的类型。</p>
<p>在很多情境下，var更像是一个提供便捷的语法糖，比如：</p>
<div class="highlight"><pre><span></span>var x = 0L;
</pre></div>
<p>后面跟个<code>L</code> 那么对应的类型就是long integer类型。如果后面跟个<code>f</code> ，那么对应float类型，如果跟个 <code>d</code> 那么对应double类型。</p>
<h3 id="_12">变量名命名规范</h3>
<p>首先是编程语言通用的规范：一般来说只推荐字母加上下划线组成变量名，某些情况下需要带上数字的数字放在后面。下划线一般变量不允许放在前面，只有某些特殊变量才会把下划线放在前面。编程语言自身的保留字不得使用。</p>
<p>下面继续C#特有的一些命名规范：</p>
<ul>
<li>C#的变量名总的来说推荐采用驼峰写法，也即是 <code>AbcAbc</code> 或者 <code>abcAbc</code> 这样的写法。其中类，结构体，枚举，delegate，方法，属性等推荐大写字母开头，其他不太重要的本地变量推荐小写字母开头。</li>
<li>python编程语言是推荐下划线风格写法，但C#这里是不推荐使用下划线的。</li>
</ul>
<h3 id="_13">变量的作用域</h3>
<p>类似于C++等语言，C#也有变量作用域这个概念，同样的简单表述就是<strong>块作用域</strong>，具体就是某个花括号块或者方法区块或者类区块，在这些区块类声明的变量，可在本区块内直接访问，区块外则不行。</p>
<h2 id="_14">访问权限控制</h2>
<p>经常看到 <code>public int x = 1;</code> ，这个public就是访问修饰符，控制该变量的访问权限的：</p>
<ul>
<li>public 访问权限无限制，只有声明public的变量你才能在unity 编辑器上看到。</li>
<li>private 访问权限限于本类，C#中没有访问权限修饰符的变量声明默认是private。</li>
<li>protected 访问权限限于本类或本类的子类</li>
<li>internal 访问权限限于本汇编（exe或dll）</li>
<li>protected internal</li>
<li>private internal</li>
</ul>
<h2 id="_15">编写方法</h2>
<p>C#有点特殊，因为其一切皆对象的设定，按照程序界的标准术语，那么在C#就没有所谓的编写函数，而只有编写方法这个说法了。</p>
<div class="highlight"><pre><span></span>accessModifier returnType methodName(parameterType parameterName){
    // do something
}
</pre></div>
<p>访问修饰符如果省略类似于变量声明那边，默认是private。</p>
<h3 id="_16">可选参数</h3>
<p>和C++格式一样。</p>
<div class="highlight"><pre><span></span>public void ExampleMethod(int required, string optionalstr = "default string",
    int optionalint = 10)
</pre></div>
<h3 id="_17">按照参数名字赋值</h3>
<div class="highlight"><pre><span></span>static void PrintOrderDetails(string sellerName, int orderNum, string productName){
    //
}

PrintOrderDetails(productName: "Red Mug", sellerName: "Gift Shop", orderNum: 31);
</pre></div>
<h3 id="_18">不定参数</h3>
<p>params关键词，参数类型一维数组，后面不能再带参数了。</p>
<div class="highlight"><pre><span></span>    public static void UseParams(params int[] list)
    {
        for (int i = 0; i &lt; list.Length; i++)
        {
            Console.Write(list[i] + " ");
        }
        Console.WriteLine();
    }
</pre></div>
<h2 id="_19">程序结构</h2>
<p>在程序结构这块，和其他编程语言大同小异的下面就不赘述了，下面主要讨论一些C#看起来不太一样的东西。</p>
<h3 id="switch">switch语句</h3>
<p>switch语句在C#这边和C++那边差异很大，C++的switch语句的目标测试变量必须是整型或者枚举类型或者能够转成整型或枚举类型的对象。而C#那边之前支持的类型就很多，现在是任何非null表达式都行。比如下面就是直接对字符串是否相等然后进行switch，这在C++那边是不行的。</p>
<div class="highlight"><pre><span></span>            <span class="kt">string</span> <span class="n">x</span> <span class="p">=</span> <span class="s">"xxxx"</span><span class="p">;</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">case</span> <span class="s">"hello"</span><span class="p">:</span>
                    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"HELLO"</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">default</span><span class="p">:</span>
                    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"default"</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
</pre></div>
<p>C#switch语句和C++还有一个不同，那就是它从语法层面是禁止这种写法的：</p>
<div class="highlight"><pre><span></span>                case "hello":
                    Console.WriteLine("HELLO");

                case "world":
                    Console.WriteLine("world");
                    break;
</pre></div>
<p>C++那边也不推荐这种写法，但并没有禁止，如果这样写的话，C++那边hello的case激活之后没有break会继续下面的case语句执行，这确实很不好，即使是C++也应该避免这种写法。</p>
<h3 id="foreach">foreach语句</h3>
<p>C#的foreach语句在C++那边可以类比for range语句或者就是python的for语句：</p>
<p>在C++那边有：</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">x</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>C#的foreach语句写法是：</p>
<div class="highlight"><pre><span></span><span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">x</span> <span class="k">in</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[]</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span> <span class="p">}){</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>C#的foreach可以迭代的对象除了上面演示的array之外，C#常用的Collection库里面的对象也都是可以迭代的。</p>
<h3 id="lambda">lambda表达式</h3>
<div class="highlight"><pre><span></span>(input-parameters) =&gt; expression
</pre></div>
<h3 id="_20">异常捕捉</h3>
<div class="highlight"><pre><span></span>try{
  // do something
}catch (Exception ex){
    Console.WriteLine(ex);
}finally{

}
</pre></div>
<h2 id="class_1">class面向对象编程</h2>
<p>C#的class类<strong>只允许单继承</strong>，也就是最多只能继承自一个父类。基本类的使用如下所示：</p>
<div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Character</span><span class="p">:</span> <span class="n">BaseClass</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">exp</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Character</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">name</span> <span class="p">=</span> <span class="n">name</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Character</span> <span class="n">hero</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Character</span><span class="p">(</span><span class="s">"lucy"</span><span class="p">);</span>
</pre></div>
<p>上面演示了如何声明一个class，这个class继承自某个父类，class类都有默认的无参构造方法，这里再给该class类定义了一个接受参数的构造方法，然后演示了this关键词，最后演示了如何实例化一个class类。</p>
<h3 id="this">this</h3>
<p>this关键词类似于python里面的self，和C++上的this大体含义也是一样的，是一个指向本类实例的指针。同样在本类里面定义的方法下面都默认带入了this这个参数，也就是在各个方法里面直接使用即可。静态类或静态方法里面是没有this关键词的，因为默认是不实例化，当然就没有this这个关键词了。</p>
<h3 id="getset">属性值的get和set写法</h3>
<div class="highlight"><pre><span></span>    <span class="k">private</span> <span class="kt">string</span> <span class="n">_name</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span><span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">_name</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">set</span> <span class="p">{</span>
        <span class="n">_name</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">}</span>
</pre></div>
<p>如果是上面没啥动作的get和set属性方法那么完全可以用下面这种默认的自动属性实现写法：</p>
<div class="highlight"><pre><span></span><span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
<h3 id="static">static</h3>
<p>C#类里面定义的静态变量和C++类里面定义的静态变量有很多差异，从底层实现角度来说static静态变量两门语言含义都是一样的，意思都是该静态变量进行了额外的静态存储管理，而不是交给编译器的自动存储管理，其在程序运行期间都是存在在内存里面的。但就编程角度来说，C++显得很是松散，而C#对这些变量的使用进行了一些规范，具体来说就是将这些变量定义为为类class所拥有的变量，C++并没有这样的限定，比如C++里面你仍然可以 <code>sw1.NoOfInstances</code> 来引用这个静态变量，而在C#这边是不行的，你只能通过 <code>StopWatch.NoOfInstances</code> 来引用。请看下面这个例子：</p>
<div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">cs_project1</span>
<span class="p">{</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">StopWatch</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">NoOfInstances</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

        <span class="k">public</span> <span class="nf">StopWatch</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">StopWatch</span><span class="p">.</span><span class="n">NoOfInstances</span><span class="p">++;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>

        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">StopWatch</span> <span class="n">sw1</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StopWatch</span><span class="p">();</span>
            <span class="n">StopWatch</span> <span class="n">sw2</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StopWatch</span><span class="p">();</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">StopWatch</span><span class="p">.</span><span class="n">NoOfInstances</span><span class="p">);</span>

            <span class="n">StopWatch</span> <span class="n">sw3</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StopWatch</span><span class="p">();</span>
            <span class="n">StopWatch</span> <span class="n">sw4</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StopWatch</span><span class="p">();</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">StopWatch</span><span class="p">.</span><span class="n">NoOfInstances</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>如果一个class被声明为static，那么其内的所有成员都必须是static的。</p>
<p>总之C#的static即使仅仅就类的作用域这块来看和C++的static仍然区别很大，其更加接近于python语言里面的 <code>@staticmethod</code> 的概念。但其实也没有那么复杂，就简单理解为这些属性为class所有，不需要实例化就可以直接调用就行了。</p>
<h3 id="_21">静态构造方法</h3>
<p>如下静态构造方法：</p>
<div class="highlight"><pre><span></span>class SimpleClass
{
    // Static variable that must be initialized at run time.
    static readonly long baseline;

    // Static constructor is called at most one time, before any
    // instance constructor is invoked or member is accessed.
    static SimpleClass()
    {
        baseline = DateTime.Now.Ticks;
    }
}
</pre></div>
<p>这个静态构造方法不接受参数，也没有访问权限修饰符，其被运行时自动调用，主要的作用就是对 <code>static readonly</code> 的变量进行初始值计算和设定【const和static是不能共存的】。具体该构造方法调用是在非静态类实例化之前或者静态类第一次属性访问之前。</p>
<h3 id="refinout">ref和in和out</h3>
<p>默认方法参数传递是按值传递，C#可以用ref关键词标记某个参数为按引用传递。</p>
<div class="highlight"><pre><span></span><span class="k">void</span> <span class="nf">Method</span><span class="p">(</span><span class="k">ref</span> <span class="kt">int</span> <span class="n">refArgument</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">refArgument</span> <span class="p">=</span> <span class="n">refArgument</span> <span class="p">+</span> <span class="m">44</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">number</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
<span class="n">Method</span><span class="p">(</span><span class="k">ref</span> <span class="n">number</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">number</span><span class="p">);</span>
<span class="c1">// Output: 45</span>
</pre></div>
<p>这底层用的应该是类似C++引用变量的概念。</p>
<p>in关键词大体可以类似于 <code>readonly ref</code> 这样的作用机制。</p>
<p>out关键词大体类似于ref除了它不要求初始化，主要是用于如下应用场景【方法进行一些动作，然后将动作的结果存储在out变量上】：</p>
<div class="highlight"><pre><span></span>int initializeInMethod;
OutArgExample(out initializeInMethod);
Console.WriteLine(initializeInMethod);     // value is now 44

void OutArgExample(out int number)
{
    number = 44;
}
</pre></div>
<h3 id="_22">继承</h3>
<p>C#就继承和C++的继承有一个很大的区别：<strong>C#的继承子类允许有一个父类</strong> 。</p>
<p>下面演示了一个新东西，这在C++那边也是没有的，也就是 <strong>base</strong>关键词对父类的引用。虽然C++那边没有base这个关键词，但如下构造方法根据父类的构造方法进行简化操作的写法在C++那边也是有的，在C++那边具体叫做成员初始化列表写法，大体可以理解为：<code>Character(name)</code> ，说的再细一点这个name参数是直接来自 <code>Paladin(string name)</code> 接收到的name参数的。</p>
<div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Paladin</span> <span class="p">:</span> <span class="n">Character</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">Paladin</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">):</span> <span class="k">base</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="p">{</span>

    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
<p>C#对于多重继承应用场景可以利用接口interface来做到类似的效果，C#的类虽然只能继承自一个父类，但可以继承自多个接口。</p>
<h4 id="interface_1">interface</h4>
<p>关于interface前面提到过，其定义了一个接口，类继承了这个接口，那么就需要实现接口里面声明的方法或者属性等其他内容。</p>
<p>对于属性的接口声明如下：</p>
<div class="highlight"><pre><span></span><span class="k">interface</span> <span class="n">IPoint</span>
<span class="p">{</span>
   <span class="c1">// Property signatures:</span>
   <span class="kt">int</span> <span class="n">X</span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="k">set</span><span class="p">;}</span>

   <span class="kt">double</span> <span class="n">Distance</span><span class="p">{</span><span class="k">get</span><span class="p">;}</span>
<span class="p">}</span>
</pre></div>
<p>需要注意的是这些属性在接口里面并没有自动实现，而需要在后续类里面实现：</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span> <span class="p">:</span> <span class="n">IPoint</span>
<span class="p">{</span>
   <span class="c1">// Constructor:</span>
   <span class="k">public</span> <span class="nf">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="n">X</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
      <span class="n">Y</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="c1">// Property implementation:</span>
   <span class="k">public</span> <span class="kt">int</span> <span class="n">X</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

   <span class="k">public</span> <span class="kt">int</span> <span class="n">Y</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

   <span class="c1">// Property implementation</span>
   <span class="k">public</span> <span class="kt">double</span> <span class="n">Distance</span> <span class="p">=&gt;</span>
      <span class="n">Math</span><span class="p">.</span><span class="n">Sqrt</span><span class="p">(</span><span class="n">X</span> <span class="p">*</span> <span class="n">X</span> <span class="p">+</span> <span class="n">Y</span> <span class="p">*</span> <span class="n">Y</span><span class="p">);</span>

<span class="p">}</span>
</pre></div>
<p>C#8对interface新增了很多内容，这块暂时先略过讨论。</p>
<h4 id="abstractsealed">abstract和sealed</h4>
<p>abstract和sealed这两个关键词都可以用来修饰class：</p>
<div class="highlight"><pre><span></span>public abstract class A
{
    // Class members here.
}
public sealed class D
{
    // Class members here.
}
</pre></div>
<p>其中sealed class含义较好理解，其标记了这个class不能再被其他类继承了。也因此sealed class不能用于子类，也不能用于abstract class抽象类。</p>
<p>abstract class抽象类如果在其他编程语言里面接触过抽象基类这个概念那么会很快理解这是个什么东西，简单来说abstract标记了这个class是一个抽象基类，抽象基类不可实例化。抽象基类至少要有一个抽象成员，或者抽象方法或者抽象属性等都行。继承自抽象基类的类必须实现那些抽象成员。</p>
<p>下面的Shape抽象基类声明了一个抽象方法GetArea，Square就必须实现这个GetArea方法。</p>
<div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Shape</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">abstract</span> <span class="kt">int</span> <span class="nf">GetArea</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Square</span> <span class="p">:</span> <span class="n">Shape</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">side</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Square</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">side</span> <span class="p">=</span> <span class="n">n</span><span class="p">;</span>

    <span class="c1">// GetArea method is required to avoid a compile-time error.</span>
    <span class="k">public</span> <span class="k">override</span> <span class="kt">int</span> <span class="nf">GetArea</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">side</span> <span class="p">*</span> <span class="n">side</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">sq</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Square</span><span class="p">(</span><span class="m">12</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">$</span><span class="s">"Area of the square = {sq.GetArea()}"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Output: Area of the square = 144</span>
</pre></div>
<p>再了解抽象基类和interface之后，大家应该觉察到interface和抽象基类在作用上似乎有某种相似性，就对父类的某些规范上确实如此，但除此之外两个是完全不同的变量类型了。抽象基类说到底其仍然是一个class，只是说被限定不能实例化，原class里面可以做的事情都是可以做的。而interface则完全是一个声明规范了，里面不能有实现【C#8略有变动】。然后前面谈到C#的单继承，一个类只能继承一个抽象基类，但它可以继承多个interface。</p>
<p>此外抽象基类在写法上如下注意点：</p>
<ol>
<li>抽象基类的abstract成员不用写上virtual关键词了，因为它已经暗含virtual了。</li>
<li>子类实现abstract成员需要加上override关键词。</li>
</ol>
<h3 id="_23">多态</h3>
<p>C++就多态这个议题从C++11开始也有virtual和override这两个关键词了，不过都不是强制性的，正因为不是强制性的，所以引出很多问题。比如不使用virtual，如果你的子类声明的时候采用的是子类引用变量或者子类指针，那么使用的方法都将是基类的。而引入virtual这个关键词会根据实例的类型来决定使用的方法。override在C++那边更多的是一个规避bug的写法，表明你的子类的这个方法是要重载基类的某个方法，因为有时一不注意，参数类型没对上，重载行为就会无意跳过去。</p>
<p>在C#这边virtual和override用来描述OOP面向对象编程的多态概念是推荐的标准写法了。</p>
<p>简单来说就是基类的方法要加上virtual，子类的方法要加上override表明这里有重载行为。</p>
<div class="highlight"><pre><span></span>    <span class="c1">// base class</span>
    <span class="k">public</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">printStatusInfo</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="n">LogFormat</span><span class="p">(</span><span class="s">"Hero: {0} - {1} EXP"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">exp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// derived class</span>
    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">printStatusInfo</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Debug</span><span class="p">.</span><span class="n">LogFormat</span><span class="p">(</span><span class="s">"Paladin: {0} - take up your weapon: {1}"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">weapon</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
<p>上面的讨论主要是在说方法，属性同样也适用上面关于多态的讨论。</p>
<h4 id="_24">运算符重载</h4>
<p>对于基本运算符的重载声明必须是public的static的。具体重载格式如下：</p>
<div class="highlight"><pre><span></span>        public static Complex operator +(Complex a, Complex b)
        {
            return new Complex(a.Real + b.Real, a.Imaginary + b.Imaginary);
        }
</pre></div>
<h3 id="_25">做点练习题温习下</h3>
<p>下面我们做几个经典的练习题来温习下前面学过的内容吧。</p>
<ol>
<li>编写经典的C系的swap_int函数，请使用ref关键词来实现。</li>
<li>编写一个QuickSort类，其内的sort方法将接受一个一维int数组，按照数值大小排序之后打印出来。并不要求处理输入问题，毕竟这不是这里的重点。</li>
<li>编写经典的复数Complex类，实现基本打印功能，并实现复数的加减运算，相等判断运算等。</li>
</ol>
<p>下面是第一题：</p>
<div class="highlight"><pre><span></span>    <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="nf">SwapInt</span><span class="p">(</span><span class="k">ref</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="k">ref</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
            <span class="n">temp</span> <span class="p">=</span> <span class="n">a</span><span class="p">;</span>
            <span class="n">a</span> <span class="p">=</span> <span class="n">b</span><span class="p">;</span>
            <span class="n">b</span> <span class="p">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">$</span><span class="s">"origin x, y = {x}, {y}"</span><span class="p">);</span>
            <span class="n">SwapInt</span><span class="p">(</span><span class="k">ref</span> <span class="n">x</span><span class="p">,</span> <span class="k">ref</span> <span class="n">y</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">$</span><span class="s">"Swaped x, y = {x}, {y}"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
<p>第二题参考维基百科快速排序的伪代码然后写为如下：</p>
<div class="highlight"><pre><span></span>    <span class="k">class</span> <span class="nc">QuickSort</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">SwapInt</span><span class="p">(</span><span class="k">ref</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="k">ref</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
            <span class="n">temp</span> <span class="p">=</span> <span class="n">a</span><span class="p">;</span>
            <span class="n">a</span> <span class="p">=</span> <span class="n">b</span><span class="p">;</span>
            <span class="n">b</span> <span class="p">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">Partition</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/*</span>
<span class="cm">             * 本函数的用途就是取末尾元素然后将比末尾元素小的元素放入前面</span>
<span class="cm">             * 留下来的比末尾元素大的在后面</span>
<span class="cm">             * 索引位置i最后是原末尾元素</span>
<span class="cm">             */</span>
            <span class="kt">int</span> <span class="n">pivot</span> <span class="p">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">high</span><span class="p">];</span> 
            <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">low</span><span class="p">;</span> 

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="n">low</span><span class="p">;</span> <span class="n">j</span> <span class="p">&lt;=</span> <span class="n">high</span><span class="p">;</span> <span class="n">j</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">pivot</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">SwapInt</span><span class="p">(</span><span class="k">ref</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="k">ref</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
                    <span class="n">i</span><span class="p">++;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">SwapInt</span><span class="p">(</span><span class="k">ref</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="k">ref</span> <span class="n">arr</span><span class="p">[</span><span class="n">high</span><span class="p">]);</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">_Sort</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="p">&lt;</span> <span class="n">high</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">pi</span> <span class="p">=</span> <span class="n">Partition</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>

                <span class="n">_Sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">pi</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
                <span class="n">_Sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pi</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Sort</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">array</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">low</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">high</span> <span class="p">=</span> <span class="n">array</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>
            <span class="n">_Sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="p">}</span>
</pre></div>
<p>第三题主要练习下运算符的重载。</p>
<div class="highlight"><pre><span></span> <span class="k">class</span> <span class="nc">Complex</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">double</span> <span class="n">Real</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="kt">double</span> <span class="n">Imaginary</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="nf">Complex</span><span class="p">(</span><span class="kt">double</span> <span class="n">real</span><span class="p">=</span><span class="m">0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">imaginary</span> <span class="p">=</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">Real</span> <span class="p">=</span> <span class="n">real</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="n">Imaginary</span> <span class="p">=</span> <span class="n">imaginary</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="err">$</span><span class="s">"{this.Real} + {this.Imaginary}i"</span><span class="p">;</span>

        <span class="k">public</span> <span class="k">static</span> <span class="n">Complex</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">Complex</span> <span class="n">a</span><span class="p">,</span> <span class="n">Complex</span> <span class="n">b</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Complex</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">Real</span> <span class="p">+</span> <span class="n">b</span><span class="p">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">Imaginary</span> <span class="p">+</span> <span class="n">b</span><span class="p">.</span><span class="n">Imaginary</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">static</span> <span class="n">Complex</span> <span class="k">operator</span> <span class="p">-(</span><span class="n">Complex</span> <span class="n">a</span><span class="p">,</span> <span class="n">Complex</span> <span class="n">b</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Complex</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">Real</span> <span class="p">-</span> <span class="n">b</span><span class="p">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">Imaginary</span> <span class="p">-</span> <span class="n">b</span><span class="p">.</span><span class="n">Imaginary</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">Real</span><span class="p">.</span><span class="n">Equals</span><span class="p">(((</span><span class="n">Complex</span><span class="p">)</span><span class="n">obj</span><span class="p">).</span><span class="n">Real</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="n">Imaginary</span><span class="p">.</span><span class="n">Equals</span><span class="p">(((</span><span class="n">Complex</span><span class="p">)</span><span class="n">obj</span><span class="p">).</span><span class="n">Imaginary</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">override</span> <span class="kt">int</span> <span class="nf">GetHashCode</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">HashCode</span><span class="p">.</span><span class="n">Combine</span><span class="p">(</span><span class="n">Real</span><span class="p">,</span> <span class="n">Imaginary</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="p">==(</span><span class="n">Complex</span> <span class="n">a</span><span class="p">,</span> <span class="n">Complex</span> <span class="n">b</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">Real</span> <span class="p">==</span> <span class="n">b</span><span class="p">.</span><span class="n">Real</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">Imaginary</span> <span class="p">==</span> <span class="n">b</span><span class="p">.</span><span class="n">Imaginary</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="p">!=(</span><span class="n">Complex</span> <span class="n">a</span><span class="p">,</span> <span class="n">Complex</span> <span class="n">b</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">Real</span> <span class="p">!=</span> <span class="n">b</span><span class="p">.</span><span class="n">Real</span><span class="p">)</span> <span class="p">||</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">Imaginary</span> <span class="p">!=</span> <span class="n">b</span><span class="p">.</span><span class="n">Imaginary</span><span class="p">);</span>
        <span class="p">}</span>
</pre></div>
<p>练习题并没有刻意找一个练习继承的习题，实际上现代编程程序界设计模式的一个守则是：<strong>多用合成，少用继承</strong>。不要刻意为了继承而继承，确实你的建模分析需要有继承才能更好地模拟反映研究对象才去用继承。</p>
<h2 id="generic">generic泛型编程</h2>
<h2 id="collection">Collection库</h2>
<h3 id="list">List</h3>
<p>C#的List类型与C++的vector类更接近，其仍然要求内部存储的元素为相同的类型，所以不能对标python的列表。因为和array相比list可以更加灵活地增删元素所以很多情况下会更好用，使用它需要加载 <code>System.Collection.Generic</code> 。</p>
<div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">ConsoleApp1</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">nums</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>

            <span class="n">nums</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
            <span class="n">nums</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="m">2</span><span class="p">);</span>
            <span class="n">nums</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="m">5</span><span class="p">);</span>

            <span class="n">nums</span><span class="p">.</span><span class="n">ForEach</span><span class="p">((</span><span class="n">num</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">num</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>此外还有Insert方法，RemoveAt和Remove方法等。</p>
<ul>
<li><code>.Count</code> 返回List的元素数</li>
</ul>
<h3 id="dictionary">Dictionary</h3>
<p>Dictionary类型声明语句如下所示，就是类似于python语言的dict类型。</p>
<div class="highlight"><pre><span></span>Dictionary&lt;keyType, valueType&gt; name = new Dictionary&lt;keyType, valueType&gt;();
</pre></div>
<div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">ConsoleApp1</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">dict</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;();</span>

            <span class="n">dict</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>
            <span class="n">dict</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="s">"b"</span><span class="p">,</span> <span class="m">2</span><span class="p">);</span>
            <span class="n">dict</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="s">"c"</span><span class="p">,</span> <span class="m">3</span><span class="p">);</span>

            <span class="k">foreach</span> <span class="p">(</span><span class="n">KeyValuePair</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">item</span> <span class="k">in</span> <span class="n">dict</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">$</span><span class="s">"{item.Key}: {item.Value}"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Dictionary引用值和修改值语句：<code>dict["a"]</code> 或者 <code>dict["a"]=3</code> ，这种引用值写法如果分配一个key原字典没有则会新增。</p>
<p>此外还有 ContainsKey方法来确认某个key是否存在。</p>
<p>还有Remove方法用于删除某个key。</p>
<h2 id="_26">其他</h2>
<h3 id="_27">表达式形式定义</h3>
<p>C#允许采用如下形式对成员通过表达式来进行定义。</p>
<div class="highlight"><pre><span></span>member =&gt; expression;
</pre></div>
<div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="err">$</span><span class="s">"{fname} {lname}"</span><span class="p">.</span><span class="n">Trim</span><span class="p">();</span> <span class="c1">// 这是定义方法</span>
<span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">=&gt;</span> <span class="n">locationName</span><span class="p">;</span>  <span class="c1">//这是定义属性</span>
</pre></div>
<h2 id="_28">参考资料</h2>
<ol>
<li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/">microsoft docs: a tour of csharp</a></li>
<li>learning C# programming by Marius Bancila and Raffaele Rialdi and Ankit Sharma</li>
</ol>

        </div>
        <section>
        <div class="col-md-2" style="float:right;font-size:0.9em;">
            <h4>首发于：</h4>
            <time pubdate="pubdate" datetime="2021-03-13T16:09:53.324505+08:00">2021年 3月 13日 </time>

            <h4>最近更新于：</h4>
            <time datetime="2021-03-13T16:09:53.324505+08:00">2021年 3月 13日 </time>


            <h4>分类：</h4>
            <a class="category-link" href="https://a358003542.github.io/categories.html#archived-ref">archived</a>

        </div>
        </section>
</div>
</article>
    </div>
    <div class="col-md-1"></div>

</div>


<div id="push"></div>
<button id="gotop" type="button" class="btn btn-default">
    <span class="glyphicon glyphicon-arrow-up" aria-hidden="true"></span>
</button>

<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a> and updated by <a href="https://github.com/a358003542" title="wanze Home Page">wanze</a></li>
    </ul>
</div>
</footer>

        <script src="https://a358003542.github.io/theme/js/jquery.min.js"></script>
    <script src="https://a358003542.github.io/theme/js/bootstrap.min.js"></script>

    <script src="https://a358003542.github.io/theme/js/moment.min.js"></script>

    <script src="https://a358003542.github.io/theme/js/base.js"></script>



</body>
</html>