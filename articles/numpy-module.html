<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="msvalidate.01" content="55CB117A61A6F8286173763FB18D9625"/>
    <meta name="google-site-verification" content="r5HyVvY-ZSgf7ctpcpK1aWIaEfKJ0dvAE3E9kW3vXgI" />
    <script data-ad-client="ca-pub-5644206261254049" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
        <meta name="author" content="wanze"/>
        <meta name="copyright" content="wanze"/>

        <meta name="description"
              content="本文介绍了python在数据运算比如数据处理或机器学习等领域很常用的一个模块，numpy模块。"/>


<meta name="keywords" content=", 计算机 - 编程 - python, " />

    <title>numpy模块  · 万泽的博客
</title>

        <link href="https://a358003542.github.io/theme/css/font-awesome.css" rel="stylesheet"
              media="screen">
        <link href="https://a358003542.github.io/theme/css/bootstrap.min.css" rel="stylesheet"
              media="screen">

        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/pygments.css" media="screen">
        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/elegant.css" media="screen">
        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/base.css" media="screen">




</head>
<body>

<nav class="navbar">
    <div class="navbar navbar-default" role="navigation">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed"
                    data-toggle="collapse" data-target=".navbar-collapse"
                    aria-expanded="false">
                <span class="sr-only">Navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <a class="navbar-brand" href="https://a358003542.github.io/"><span
                    class=site-name>网站首页</span></a>
        </div>


        <div class="navbar-collapse collapse">
            <form action="https://a358003542.github.io/search.html"
                  onsubmit="return validateForm(this.elements['q'].value);"
                  class="navbar-form navbar-left">
                <div class="form-group">
                    <input type="text" name="q" id="tipue_search_input"
                           class="form-control" placeholder="Search..."
                           style="width:430px;">
                </div>
                <button class="btn btn-default" type="submit">搜索</button>
            </form>


            <ul class="nav navbar-nav nav-pills navbar-right">

                <li >
                    <a  href="/archives.html">所有博文</a></li>
                    
                <li ><a href="/categories.html">博文分类</a></li>
                

                        <li >
                            <a href="https://a358003542.github.io/about.html">关于本网站</a>
                        </li>
            </ul>


        </div>
    </div>
</nav>


<div class="container-fluid">
    <div class="col-md-1 col-md-1-left"></div>
    <div class="col-md-10">
<article>
    <div class="row">
        <header class="page-header col-md-10 col-md-offset-2">
            <h1><a href="https://a358003542.github.io/articles/numpy-module.html"> numpy模块  </a></h1>
        </header>
    </div>

    <div class="row">
        <div class="col-md-2 table-of-content">
            <nav>
                <h4>目录</h4>
                <div class="toc">
<ul>
<li><a href="#_1">前言</a></li>
<li><a href="#numpy-ndarraypython">numpy ndarray对象和python的列表的区别</a></li>
<li><a href="#ndarray">ndarray对象</a><ul>
<li><a href="#dtype">dtype</a><ul>
<li><a href="#ndarraydtype">ndarray的dtype变换</a></li>
<li><a href="#dtype_1">dtype对象的从属关系</a></li>
</ul>
</li>
<li><a href="#shape">shape属性</a><ul>
<li><a href="#reshape">reshape</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ndarray_1">创建一个ndarray对象</a><ul>
<li><a href="#python">从python数据结构中创建</a></li>
<li><a href="#_2">生成一系列的随机数</a></li>
<li><a href="#arrange">arrange函数</a></li>
<li><a href="#linspace">linspace函数</a></li>
<li><a href="#zeros">zeros函数</a></li>
<li><a href="#ones">ones函数</a></li>
<li><a href="#empty">empty函数</a></li>
</ul>
</li>
<li><a href="#_3">索引值</a><ul>
<li><a href="#view">索引多个值或说view</a></li>
<li><a href="#_4">多维切片</a><ul>
<li><a href="#copy">copy方法</a></li>
</ul>
</li>
<li><a href="#_5">布尔值索引</a></li>
</ul>
</li>
<li><a href="#_6">基本的运算</a></li>
<li><a href="#ndarray_2">ndarray对象上的一些方法</a><ul>
<li><a href="#flatten">flatten方法</a></li>
<li><a href="#sort">sort方法</a></li>
<li><a href="#mean">mean方法</a></li>
<li><a href="#std">std方法</a></li>
</ul>
</li>
<li><a href="#_7">一些通用函数</a><ul>
<li><a href="#sqrt">sqrt函数</a></li>
<li><a href="#exp">exp函数</a></li>
<li><a href="#maximum">maximum函数</a></li>
<li><a href="#abs">abs函数</a></li>
<li><a href="#unique">unique函数</a></li>
<li><a href="#tile">tile函数</a></li>
<li><a href="#argsort">argsort函数</a></li>
<li><a href="#npargpartition">np.argpartition函数</a></li>
<li><a href="#npallclose">np.allclose</a></li>
<li><a href="#npisclose">np.isclose</a></li>
<li><a href="#nplogical_and">np.logical_and</a></li>
<li><a href="#npall">np.all</a></li>
</ul>
</li>
<li><a href="#ndarray_3">ndarray对象转置</a></li>
<li><a href="#broadcasting">广播(broadcasting)</a></li>
<li><a href="#_8">矩阵对象</a><ul>
<li><a href="#matrix">matrix函数</a></li>
<li><a href="#_9">矩阵转置</a></li>
<li><a href="#_10">行矢量和列矢量</a></li>
<li><a href="#_11">矩阵的点乘</a></li>
</ul>
</li>
</ul>
</div>
            </nav>
        </div>
        <div class="col-md-8 article-content">

                
<h2 id="_1">前言</h2>
<p>本文对于numpy模块具体各个函数细节不做过多说明，具体请参看文档。本文主要是就numpy的一些核心概念进行理清。</p>
<p>numpy模块里面最核心的概念就是 ndarray对象，请参看 <a href="https://stackoverflow.com/questions/15879315/what-is-the-difference-between-ndarray-and-array-in-numpy">这个问题</a> ，当时我也有疑问，numpy里面的array函数和ndarray对象有什么区别，答案就是：一般使用推荐使用 <code>numpy.array</code> 来创建 ndarray对象，其他还有 zeros ，empty等等其他的函数，他们都是很好的接口去创建一个 numpy.ndarray 对象，当然你也可以通过 numpy.ndarray 来创建一个ndarray对象，但这不是 numpy模块开发人员推荐的风格。</p>
<h2 id="numpy-ndarraypython">numpy ndarray对象和python的列表的区别</h2>
<ol>
<li>numpy ndarray内部的item是固定内存size的，改变size将会重新创建一个ndarray。</li>
<li>numpy ndarray内部的item是相同的data type的，因此是固定内存size的。</li>
<li>numpy的ndarray有助于大型数据的高级数学运算或其他操作，比python的序列那些执行会更有效率。</li>
<li>很多科学和数学计算的python模块都是基于numpy的ndarray的，当然他们支持python的序列类型输入，但都是转变成为numpy的array之后再进行相关计算的，然后他们的输出也通常是numpy的ndarray对象。</li>
</ol>
<h2 id="ndarray">ndarray对象</h2>
<p>numpy模块中很核心的一个概念就是ndarray对象。ndarray对象按照numpy官方手册的绘图是这样一个数据结构：</p>
<p><img alt="img" src="https://a358003542.github.io/images/机器学习/ndarray.png" title="ndarray"/></p>
<p>ndarray有一个头header来控制所有接下来存储的数据类型(dtype)，然后存储的数据则必然都是相同的数据类型，这是一个不同于列表的限定条件，这样约定将大大提高数据处理的效率。</p>
<p>你可以利用array函数简单将一个列表变成ndarray对象：</p>
<div class="highlight"><pre><span></span><code>    <span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
    <span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="s1">'&gt;</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">dtype</span><span class="p">(</span><span class="s1">'int32'</span><span class="p">)</span>
</code></pre></div>
<p>在上面的例子中我们看到，每一个ndarray对象都有一个属性( <strong>dtype</strong> )，其存储的就是前面讲的ndarray对象后面一连串数据的数据类型，比如这里的数据类型是“int32”。</p>
<h3 id="dtype">dtype</h3>
<p>这个基本上讨论numpy的资料都会把这个清单列出来，这里也列出来吧。</p>
<ul>
<li><strong>bool_:</strong> True or False</li>
<li><strong>int_:</strong> 相当于C语言的long，一般是int32或int64。整数型其内细分:<ul>
<li><strong>intc:</strong> 等于C语言的int，int32或int64</li>
<li><strong>intp:</strong> 整数用于索引，和C语言的ssize_t相同，一般是int32或int64。</li>
<li><strong>int8:</strong> Byte（-128 ~ 127）</li>
<li><strong>int16:</strong> Integer（-32769 ~ 32767）</li>
<li><strong>int32:</strong> Integer</li>
<li><strong>int64:</strong> Integer</li>
<li><strong>uint8:</strong> Unsigned Integer（0 ~ 255）</li>
<li><strong>uint16:</strong> Unsigned Integer（0 ~ 65535）</li>
<li><strong>uint32:</strong> Unsigned Integer</li>
<li><strong>uint64:</strong> Unsigned Integer</li>
</ul>
</li>
<li><strong>float_:</strong> 具体为float64。浮点型细分为:<ul>
<li><strong>float16:</strong> 半精度浮点型</li>
<li><strong>float32:</strong> 单精度浮点型</li>
<li><strong>float64:</strong> 双精度浮点型</li>
</ul>
</li>
<li><strong>complex_:</strong> 就是complex128。 复数型细分为:<ul>
<li><strong>complex64:</strong> 复数型，由32位浮点型组成</li>
<li><strong>complex128:</strong> 复数形，由64位浮点型组成</li>
</ul>
</li>
</ul>
<p>具体使用声明如下:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; t = np.array([1,2,3],dtype='int32')
&gt;&gt;&gt; type(t)
&lt;class 'numpy.ndarray'&gt;
&gt;&gt;&gt; t.dtype
dtype('int32')
&gt;&gt;&gt;
</code></pre></div>
<p>在实际使用的时候，dtype若指定为int，则实际就是对应的 <code>np.int_</code></p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; t = np.array([1,2,3],dtype='int')
&gt;&gt;&gt; t.dtype
dtype('int64')
</code></pre></div>
<p>类似的 <code>float</code> 对应 <code>np.float_</code> ; <code>bool</code> 对应 <code>np.bool_</code> ; <code>complex</code> 对应 <code>np.complex_</code> 。</p>
<h4 id="ndarraydtype">ndarray的dtype变换</h4>
<p>还可以通过调用ndarray的 <code>astype</code> 方法来实现。注意这个方法是 <strong>非破坏型</strong> 方法，具体使用如下面例子所示：</p>
<div class="highlight"><pre><span></span><code>    &gt;&gt;&gt; t = np.array([1,2,3],dtype='int8')
    &gt;&gt;&gt; t.astype('int32')
    array([1, 2, 3], dtype=int32)
    &gt;&gt;&gt; t
    array([1, 2, 3], dtype=int8)
</code></pre></div>
<h4 id="dtype_1">dtype对象的从属关系</h4>
<p>用 <code>np.issubdtype</code> 函数来判断某个ndarray的dtype对象是不是整型的子集。</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; t
array([1, 2, 3], dtype=int8)
&gt;&gt;&gt; t.dtype
dtype('int8')
&gt;&gt;&gt; np.issubdtype(t.dtype,'int')
True
&gt;&gt;&gt; np.issubdtype(t.dtype,'float')
False
</code></pre></div>
<h3 id="shape">shape属性</h3>
<p>此外，每一个ndarray对象都有 <code>shape</code> 属性，用于控制后面跟着的这些数据的维度。请看下面的例子：</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; x
array([1, 2, 3, 4, 5, 6])
&gt;&gt;&gt; x.shape
(6,)
&gt;&gt;&gt; x.shape = (2,3)
&gt;&gt;&gt; x
array([[1, 2, 3],
       [4, 5, 6]])
</code></pre></div>
<p>shape 属性用来控制对于后面数据维度的理解，一个数字表示一维，二个数字表示二维几行几列（也就是数学中我们常见的概念矩阵），三个数字表示三维等。这里直接修改ndarray对象的shape属性将直接影响程序对于该对象数据的理解，此外更常用的是用 <code>reshape</code> 方法，其并不原地修改某个ndarray对象的shape，而是返回一个被修改shape属性的新的ndarray对象。</p>
<h4 id="reshape">reshape</h4>
<p>ndarray可以调用reshape来改变本ndarray的shape属性，其并不原地修改某个ndarray对象的shape，而是返回一个被修改shape属性的新的ndarray对象。</p>
<p>你可以只指定一个维度，然后另外一个维度填上 <code>-1</code> ，这样改维度的shape将会自动计算出来。</p>
<p>比如 4*5的矩阵，你reshape为 <code>(-1,4)</code> ，那么出来的该矩阵的row=5。</p>
<h2 id="ndarray_1">创建一个ndarray对象</h2>
<h3 id="python">从python数据结构中创建</h3>
<p>这个就是前面接触过的 <code>np.array</code> 函数，用来接受一个python list 或 tuple ，从而返回一个ndarray对象。</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; x = np.array([[1+2j,2+3j],[3+4j,4+5j]])
&gt;&gt;&gt; x
array([[ 1.+2.j,  2.+3.j],
       [ 3.+4.j,  4.+5.j]])
&gt;&gt;&gt; x.dtype
dtype('complex128')
&gt;&gt;&gt;
</code></pre></div>
<h3 id="_2">生成一系列的随机数</h3>
<p>这个经常在各个例子中看到：</p>
<div class="highlight"><pre><span></span><code>np.random.randn(2,3)

array([[-0.26670745,  1.09572856, -0.38875728],
       [ 1.04339429,  0.06330302,  1.35696512]])
</code></pre></div>
<p>填充一个2行3列的随机数，randn后面的n是normal，也就是正态分布的意思。</p>
<h3 id="arrange">arrange函数</h3>
<p>arange(start,end,step)  参数类似range函数。生成一个数据递增（减）的ndarray对象：</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; x = np.arange(5)
&gt;&gt;&gt; x
array([0, 1, 2, 3, 4])
&gt;&gt;&gt; x = np.arange(1,10,0.5)
&gt;&gt;&gt; type(x)
&lt;class 'numpy.ndarray'&gt;
&gt;&gt;&gt; x
array([ 1. ,  1.5,  2. ,  2.5,  3. ,  3.5,  4. ,  4.5,  5. ,  5.5,  6. ,
        6.5,  7. ,  7.5,  8. ,  8.5,  9. ,  9.5])
</code></pre></div>
<p>其是一维的，但通过reshape操作可以生成二维的ndarray对象，其可以接受 <code>dtype</code> 对象来控制dtype属性。</p>
<h3 id="linspace">linspace函数</h3>
<p>linspace函数可以看作上面 arange函数的补充，arange函数虽然指定了start和stop，最后的数值是不被包含的，然后具体生成了多少个item是不易知的，而linspace可以接受这样三个参数: <code>start end number</code> ，其中start和end一定是在ndarray中包含的，然后number给定了具体生成了多少个item。</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; np.linspace(1,10,6)
array([  1. ,   2.8,   4.6,   6.4,   8.2,  10. ])
</code></pre></div>
<p>结束元素包不包含倒不是很重要，关键是某些情况下你需要控制具体生成了多少个item，那么就需要使用 <code>linspace</code> 函数。</p>
<h3 id="zeros">zeros函数</h3>
<p>zeros函数用于快速创建一个ndarray对象，其内数据都填充的是 <code>0.</code> ，默认dtype是 <code>float64</code> 。其接受的一个参数你可以简单看作就是shape属性参数，如下所示：</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; np.zeros((10,))
array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
&gt;&gt;&gt; np.zeros(10)
array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
&gt;&gt;&gt; np.zeros((5,5))
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
</code></pre></div>
<h3 id="ones">ones函数</h3>
<p>ones函数类似于zeros函数，不同的是填充的数据是1。就不做例子演示了。</p>
<h3 id="empty">empty函数</h3>
<p>empty函数和前面谈论的 zeros ones 函数类似，除了各个item都是原内存的随机数值，并不做任何修改。</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; np.empty((2,3))
array([[  0.00000000e+000,   4.99297208e-317,   4.94026911e-317],
       [  6.94094003e-310,   1.03878549e-013,   0.00000000e+000]])
&gt;&gt;&gt;
</code></pre></div>
<h2 id="_3">索引值</h2>
<p>ndarray对于值的索引操作和python中列表索引值的操作非常相似，即方括号语法索引 <code>[index]</code> :</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6],[7,8,9]])
&gt;&gt;&gt; x
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; x[0]
array([1, 2, 3])
&gt;&gt;&gt; x[0][0]
1
&gt;&gt;&gt; y[1][5]
5
</code></pre></div>
<p>此外你还可以用这种语法:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; x
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; x[0,0]
1
&gt;&gt;&gt; x[1,1]
5
&gt;&gt;&gt;
</code></pre></div>
<p>通过上面描述的索引值语法可以直接修改该ndarray对象的这个元素的值。此外numpy还提供了另外一种表示语法： <code>[a,b]</code> ，对于ndarray对象其和 <code>[a][b]</code> 的意思是一样的。但是矩阵 <em>不</em> 支持 <code>[a][b]</code> 这种索引语法，而只支持 <code>[a,b]</code> 这种表示语法，推荐对于矩阵都用带逗号的这种索引方法，表示矩阵的a行b列。</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; A = np.matrix([[1,2,3],[4,5,6],[7,8,9]])
&gt;&gt;&gt; A[0]
matrix([[1, 2, 3]])
&gt;&gt;&gt; A[0][0]#并没有索引下去
matrix([[1, 2, 3]])
&gt;&gt;&gt; A[0,0]
1
</code></pre></div>
<h3 id="view">索引多个值或说view</h3>
<p>同样ndarray对象也有在上面谈及的索引规则下 <code>[start:end:step]</code> :</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6],[7,8,9]])
&gt;&gt;&gt; x
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; x[::-1]
array([[7, 8, 9],
       [4, 5, 6],
       [1, 2, 3]])
&gt;&gt;&gt; y = np.arange(10)
&gt;&gt;&gt; y
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; y[0::2]
array([0, 2, 4, 6, 8])
</code></pre></div>
<p>支持索引多个值，但注意上面不是说切片，而是 <strong>view</strong> 视图。因为python的list如果你索引多个值，切片了，则等于制造了一个新的列表，如:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; lst = [1,2,3,4,5]
&gt;&gt;&gt; lst[0:2]
[1, 2]
&gt;&gt;&gt; x = lst[0:2]
&gt;&gt;&gt; x[0] = 12
&gt;&gt;&gt; x
[12, 2]
&gt;&gt;&gt; lst
[1, 2, 3, 4, 5]
</code></pre></div>
<p>在调用 <code>lst[0:2]</code> 时，python程序是制造一个新的子列表，然后赋值给x，但是我们看ndarray对象不是这样的:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; array = np.array([1,2,3,4,5])
&gt;&gt;&gt; array
array([1, 2, 3, 4, 5])
&gt;&gt;&gt; x = array[:2]
&gt;&gt;&gt; x
array([1, 2])
&gt;&gt;&gt; x[0] = 12
&gt;&gt;&gt; x
array([12,  2])
&gt;&gt;&gt; array
array([12,  2,  3,  4,  5])
</code></pre></div>
<p>这就是ndarray对象索引多个值称之为 <strong>视图</strong> 的原因，其返回的还是指向原处的那个片段！</p>
<p>最后对于索引多个值的视图赋值操作，是所有元素都赋值为那个值:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; x[:] = 99
&gt;&gt;&gt; array
array([99, 99,  3,  4,  5])
</code></pre></div>
<h3 id="_4">多维切片</h3>
<p>上面的 <code>[start:end:step]</code> 语法只是第一个维度上的切片，numpy支持下面的语法，可以灵活地在多个维度进行切片 <code>[d1, d2, d3]</code> ，上面的d1是具体在第一个维度上的索引值，也就是对于每个维度都可以进一步使用 <code>[start:end:step]</code> 这样的进一步切片操作。</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">35</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">45</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]]</span> <span class="p">)</span>
<span class="n">arr</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">5</span><span class="p">]:</span> 
<span class="n">array</span><span class="p">([[[</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">35</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">45</span><span class="p">]],</span>
       <span class="p">[[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">],</span>
        <span class="p">[</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">2</span><span class="p">],</span>
        <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">]]])</span>
<span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">6</span><span class="p">]:</span> 
<span class="n">array</span><span class="p">([[</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">35</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">45</span><span class="p">]])</span>
<span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">7</span><span class="p">]:</span> 
<span class="n">array</span><span class="p">([[</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">35</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">45</span><span class="p">]])</span>
<span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">8</span><span class="p">]:</span> 
<span class="n">array</span><span class="p">([[</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">]])</span>
</code></pre></div>
<p>注意看最后一个例子，含义是第一维度所有元素，第二维度选择索引值0，第三维度所有元素。</p>
<h4 id="copy">copy方法</h4>
<p>如果你希望达到原python的那种索引多个值的效果而不影响原ndarray对象，你可以调用ndarrary对象的 <code>copy</code> 方法:</p>
<div class="highlight"><pre><span></span><code>array[:2].copy()
</code></pre></div>
<h3 id="_5">布尔值索引</h3>
<p>布尔值索引是基于 ndarray对象进行布尔值判断操作，如 <code>== &gt; &lt;</code> 等等之类的时候，将输出一个原维度的bool值ndarray对象。然后将这个ndarray对象送入array的索引输入框中，其将返回bool值为True的那些值。</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; array
array([0, 0, 3, 4, 5])
&gt;&gt;&gt; array == 0
array([ True,  True, False, False, False], dtype=bool)
&gt;&gt;&gt; array[array == 0]
array([0, 0])
&gt;&gt;&gt; array[array == 0] = 99
&gt;&gt;&gt; array
array([99, 99,  3,  4,  5])
</code></pre></div>
<p>布尔值索引返回的也是 <strong>视图</strong> ，对齐操作将改变原ndarray对象。</p>
<p>你还可以用 <code>&amp;</code> 和 <code>|</code> 来形成组合逻辑，但不能使用 and 和 or 。</p>
<p>一大用法就是利用某个item各个属性的映射关系，利用其他属性来过滤另外某个data:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; data = np.random.randn(7,3)
&gt;&gt;&gt; data
array([[-0.82117767,  1.02481308,  0.50908019],
       [ 0.79851282,  0.37692996, -1.0129145 ],
       [-1.30120201,  1.71270027,  0.2113716 ],
       [-1.33386207,  0.02978504, -0.58061781],
       [ 0.72466458,  1.94170572,  2.09521622],
       [-1.24241997, -1.20557331, -0.66292731],
       [-0.66145326,  0.28330579,  0.2803069 ]])
&gt;&gt;&gt; names = np.array(['a','b','c','a','b','d','a'])
&gt;&gt;&gt; data[names == 'a']
array([[-0.82117767,  1.02481308,  0.50908019],
       [-1.33386207,  0.02978504, -0.58061781],
       [-0.66145326,  0.28330579,  0.2803069 ]])
</code></pre></div>
<p>这里将索引的是每一行，其行对应的name是'a'的值。</p>
<h2 id="_6">基本的运算</h2>
<p>两个ndarray对象之间进行基本的数学运算，如果两个ndarray维度是相同的，则称之为 <code>vectorization</code> ，矢量化操作。大致意思就是 加减乘除幂 具体操作都是 <span class="underline">对应的元素和对应的元素进行加减乘除幂操作</span> :</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; x = np.array([[4,0,5],[-1,3,2]])
&gt;&gt;&gt; x
array([[ 4,  0,  5],
       [-1,  3,  2]])
&gt;&gt;&gt; y = np.array([[1,1,1],[3,5,7]])
&gt;&gt;&gt; y
array([[1, 1, 1],
       [3, 5, 7]])
&gt;&gt;&gt; x + y
array([[5, 1, 6],
       [2, 8, 9]])
&gt;&gt;&gt; x - y
array([[ 3, -1,  4],
       [-4, -2, -5]])
&gt;&gt;&gt; x * 2
array([[ 8,  0, 10],
       [-2,  6,  4]])
&gt;&gt;&gt; x ** 2
array([[16,  0, 25],
       [ 1,  9,  4]])
</code></pre></div>
<p>如果两个ndarray对象的维度（多维的情况不讨论了吧），如果 列维数目相同，则似乎也是可以的，但应该不推荐这么使用。而如果列维数目不同，则会抛出 <code>ValueError</code> 。</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; z = np.array([1,2,3])
&gt;&gt;&gt; x+z
array([[5, 2, 8],
       [0, 5, 5]])
</code></pre></div>
<p>我们看到这里z是重复应用到x的每一行了。</p>
<h2 id="ndarray_2">ndarray对象上的一些方法</h2>
<h3 id="flatten">flatten方法</h3>
<p>flatten，拉平。flatten是ndarray对象（包括矩阵）的一个方法，可将其变为一维形式， <em>非破坏型</em> 方法。</p>
<p>这里将flatten方法归到矩阵这里是因为多维数组必须各个维度所含元素数目相等（也就是必须要有类似矩阵的空间矩形排布感）才有意义。然后矩阵返回的是行矢量形式。</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6],[7,8,9]])
&gt;&gt;&gt; x
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; x.flatten()
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; x
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; y = np.array([[1,2,3],[4,5,6,7]])
&gt;&gt;&gt; y
array([[1, 2, 3], [4, 5, 6, 7]], dtype=object)
&gt;&gt;&gt; y.flatten()
array([[1, 2, 3], [4, 5, 6, 7]], dtype=object)
&gt;&gt;&gt; z
matrix([[1, 2, 3],
        [4, 5, 6]])
&gt;&gt;&gt; z.flatten()
matrix([[1, 2, 3, 4, 5, 6]])
</code></pre></div>
<h3 id="sort">sort方法</h3>
<p>sort方法虽然可以作用多维，但似乎对一维更显的有意义些，其是一个 <em>破坏型</em> 方法。</p>
<p>如下所示，注意看，每一行并没有变动，只在行内一维情况下排序。</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; data
array([[ 0.68518059,  1.05271585,  1.00174264],
       [-1.44506879,  1.45532422,  1.30856608],
       [ 0.1121552 , -3.04487041, -0.03301996]])
&gt;&gt;&gt; data.sort()
&gt;&gt;&gt; data
array([[ 0.68518059,  1.00174264,  1.05271585],
       [-1.44506879,  1.30856608,  1.45532422],
       [-3.04487041, -0.03301996,  0.1121552 ]])
</code></pre></div>
<h3 id="mean">mean方法</h3>
<p>计算给定维度下所有元素的值的的均值。</p>
<div class="highlight"><pre><span></span><code>ndarray.mean(axis=None, dtype=None, out=None, keepdims=False)
</code></pre></div>
<p>在这里的难点在于理解按照维度扩展这个概念，如果是矩阵的话，竖向列是axis=0，横向行是axis=1。</p>
<p>numpy.mean(axis=0) 这里一般的理解是按照竖向列计算均值，更好的理解是行表示记录，列表示特征，一般第一维度表示样本维，第二维度表示特征维，这里axis=0，官方文档对于axis的解释是沿着某个维度或者轴进行计算，这里axis=0选择的实际上是样本维，然后沿着样本维每个特征计算得到一个均值。</p>
<h3 id="std">std方法</h3>
<p>计算给定维度下所有元素的值的标准差，具体使用类似于上面的mean方法。</p>
<h2 id="_7">一些通用函数</h2>
<p>下面讲的一些通用函数，大多是numpy自带的，然后接受的参数一般是ndarray对象，一般也不会改变目标ndarray对象的shape（有些会稍微做一些改变），然后对各个元素进行一些函数操作。</p>
<h3 id="sqrt">sqrt函数</h3>
<p>开个平方根</p>
<div class="highlight"><pre><span></span><code>x = np.arange(10)

array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

np.sqrt(x)

array([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,
       2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])
</code></pre></div>
<h3 id="exp">exp函数</h3>
<p>算个指数函数 <span class="math">\(e^{x}\)</span></p>
<div class="highlight"><pre><span></span><code>np.exp(x)
</code></pre></div>
<h3 id="maximum">maximum函数</h3>
<p>点对点返回最大值 【会自动进行广播操作】</p>
<div class="highlight"><pre><span></span><code>x = np.random.randn(8)
y = np.random.randn(8)
np.maximum(x, y)
</code></pre></div>
<h3 id="abs">abs函数</h3>
<div class="highlight"><pre><span></span><code>x = np.random.randn(2,3)

array([[-0.11653471,  0.72362219,  0.93142213],
       [-2.03263166, -0.1941374 ,  1.23463108]])

np.abs(x)   

array([[0.11653471, 0.72362219, 0.93142213],
       [2.03263166, 0.1941374 , 1.23463108]])
</code></pre></div>
<h3 id="unique">unique函数</h3>
<div class="highlight"><pre><span></span><code>import numpy as np

list_dupes = [1, 5, 6, 2, 5, 6, 8, 3, 8, 3, 3, 7, 9]

res = np.unique(list_dupes)

&gt;&gt;&gt; [1 2 3 5 6 7 8 9]

import numpy as np

list_dupes = [[1, 5, 6, 2, 5, 6, 8, 7, 9], [1, 1, 2, 2, 3, 3, 5, 6, 7]]

res = np.unique(np.array(list_dupes))

&gt;&gt;&gt; [1 2 3 5 6 7 8 9]
</code></pre></div>
<p>将返回给定数据集的唯一元素集合。对于ndarray的多维对象，将会flatten还有再找出唯一值。</p>
<h3 id="tile">tile函数</h3>
<div class="highlight"><pre><span></span><code>np.tile(A, reps)
</code></pre></div>
<p>输入一个array，根据reps决定在那个维度重复数据：</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = np.array([0, 1, 2])
&gt;&gt;&gt; np.tile(a, 2)
array([0, 1, 2, 0, 1, 2])
&gt;&gt;&gt; np.tile(a, (2, 2))
array([[0, 1, 2, 0, 1, 2],
       [0, 1, 2, 0, 1, 2]])
&gt;&gt;&gt; np.tile(a, (2, 1, 2))
array([[[0, 1, 2, 0, 1, 2]],
       [[0, 1, 2, 0, 1, 2]]])
</code></pre></div>
<h3 id="argsort">argsort函数</h3>
<p>ndarray对象调用argsort函数将返回一个按照大小排序的索引值：</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; x = np.array([3, 1, 2])
&gt;&gt;&gt; np.argsort(x)
array([1, 2, 0])
</code></pre></div>
<p>上面的含义是排序后第一个值是 x[1] ，后面以此类推。</p>
<h3 id="npargpartition">np.argpartition函数</h3>
<p>以arg开头其返回的是索引值。</p>
<p>然后其默认调用的行为有点类似于快速排序中的选择一个点，左边都是比这个值小的点，右边都是比这个值大的点。在某些情况下，你可能指向要topk个结果，这样调用这个函数，你必须将排序操作进行完，有时会很高效的。</p>
<div class="highlight"><pre><span></span><code>x = [9,8,7,5,4,6,1]
np.argpartition(x, 2)

array([6, 4, 3, 2, 1, 5, 0], dtype=int64)
</code></pre></div>
<p>上面这个例子的意思就是，结果输出的分区点是 2 哪里，也就是前面的2个就是整个内容中最小的两个。2对应的数字5，前面两个是 1 4，然后剩下的9 8 7 6 都是比5大的。大概就是这样子。</p>
<h3 id="npallclose">np.allclose</h3>
<div class="highlight"><pre><span></span><code>numpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)
</code></pre></div>
<p>类似于isclose，不过返回的True或者False</p>
<h3 id="npisclose">np.isclose</h3>
<div class="highlight"><pre><span></span><code>numpy.isclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)
</code></pre></div>
<p>点对点的比较两个ndarray的值，rtol是相对容忍度，atol是绝对容忍度，这是一种近似的数值相近比较判断操作。</p>
<h3 id="nplogical_and">np.logical_and</h3>
<p>点对点的逻辑and操作。</p>
<h3 id="npall">np.all</h3>
<p>沿某个轴或者所有数值执行all操作。</p>
<h2 id="ndarray_3">ndarray对象转置</h2>
<p>就是调用ndarray对象的 <code>T</code> 属性，这更接近于矩阵中的转置操作（但是对于一维ndarray并没有任何改变）。而之前提及的 <code>data[::-1]</code> 这么使用，只是把行翻转了一下，对于一维倒是整个array都翻转了。</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; data = np.random.randn(4,3)
&gt;&gt;&gt; data
array([[ 0.53700477, -1.30139712,  1.12184318],
       [-0.91918847,  1.52850268,  0.73218978],
       [-1.14840704, -0.0413753 ,  0.52820585],
       [ 1.84307255,  0.21356674,  0.23331023]])
&gt;&gt;&gt; data.T
array([[ 0.53700477, -0.91918847, -1.14840704,  1.84307255],
       [-1.30139712,  1.52850268, -0.0413753 ,  0.21356674],
       [ 1.12184318,  0.73218978,  0.52820585,  0.23331023]])
&gt;&gt;&gt; data[::-1]
array([[ 1.84307255,  0.21356674,  0.23331023],
       [-1.14840704, -0.0413753 ,  0.52820585],
       [-0.91918847,  1.52850268,  0.73218978],
       [ 0.53700477, -1.30139712,  1.12184318]])
</code></pre></div>
<h2 id="broadcasting">广播(broadcasting)</h2>
<p>广播一种操作，shape较小的张量和shape较大的张量进行点对点运算时，需要对shape较小的张量进行广播操作，使其在运算上shape兼容。</p>
<p>广播具体操作规则是：</p>
<ul>
<li>
<p>shape较小的张量添加新的维度是的两个张量维度数相同</p>
</li>
<li>
<p>shape较小的张量在新的维度中的数据是重复的，相当于没有原维度的数据，即： y[1,j] = y[2,j] = y[3,j] =... y[j]</p>
</li>
</ul>
<h2 id="_8">矩阵对象</h2>
<p>矩阵对象是ndarray对象的子类，也就是说ndarray对象的一些属性和方法它都是可以使用的。行矢量和列矢量是属于矩阵中的特殊情况。矩阵这个概念在以后的数学运算中较为重要，然后对于一些概念，比如转置啊，点乘啊等，总之和矩阵的数学运算相关的，虽然ndarray对象也可以做，但推荐将其变成矩阵（matrix）对象之后再处理，这样容易理清概念。</p>
<h3 id="matrix">matrix函数</h3>
<p>用numpy的matrix函数可以创建一个矩阵对象:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; data = np.random.randn(3,3)
&gt;&gt;&gt; data
array([[-0.79589206, -0.97535141,  1.05750453],
       [ 0.05051448,  0.19753523,  0.99618112],
       [ 2.09805081, -0.33623748,  0.26033154]])
&gt;&gt;&gt; x = np.matrix(data)
&gt;&gt;&gt; type(x)
&lt;class 'numpy.matrixlib.defmatrix.matrix'&gt;
&gt;&gt;&gt; x
matrix([[-0.79589206, -0.97535141,  1.05750453],
        [ 0.05051448,  0.19753523,  0.99618112],
        [ 2.09805081, -0.33623748,  0.26033154]])
</code></pre></div>
<h3 id="_9">矩阵转置</h3>
<p><code>transpose</code> 方法，将矩阵转置过来。只返回结果， <em>非破坏型</em> 方法。</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; x = np.matrix([[1,2,3],[4,5,6],[7,8,9]])
&gt;&gt;&gt; x
matrix([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
&gt;&gt;&gt; x.transpose()
matrix([[1, 4, 7],
        [2, 5, 8],
        [3, 6, 9]])
</code></pre></div>
<h3 id="_10">行矢量和列矢量</h3>
<p>行矢量和列矢量是矩阵的特殊情况，需要用matrix函数创建之。行矢量转置之后就是列矢量请注意看它的写法。</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; x = np.matrix([1,2,3,4,5])
&gt;&gt;&gt; x
matrix([[1, 2, 3, 4, 5]])
&gt;&gt;&gt; x.transpose()
matrix([[1],
        [2],
        [3],
        [4],
        [5]])
</code></pre></div>
<h3 id="_11">矩阵的点乘</h3>
<p>学过线性代数印像最深的可能就是矩阵那个怪异的乘法运算了。这里有了numpy模块的支持，就可以直接用 <code>*</code> 来执行两个矩阵的乘法，或者 <code>np.dot</code> 函数。</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; A = np.matrix([[1,0,3,-1],[2,1,0,2]])
&gt;&gt;&gt; B = np.matrix([[4,1,0],[-1,1,3],[2,0,1],[1,3,4]])
&gt;&gt;&gt; A * B
matrix([[ 9, -2, -1],
        [ 9,  9, 11]])
&gt;&gt;&gt; x = np.matrix([1,2,3])
&gt;&gt;&gt; y = np.matrix([4,5,6]).transpose()
&gt;&gt;&gt; x * y
matrix([[32]])
&gt;&gt;&gt; y * x
matrix([[ 4,  8, 12],
        [ 5, 10, 15],
        [ 6, 12, 18]])
&gt;&gt;&gt; np.dot(x,y)
matrix([[32]])
&gt;&gt;&gt; np.dot(y,x)
matrix([[ 4,  8, 12],
        [ 5, 10, 15],
        [ 6, 12, 18]])
&gt;&gt;&gt;
</code></pre></div>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '/MathJax-2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js','mhchem.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>

            </div>
            <section>
                <div class="col-md-2" style="float:right;font-size:0.9em;">
                    <h4>首发于：</h4>
                    <time pubdate="pubdate" datetime="2021-01-17T04:47:56.504216+08:00">2021年 1月 17日 </time>

                    <h4>最近更新于：</h4>
                    <time datetime="2021-01-17T04:47:56.504216+08:00">2021年 1月 17日 </time>


                    <h4>分类：</h4>
                    <a class="category-link" href="https://a358003542.github.io/categories.html#ji-suan-ji-bian-cheng-python-ref">计算机 - 编程 - python</a>
                    

                </div>
            </section>
        </div>
</article>
    </div>
    <div class="col-md-1"></div>

</div>


<div id="push"></div>
<button id="gotop" type="button" class="btn btn-default">
    <span class="glyphicon glyphicon-arrow-up" aria-hidden="true"></span>
</button>

<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a> and updated by <a href="https://github.com/a358003542" title="wanze Home Page">wanze</a></li>
    </ul>
</div>
</footer>

    <script src="https://a358003542.github.io/theme/js/jquery.min.js"></script>
    <script src="https://a358003542.github.io/theme/js/bootstrap.min.js"></script>

    <script src="https://a358003542.github.io/theme/js/moment.min.js"></script>

    <script src="https://a358003542.github.io/theme/js/base.js"></script>



</body>
</html>