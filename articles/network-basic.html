<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="msvalidate.01" content="55CB117A61A6F8286173763FB18D9625"/>

        <meta name="author" content="wanze"/>
        <meta name="copyright" content="wanze"/>

        <meta name="description"
              content="先找到目标计算机 首先让我们简单回顾一下在学习Linux系统时接触到的网络知识，Internet源起于美国的ARPAnet项目，其有个基本的知识点就是 只有两个位于同一网域的计算机才可以直接进行文件交互 。那么读者就会问了什么是网域，所谓网域说白了就是把一个大的互联网分割分割再分割的一个产物。而分割手段就是 子网掩码 ，怎么判断两个计算机是同一网域呢？就是把这个计算机的IP地址和子网掩码相加，结果相同我们就说他们位于同一网域。 现在我们说一台计算机要对另外一台计算机发送一个信息包，首先这个计算机会分析自己的路由表，如果发现目标机器和自己在同一网域，那么就直接发送信息了。如果不在同一网域，那么这个计算机就要根据路由表将这个信息包发送给默认的路由器（gateway）。路由器或者交换机在网络世界里扮演着一个特殊的角色，那就是它们不具体处理数据，只负责数据分发。具体过程实际上就是上面描述的过程的不断迭代重复，也就是路由器也有一个自己的路由表，然后看看目标机器是不是和自己在同一网域等等，如果不则将信息包发送给另外一个默认的路由器或交换机之类的等等，直到最终目标机器和自己位于同一网域，然后将信息包发送给目标机器。 通信协议 计算机找到目标计算机了就可以开口说话了，但是不能随便说话也就是发送一堆乱码过去，那样目标机器是看不懂的。这个时候我们就需要制定计算机之间的通信协议。那么什么是计算机之间的通信协议？简单来说就好比两个人之间对话的某种规范，或者两个国家进行外交协商的某种特定交互流程。比如一个人对另外一个人说&#34;你好&#34;，另外一个人收到则回应&#34;你好&#34;，表明我已经收到了，然后第一个如果收到这个回应，则表明协议牵手成功，然后继续进行其他会话，比如&#34;今天星期几&#34;，发送过去，然后另外一个人收到之后回应&#34;今天星期一&#34;……就是类似这样的交互方式 …
"/>

        <meta property="og:type" content="article"/>
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="basic, programming, " />

<meta property="og:title" content="计算机网络基础知识 "/>
<meta property="og:url" content="https://a358003542.github.io/articles/network-basic.html" />
<meta property="og:description" content="先找到目标计算机 首先让我们简单回顾一下在学习Linux系统时接触到的网络知识，Internet源起于美国的ARPAnet项目，其有个基本的知识点就是 只有两个位于同一网域的计算机才可以直接进行文件交互 。那么读者就会问了什么是网域，所谓网域说白了就是把一个大的互联网分割分割再分割的一个产物。而分割手段就是 子网掩码 ，怎么判断两个计算机是同一网域呢？就是把这个计算机的IP地址和子网掩码相加，结果相同我们就说他们位于同一网域。 现在我们说一台计算机要对另外一台计算机发送一个信息包，首先这个计算机会分析自己的路由表，如果发现目标机器和自己在同一网域，那么就直接发送信息了。如果不在同一网域，那么这个计算机就要根据路由表将这个信息包发送给默认的路由器（gateway）。路由器或者交换机在网络世界里扮演着一个特殊的角色，那就是它们不具体处理数据，只负责数据分发。具体过程实际上就是上面描述的过程的不断迭代重复，也就是路由器也有一个自己的路由表，然后看看目标机器是不是和自己在同一网域等等，如果不则将信息包发送给另外一个默认的路由器或交换机之类的等等，直到最终目标机器和自己位于同一网域，然后将信息包发送给目标机器。 通信协议 计算机找到目标计算机了就可以开口说话了，但是不能随便说话也就是发送一堆乱码过去，那样目标机器是看不懂的。这个时候我们就需要制定计算机之间的通信协议。那么什么是计算机之间的通信协议？简单来说就好比两个人之间对话的某种规范，或者两个国家进行外交协商的某种特定交互流程。比如一个人对另外一个人说&#34;你好&#34;，另外一个人收到则回应&#34;你好&#34;，表明我已经收到了，然后第一个如果收到这个回应，则表明协议牵手成功，然后继续进行其他会话，比如&#34;今天星期几&#34;，发送过去，然后另外一个人收到之后回应&#34;今天星期一&#34;……就是类似这样的交互方式 …" />
<meta property="og:site_name" content="wanze的博文" />
<meta property="og:article:author" content="wanze" />
<meta property="og:article:published_time" content="2020-03-28T16:50:04.617367+08:00" />
<meta name="twitter:title" content="计算机网络基础知识 ">
<meta name="twitter:description" content="先找到目标计算机 首先让我们简单回顾一下在学习Linux系统时接触到的网络知识，Internet源起于美国的ARPAnet项目，其有个基本的知识点就是 只有两个位于同一网域的计算机才可以直接进行文件交互 。那么读者就会问了什么是网域，所谓网域说白了就是把一个大的互联网分割分割再分割的一个产物。而分割手段就是 子网掩码 ，怎么判断两个计算机是同一网域呢？就是把这个计算机的IP地址和子网掩码相加，结果相同我们就说他们位于同一网域。 现在我们说一台计算机要对另外一台计算机发送一个信息包，首先这个计算机会分析自己的路由表，如果发现目标机器和自己在同一网域，那么就直接发送信息了。如果不在同一网域，那么这个计算机就要根据路由表将这个信息包发送给默认的路由器（gateway）。路由器或者交换机在网络世界里扮演着一个特殊的角色，那就是它们不具体处理数据，只负责数据分发。具体过程实际上就是上面描述的过程的不断迭代重复，也就是路由器也有一个自己的路由表，然后看看目标机器是不是和自己在同一网域等等，如果不则将信息包发送给另外一个默认的路由器或交换机之类的等等，直到最终目标机器和自己位于同一网域，然后将信息包发送给目标机器。 通信协议 计算机找到目标计算机了就可以开口说话了，但是不能随便说话也就是发送一堆乱码过去，那样目标机器是看不懂的。这个时候我们就需要制定计算机之间的通信协议。那么什么是计算机之间的通信协议？简单来说就好比两个人之间对话的某种规范，或者两个国家进行外交协商的某种特定交互流程。比如一个人对另外一个人说&#34;你好&#34;，另外一个人收到则回应&#34;你好&#34;，表明我已经收到了，然后第一个如果收到这个回应，则表明协议牵手成功，然后继续进行其他会话，比如&#34;今天星期几&#34;，发送过去，然后另外一个人收到之后回应&#34;今天星期一&#34;……就是类似这样的交互方式 …">


    <title>计算机网络基础知识  · wanze的博文
</title>

        <link href="https://a358003542.github.io/theme/css/font-awesome.css" rel="stylesheet"
              media="screen">
        <link href="https://a358003542.github.io/theme/css/bootstrap.min.css" rel="stylesheet"
              media="screen">

        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/pygments.css" media="screen">
        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/elegant.css" media="screen">
        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/base.css" media="screen">




</head>
<body>

<nav class="navbar">
    <div class="navbar navbar-default" role="navigation">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed"
                    data-toggle="collapse" data-target=".navbar-collapse"
                    aria-expanded="false">
                <span class="sr-only">Navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <a class="navbar-brand" href="https://a358003542.github.io/"><span
                    class=site-name>网站首页</span></a>
        </div>


        <div class="navbar-collapse collapse">
            <form action="https://a358003542.github.io/search.html"
                  onsubmit="return validateForm(this.elements['q'].value);"
                  class="navbar-form navbar-left">
                <div class="form-group">
                    <input type="text" name="q" id="tipue_search_input"
                           class="form-control" placeholder="Search..."
                           style="width:430px;">
                </div>
                <button class="btn btn-default" type="submit">搜索</button>
            </form>


            <ul class="nav navbar-nav nav-pills navbar-right">
                <li >
                    <a  href="/archives.html">所有文章</a></li>

                <li ><a href="/categories.html">文章分类</a></li>
                <li ><a href="/tags.html">文章标签</a></li>


                        <li >
                            <a href="https://a358003542.github.io/about.html">关于本网站</a>
                        </li>
            </ul>


        </div>
    </div>
</nav>


<div class="container-fluid">
    <div class="col-md-1 col-md-1-left"></div>
    <div class="col-md-10">
<article>
<div class="row">
    <header class="page-header col-md-10 col-md-offset-2">
    <h1><a href="https://a358003542.github.io/articles/network-basic.html"> 计算机网络基础知识  </a></h1>
    </header>
</div>

<div class="row">
    <div class="col-md-2 table-of-content">
        <nav>
        <h4>目录</h4>
        <div class="toc">
<ul>
<li><a href="#_1">先找到目标计算机</a></li>
<li><a href="#_2">通信协议</a></li>
<li><a href="#_3">应用程序体系结构</a></li>
<li><a href="#_4">什么是套接字</a></li>
<li><a href="#tcp">TCP协议</a></li>
<li><a href="#udp">UDP协议</a></li>
<li><a href="#http">HTTP协议</a><ul>
<li><a href="#http_1">HTTP报文格式</a></li>
<li><a href="#cookie">cookie技术</a></li>
<li><a href="#web">web缓存器</a></li>
</ul>
</li>
<li><a href="#dns">DNS协议</a></li>
</ul>
</div>
        </nav>
    </div>
    <div class="col-md-8 article-content">

            
<h2 id="_1">先找到目标计算机</h2>
<p>首先让我们简单回顾一下在学习Linux系统时接触到的网络知识，Internet源起于美国的ARPAnet项目，其有个基本的知识点就是 <strong>只有两个位于同一网域的计算机才可以直接进行文件交互</strong> 。那么读者就会问了什么是网域，所谓网域说白了就是把一个大的互联网分割分割再分割的一个产物。而分割手段就是 <strong>子网掩码</strong> ，怎么判断两个计算机是同一网域呢？就是把这个计算机的IP地址和子网掩码相加，结果相同我们就说他们位于同一网域。</p>
<p>现在我们说一台计算机要对另外一台计算机发送一个信息包，首先这个计算机会分析自己的路由表，如果发现目标机器和自己在同一网域，那么就直接发送信息了。如果不在同一网域，那么这个计算机就要根据路由表将这个信息包发送给默认的路由器（gateway）。路由器或者交换机在网络世界里扮演着一个特殊的角色，那就是它们不具体处理数据，只负责数据分发。具体过程实际上就是上面描述的过程的不断迭代重复，也就是路由器也有一个自己的路由表，然后看看目标机器是不是和自己在同一网域等等，如果不则将信息包发送给另外一个默认的路由器或交换机之类的等等，直到最终目标机器和自己位于同一网域，然后将信息包发送给目标机器。</p>
<h2 id="_2">通信协议</h2>
<p>计算机找到目标计算机了就可以开口说话了，但是不能随便说话也就是发送一堆乱码过去，那样目标机器是看不懂的。这个时候我们就需要制定计算机之间的通信协议。那么什么是计算机之间的通信协议？简单来说就好比两个人之间对话的某种规范，或者两个国家进行外交协商的某种特定交互流程。比如一个人对另外一个人说"你好"，另外一个人收到则回应"你好"，表明我已经收到了，然后第一个如果收到这个回应，则表明协议牵手成功，然后继续进行其他会话，比如"今天星期几"，发送过去，然后另外一个人收到之后回应"今天星期一"……就是类似这样的交互方式。有的连接是双向的，连接为持续存在，一般最后需要发送goodbye来关闭协议，而有的协议是单向的，也叫做无状态协议，比如HTTP协议，信息发送了完了连接就算自动关闭了。</p>
<p>上面的描述还遗漏了一点那就是不仅交互的流程上有规范，而且发送的信息包的格式也是有规范的，或者说有一定的格式的。</p>
<h2 id="_3">应用程序体系结构</h2>
<p>网络世界里目前有两种应用程序体系结构：一种是client/server体系结构；另一种peer to peer，也就是P2P体系结构。</p>
<p>选择客户机/服务器体系结构，你的应用程序会有两个命令两种工作模式，一个启动本地客户机进程，一个启动服务器进程，很多应用程序都是这样的。P2P目前主要是BitTorrent下载软件为大家熟知。</p>
<p>下面主要讨论应用最普遍的client/server体系结构。</p>
<h2 id="_4">什么是套接字</h2>
<p>程序之间具体是进程和进程之间进行通信，一般是一个是客户机进程，另一个是服务器进程，这两个进程之间进行通信。前面谈到的P2P体系结构，也可以这样理解，只是具体某一个进程其既可以是客户机也可以是服务器。我们有如下定义:</p>
<blockquote>
<p>在给定的一对进程之间进行通信，我们称发起通信的进程为客户机进程，在会话中等待联系的进程是服务器进程。（也可以理解为被动等待通信信号）</p>
</blockquote>
<p>两个进程之间具体是用 \textbf{套接字} (socket)来发送和接受报文的。套接字是一个主机内应用层和传输层之间的接口，应用程序开发者可以控制套接字在应用层面上的所有东西，而对于套接字在传输层可以控制的东西非常有限，就仅限于: 选择传输层协议和设定几个传输层参数（如最大缓存最大报文长度等）。</p>
<p>目前TCP/IP网络上的应用就使用了两个传输协议: UDP协议和TCP协议。软件开发者在创建新的应用程序时，首先应该决定传输层是用TCP协议还是UDP协议。</p>
<h2 id="tcp">TCP协议</h2>
<p>TCP协议是面向连接的和可靠数据传输的。所谓的面向连接是指客户机和服务器之间一开始要进行握手过程好建立TCP连接，然后结束之后需要拆除连接。所谓的可靠数据传输是指TCP协议保证数据是无差错的按顺序交付发送的。此外TCP协议还具有拥塞控制机制。SMTP（电子邮件）协议，Telnet协议，HTTP协议，FTP协议多用TCP协议实现。</p>
<h2 id="udp">UDP协议</h2>
<p>UDP是一种不提供不必要服务的轻量级传输层协议，它仅提供最小的服务。UDP是无连接的，两个进程之间没有握手过程。UDP协议并不保证报文能够被接受进程收到，也不保证数据是按顺序到达的。UDP也没有拥塞控制机制。因特网电话和流媒体多用UDP协议实现。</p>
<h2 id="http">HTTP协议</h2>
<p>HTTP（HyperText Transfer Protocol）超文本传输协议是网络世界一个为大家熟知的协议，其属于应用层，为应用层协议。HTTP定义了两个端系统，一个客户机，一个服务器，两个之间如何进行报文交换和这些报文的格式。Web浏览器就是HTTP协议的客户机端，Web服务器就是HTTP协议的服务器端。</p>
<p>HTTP协议使用TCP协议作为其传输层的协议，当用户请求一个Web页面时，浏览器或其他HTTP客户机将首先和服务器建立起一个TCP连接，等连接建立之后，浏览器和服务器就可以通过套接字来交流了。然后客户机经由其套接字向服务器发送一个HTTP请求报文，随后服务器接受到了这个HTTP请求报文，其内部经过某些处理，比如找到html文件即其他资源文件或者其他数据运算之后，也经由套接字回应了一个HTTP响应报文给客户机。然后HTTP服务器进程通知TCP可以断开TCP连接了，然后TCP那边大概等到客户机完整接受这个HTTP响应报文之后，TCP连接就真正断开了。HTTP客户机那边接受到HTTP响应报文，TCP连接断开了，这一次HTTP请求算是完了。</p>
<p>然后这个Web页面还包含有其他图片引用或者javascript引用，每一个引用浏览器客户机那边都将产生一个HTTP请求，类似上面的继续处理。因此基于HTTP协议的TCP协议只进行了一个请求报文和一个响应报文的传输，一个Web页面，可能要发送十几个HTTP请求，那么就要建立十几个TCP连接。（整个过程大抵如此，而现在客户机一般都会打开5-10个并行的TCP连接。）</p>
<p>上面描述的是HTTP协议初始版本的情况，自HTTP/ 1.1起HTTP协议加入了持久连接特性，而且默认就采用持久连接的方式。持久连接可以减少新开TCP连接的消耗，现在HTTP不会每送一个报文就请求断开TCP连接了，而是如果该连接长时间未使用，HTTP服务器才关闭该连接。</p>
<p>然后我们说HTTP协议本身是无状态的，因为HTTP服务器并没有记忆关于客户机的任何信息，但现在有cookie和session，cookie是客户机保存状态信息，session是服务器保存状态信息，这个后面再说。</p>
<h3 id="http_1">HTTP报文格式</h3>
<p>HTTP报文就分为两种，一种是请求报文，一种是响应报文。</p>
<p>比如下面就是一个HTTP请求</p>
<div class="highlight"><pre><span></span>    GET / HTTP/1.1
    Host: www.google.com
    User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:40.0) Gecko/20100101 Firefox/40.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3
    Accept-Encoding: gzip, deflate
    Connection: keep-alive
</pre></div>
<p>第一个是方法字段，HTTP有GET、POST、PUT、DELETE等方法，然后HOST是请求的主机名字，然后User-Agent是用户使用的浏览器，然后Connection这里设置为keep-alive正是前面说的建立持久连接。</p>
<p>然后响应如下:</p>
<div class="highlight"><pre><span></span>    HTTP/1.1 200 OK
    Cache-Control: private
    Content-Length: 231
    Content-Type: text/html; charset=UTF-8
    Date: Wed, 02 Sep 2015 08:47:52 GMT
    Location: https://www.google.com/?gws_rd=ssl
    .........
</pre></div>
<p>这个响应的那个200就是大家熟知的HTTP响应状态码。关于HTTP协议更多内容将在html5学习中讨论。</p>
<h3 id="cookie">cookie技术</h3>
<p>cookie的作用原理如下，用户首先登录一个网站，然后该网站的服务器返回一个HTTP响应，其中有一行</p>
<div class="highlight"><pre><span></span>    Set-cookie: whatwhatwhat
</pre></div>
<p>这个HTTP响应被用户的浏览器接受之后，其将在特定的cookie文件中添加一行，其中有该服务器的名字（HOST）和这个Set-cookie还有后面的标识码信息。然后以后浏览器再访问这个网站的时候，其将自动在HTTP请求上加上这么一行:</p>
<div class="highlight"><pre><span></span>    Cookie: whatwhatwhat
</pre></div>
<p>那个网站的服务器看到HTTP请求的这么一行之后，就说，唉，张三又回来了。然后之后该用户在这个网站上的操作记录都被这个网站的数据库统一管理起来了，什么张三点击了那个页面，什么张三买了什么东西等等。</p>
<h3 id="web">web缓存器</h3>
<p>web缓存器又叫代理服务器，其能够代表初始服务器来满足用户的HTTP请求。其过程如下:</p>
<ol>
<li>
<p>首先是用户那边的浏览器与we缓存器建立TCP连接，然后对其发送一个HTTP请求。</p>
</li>
<li>
<p>web缓存器会检查自己本地是否缓存了目标对象的备份，如果有，则web缓存器用HTTP响应回应用户浏览器。</p>
</li>
<li>
<p>如果web缓存器没有该目标对象的缓存，则其就会向初始服务器打开一个TCP连接，发送一个HTTP请求，获得该目标对象，并将该对象缓存在自己本地，当然还有向用户浏览器回应一个HTTP响应好把新获得的对象也发给用户浏览器。</p>
</li>
</ol>
<p>web缓存器本地虽然可能有目标对象缓存了，但可能这个缓存过于陈旧了。缓存器必须证实本地的缓存内容是最新的，其利用的是HTTP协议的 \verb+If-modified-since+ 这一行。web缓存器将发送一个非常短小的HTTP请求，其中就包含这样一行:</p>
<div class="highlight"><pre><span></span>    If-modified-sine: Wed, 4 Jul 2007 09:23:24
</pre></div>
<p>这个日期是web缓存器存储上一次该缓存对象是获得的HTTP响应头上就有的 <code>Last-Modified</code> 这一行。</p>
<p>然后Web服务器会回应一个很短小的HTTP响应，就是最简短的HTTP状态码和其他几个必要的信息，比如304,Not Modified。</p>
<h2 id="dns">DNS协议</h2>
<p>DNS协议虽然和计算机网络最底层的找到目标计算机操作相关，但其是属于应用层的。</p>
<p>当你输入域名 <code>www.example.com</code> 的时候，计算机是不认识的，计算机首先要将其转化成为IP地址才行，那么计算机怎么转化了，在互联网世界，有很多的DNS服务器，计算机通过查询DNS服务器，然后就获取了这个域名对应的IP地址。</p>

            
            <hr/>

        </div>
        <section>
        <div class="col-md-2" style="float:right;font-size:0.9em;">
            <h4>首发于：</h4>
            <time pubdate="pubdate" datetime="2020-03-28T16:50:04.617367+08:00">2020年 3月 28日 </time>

            <h4>分类：</h4>
            <a class="category-link" href="https://a358003542.github.io/categories.html#programming-ref">programming</a>
            <h4>标签：</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="https://a358003542.github.io/tags.html#basic-ref">basic
                    <span>2</span>
</a></li>
            </ul>

        </div>
        </section>
</div>
</article>
    </div>
    <div class="col-md-1"></div>

</div>


<div id="push"></div>
<button id="gotop" type="button" class="btn btn-default">
    <span class="glyphicon glyphicon-arrow-up" aria-hidden="true"></span>
</button>

<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a> and updated by <a href="https://github.com/a358003542" title="wanze Home Page">wanze</a></li>
    </ul>
</div>
</footer>

        <script src="https://a358003542.github.io/theme/js/jquery.min.js"></script>
    <script src="https://a358003542.github.io/theme/js/bootstrap.min.js"></script>

    <script src="https://a358003542.github.io/theme/js/base.js"></script>

    


</body>
</html>