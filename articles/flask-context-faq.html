<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="baidu-site-verification" content="D4VqC4HppC"/>
    <meta name="msvalidate.01" content="55CB117A61A6F8286173763FB18D9625"/>

        <meta name="author" content="cdwanze"/>
        <meta name="copyright" content="cdwanze"/>

        <meta property="og:type" content="article"/>
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="flask, WEB, " />

<meta property="og:title" content="flask上下文释疑 "/>
<meta property="og:url" content="https://docs.cdwanze.work/articles/flask-context-faq.html" />
<meta property="og:description" content="问题一 gunicorn多进程模式是怎样和flask作用的 参考 这个问题 的解答： import socket import os def main(): serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) serversocket.bind((&#34;127.0.0.1&#34;, 8888)) serversocket.listen(0) # Child Process if os.fork() == 0: accept_conn(&#34;child&#34;, serversocket) accept_conn(&#34;parent&#34;, serversocket) def accept_conn(message, s): while True: c, addr = s.accept …" />
<meta property="og:site_name" content="cdwanze的博文" />
<meta property="og:article:author" content="cdwanze" />
<meta property="og:article:published_time" content="2019-07-22T00:00:00+08:00" />
<meta property="" content="2019-07-22T00:00:00+08:00" />
<meta name="twitter:title" content="flask上下文释疑 ">
<meta name="twitter:description" content="问题一 gunicorn多进程模式是怎样和flask作用的 参考 这个问题 的解答： import socket import os def main(): serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) serversocket.bind((&#34;127.0.0.1&#34;, 8888)) serversocket.listen(0) # Child Process if os.fork() == 0: accept_conn(&#34;child&#34;, serversocket) accept_conn(&#34;parent&#34;, serversocket) def accept_conn(message, s): while True: c, addr = s.accept …">

    <title>
flask上下文释疑  · cdwanze的博文
</title>


        <link href="https://docs.cdwanze.work/theme/css/font-awesome.css" rel="stylesheet"
              media="screen">
        <link href="https://docs.cdwanze.work/theme/css/bootstrap.min.css" rel="stylesheet"
              media="screen">

            <link rel="stylesheet" type="text/css"
                  href="https://docs.cdwanze.work/theme/css/pygments.css" media="screen">
            <link rel="stylesheet" type="text/css"
                  href="https://docs.cdwanze.work/theme/css/elegant.css" media="screen">
            <link rel="stylesheet" type="text/css"
                  href="https://docs.cdwanze.work/theme/css/custom.css" media="screen">






</head>
<body>

<nav class="navbar">
    <div class="navbar navbar-default" role="navigation">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed"
                    data-toggle="collapse" data-target=".navbar-collapse"
                    aria-expanded="false">
                <span class="sr-only">Navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <a class="navbar-brand" href="https://docs.cdwanze.work/"><span
                    class=site-name>网站首页</span></a>
        </div>


        <div class="navbar-collapse collapse">
            <form action="https://docs.cdwanze.work/search.html"
                  onsubmit="return validateForm(this.elements['q'].value);"
                  class="navbar-form navbar-left">
                <div class="form-group">
                    <input type="text" name="q" id="tipue_search_input"
                           class="form-control" placeholder="Search..."
                           style="width:430px;">
                </div>
                <button class="btn btn-default" type="submit">搜索</button>
            </form>


            <ul class="nav navbar-nav nav-pills navbar-right">
                <li >
                    <a href="https://docs.cdwanze.work">博文首页</a></li>

                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle"
                           data-toggle="dropdown" role="button"
                           aria-haspopup="true" aria-expanded="false">查找文章<span
                                class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li><a class="slowscroll" href="/categories.html">按分类</a>
                            </li>
                            <li><a class="slowscroll" href="/tags.html">按标签</a>
                            </li>
                        </ul>
                    </li>


                        <li >
                            <a href="https://docs.cdwanze.work/pdf-ebooks.html">pdf电子书籍</a>
                        </li>
                        <li >
                            <a href="https://docs.cdwanze.work/epub-ebooks.html">epub电子书籍</a>
                        </li>
                        <li >
                            <a href="https://docs.cdwanze.work/about.html">关于本网站</a>
                        </li>
            </ul>


        </div>
    </div>
</nav>


<div class="container-fluid">
    <div class="col-md-1 col-md-1-left"></div>
    <div class="col-md-10">
<article>
<div class="row">
    <header class="page-header col-md-10 col-md-offset-2">
    <h1><a href="https://docs.cdwanze.work/articles/flask-context-faq.html"> flask上下文释疑  </a></h1>
    </header>
</div>

<div class="row">
    <div class="col-md-2 table-of-content">
        <nav>
        <h4>目录</h4>
        <div class="toc">
<ul>
<li><a href="#gunicornflask">问题一 gunicorn多进程模式是怎样和flask作用的</a></li>
<li><a href="#flask">问题二 flask如何应对多线程</a></li>
<li><a href="#flask_1">问题三 flask如何应对多协程</a></li>
<li><a href="#_1">问题四 请求环境栈到底做了什么工作</a></li>
<li><a href="#_2">问题五 多应用的情况是怎么回事</a></li>
<li><a href="#session">问题六 session到底是个什么东西</a></li>
</ul>
</div>
        </nav>
    </div>
    <div class="col-md-8 article-content">

            
            
<h3 id="gunicornflask">问题一 gunicorn多进程模式是怎样和flask作用的</h3>
<p>参考 <a href="https://stackoverflow.com/questions/670891/is-there-a-way-for-multiple-processes-to-share-a-listening-socket#">这个问题</a> 的解答：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">serversocket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">serversocket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s2">"127.0.0.1"</span><span class="p">,</span> <span class="mi">8888</span><span class="p">))</span>
    <span class="n">serversocket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Child Process</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">accept_conn</span><span class="p">(</span><span class="s2">"child"</span><span class="p">,</span> <span class="n">serversocket</span><span class="p">)</span>

    <span class="n">accept_conn</span><span class="p">(</span><span class="s2">"parent"</span><span class="p">,</span> <span class="n">serversocket</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">accept_conn</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="k">print</span> <span class="s1">'Got connection from in </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">message</span>
        <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">'Thank you for your connecting to </span><span class="si">%s</span><span class="se">\n</span><span class="s1">'</span> <span class="o">%</span> <span class="n">message</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>gunicorn 采用的是 pre-fork work 模式，大概作业模式如上代码所示，不同点是 gunicorn 起的主进程不负责消息处理，只负责端口监听和消息分发给子进程。</p>
<p>多进程的情况我们大体是熟悉的，基本上都是独立运行的内部变量类之间完全不相同的程序了。flask wsgi源码中有如下代码：</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">wsgi_app</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
        <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
                <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_dispatch_request</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">e</span>
                <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>  <span class="c1"># noqa: B001</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">raise</span>
            <span class="k">return</span> <span class="n">response</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_ignore_error</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
                <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">auto_pop</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
</pre></div>
<p>其中environ环境中大概有本进程的 app类，然后ctx就是所谓的请求环境，简单了解下这个对后面的讨论有帮助。</p>
<h3 id="flask">问题二 flask如何应对多线程</h3>
<p>这个就要从 flask 源码的 globals 里面的这两行代码说起：</p>
<div class="highlight"><pre><span></span><span class="n">_request_ctx_stack</span> <span class="o">=</span> <span class="n">LocalStack</span><span class="p">()</span>
<span class="n">_app_ctx_stack</span> <span class="o">=</span> <span class="n">LocalStack</span><span class="p">()</span>
</pre></div>
<p>后面代码使用的 请求环境栈和应用环境栈都是这里定义的，这个LocalStack 参考了 <a href="https://cizixs.com/2017/01/13/flask-insight-context/">这片文章</a> 的讨论，借鉴了python threading 模块的 local，其是一个线程本地变量，简单来说就是其是一个字典按照线程不同id的索引，不同的id各自取各自的值，互不干扰。</p>
<p>所以flask在多线程下，请求环境栈和应用环境栈你可以将其看做各自不同的堆栈，互补干扰。</p>
<h3 id="flask_1">问题三 flask如何应对多协程</h3>
<p>原则上如果flask使用的python的threading的local，那么对于协程问题是不能很好地应对的，这个python3.7似乎新增了一个 <code>contextvars</code> 模块就是为了解决这个问题的。那么问题就来了，我们知道gunicorn 可以开始多个进程的worker，而且多个进程worker之下还可以开启多个线程，除了默认的线程之外，gunicorn是还可以开启gevent之类的异步线程的。gevent之类的就是在开启多协程，那么flask能够应对这种情况吗？</p>
<p>flask使用的是 werkzeug定义的Local类，而在源码中我们看到这个：</p>
<div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">greenlet</span> <span class="kn">import</span> <span class="n">getcurrent</span> <span class="k">as</span> <span class="n">get_ident</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">thread</span> <span class="kn">import</span> <span class="n">get_ident</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">_thread</span> <span class="kn">import</span> <span class="n">get_ident</span>
</pre></div>
<p>也就是werkzeug会试着先加载greenlet的get_ident 函数，我想这个函数应该是支持不同的greenlet协程的，而gevent底层似乎开启的就是greenlet协程。</p>
<p>这就说明清楚了，也就是说flask的请求环境栈和应用环境栈不仅是线程独立的，而且还有额外对于greenlet的支持。</p>
<p>那么这里就提出一个问题，我估计现在flask现在应该对于python内部的asyncio协程模式是不能支持的。</p>
<h3 id="_1">问题四 请求环境栈到底做了什么工作</h3>
<p>在请求没有到来之前，请求环境栈和应用环境栈都是空的。你要使用app类除了在代码里面直接引用之没有其他办法。</p>
<p>当一个请求过来了之后，请求环境栈会执行push动作，收集好当前环境的很多变量之后，比如 <code>request</code> <code>session</code> ，还有其他变量，然后将这个请求环境上下文压入堆栈，然后检查应用环境堆栈，如果为空，则会自动创建；或者默认top应用不同当前的，也会自动创建压入。</p>
<p>因为前面讨论过在flask能够应对的多线程多协程默认下，【下面为了讨论方便，只说线程了】，在最小的线程单元中，每个请求环境栈和应用环境栈都是不同的，都会默默记录下当前的请求环境和应用环境，都是一个请求一个请求顺序处理的。于是一个请求来，push，处理完，pop。这是很简单的模式。</p>
<p>具体应用环境存储做了一些优化，比如当前top的和当前一致的话就直接存储None，到时候需要的话，直接调用 <code>current_app</code> 来取就是了。</p>
<p>在取的时候采用了如下代码使用了一种惰性的动态代理机制：</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_lookup_req_object</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">top</span> <span class="o">=</span> <span class="n">_request_ctx_stack</span><span class="o">.</span><span class="n">top</span>
    <span class="k">if</span> <span class="n">top</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">_request_ctx_err_msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<span class="n">request</span> <span class="o">=</span> <span class="n">LocalProxy</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">_lookup_req_object</span><span class="p">,</span> <span class="s2">"request"</span><span class="p">))</span>
<span class="n">session</span> <span class="o">=</span> <span class="n">LocalProxy</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">_lookup_req_object</span><span class="p">,</span> <span class="s2">"session"</span><span class="p">))</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">LocalProxy</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">_lookup_app_object</span><span class="p">,</span> <span class="s2">"g"</span><span class="p">))</span>
</pre></div>
<p>然后request 和session的生存期就是本请求期，这是没有问题的。不过对于g这个变量还需要讨论下。第一个这个g最小粒度在线程这是没有问题的，各个线程之间g彼此完全不相干。而在线程内部接受的不同请求，由于他们都是引用的默认的那个相同的应用上下文环境，那么这个g是可以为多个请求公用的。但正如上面讨论的，不仅不同线程之间g不通用，而且就算某个线程内部，虽然可以应付多个请求，但对于多个应用情况来说g是和应用上下文绑定的，这些请求彼此并不公用g。</p>
<p>flask推荐请求之间要记住某个值，推荐使用数据库或者session这个变量，session虽然是挂在请求上下文中的，但实际在请求上下文创建的时候其是直接接受session参数的：</p>
<div class="highlight"><pre><span></span><span class="n">def</span> <span class="n">__init__</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">app</span><span class="p">,</span> <span class="n">environ</span><span class="p">,</span> <span class="n">request</span><span class="o">=</span><span class="k">None</span><span class="p">,</span> <span class="k">session</span><span class="o">=</span><span class="k">None</span><span class="p">):</span>
</pre></div>
<p>这个session具体怎么传递的还不是清楚，应该在werkzeug那边。</p>
<p>flask推荐g的一种使用方式，是比如管理数据库的连接等，虽然g可能会为空，但只要如下，确保引用的时候，检查一下即可：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">g</span>

<span class="k">def</span> <span class="nf">get_db</span><span class="p">():</span>
    <span class="k">if</span> <span class="s1">'db'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
        <span class="n">g</span><span class="o">.</span><span class="n">db</span> <span class="o">=</span> <span class="n">connect_to_database</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">g</span><span class="o">.</span><span class="n">db</span>

<span class="nd">@app.teardown_appcontext</span>
<span class="k">def</span> <span class="nf">teardown_db</span><span class="p">():</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'db'</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">db</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
<h3 id="_2">问题五 多应用的情况是怎么回事</h3>
<p>参考了 <a href="https://cizixs.com/2017/01/13/flask-insight-context/">这篇文章</a> 的讨论 ，flask是支持多应用的编码风格的：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">werkzeug.wsgi</span> <span class="kn">import</span> <span class="n">DispatcherMiddleware</span>
<span class="kn">from</span> <span class="nn">frontend_app</span> <span class="kn">import</span> <span class="n">application</span> <span class="k">as</span> <span class="n">frontend</span>
<span class="kn">from</span> <span class="nn">backend_app</span> <span class="kn">import</span> <span class="n">application</span> <span class="k">as</span> <span class="n">backend</span>

<span class="n">application</span> <span class="o">=</span> <span class="n">DispatcherMiddleware</span><span class="p">(</span><span class="n">frontend</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">'/backend'</span><span class="p">:</span>     <span class="n">backend</span>
<span class="p">})</span>
</pre></div>
<p>也就是单一线程接受不同的请求，这个请求是哪个app负责的，这个请求是哪个app负责的，依靠应用上下文环境栈是支持这种情况的。</p>
<p>最后一般教程都会提到应用上下文环境可用于单元测试：</p>
<div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">app</span><span class="p">.</span><span class="n">app_context</span><span class="p">():</span>
    <span class="n">pass</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">hello</span> <span class="kn">import</span> <span class="n">app</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">current_app</span>
<span class="n">app_ctx</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">app_context</span><span class="p">()</span>
<span class="n">app_ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">current_app</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
<h3 id="session">问题六 session到底是个什么东西</h3>
<p>前面提到flask在创建请求上下文的时候session这个参数是不知道从哪里直接传进来的，那个flask的这个session到底是个什么东西？</p>
<p>首先说下背景知识：我们知道服务器那么响应内容可以设置这样的响应头： <code>Set-Cookie</code> ，对应flask里面的：</p>
<div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">Response</span><span class="p">(</span><span class="s1">'test'</span><span class="p">)</span>
<span class="n">r</span><span class="p">.</span><span class="n">set_cookie</span><span class="p">(</span><span class="s1">'a'</span><span class="p">,</span><span class="s1">'1'</span><span class="p">)</span>
</pre></div>
<p>客服端client或者说浏览器在接收到这样的响应之后，下次对目标服务器的请求会在请求头上加上对应的Cookie。</p>
<p>如下图所示：</p>
<p><img alt="img" src="https://docs.cdwanze.work/images/python_third_party/session_and_cookie.png"/></p>
<p>说明： 上面是第二次刷新的结果，如果用浏览器的无痕模式测试，第一次request的请求头没有Cookie的。</p>
<p>然后我们在上图的Cookie中看到了 <code>session</code> 这个字段，只是内容含义不明。这个就是对应flask里面的session：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">session</span>
</pre></div>
<p>只是经过了flask的加密。</p>
            
            
            <hr/>

        </div>
        <section>
        <div class="col-md-2" style="float:right;font-size:0.9em;">
            <h4>首发于：</h4>
            <time pubdate="pubdate" datetime="2019-07-22T00:00:00+08:00">2019年 7月 22日 </time>

<h4>最近更新于：</h4>
<time datetime="2019-07-22T00:00:00+08:00">2019年 7月 22日 </time>

            <h4>分类：</h4>
            <a class="category-link" href="https://docs.cdwanze.work/categories.html#web-ref">WEB</a>
            <h4>标签：</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="https://docs.cdwanze.work/tags.html#flask-ref">flask
                    <span>2</span>
</a></li>
            </ul>
        </div>
        </section>
</div>
</article>
    </div>
    <div class="col-md-1"></div>

</div>


<div id="push"></div>


<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a> and updated by <a href="http://www.cdwanze.work" title="cdwanze Home Page">cdwanze</a></li>
    </ul>
</div>
</footer>

        <script src="https://docs.cdwanze.work/theme/js/jquery.min.js"></script>
    <script src="https://docs.cdwanze.work/theme/js/bootstrap.min.js"></script>
    <script>
        function validateForm(query) {
            return (query.length > 0);
        }
    </script>

    <script>
        function adjust_search_width() {
            var w = document.documentElement.clientWidth;
            if ((w > 755) && (w < 975)) {
                plus_width = w - 755;
                $('.navbar-form .form-control').outerWidth(210 + plus_width);
            } else if (w >= 975) {
                $('.navbar-form .form-control').outerWidth(210 + 220);
            } else if (w <= 755) {
                $('.navbar-form .form-control').css('width', '100%')
            }
        }

        $(document).ready(function () {
            adjust_search_width();
        });

        window.onresize = function () {
            adjust_search_width();
        }

    </script>


    



</body>
</html>