<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="msvalidate.01" content="55CB117A61A6F8286173763FB18D9625"/>
    <meta name="google-site-verification" content="r5HyVvY-ZSgf7ctpcpK1aWIaEfKJ0dvAE3E9kW3vXgI" />
    <script data-ad-client="ca-pub-5644206261254049" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
        <meta name="author" content="wanze"/>
        <meta name="copyright" content="wanze"/>

        <meta name="description"
              content="前言 django是一种构建大型商务网站的解决方案，除非目前贵公司的技术栈是已经架构在django之上的，否则不管是个人性质的 …"/>


<meta name="keywords" content="flask, 计算机 - Web开发 - 动态网站, " />

    <title>flask模块  · 万泽的博客
</title>

        <link href="https://a358003542.github.io/theme/css/font-awesome.css" rel="stylesheet"
              media="screen">
        <link href="https://a358003542.github.io/theme/css/bootstrap.min.css" rel="stylesheet"
              media="screen">

        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/pygments.css" media="screen">
        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/elegant.css" media="screen">
        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/base.css" media="screen">




</head>
<body>

<nav class="navbar">
    <div class="navbar navbar-default" role="navigation">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed"
                    data-toggle="collapse" data-target=".navbar-collapse"
                    aria-expanded="false">
                <span class="sr-only">Navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <a class="navbar-brand" href="https://a358003542.github.io/"><span
                    class=site-name>网站首页</span></a>
        </div>


        <div class="navbar-collapse collapse">
            <form action="https://a358003542.github.io/search.html"
                  onsubmit="return validateForm(this.elements['q'].value);"
                  class="navbar-form navbar-left">
                <div class="form-group">
                    <input type="text" name="q" id="tipue_search_input"
                           class="form-control" placeholder="Search..."
                           style="width:430px;">
                </div>
                <button class="btn btn-default" type="submit">搜索</button>
            </form>


            <ul class="nav navbar-nav nav-pills navbar-right">

                <li >
                    <a  href="/archives.html">所有博文</a></li>
                    
                <li ><a href="/categories.html">博文分类</a></li>
                

                        <li >
                            <a href="https://a358003542.github.io/about.html">关于本网站</a>
                        </li>
            </ul>


        </div>
    </div>
</nav>


<div class="container-fluid">
    <div class="col-md-1 col-md-1-left"></div>
    <div class="col-md-10">
<article>
    <div class="row">
        <header class="page-header col-md-10 col-md-offset-2">
            <h1><a href="https://a358003542.github.io/articles/flask-module.html"> flask模块  </a></h1>
        </header>
    </div>

    <div class="row">
        <div class="col-md-2 table-of-content">
            <nav>
                <h4>目录</h4>
                <div class="toc">
<ul>
<li><a href="#_1">前言</a></li>
<li><a href="#_2">更新日志</a></li>
<li><a href="#flask">flask基础</a><ul>
<li><a href="#_3">最简单的例子</a></li>
<li><a href="#_4">其他启动方式</a><ul>
<li><a href="#flask_debug">FLASK_DEBUG</a></li>
<li><a href="#pycharm">pycharm启动</a></li>
</ul>
</li>
<li><a href="#url">url分发</a></li>
<li><a href="#_5">使用蓝图来管理你的项目</a></li>
<li><a href="#url_for">url_for</a></li>
<li><a href="#json-api">JSON api</a></li>
</ul>
</li>
<li><a href="#_6">其他技巧</a><ul>
<li><a href="#flask-shell">flask shell命令定制</a></li>
<li><a href="#_7">加入错误页面</a></li>
<li><a href="#url_1">查看当前url分发情况</a></li>
<li><a href="#flash">flash消息</a></li>
<li><a href="#_8">静态文件</a></li>
</ul>
</li>
<li><a href="#flask_1">flask进阶参考</a><ul>
<li><a href="#_9">请求对象</a></li>
<li><a href="#_10">请求钩子</a></li>
<li><a href="#_11">响应对象</a></li>
<li><a href="#gunicornflask">问题一 gunicorn多进程模式是怎样和flask作用的</a></li>
<li><a href="#flask_2">问题二 flask如何应对多线程</a></li>
<li><a href="#flask_3">问题三 flask如何应对多协程</a></li>
<li><a href="#_12">问题四 请求环境栈到底做了什么工作</a></li>
<li><a href="#_13">问题五 多应用的情况是怎么回事</a></li>
<li><a href="#session">问题六 session到底是个什么东西</a></li>
</ul>
</li>
<li><a href="#_14">第三方插件</a><ul>
<li><a href="#flask-migrate">flask-migrate</a><ul>
<li><a href="#_15">删除无用的迁移脚本</a></li>
<li><a href="#_16">彻底从零开始的迁移脚本</a></li>
</ul>
</li>
<li><a href="#flask-moment">flask-moment</a></li>
<li><a href="#flask-wtf">flask-wtf</a><ul>
<li><a href="#wtforms">WTForms模块</a></li>
<li><a href="#wtforms_1">WTForms的渲染</a></li>
<li><a href="#csrf_token">csrf_token相关</a></li>
<li><a href="#flask-bootstrap">flask-bootstrap提供的额外支持</a></li>
<li><a href="#wtformsfield">WTForms支持的Field</a></li>
<li><a href="#wtformsvalidator">WTForms提供的Validator</a></li>
</ul>
</li>
<li><a href="#flask-login">flask-login</a></li>
</ul>
</li>
<li><a href="#_17">参考资料</a></li>
</ul>
</div>
            </nav>
        </div>
        <div class="col-md-8 article-content">

                
<h2 id="_1">前言</h2>
<p>django是一种构建大型商务网站的解决方案，除非目前贵公司的技术栈是已经架构在django之上的，否则不管是个人性质的小项目，或者刚刚开始的新的项目，个人推荐flask多于django的。当然在flask和tornado之间如何选择上，个人觉得更多的是在你对python的异步这一块的理解上，如果你懂python的异步，并且也知道你要做的api对并发和速度都有很高的要求，那么就应该选择tornado，否则就选择flask。</p>
<p>比如作为个人爱好去搭建的小网站或者api服务，那么选择flask是很适合的。本文也是作者有时鼓捣个人的小网站慢慢积累的一些东西。</p>
<h2 id="_2">更新日志</h2>
<p>2020年10月本文进行了大量更新，主要是将重点更加关注于后台API编写这块，从而编写出更精简的基础知识介绍一章，其他内容另外组织一章。</p>
<p><strong>NOTICE: 本文只关注通用意义上的后台API，并不一定要求是RESTful风格的api，实际上RESTful api也只是一个编程风格上的建议，在某些场景下并不一定是合适的。</strong></p>
<h2 id="flask">flask基础</h2>
<h3 id="_3">最简单的例子</h3>
<p>编写如下脚本，运行之，就是一个最简单的flask后台api服务了。</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_world</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">'hello world'</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">'localhost'</span><span class="p">,</span> <span class="s1">'8080'</span><span class="p">)</span>
</code></pre></div>
<h3 id="_4">其他启动方式</h3>
<p>目前flask官方文档推荐的启动方式是不直接运行上面的hello.py脚本，而是通过运行：</p>
<div class="highlight"><pre><span></span><code>flask run
</code></pre></div>
<p>或者</p>
<div class="highlight"><pre><span></span><code>python -m flask run 
</code></pre></div>
<p>来启动flask。【这个方式很适合开发和测试，实际部署还是WSGI server来进行】</p>
<p>要正常执行上面的命令，你需要设置好一些环境变量，最主要的是 <code>FLASK_APP</code> 这个变量：</p>
<p>windows </p>
<div class="highlight"><pre><span></span><code>set FLASK_APP=hello.py
flask run
</code></pre></div>
<p>linux </p>
<div class="highlight"><pre><span></span><code>export FLASK_APP=hello.py
flask run
</code></pre></div>
<p>推荐是通过在当前工作目录下加上 <code>.env</code> 这个文件，里面定义：</p>
<div class="highlight"><pre><span></span><code>FLASK_APP=myapp.py
FLASK_ENV=development
FLASK_DEBUG=1
</code></pre></div>
<p>环境变量，在运行 flask 命令的时候会自动加载这些环境变量。【这种加载行为只是针对flask命令，load_dotenv 模块之前该做的还是要做，不受影响。】</p>
<h4 id="flask_debug">FLASK_DEBUG</h4>
<p>如果设置为1则开启flask调试模式：</p>
<ul>
<li>重载器 所有源码文件变动自动重启服务器</li>
<li>调试器 出现异常在浏览器中显示异常信息</li>
</ul>
<p>生产环境一定要把调试模式关闭！</p>
<h4 id="pycharm">pycharm启动</h4>
<p>pycharm现在有专门的flask启动支持，不过也可以继续采用如上描述的启动方式，这样会更加接近服务器那边的部署环境。</p>
<p><img alt="img" src="https://a358003542.github.io/images/python_third_party/pycharm_flask.png"/></p>
<p>选择启动python脚本，选择 <code>Module name</code> ，这样就对应 <code>python -m flask</code> 命令的效果，然后加上参数 <code>run</code> ，环境变量如上所示，不用再特别调配了，工作目录设置下即可。</p>
<p>类似的你还可以再加上一个 <code>python -m flask shell</code> 命令。</p>
<h3 id="url">url分发</h3>
<p>url分发是web server的很核心的一个功能。flask最简单的url分发的编写就是通过app.route这样封装各个函数来实现：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">'/users/&lt;int:id&gt;'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_user</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">get_or_404</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">to_json</span><span class="p">())</span>
</code></pre></div>
<p>上面实现了一个动态路由，也就是假设用户请求 <code>/users/1</code> ，到对应的函数那边将传递一个id参数进去，这个id参数类型是int型，数值是1。再来看个例子：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">'/users/&lt;username&gt;'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_user_profile</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">username</span>
</code></pre></div>
<p>假设现在用户请求的是 <code>/users/zhangsan</code> ， 那么到对应的函数那边username将有值 zhangsan，这是一个字符串类型，默认前面不加类型说明的就是字符串类型。此外动态路由还支持的类型有：</p>
<ul>
<li>float</li>
<li>path 和字符串类型，不过可以接受 <code>/</code> 这样的符号。</li>
<li>uuid </li>
</ul>
<h3 id="_5">使用蓝图来管理你的项目</h3>
<p>关于项目结构管理有很多规范，有些并不是那么必要，但推荐使用蓝图来管理你的flask项目这一点是非常重要的一点。实际上除非你的项目是最早期的那种hello world临时测试性质，否则建议马上转成蓝图组织结构。</p>
<p>首先推荐你编写一个 <code>create_app</code> 函数，这一块有些配置上的优化，这还不是很紧要的选项，暂时略过：</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>


<span class="k">def</span> <span class="nf">create_app</span><span class="p">():</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">.main</span> <span class="kn">import</span> <span class="n">main</span> <span class="k">as</span> <span class="n">main_blueprint</span>
    <span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">main_blueprint</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">errors</span> <span class="k">as</span> <span class="n">errors_blueprint</span>
    <span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">errors_blueprint</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">app</span>
</code></pre></div>
<p>各个蓝图比如说errors.py内容如下：</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">jsonify</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Blueprint</span>

<span class="n">errors</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s1">'errors'</span><span class="p">,</span> <span class="vm">__name__</span><span class="p">)</span>


<span class="nd">@errors</span><span class="o">.</span><span class="n">app_errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bad_request</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">jsonify</span><span class="p">({</span><span class="s1">'error'</span><span class="p">:</span> <span class="s1">'bad request'</span><span class="p">,</span> <span class="s1">'message'</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">message</span><span class="p">)})</span>
    <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">=</span> <span class="mi">400</span>
    <span class="k">return</span> <span class="n">response</span>


<span class="nd">@errors</span><span class="o">.</span><span class="n">app_errorhandler</span><span class="p">(</span><span class="mi">401</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">unauthorized</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">jsonify</span><span class="p">({</span><span class="s1">'error'</span><span class="p">:</span> <span class="s1">'unauthorized'</span><span class="p">,</span> <span class="s1">'message'</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">message</span><span class="p">)})</span>
    <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">=</span> <span class="mi">401</span>
    <span class="k">return</span> <span class="n">response</span>


<span class="nd">@errors</span><span class="o">.</span><span class="n">app_errorhandler</span><span class="p">(</span><span class="mi">403</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">forbidden</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">jsonify</span><span class="p">({</span><span class="s1">'error'</span><span class="p">:</span> <span class="s1">'forbidden'</span><span class="p">,</span> <span class="s1">'message'</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">message</span><span class="p">)})</span>
    <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">=</span> <span class="mi">403</span>
    <span class="k">return</span> <span class="n">response</span>
</code></pre></div>
<p>然后main.py内容如下：</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Blueprint</span>

<span class="n">main</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s1">'main'</span><span class="p">,</span> <span class="vm">__name__</span><span class="p">)</span>


<span class="nd">@main</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_world</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">'content'</span><span class="p">:</span> <span class="s1">'hello world'</span>
    <span class="p">}</span>
</code></pre></div>
<p>蓝图在应用中注册写法如下：</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">.main</span> <span class="kn">import</span> <span class="n">main</span> <span class="k">as</span> <span class="n">main_blueprint</span>
<span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">main_blueprint</span><span class="p">)</span>
</code></pre></div>
<p>蓝图的错误页面需要使用 <code>app_errorhandler</code> 要注册为全局的错误处理，如果是 <code>errorhandler</code> 则只负责本蓝图内的错误。</p>
<div class="highlight"><pre><span></span><code><span class="nd">@main</span><span class="o">.</span><span class="n">app_errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">page_not_found</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">'404.html'</span><span class="p">),</span> <span class="mi">404</span>
</code></pre></div>
<p>蓝图内注册的视图函数，用 <code>url_for</code> 来获取的是 <code>main.index</code> 这种形式，即蓝图名加上视图函数名。</p>
<h3 id="url_for">url_for</h3>
<p>url_for是很好用的一个查询flask app内部url链接的函数，具体如下：</p>
<div class="highlight"><pre><span></span><code>url_for('index', _external=True)
</code></pre></div>
<ol>
<li>名字： 默认的名字格式是 <code>蓝图名.视图函数名</code> ，如果 <code>.视图函数名</code> 这种写法意思是当前蓝图的意思的。</li>
<li>送入一些参数进去</li>
<li><code>_external</code> 绝对路径 ，一般使用相对路径即可，浏览器之外的某些链接一定要使用绝对路径</li>
</ol>
<h3 id="json-api">JSON api</h3>
<p>现在一个后台api都推荐JSON风格，如果你的返回内容是字典值，实际上现在也一般推荐返回内容是字典值，那么flask会自动用 <code>jsonify</code> 这个函数来处理你的返回内容，jsonify这个函数返回的flask 的response对象，然后加上了 <code>application/json</code> mime type头字段信息，然后当然还封装了json的dumps方法。</p>
<p>如果不是字典值，则需要你自己使用jsonify函数来处理返回内容。</p>
<h2 id="_6">其他技巧</h2>
<h3 id="flask-shell">flask shell命令定制</h3>
<div class="highlight"><pre><span></span><code><span class="nd">@app</span><span class="o">.</span><span class="n">shell_context_processor</span>
<span class="k">def</span> <span class="nf">make_shell_context</span><span class="p">():</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">db</span><span class="o">=</span><span class="n">db</span><span class="p">,</span> <span class="n">User</span><span class="o">=</span><span class="n">User</span><span class="p">,</span> <span class="n">Role</span><span class="o">=</span><span class="n">Role</span><span class="p">)</span>
</code></pre></div>
<p>运行： </p>
<div class="highlight"><pre><span></span><code>flask shell
</code></pre></div>
<p>db那些变量是可以正常使用的。</p>
<p>cmd里面要配置好环境变量 <code>export FLASK_APP=hello.py</code> </p>
<h3 id="_7">加入错误页面</h3>
<div class="highlight"><pre><span></span><code>@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'),404
</code></pre></div>
<p>如果是蓝图的话，要有全局的效果，则应该使用 <code>app_errorhandler</code> ：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@main</span><span class="o">.</span><span class="n">app_errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">page_not_found</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">'404.html'</span><span class="p">),</span> <span class="mi">404</span>
</code></pre></div>
<h3 id="url_1">查看当前url分发情况</h3>
<p>可以通过 <code>app.url_map</code> 来查看flask当前app的url分发情况。</p>
<h3 id="flash">flash消息</h3>
<p>flash消息方便让用户知道一些必要的信息。flash函数可以实现这点。然后模板文件上需要加上：</p>
<div class="highlight"><pre><span></span><code>    {% for message in get_flashed_messages() %}
        &lt;div class="alert alert-warning"&gt;
            &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt;
            {{ message }}
        &lt;/div&gt;
    {% endfor %}
</code></pre></div>
<h3 id="_8">静态文件</h3>
<p>flask默认有路由：</p>
<div class="highlight"><pre><span></span><code>/static/&lt;filename&gt;
</code></pre></div>
<p>所以你可以如下</p>
<div class="highlight"><pre><span></span><code>url_for('static', filename='favicon.ico')
</code></pre></div>
<p>来直接引用static文件夹的静态文件。</p>
<h2 id="flask_1">flask进阶参考</h2>
<p>在深入了解flask框架内部工作原理之后，读者可以参看我写的 flask上下文释疑这篇文章 ，然后再了解下flask具体的一些API细节即可。下面也列出了一些可做核心参考。</p>
<h3 id="_9">请求对象</h3>
<p>request请求对象有：</p>
<ul>
<li>form dict 存储请求的表单字段</li>
<li>args  dict 存储URL上传递的参数</li>
<li>values form和args的合集</li>
<li>cookies dict 存储请求的所有cookies</li>
<li>headers dict 存储http的headers</li>
<li>files dict 存储请求上传的所有文件</li>
<li>get_data 返回请求主体缓冲的数据</li>
<li>get_json return dict 包含解析请求主题后得到的json</li>
<li>blueprint 处理请求的Flask蓝本</li>
<li>endpoint 处理请求的Flask端点名称</li>
<li>method HTTP请求方法</li>
<li>scheme http或https</li>
<li>is_secure 通过HTTPS发送的请求返回True</li>
<li>host  请求主机名</li>
<li>path 请求URL路径</li>
<li>query_string URL查询字符串部分</li>
<li>full_path URL 路径和查询字符串部分</li>
<li>url 完整URL</li>
<li>base_url 同url但没有查询字符串部分</li>
<li>remote_addr 远程IP地址</li>
<li>environ dict 请求原始WSGI环境 </li>
</ul>
<h3 id="_10">请求钩子</h3>
<p>请求钩子用装饰器来实现，flask有以下四种钩子：</p>
<ul>
<li>before_request 请求之前执行</li>
<li>before_first_request 只在第一次请求前执行</li>
<li>after_request 每次请求后执行 如果程序没有抛出异常的话</li>
<li>teardown_request 每次请求之后执行，即使抛出异常</li>
</ul>
<p>请求钩子和视图函数之间变量互通一般用上下文全局变量 g ，比如 <code>before_request</code> 处理的时候设置 <code>g.user</code> 为登录用户，后面视图函数可以调用 <code>g.user</code> 来得知当前登录用户。</p>
<h3 id="_11">响应对象</h3>
<div class="highlight"><pre><span></span><code>response = make_response(content, status_code)
response.set_cookie('a',1)
</code></pre></div>
<p>响应对象有以下属性或方法：</p>
<ul>
<li>status_code</li>
<li>headers</li>
<li>set_cookies 设置cookies</li>
<li>delete_cookies 删除一个cookies</li>
<li>content_length 内容长度</li>
<li>content_type 响应主体的媒体类型</li>
<li>set_data  </li>
<li>get_data</li>
</ul>
<p>特殊的响应： 重定向响应 状态码 302 Location部分写上目标URL flask提供 redirect函数快速生成这个重定向响应对象。</p>
<p>abort函数 其返回的是状态码404 其是抛出异常 </p>
<h3 id="gunicornflask">问题一 gunicorn多进程模式是怎样和flask作用的</h3>
<p>参考 <a href="https://stackoverflow.com/questions/670891/is-there-a-way-for-multiple-processes-to-share-a-listening-socket#">这个问题</a> 的解答：</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">serversocket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">serversocket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s2">"127.0.0.1"</span><span class="p">,</span> <span class="mi">8888</span><span class="p">))</span>
    <span class="n">serversocket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Child Process</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">accept_conn</span><span class="p">(</span><span class="s2">"child"</span><span class="p">,</span> <span class="n">serversocket</span><span class="p">)</span>

    <span class="n">accept_conn</span><span class="p">(</span><span class="s2">"parent"</span><span class="p">,</span> <span class="n">serversocket</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">accept_conn</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="nb">print</span> <span class="s1">'Got connection from in </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">message</span>
        <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">'Thank you for your connecting to </span><span class="si">%s</span><span class="se">\n</span><span class="s1">'</span> <span class="o">%</span> <span class="n">message</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div>
<p>gunicorn 采用的是 pre-fork work 模式，大概作业模式如上代码所示，不同点是 gunicorn 起的主进程不负责消息处理，只负责端口监听和消息分发给子进程。</p>
<p>多进程的情况我们大体是熟悉的，基本上都是独立运行的内部变量类之间完全不相同的程序了。flask wsgi源码中有如下代码：</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">wsgi_app</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
        <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
                <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_dispatch_request</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">e</span>
                <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>  <span class="c1"># noqa: B001</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">raise</span>
            <span class="k">return</span> <span class="n">response</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_ignore_error</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
                <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">auto_pop</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
</code></pre></div>
<p>其中environ环境中大概有本进程的 app类，然后ctx就是所谓的请求环境，简单了解下这个对后面的讨论有帮助。</p>
<h3 id="flask_2">问题二 flask如何应对多线程</h3>
<p>这个就要从 flask 源码的 globals 里面的这两行代码说起：</p>
<div class="highlight"><pre><span></span><code><span class="n">_request_ctx_stack</span> <span class="o">=</span> <span class="n">LocalStack</span><span class="p">()</span>
<span class="n">_app_ctx_stack</span> <span class="o">=</span> <span class="n">LocalStack</span><span class="p">()</span>
</code></pre></div>
<p>后面代码使用的 请求环境栈和应用环境栈都是这里定义的，这个LocalStack 参考了 <a href="https://cizixs.com/2017/01/13/flask-insight-context/">这片文章</a> 的讨论，借鉴了python threading 模块的 local，其是一个线程本地变量，简单来说就是其是一个字典按照线程不同id的索引，不同的id各自取各自的值，互不干扰。</p>
<p>所以flask在多线程下，请求环境栈和应用环境栈你可以将其看做各自不同的堆栈，互不干扰。</p>
<h3 id="flask_3">问题三 flask如何应对多协程</h3>
<p>原则上如果flask使用的python的threading的local，那么对于协程问题是不能很好地应对的，这个python3.7似乎新增了一个 <code>contextvars</code> 模块就是为了解决这个问题的。那么问题就来了，我们知道gunicorn 可以开始多个进程的worker，而且多个进程worker之下还可以开启多个线程，除了默认的线程之外，gunicorn是还可以开启gevent之类的异步线程的。gevent之类的就是在开启多协程，那么flask能够应对这种情况吗？</p>
<p>flask使用的是 werkzeug定义的Local类，而在源码中我们看到这个：</p>
<div class="highlight"><pre><span></span><code><span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">greenlet</span> <span class="kn">import</span> <span class="n">getcurrent</span> <span class="k">as</span> <span class="n">get_ident</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">thread</span> <span class="kn">import</span> <span class="n">get_ident</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">_thread</span> <span class="kn">import</span> <span class="n">get_ident</span>
</code></pre></div>
<p>也就是werkzeug会试着先加载greenlet的get_ident 函数，我想这个函数应该是支持不同的greenlet协程的，而gevent底层似乎开启的就是greenlet协程。</p>
<p>这就说明清楚了，也就是说flask的请求环境栈和应用环境栈不仅是线程独立的，而且还有额外对于greenlet的支持。</p>
<p>那么这里就提出一个问题，我估计现在flask现在应该对于python内部的asyncio协程模式是不能支持的。</p>
<h3 id="_12">问题四 请求环境栈到底做了什么工作</h3>
<p>在请求没有到来之前，请求环境栈和应用环境栈都是空的。你要使用app类除了在代码里面直接引用之没有其他办法。</p>
<p>当一个请求过来了之后，请求环境栈会执行push动作，收集好当前环境的很多变量之后，比如 <code>request</code> <code>session</code> ，还有其他变量，然后将这个请求环境上下文压入堆栈，然后检查应用环境堆栈，如果为空，则会自动创建；或者默认top应用不同当前的，也会自动创建压入。</p>
<p>因为前面讨论过在flask能够应对的多线程多协程默认下，【下面为了讨论方便，只说线程了】，在最小的线程单元中，每个请求环境栈和应用环境栈都是不同的，都会默默记录下当前的请求环境和应用环境，都是一个请求一个请求顺序处理的。于是一个请求来，push，处理完，pop。这是很简单的模式。</p>
<p>具体应用环境存储做了一些优化，比如当前top的和当前一致的话就直接存储None，到时候需要的话，直接调用 <code>current_app</code> 来取就是了。</p>
<p>在取的时候采用了如下代码使用了一种惰性的动态代理机制：</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_lookup_req_object</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">top</span> <span class="o">=</span> <span class="n">_request_ctx_stack</span><span class="o">.</span><span class="n">top</span>
    <span class="k">if</span> <span class="n">top</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">_request_ctx_err_msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<span class="n">request</span> <span class="o">=</span> <span class="n">LocalProxy</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">_lookup_req_object</span><span class="p">,</span> <span class="s2">"request"</span><span class="p">))</span>
<span class="n">session</span> <span class="o">=</span> <span class="n">LocalProxy</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">_lookup_req_object</span><span class="p">,</span> <span class="s2">"session"</span><span class="p">))</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">LocalProxy</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">_lookup_app_object</span><span class="p">,</span> <span class="s2">"g"</span><span class="p">))</span>
</code></pre></div>
<p>然后request 和session的生存期就是本请求期，这是没有问题的。不过对于g这个变量还需要讨论下。第一个这个g最小粒度在线程这是没有问题的，各个线程之间g彼此完全不相干。而在线程内部接受的不同请求，由于他们都是引用的默认的那个相同的应用上下文环境，那么这个g是可以为多个请求公用的。但正如上面讨论的，不仅不同线程之间g不通用，而且就算某个线程内部，虽然可以应付多个请求，但对于多个应用情况来说g是和应用上下文绑定的，这些请求彼此并不公用g。</p>
<p>flask推荐请求之间要记住某个值，推荐使用数据库或者session这个变量，session虽然是挂在请求上下文中的，但实际在请求上下文创建的时候其是直接接受session参数的：</p>
<div class="highlight"><pre><span></span><code>def __init__(self, app, environ, request=None, session=None):
</code></pre></div>
<p>这个session具体怎么传递的还不是清楚，应该在werkzeug那边。</p>
<p>flask推荐g的一种使用方式，是比如管理数据库的连接等，虽然g可能会为空，但只要如下，确保引用的时候，检查一下即可：</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">g</span>

<span class="k">def</span> <span class="nf">get_db</span><span class="p">():</span>
    <span class="k">if</span> <span class="s1">'db'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
        <span class="n">g</span><span class="o">.</span><span class="n">db</span> <span class="o">=</span> <span class="n">connect_to_database</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">g</span><span class="o">.</span><span class="n">db</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">teardown_appcontext</span>
<span class="k">def</span> <span class="nf">teardown_db</span><span class="p">():</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'db'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">db</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div>
<h3 id="_13">问题五 多应用的情况是怎么回事</h3>
<p>参考了 <a href="https://cizixs.com/2017/01/13/flask-insight-context/">这篇文章</a> 的讨论 ，flask是支持多应用的编码风格的：</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">werkzeug.wsgi</span> <span class="kn">import</span> <span class="n">DispatcherMiddleware</span>
<span class="kn">from</span> <span class="nn">frontend_app</span> <span class="kn">import</span> <span class="n">application</span> <span class="k">as</span> <span class="n">frontend</span>
<span class="kn">from</span> <span class="nn">backend_app</span> <span class="kn">import</span> <span class="n">application</span> <span class="k">as</span> <span class="n">backend</span>

<span class="n">application</span> <span class="o">=</span> <span class="n">DispatcherMiddleware</span><span class="p">(</span><span class="n">frontend</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">'/backend'</span><span class="p">:</span>     <span class="n">backend</span>
<span class="p">})</span>
</code></pre></div>
<p>也就是单一线程接受不同的请求，这个请求是哪个app负责的，这个请求是哪个app负责的，依靠应用上下文环境栈是支持这种情况的。</p>
<p>最后一般教程都会提到应用上下文环境可用于单元测试：</p>
<div class="highlight"><pre><span></span><code>with app.app_context():
    pass
</code></pre></div>
<div class="highlight"><pre><span></span><code>from hello import app
from flask import current_app
app_ctx = app.app_context()
app_ctx.push()
print(current_app.name)
</code></pre></div>
<h3 id="session">问题六 session到底是个什么东西</h3>
<p>前面提到flask在创建请求上下文的时候session这个参数是不知道从哪里直接传进来的，那个flask的这个session到底是个什么东西？</p>
<p>首先说下背景知识：我们知道服务器那么响应内容可以设置这样的响应头： <code>Set-Cookie</code> ，对应flask里面的：</p>
<div class="highlight"><pre><span></span><code>r = Response('test')
r.set_cookie('a','1')
</code></pre></div>
<p>客服端client或者说浏览器在接收到这样的响应之后，下次对目标服务器的请求会在请求头上加上对应的Cookie。</p>
<p>如下图所示：</p>
<p><img alt="img" src="https://a358003542.github.io/images/python_third_party/session_and_cookie.png"/></p>
<p>说明： 上面是第二次刷新的结果，如果用浏览器的无痕模式测试，第一次request的请求头没有Cookie的。</p>
<p>然后我们在上图的Cookie中看到了 <code>session</code> 这个字段，只是内容含义不明。这个就是对应flask里面的session：</p>
<div class="highlight"><pre><span></span><code>from flask import session
</code></pre></div>
<p>只是经过了flask的加密。</p>
<h2 id="_14">第三方插件</h2>
<p>第三方插件请读者根据需要选择使用之。</p>
<h3 id="flask-migrate">flask-migrate</h3>
<p><code>flask-migrate</code> 其基于sqlalchemy 的  alembic ，然后做了一些额外的工作。 主要提供了一些便捷的命令行接口，具体使用还是要熟悉sqlalchemy和alembic。</p>
<p>一个简要的例子如下：</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">flask_sqlalchemy</span> <span class="kn">import</span> <span class="n">SQLAlchemy</span>
<span class="kn">from</span> <span class="nn">flask_migrate</span> <span class="kn">import</span> <span class="n">Migrate</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">'SQLALCHEMY_DATABASE_URI'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'sqlite:///app.db'</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">SQLAlchemy</span><span class="p">()</span>

<span class="n">db</span><span class="o">.</span><span class="n">init_app</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
<span class="n">migrate</span> <span class="o">=</span> <span class="n">Migrate</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span>
</code></pre></div>
<p>新项目首先要运行：</p>
<div class="highlight"><pre><span></span><code>flask db init
</code></pre></div>
<p>这对应alembic的 <code>alembic init</code> 命令，其将创建 <code>migrations</code> 文件夹，里面的文件就是alembic需要的，migrations文件夹是推荐和源代码一起加入版本控制的。</p>
<p>和简单的使用的alembic不同，其新建的 <code>env.py</code> 有一些优化，flask的配置环境里只要配置了 <code>SQLALCHEMY_DATABASE_URI</code> 这样变量，alembic就能正确找到数据库了。</p>
<p>然后：</p>
<div class="highlight"><pre><span></span><code>flask db revision # 对应的是 alembic revison
flask db migrate # 对应的是 alembic revision --autogenerate
flask db upgrade # 对应的是 alembic upgrade
flask db downgrade # 对应的是 alembic downgrade
</code></pre></div>
<p>一般工作流程：</p>
<ol>
<li>修改数据库模型或者说数据库模型发生了变动</li>
<li><code>flask db migrate</code> 创建迁移脚本</li>
<li>检查自动生成的脚本，改正不正确的地方</li>
<li><code>flask db upgrade</code>  将改动应用到数据库</li>
</ol>
<h4 id="_15">删除无用的迁移脚本</h4>
<p>alembic的自动生成脚本并不是万能的，需要人工审核。而就算没问题的某些迁移脚本，如果你觉得已经毫无意义了，那么将那个版本的迁移脚本删除是没有任何问题的。</p>
<h4 id="_16">彻底从零开始的迁移脚本</h4>
<p>虽然alembic的官方文档觉得没有这个必要，不过我觉得还是很有用的。</p>
<ol>
<li>首先我们在flask应用下加上这样两个命令，负责最开始的创建数据库和根本代码生成表格工作。</li>
<li>表格生成成功之后后面都用flask-migrate 或者说 alembic来管理，经过测试比如在models.py 哪里新加一列，然后利用 <code>flask db migrate</code> 是能够自动检测新加入了一列，从而自动生成的代码会更加精准。</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">sqlalchemy_utils</span> <span class="kn">import</span> <span class="n">database_exists</span><span class="p">,</span> <span class="n">create_database</span><span class="p">,</span> <span class="n">drop_database</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">cli</span><span class="o">.</span><span class="n">command</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">initdb</span><span class="p">():</span>
    <span class="n">user_input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">'本命令只用于数据库初始化，后续更改请使用alembic来管理，确定请输入 [Y]'</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">user_input</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'y'</span><span class="p">:</span>
        <span class="n">engine</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">engine</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">database_exists</span><span class="p">(</span><span class="n">engine</span><span class="o">.</span><span class="n">url</span><span class="p">):</span>
            <span class="n">create_database</span><span class="p">(</span><span class="n">engine</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">'db exists...'</span><span class="p">)</span>
            <span class="kn">import</span> <span class="nn">sys</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">database_exists</span><span class="p">(</span><span class="n">engine</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>

        <span class="n">db</span><span class="o">.</span><span class="n">create_all</span><span class="p">()</span>

        <span class="kn">from</span> <span class="nn">alembic.config</span> <span class="kn">import</span> <span class="n">Config</span>
        <span class="kn">from</span> <span class="nn">alembic</span> <span class="kn">import</span> <span class="n">command</span>
        <span class="n">alembic_cfg</span> <span class="o">=</span> <span class="n">Config</span><span class="p">(</span><span class="s1">'migrations/alembic.ini'</span><span class="p">)</span>

        <span class="n">command</span><span class="o">.</span><span class="n">stamp</span><span class="p">(</span><span class="n">alembic_cfg</span><span class="p">,</span> <span class="s2">"head"</span><span class="p">)</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">cli</span><span class="o">.</span><span class="n">command</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">dropdb</span><span class="p">():</span>
    <span class="sd">"""</span>
<span class="sd">    TODO 生产环境不允许调用本命令</span>
<span class="sd">    :return:</span>
<span class="sd">    """</span>
    <span class="n">user_input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">'警告!!! 本操作将删除数据库，数据将完全丢失，确定请输入： [YYY]'</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="s1">'YYY'</span><span class="p">:</span>
        <span class="n">engine</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">engine</span>

        <span class="n">db</span><span class="o">.</span><span class="n">drop_all</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">database_exists</span><span class="p">(</span><span class="n">engine</span><span class="o">.</span><span class="n">url</span><span class="p">):</span>
            <span class="n">drop_database</span><span class="p">(</span><span class="n">engine</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">'db not exists...'</span><span class="p">)</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="n">database_exists</span><span class="p">(</span><span class="n">engine</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
</code></pre></div>
<h3 id="flask-moment">flask-moment</h3>
<p>Moment JS 送入UTC时间会自动转换成为本地时间，服务器那边的时间戳最好是记录UTC时间。用户则应该看到本地时间。</p>
<div class="highlight"><pre><span></span><code>{% block scripts %}
    {{ super() }}
    {{ moment.include_moment() }}
    {{ moment.lang("zh-cn") }}
{% endblock %}
</code></pre></div>
<p>在模板上使用：</p>
<div class="highlight"><pre><span></span><code>    &lt;p&gt;当前时间是： {{ moment(current_time).format('LLLL') }}.&lt;/p&gt;
    &lt;p&gt;{{ moment(current_time).fromNow(refresh=True) }}刷新过.&lt;/p&gt;
</code></pre></div>
<p>具体格式请参看 <a href="http://momentjs.cn/">MomentJs 官网</a> 。</p>
<h3 id="flask-wtf">flask-wtf</h3>
<p>这块初接触在理解上是有点困难的，其实flask-wtf提供的主要是对WTForms这个模块的集成支持，然后还有一些功能比如 <code>wtf.quick_form(form)</code> 这个是 flask-bootstrap 对 WTForms的一些额外的支持。这里理解上的关键在于理解 WTForms 这个模块到底在干什么事情。</p>
<h4 id="wtforms">WTForms模块</h4>
<p>简单来说WTForms模块做的工作就是方便你在模板引擎上比如jinja2模块引擎上快速创建输入表单和相关验证事宜。</p>
<p>首先需要定义一个Form类：</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">wtforms</span> <span class="kn">import</span> <span class="n">Form</span><span class="p">,</span> <span class="n">BooleanField</span><span class="p">,</span> <span class="n">StringField</span><span class="p">,</span> <span class="n">validators</span>

<span class="k">class</span> <span class="nc">RegistrationForm</span><span class="p">(</span><span class="n">Form</span><span class="p">):</span>
    <span class="n">username</span>     <span class="o">=</span> <span class="n">StringField</span><span class="p">(</span><span class="s1">'Username'</span><span class="p">,</span> <span class="p">[</span><span class="n">validators</span><span class="o">.</span><span class="n">Length</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">25</span><span class="p">)])</span>
    <span class="n">email</span>        <span class="o">=</span> <span class="n">StringField</span><span class="p">(</span><span class="s1">'Email Address'</span><span class="p">,</span> <span class="p">[</span><span class="n">validators</span><span class="o">.</span><span class="n">Length</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">35</span><span class="p">)])</span>
    <span class="n">accept_rules</span> <span class="o">=</span> <span class="n">BooleanField</span><span class="p">(</span><span class="s1">'I accept the site rules'</span><span class="p">,</span> <span class="p">[</span><span class="n">validators</span><span class="o">.</span><span class="n">InputRequired</span><span class="p">()])</span>
</code></pre></div>
<p>Form类里面有一些Field类，然后Field类里面可以通过一个列表定义一系列的Validators 验证器。每个Field都有一个Widget ，Widget的任务就是负责HTML的渲染工作。</p>
<p>关于这个form类值得我们注意的有：</p>
<ol>
<li>这个form对象，你可以通过 <code>form.username.data</code> 来获取表单中的值。</li>
<li>如果你在定义这个form对象的时候定义了其他 <code>validate_&lt;field_name&gt;</code> 函数，这些函数会针对特定的field_name而进行调用。如果验证失败，则抛出 <code>ValidationError</code> 异常，异常的信息将作为错误信息。</li>
</ol>
<p>这个Form类在python中的代码使用如下：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">'/submit'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">(</span><span class="s1">'GET'</span><span class="p">,</span> <span class="s1">'POST'</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">submit</span><span class="p">():</span>
    <span class="n">form</span> <span class="o">=</span> <span class="n">MyForm</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">'POST'</span> <span class="ow">and</span> <span class="n">form</span><span class="o">.</span><span class="n">validate</span><span class="p">():</span>
         <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="s1">'/success'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">'submit.html'</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="n">form</span><span class="p">)</span>
</code></pre></div>
<p>然后 flask-wtf 下的使用代码如下：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">'/submit'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">(</span><span class="s1">'GET'</span><span class="p">,</span> <span class="s1">'POST'</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">submit</span><span class="p">():</span>
    <span class="n">form</span> <span class="o">=</span> <span class="n">MyForm</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">form</span><span class="o">.</span><span class="n">validate_on_submit</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="s1">'/success'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">'submit.html'</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="n">form</span><span class="p">)</span>
</code></pre></div>
<p>flask-wtf 定义的Form类在使用上提供的便利有：</p>
<ol>
<li>会自动将 <code>request.form</code> 或者 <code>request.files</code> 塞进去。</li>
<li>直接使用 <code>validate_on_submit</code> 方法即可，里面集成了对 request.method 的判断——<code>POST PUT PATCH DELETE</code> 都是可以的。</li>
</ol>
<p>WTForms 初始化接收值，除了第一个值 <code>request.form</code> 等，还支持对接某个model 对象，后面还可以跟上一些关键词参数：</p>
<div class="highlight"><pre><span></span><code>form = MyForm(request.form, user, username='zhangsan')
</code></pre></div>
<p>WTForms提供了很多内置的验证器支持，你还可以定义自己的验证器。这些验证器对应到上面的 <code>validate</code> 方法中，这个后面再说。</p>
<h4 id="wtforms_1">WTForms的渲染</h4>
<p>上面提到的form类实例中的Field是可以直接调用str() 来获得如下的一段HTML代码的：</p>
<div class="highlight"><pre><span></span><code>&lt;input id="content" name="content" type="text" value="foobar" /&gt;
</code></pre></div>
<p>我们看到一般模板引擎渲染时，比如jinja2，会接受form实例。然后一个一般的表单渲染如下：</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">LoginForm</span><span class="p">(</span><span class="n">Form</span><span class="p">):</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">StringField</span><span class="p">(</span><span class="s1">'Username'</span><span class="p">)</span>
    <span class="n">password</span> <span class="o">=</span> <span class="n">PasswordField</span><span class="p">(</span><span class="s1">'Password'</span><span class="p">)</span>

<span class="n">form</span> <span class="o">=</span> <span class="n">LoginForm</span><span class="p">()</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>&lt;form method="POST" action="/login"&gt;
    &lt;div&gt;{{ form.username.label }}: {{ form.username(class="css_class") }}&lt;/div&gt;
    &lt;div&gt;{{ form.password.label }}: {{ form.password() }}&lt;/div&gt;
&lt;/form&gt;
</code></pre></div>
<p>在python代码那边，form的Field部分是可以接受一些额外的关键词参数，其将作为属性传入从而作为input标签的属性。</p>
<h4 id="csrf_token">csrf_token相关</h4>
<p>WTForms 已经有了 <code>csrf_token</code> 的支持功能：</p>
<div class="highlight"><pre><span></span><code> {{ form.csrf_token }}
</code></pre></div>
<p>关于这块具体细节请参看WTForms的csrf_token相关章节，这里不深究了，一个csrf_token安全校验。</p>
<p>而 flask-wtf 这边推荐的写法是：</p>
<div class="highlight"><pre><span></span><code>&lt;form method="POST" action="/"&gt;
    {{ form.hidden_tag() }}
    {{ form.name.label }} {{ form.name(size=20) }}
&lt;/form&gt;
</code></pre></div>
<p><code>hidden_tag</code> 这个方法是flask-wtf提供的，就是将所有隐藏的html field 渲染在这里，因为 flask-wtf 默认会加上 csrf_token 支持，也就是上面的语句：</p>
<div class="highlight"><pre><span></span><code> {{ form.csrf_token }}
</code></pre></div>
<p>这是一个hidden标签，所以最后还是会渲染在这里。</p>
<h4 id="flask-bootstrap">flask-bootstrap提供的额外支持</h4>
<p>flask-bootstrap又提供了一些额外的支持，简单来说就是编写了一些jinja2的宏。比如 <code>quick_form</code> 宏：</p>
<div class="highlight"><pre><span></span><code>{{ wtf.quick_form(form) }}
</code></pre></div>
<p>大体对应于输出这样的语句：</p>
<div class="highlight"><pre><span></span><code>{% import "bootstrap/wtf.html" as wtf %}
&lt;form class="form form-horizontal" method="post" role="form"&gt;
  {{ form.hidden_tag() }}
  {{ wtf.form_errors(form, hiddens="only") }}

  {{ wtf.form_field(form.field1) }}
  {{ wtf.form_field(form.field2) }}
&lt;/form&gt;
</code></pre></div>
<p>这里只是说大体对应，因为quick_form 宏还有一些参数可以调配。上面对应的只是默认参数的输出情况。</p>
<p>然后上面的 <code>form_errors</code> 宏 和 <code>form_field</code> 宏也都是 flask-bootstrap 那个宏文件里面定义的。总之如果刚开始对表单的显示没有什么特别的要求的话， <code>quick_form</code> 宏还是很好用的。</p>
<p>有的时候有特别的要求，个人觉得是没有必要深究flask-bootstrap 那边宏定义的情况，退化为上面的写法，再稍作定制看看是否满足你的要求。否则直接用 flask-wtf 如下这种最原始的写法，再调配下即可。</p>
<div class="highlight"><pre><span></span><code>&lt;form method="POST" action="/"&gt;
    {{ form.hidden_tag() }}
    {{ form.name.label }} {{ form.name(size=20) }}
&lt;/form&gt;
</code></pre></div>
<h4 id="wtformsfield">WTForms支持的Field</h4>
<ul>
<li>BooleanField 复选框</li>
<li>DateField 文本字段 for datetime.date</li>
<li>DateTimeField 文本字段 for datetime.datetime</li>
<li>DecimalField 文本字段 for  decimal.Decimal</li>
<li>FileField 文件上传字段</li>
<li>HiddenField 隐藏文本字段</li>
<li>FieldList 一组指定类型的字段</li>
<li>FloatField 文本字段 for float</li>
<li>FormField 把一个表单作为字段嵌入另一个表单</li>
<li>IntegerField 文本字段 for integer</li>
<li>PasswordField 密码文本字段</li>
<li>RadioField 单选按钮</li>
<li>SelectField 下拉列表</li>
<li>SelectmultipleField 下拉多选列表</li>
<li>SubmitField 表单提交按钮</li>
<li>StringField 文本字段</li>
<li>TextAreaField 多行文本字段</li>
</ul>
<h4 id="wtformsvalidator">WTForms提供的Validator</h4>
<ul>
<li>DataRequired 确保类型转换后字段有数据</li>
<li>Email 验证电子邮箱</li>
<li>EqualTo 比较两个字段的值 常用于比较两次密码是否输入一致</li>
<li>InputRequired 确保类型转换前字段有数据</li>
<li>IPAddress 验证IPv4地址</li>
<li>Length 长度验证</li>
<li>MacAddress 验证MAC地址</li>
<li>NumberRange 数字范围校验</li>
<li>Optional 允许字段没有输入，将跳过其他校验函数</li>
<li>Regexp 正则表达式校验</li>
<li>URL URL校验</li>
<li>UUID UUID校验</li>
<li>AnyOf 输入值在任一可能值中</li>
<li>NoneOf 输入值不在一组可能值中</li>
</ul>
<h3 id="flask-login">flask-login</h3>
<p>flask-login引入进来之后 所有的jinja2模块都支持 <code>current_user</code> 这个变量了。</p>
<p>然后其提供了 <code>login_required</code> 来对url进行权限控制。</p>
<p>具体flask-login的使用请参看官方文档，这里重点讲一下flask-login都做了哪些事情，这个参考资料1说的很好。</p>
<ol>
<li><code>login_user</code> 函数用于登录用户，核心任务就是将用户的id写入flask的session。类似的 <code>logout_user</code> 就是将这个id从session中删除。</li>
<li>渲染jinja2模板的时候，会出现对 flask-login 的 <code>current_user</code> 这个变量的请求。具体就是调用flask-login 的<code>_get_user</code> 函数。<code>_get_user</code> 首先检查session中有没有用户id，没有则返回 <code>AnonymousUser</code> ，有则调用 <code>user_loader</code> 装饰器注册的函数。【这里值得额外一提的是，在python代码那边引用 <code>current_user</code> 返回的不是数据库的User对象，要获得数据库对象需要使用 <code>current_user._get_current_object()</code>】</li>
<li><code>login_required</code> 是对当前的 <code>current_user</code> 的 <code>is_authenticated</code> 方法进行调用，如果True 则通过，False则拒绝。</li>
</ol>
<h2 id="_17">参考资料</h2>
<ol>
<li>Flask Web 开发第二版 米格尔·格林贝格著 安道译</li>
</ol>

            </div>
            <section>
                <div class="col-md-2" style="float:right;font-size:0.9em;">
                    <h4>首发于：</h4>
                    <time pubdate="pubdate" datetime="2019-04-05T00:00:00+08:00">2019年 4月 5日 </time>

                    <h4>最近更新于：</h4>
                    <time datetime="2021-10-28T15:37:48.064564+08:00">2021年 10月 28日 </time>


                    <h4>分类：</h4>
                    <a class="category-link" href="https://a358003542.github.io/categories.html#ji-suan-ji-webkai-fa-dong-tai-wang-zhan-ref">计算机 - Web开发 - 动态网站</a>
                    
                    <h4>标签：</h4>
                    <ul class="list-of-tags tags-in-article">
                        <li><a href="https://a358003542.github.io/tags.html#flask-ref">flask
                                <span>1</span>
</a></li>
                    </ul>

                </div>
            </section>
        </div>
</article>
    </div>
    <div class="col-md-1"></div>

</div>


<div id="push"></div>
<button id="gotop" type="button" class="btn btn-default">
    <span class="glyphicon glyphicon-arrow-up" aria-hidden="true"></span>
</button>

<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a> and updated by <a href="https://github.com/a358003542" title="wanze Home Page">wanze</a></li>
    </ul>
</div>
</footer>

    <script src="https://a358003542.github.io/theme/js/jquery.min.js"></script>
    <script src="https://a358003542.github.io/theme/js/bootstrap.min.js"></script>

    <script src="https://a358003542.github.io/theme/js/moment.min.js"></script>

    <script src="https://a358003542.github.io/theme/js/base.js"></script>



</body>
</html>