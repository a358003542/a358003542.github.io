<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="baidu-site-verification" content="D4VqC4HppC"/>
    <meta name="msvalidate.01" content="55CB117A61A6F8286173763FB18D9625"/>

        <meta name="author" content="cdwanze"/>
        <meta name="copyright" content="cdwanze"/>

        <meta property="og:type" content="article"/>
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="protocol, 物联网, " />

<meta property="og:title" content="SIP协议学习笔记 "/>
<meta property="og:url" content="https://docs.cdwanze.work/articles/SIP-learning-note.html" />
<meta property="og:description" content="前言 SIP协议算是物联网的核心底层基础了，网上有一份关于SIP协议RFC3261的中文翻译版本了，只是翻译质量实在堪忧。本文对于协议的一些核心内容会重新翻译。然后会阅读一些基本的入门教程，然后结合阅读 《SIP Understanding Session Initiation Protocol》这本书籍来对SIP协议做更深入的了解。 有关协议实际内容部分，我会关注最前面的通俗理解部分，但关于协议的具体细节和内容，我的建议还是阅读原英文文档，没有一家翻译是完美的。本文随着作者的学习会继续对SIP协议做深入的学习介绍，只是不敢保证是大而全的。 事务层从何而来 TODO 事务层的初步学习，发现第17节事务层主要讨论了内部机制，比如状态，计时，和传输层的交互，和事务用户的交互，事务层基本上不包含信息处理逻辑，只相当于一个信息周转层。 这里有个基本的问题，事务层从何而来。 下面是学习 Alan B. Johnston SIP Understanding the Session Initiation Protocol 这本书的内容 ，在学习阅读官方协议文档的基础上，选择了某些内容摘记在这里。 一个简单的会话建立例子 Tesla先给Marconi发送INVITE消息 INVITE sip:marconi …" />
<meta property="og:site_name" content="cdwanze的博文" />
<meta property="og:article:author" content="cdwanze" />
<meta property="og:article:published_time" content="2019-08-30T00:00:00+08:00" />
<meta property="" content="2019-08-30T00:00:00+08:00" />
<meta name="twitter:title" content="SIP协议学习笔记 ">
<meta name="twitter:description" content="前言 SIP协议算是物联网的核心底层基础了，网上有一份关于SIP协议RFC3261的中文翻译版本了，只是翻译质量实在堪忧。本文对于协议的一些核心内容会重新翻译。然后会阅读一些基本的入门教程，然后结合阅读 《SIP Understanding Session Initiation Protocol》这本书籍来对SIP协议做更深入的了解。 有关协议实际内容部分，我会关注最前面的通俗理解部分，但关于协议的具体细节和内容，我的建议还是阅读原英文文档，没有一家翻译是完美的。本文随着作者的学习会继续对SIP协议做深入的学习介绍，只是不敢保证是大而全的。 事务层从何而来 TODO 事务层的初步学习，发现第17节事务层主要讨论了内部机制，比如状态，计时，和传输层的交互，和事务用户的交互，事务层基本上不包含信息处理逻辑，只相当于一个信息周转层。 这里有个基本的问题，事务层从何而来。 下面是学习 Alan B. Johnston SIP Understanding the Session Initiation Protocol 这本书的内容 ，在学习阅读官方协议文档的基础上，选择了某些内容摘记在这里。 一个简单的会话建立例子 Tesla先给Marconi发送INVITE消息 INVITE sip:marconi …">

    <title>
SIP协议学习笔记  · cdwanze的博文
</title>


        <link href="https://docs.cdwanze.work/theme/css/font-awesome.css" rel="stylesheet"
              media="screen">
        <link href="https://docs.cdwanze.work/theme/css/bootstrap.min.css" rel="stylesheet"
              media="screen">

            <link rel="stylesheet" type="text/css"
                  href="https://docs.cdwanze.work/theme/css/pygments.css" media="screen">
            <link rel="stylesheet" type="text/css"
                  href="https://docs.cdwanze.work/theme/css/elegant.css" media="screen">
            <link rel="stylesheet" type="text/css"
                  href="https://docs.cdwanze.work/theme/css/custom.css" media="screen">






</head>
<body>

<nav class="navbar">
    <div class="navbar navbar-default" role="navigation">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed"
                    data-toggle="collapse" data-target=".navbar-collapse"
                    aria-expanded="false">
                <span class="sr-only">Navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <a class="navbar-brand" href="https://www.cdwanze.work"><span
                    class=site-name>网站首页</span></a>
        </div>


        <div class="navbar-collapse collapse">
            <form action="https://docs.cdwanze.work/search.html"
                  onsubmit="return validateForm(this.elements['q'].value);"
                  class="navbar-form navbar-left">
                <div class="form-group">
                    <input type="text" name="q" id="tipue_search_input"
                           class="form-control" placeholder="Search..."
                           style="width:430px;">
                </div>
                <button class="btn btn-default" type="submit">搜索</button>
            </form>


            <ul class="nav navbar-nav nav-pills navbar-right">
                <li >
                    <a href="https://docs.cdwanze.work">博文首页</a></li>

                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle"
                           data-toggle="dropdown" role="button"
                           aria-haspopup="true" aria-expanded="false">查找文章<span
                                class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li><a class="slowscroll" href="/categories.html">按分类</a>
                            </li>
                            <li><a class="slowscroll" href="/tags.html">按标签</a>
                            </li>
                        </ul>
                    </li>


                        <li >
                            <a href="https://docs.cdwanze.work/guan-yu-ben-wang-zhan.html">关于本网站</a>
                        </li>
                        <li >
                            <a href="https://docs.cdwanze.work/gong-gao.html">公告</a>
                        </li>
            </ul>


        </div>
    </div>
</nav>


<div class="container-fluid">
    <div class="col-md-1 col-md-1-left"></div>
    <div class="col-md-10">
<article>
<div class="row">
    <header class="page-header col-md-10 col-md-offset-2">
    <h1><a href="https://docs.cdwanze.work/articles/SIP-learning-note.html"> SIP协议学习笔记  </a></h1>
    </header>
</div>

<div class="row">
    <div class="col-md-2 table-of-content">
        <nav>
        <h4>目录</h4>
        <div class="toc">
<ul>
<li><a href="#_1">前言</a></li>
<li><a href="#todo">事务层从何而来 TODO</a></li>
<li><a href="#_2">一个简单的会话建立例子</a></li>
<li><a href="#sip">通过代理建立SIP呼叫例子</a></li>
<li><a href="#sip_1">SIP注册例子</a></li>
<li><a href="#1-sip">1. SIP协议介绍</a></li>
<li><a href="#2-sip">2. SIP协议功能概况</a></li>
<li><a href="#4-sip">4. SIP操作概览</a></li>
<li><a href="#5-sip">5. SIP协议的结构</a></li>
<li><a href="#6">6. 术语解释</a></li>
<li><a href="#7-sip">7. SIP消息</a><ul>
<li><a href="#71">7.1 请求</a></li>
<li><a href="#72">7.2 响应</a></li>
<li><a href="#73">7.3 头字段</a><ul>
<li><a href="#731">7.3.1 头字段的格式</a></li>
<li><a href="#732">7.3.2 头字段分类</a></li>
<li><a href="#733">7.3.3 紧促格式</a></li>
</ul>
</li>
<li><a href="#74">7.4 信息体</a><ul>
<li><a href="#741">7.4.1 信息体类型</a></li>
<li><a href="#742">7.4.2 信息体长度</a></li>
</ul>
</li>
<li><a href="#75">7.5 构造信息体</a></li>
</ul>
</li>
<li><a href="#8-user-agent">8. 一般User Agent行为</a><ul>
<li><a href="#81-uac">8.1 UAC行为</a><ul>
<li><a href="#811">8.1.1 产生请求</a><ul>
<li><a href="#8111-request-uri">8.1.1.1 Request-URI</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#9">9. 取消一个请求</a></li>
<li><a href="#10">10. 注册</a></li>
<li><a href="#11-options">11. OPTIONS方法</a></li>
<li><a href="#12-dialogs">12. Dialogs</a></li>
<li><a href="#13">13. 会话初始化</a></li>
<li><a href="#14">14. 修改已存在的会话</a></li>
<li><a href="#15">15. 终止会话</a></li>
<li><a href="#16">16. 代理总览</a></li>
<li><a href="#17-transcations">17. Transcations</a><ul>
<li><a href="#171-client-transaction">17.1 Client Transaction</a><ul>
<li><a href="#1711-invite-client">17.1.1 INVITE client事务</a><ul>
<li><a href="#17111-invite">17.1.1.1 INVITE事务总览</a></li>
<li><a href="#17112">17.1.1.2 正式描述</a></li>
<li><a href="#17113-ack">17.1.1.3 构建ACK请求</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#172-server-transaction">17.2 Server Transaction</a><ul>
<li><a href="#1721-invite">17.2.1 INVITE服务事务</a></li>
<li><a href="#1722-invite">17.2.2 非INVITE服务事务</a></li>
<li><a href="#1723">17.2.3 匹配请求事务和服务事务</a></li>
<li><a href="#1724">17.2.4 处理传输异常</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#18-transport">18. Transport</a></li>
<li><a href="#19">19. 通用信息组件</a></li>
<li><a href="#20">20. 头字段</a></li>
<li><a href="#21">21. 响应状态码</a></li>
<li><a href="#22-http">22. 使用HTTP认证</a></li>
<li><a href="#23-smime">23. S/MIME</a></li>
<li><a href="#24">24. 样例</a></li>
</ul>
</div>
        </nav>
    </div>
    <div class="col-md-8 article-content">

            
            
<h2 id="_1">前言</h2>
<p>SIP协议算是物联网的核心底层基础了，网上有一份关于SIP协议RFC3261的中文翻译版本了，只是翻译质量实在堪忧。本文对于协议的一些核心内容会重新翻译。然后会阅读一些基本的入门教程，然后结合阅读 《SIP Understanding Session Initiation Protocol》这本书籍来对SIP协议做更深入的了解。</p>
<p>有关协议实际内容部分，我会关注最前面的通俗理解部分，但关于协议的具体细节和内容，我的建议还是阅读原英文文档，没有一家翻译是完美的。本文随着作者的学习会继续对SIP协议做深入的学习介绍，只是不敢保证是大而全的。</p>
<h2 id="todo">事务层从何而来 TODO</h2>
<p>事务层的初步学习，发现第17节事务层主要讨论了内部机制，比如状态，计时，和传输层的交互，和事务用户的交互，事务层基本上不包含信息处理逻辑，只相当于一个信息周转层。</p>
<p>这里有个基本的问题，事务层从何而来。</p>
<hr/>
<p><strong>下面是学习 Alan B. Johnston SIP Understanding the Session Initiation Protocol 这本书的内容 </strong> ，在学习阅读官方协议文档的基础上，选择了某些内容摘记在这里。</p>
<h2 id="_2">一个简单的会话建立例子</h2>
<p><img alt="img" src="https://docs.cdwanze.work/images/sip_example_1.jpg"/></p>
<ol>
<li>Tesla先给Marconi发送INVITE消息</li>
</ol>
<div class="highlight"><pre><span></span>INVITE sip:marconi@radio.org SIP/2.0
Via: SIP/2.0/UDP lab.high-voltage.org:5060;branch=z9hG4bKfw19b 
Max-Forwards: 70
To: G. Marconi &lt;sip:Marconi@radio.org&gt;
From: Nikola Tesla &lt;sip:n.tesla@high-voltage.org&gt;;tag=76341 
Call-ID: 123456789@lab.high-voltage.org
CSeq: 1 INVITE
Subject: About That Power Outage...
Contact: &lt;sip:n.tesla@lab.high-voltage.org&gt;
Content-Type: application/sdp
Content-Length: 158

v=0
o=Tesla 2890844526 2890844526 IN IP4 lab.high-voltage.org 
s=Phone Call
c=IN IP4 100.101.102.103
t=0 0
m=audio 49170 RTP/AVP 0
a=rtpmap:0 PCMU/8000
</pre></div>
<p>关于头字段的的含义解释更多的请参看官方文档对应部分。</p>
<ol>
<li>Marconi给Tesla发送180响应 （To From Call-Id CSeq 都是直接Copy过来的， Via添加了一个received参数）更多响应信息制造细节参看官方文档</li>
</ol>
<div class="highlight"><pre><span></span>SIP/2.0 180 Ringing
Via: SIP/2.0/UDP lab.high-voltage.org:5060;branch=z9hG4bKfw19b
;received=100.101.102.103
To: G. Marconi &lt;sip:marconi@radio.org&gt;;tag=a53e42
From: Nikola Tesla &lt;sip:n.tesla@high-voltage.org&gt;;tag=76341 
Call-ID: 123456789@lab.high-voltage.org
CSeq: 1 INVITE
Contact: &lt;sip:marconi@tower.radio.org&gt;
Content-Length: 0
</pre></div>
<ol>
<li>180响应会被忽略</li>
<li>200响应 （还包含了sdp载体）</li>
</ol>
<div class="highlight"><pre><span></span>SIP/2.0 200 OK
Via: SIP/2.0/UDP lab.high-voltage.org:5060;branch=z9hG4bKfw19b
;received=100.101.102.103
To: G. Marconi &lt;sip:marconi@radio.org&gt;;tag=a53e42
From: Nikola Tesla &lt;sip:n.tesla@high-voltage.org&gt;;tag=76341 
Call-ID: 123456789@lab.high-voltage.org
CSeq: 1 INVITE
Contact: &lt;sip:marconi@tower.radio.org&gt;
Content-Type: application/sdp
Content-Length: 155

v=0
o=Marconi 2890844528 2890844528 IN IP4 tower.radio.org 
s=Phone Call
c=IN IP4 200.201.202.203
t=0 0
m=audio 60000 RTP/AVP 0
a=rtpmap:0 PCMU/8000
</pre></div>
<ol>
<li>T给M发送ACK消息</li>
</ol>
<div class="highlight"><pre><span></span>ACK sip:marconi@tower.radio.org SIP/2.0
Via: SIP/2.0/UDP lab.high-voltage.org:5060;branch=z9hG4bK321g 
Max-Forwards: 70
To: G. Marconi &lt;sip:marconi@radio.org&gt;;tag=a53e42
From: Nikola Tesla &lt;sip:n.tesla@high-voltage.org&gt;;tag=76341 
Call-ID: 123456789@lab.high-voltage.org
CSeq: 1 ACK
Content-Length: 0
</pre></div>
<ol>
<li>实际媒体会话过程</li>
<li>M给T发送BYE消息</li>
</ol>
<div class="highlight"><pre><span></span>BYE sip:n.tesla@lab.high-voltage.org SIP/2.0
Via: SIP/2.0/UDP tower.radio.org:5060;branch=z9hG4bK392kf 
Max-Forwards: 70
To: Nikola Tesla &lt;sip:n.tesla@high-voltage.org&gt;;tag=76341 
From: G. Marconi &lt;sip:marconi@radio.org&gt;;tag=a53e42 
Call-ID: 123456789@lab.high-voltage.org
CSeq: 1 BYE
Content-Length: 0
</pre></div>
<ol>
<li>T给M发送BYE消息的200响应</li>
</ol>
<div class="highlight"><pre><span></span>SIP/2.0 200 OK
Via: SIP/2.0/UDP tower.radio.org:5060;branch=z9hG4bK392kf
;received=200.201.202.203
To: Nikola Tesla &lt;sip:n.tesla@high-voltage.org&gt;;tag=76341 
From: G. Marconi &lt;sip:marconi@radio.org&gt;;tag=a53e42 
Call-ID: 123456789@lab.high-voltage.org
CSeq: 1 BYE
Content-Length: 0
</pre></div>
<p>INVITE方法是SIP协议里面很重要的一个方法，本例子可以说是最核心的SIP协议功能实现了。</p>
<p>关于本例子更多细节请参见官方文档，下面我会补充说明一些东西。</p>
<h2 id="sip">通过代理建立SIP呼叫例子</h2>
<p><img alt="Jietu20190911-114217" src="/Users/beixi/Desktop/Jietu20190911-114217.jpg"/></p>
<h2 id="sip_1">SIP注册例子</h2>
<hr/>
<p><strong>下面是SIP协议官方文档部分。</strong></p>
<h2 id="1-sip">1. SIP协议介绍</h2>
<p>Internet的许多应用都需要建立和管理一个会话，会话在这里的含义是在参与者之间的数据的交换。由于考虑到参与者的实际情况，这些应用的实现往往是很复杂的：用户可能在终端移动，他们可能有多个名字，他们可能使用不同的媒介（比如文本，多媒体，视频，音频等）——有时候都使用。人们创造了很多不同的通讯协议用来携带哪些实时的多媒体会话数据，比如声音，影像，或者文本。本SIP（会话初始协议）和这些协议是合作关系，SIP协议让网络终端（叫做用户代理UserAgent UA）发现彼此并同意哪些他们愿意分享的会话细节。为了能够定位预定的会话参与者，和其他目的，SIP要创建一些网络主机基础设施（叫做代理服务器），通过这些代理服务器，UA能够发送注册、邀请信息到会话中，当然也包括其他请求。SIP是一个轻量级的，多用途的工具，可以用来创建，修改和终止会话，它独立运作于通讯协议之下，不依赖于正要建立的会话类型。</p>
<h2 id="2-sip">2. SIP协议功能概况</h2>
<p>SIP是一个应用层的控制协议，可以用来建立、修改、和终止多媒体会话（或者会议）例如Internet 电话。SIP也可以邀请参与者参加已经存在的会话，比如多方会议。媒体也可以从一个已经存在的会话中添加进来（或删除）。SIP显然也支持名字映射和重定向服务，这个可用于支持个人便携式设备－用户可以对外维护一个唯一的外部标志而不用考虑他们的实际网络地点。</p>
<p>SIP建立和终止多媒体交流，有以下五个方面上的支持：</p>
<p><strong>用户定位</strong>： 检查终端用户的位置，用于通讯。</p>
<p><strong>用户有效性</strong>：检查用户参与会话的意愿程度。</p>
<p><strong>用户能力</strong>：检查媒体和媒体的参数。</p>
<p><strong>建立会话</strong>：”ringing”, 响铃 确立会话参数在呼叫方和被叫方。</p>
<p><strong>会话管理</strong>：包括发送和终止会话，修改会话参数，激活服务等等。</p>
<p>SIP不是要做一个垂直集成的通讯系统。SIP更宁愿做一个组件，可以被其他IETF协议锁使用来构造一个完整的多媒体架构。更具体一点来说，这些协议包括实时数据传输协议（RTP）（RFC 1889）用来传输实时的数据并且提供QoS反馈，实时流协议（RSTP）(RFC 2326)用于控制流媒体的的传输，媒体网关控制协议（MEGACO）(RFC 3015)用来控制到公共电话交换网（PSTN）的网关，还有会话描述协议（SDP）（RFC 2327）用于描述多媒体会话。因此，SIP应该和其他的协议一起工作，才能对终端用户的提供完整的服务。然而SIP协议的基本功能和操作是不依赖这些协议的。</p>
<p>SIP本身并不提供服务，而是提供了一个基础来实现不同的服务。比如，SIP可以定位用户和传输一个封装好的对象到对方的当前位置且如果我们利用这点来通过SDP传输会话的描述，立刻，对方的用户代理可以得到这个会话的参数。如果我们用这个像传输会话描述（SESSION DESCRIPTION SD）一样传输呼叫方的照片，一个”呼叫ID”服务很容易就建立了。这个简单的例子说明了，SIP作为一个基础，可以在其上提供很多不同的服务。</p>
<p>SIP并不提供会议控制服务（比如议席控制或者投票系统），并且并没有建议会议应该那样管理。可以通过在SIP上建立其他的会议控制协议来发起一个会议。由于SIP可以管理参与会议的各方的会话，所以会议可以跨异构的网络，SIP 并不能，也不打算提供任何形式的网络资源预定能力。</p>
<p>安全对于提供的服务来说特别重要。要达到理想的安全程度，SIP提供了一套安全服务，包括防止拒绝服务，认证服务（用户到用户，代理到用户），完整性保证，加密和隐私服务。</p>
<p>SIP可以基于IPV4也可以基于IPV6</p>
<h2 id="4-sip">4. SIP操作概览</h2>
<p>本小节摘自SIP协议，用一个简单的例子介绍了SIP协议的一些基本操作，采用的是tutorial风格而不是那种正式的晦涩难懂的风格，还是值得好好读一下的。</p>
<p>第一个例子演示了SIP的基本功能：寻址一个终端，发送一个意欲交流的信号，协商等下要建立会话的一些会话参数和终止一个已经建立的会话。</p>
<p>下面是一个典型的例子，演示了Alice和bob这两个用户是如何交换SIP信息的。</p>
<div class="highlight"><pre><span></span>            atlanta.com . . .  biloxi.com
          .     proxy            proxy       .          
     .                                           .
  Alice’s . . . . . . . . . . . . . . . . . . . .  Bob’s
 softphone                                       SIP Phone
 |                |                |                |
 | INVITE F1      |                |                |
 |---------------&gt;| INVITE F2      |                |
 | 100 Trying F3  |---------------&gt;| INVITE F4      |
 |&lt;---------------| 100 Trying F5  |---------------&gt;|
 |                |&lt;-------------- | 180 Ringing F6 |
 |                | 180 Ringing F7 |&lt;---------------|
 | 180 Ringing F8 |&lt;---------------| 200 OK F9      |
 |&lt;---------------| 200 OK F10     |&lt;---------------|
 | 200 OK F11     |&lt;---------------|                |
 |&lt;---------------|                |                |
 |                         ACK F12                  |
 |-------------------------------------------------&gt;|
 |                     Media Session                |
 |&lt;================================================&gt;|
 |                         BYE F13                  |
 |&lt;-------------------------------------------------|
 |                      200 OK F14                  |
 |-------------------------------------------------&gt;|
 |                                                  |
</pre></div>
<p>在这个例子中，Alice在PC上使用的他的SIP应用（软体电话softphone）通过互联网去呼叫Bob的SIP phone。同时这个例子还演示了两个SIP代理服务，他们代表Alice和bob来帮助他们建立会话连接。这种典型的安排用专业术语来说就是“SIP trapezoid” （SIP梯形），就是上图的那个带点虚线的几何形状。</p>
<p>Alice呼叫Bob用的是他的SIP标识，一种Uniform Resource Identifier URI ，叫做SIP URI。SIP URI的具体定义在本memo的19.1小节。它和电子邮箱地址有相似的结构，一般会包含用户名和主机名。比如上面这个例子，就是 <code>sip:bob@biloxi.com</code> ，<code>biloxi.com</code> 是Bob的SIP 服务提供者的域名。Alice的SIP URI是 <code>sip:alice@atlanta.com</code> 。Alice可能已经输入了Bob的URI，或者点击了某个超链接，或者点击了某个地址本的入口。SIP当然也提供了加密URI，叫做SIPS URI，比如： <code>sips:bob@biloxi.com</code> 。基于SIPS URI 的呼叫要保证是安全的，信道加密的（即TLS）来用户传输所有SIP信息从呼叫者到某个域名下的被呼叫者。这样，请求安全地发送给了被呼叫者，不过这种安全机制还依赖于被呼叫者的域名策略。</p>
<p>SIP是有点类似于HTTP的那种请求/响应事务模型。每一个事务都包含一个请求（调用了具体某个方法或者说函数）和至少一个服务器那边的响应。在上面这个例子中，事务开始于Alice的软件电话发送了一个INVITE请求到Bob的SIP URI的地址哪里，INVITE这个SIP方法具体来说就是，请求者Alice希望服务器Bob接受自己。INVITE请求一系列的头部字段，头部字段是一些命名了的属性，关于本信息提供了一些额外的信息。比如说一个INVITE请求那里包含一个关于本次call的唯一标识id，目标地地址，Alice的地址和Alice希望与Bob建立会话的类型信息。INVITE信息对应上图的F1可能看起来是这个样子：</p>
<div class="highlight"><pre><span></span> INVITE sip:bob@biloxi.com SIP/2.0
 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bK776asdhds
 Max-Forwards: 70
 To: Bob &lt;sip:bob@biloxi.com&gt;
 From: Alice &lt;sip:alice@atlanta.com&gt;;tag=1928301774
 Call-ID: a84b4c76e66710@pc33.atlanta.com
 CSeq: 314159 INVITE
 Contact: &lt;sip:alice@pc33.atlanta.com&gt;
 Content-Type: application/sdp
 Content-Length: 142
</pre></div>
<p>第一行文本加密信息包含了方法名，下面的行是一系列的头部字段。上面这个例子是最小的需求集了，头部字段简要描述如下：</p>
<ul>
<li>Via 包含一个地址（pc33.atlanta.com）是Alice希望从哪里接受到本请求的响应。然后它还含有一个branch参数来标记了具体本次交互。</li>
<li>To 包含了一个显示名字（Bob）和一个SIP或者SIPS URI（sip:bob@biloxi.com），也就是本次请求的原始目的地。显示名字在RFC 2822中讨论了。</li>
<li>From 也包含了一个显示名字（Alice）和一个SIP或者SIPS URI  (sip:alice@atlanta.com)  ，说明了本次请求的原始起点。后面的header field还有个tag参数，包含一串随机字符串，这是Alice的软体电话加上去的，它被用作标记目的。</li>
<li>Call-ID 包含了用于本次call的一个全局唯一的id标识，由一个随机字符串和软体电话的主机名或者IP地址组成。这种To tag ，From tag和Call-ID的组合定义了SIP中的一种点对点的关系，称作Alice和Bob之间的会话dialog。</li>
<li>CSeq 或者 Command Sequence 包含一个整数值和方法名。CSeq的数值在dialog会话中没有一次新的请求就会增加，这是一个传统的序列数值。</li>
<li>
<p>Contact 包含了一个SIP或者SIPS URI，这表示了要联系Alice的直接方式。通常是由用户名和完整合格域名（FQDN fully qualified domain name）组成。推荐是用FQDN，很多终端系统没有注册域名，所以IP地址也是允许的。Via 头部字段是告诉其他人该往那里发送响应，而Contact 头部字段是告诉其他人那里发送将来的请求。【一个是响应，服务器的常规响应动作；一个是请求，服务器的某些请求动作】</p>
</li>
<li>
<p>Max-Forwards 最大跳跃次数 </p>
</li>
<li>Content-Type </li>
<li>Content-Length</li>
</ul>
<p>SIP的完整头部字段描述信息在本memo的第20小节。</p>
<p>具体会话session的细节，比如说媒体的类型，编码或者取样率，并不是在SIP哪里定义的。而是SIP信息的body本身包含了本会话的描述，具体是以其他的协议的格式来编写的。比如SDP协议，RFC2327，上面的示例中本没有说明，就是被SIP信息携带着的。这可以类比于电子邮箱信息或者web page网页内容被HTTP信息携带着。</p>
<p>因为软体电话不知道Bob的位置或者 biloxi.com 域名SIP服务器的位置，所以软体电话就发送INVITE给SIP服务器，其服务于 Alice 域名，atlanta.com。atlanta.com上的SIP服务器地址可以在Alice的软体电话上配置，或者可以被DHCP发现。</p>
<p>atlanta.com 上的SIP 服务器是一种称为代理服务的SIP 服务器。代理服务器接受SIP 请求然后代表各个请求者去向前分发它们。在上面的例子中，代理服务器接受了INVITE请求，然后回传了一个100（Trying）的响应给Alice的软体电话。100（Tring）响应的意思是INVITE请求已经接受到了，代理正在忙着代表它们去将INVITE请求分发到目的地。SIP 的响应使用三位的数字码，然后后面跟着一段描述文字。响应也包含 From 、To、Call-ID、CSeq和Via（其内的branch参数也一样）——这将使得Alice的软体电话将这个响应和之前发送的INVITE请求相关联。atlanta.com 上的代理服务器定位biloxi.com上的代理服务器，可能通过一系列的DNS查找操作然后找到了biloxi.com域名上的代理服务器。然后，它获取了biloxi.com代理服务器的IP地址，继续向前或者说代理这个INVITE请求到了那儿。在向前发送请求之前，atlanta.com代理服务器会加上一个额外Via头字段 ，其值记录的是本代理服务器的地址（这个INVITE请求已经包含Alice的地址了，在第一个Via那里）。biloxi.com 代理服务器接受这个INVITE请求之后，先响应100（Trying）给atlanta.com代理服务器，说INVITE信息已接受，正在处理中。这个代理服务器会查询数据库，一般叫做寻址服务，里面包含了Bob现在的IP地址。（后面章节我们会看到这个数据库该怎么样填充）biloxi.com代理服务器增加了另外一个Via 头字段，其值是把他自己的IP地址，然后将INVITE请求发送给Bob的SIP电话。</p>
<p>Bob的SIP电话在接受INVITE请求之后，会通知Bob Alice打电话过来了，好让Bob决定是否接听这个Call，也就是Bob的电话响了。Bob的SIP 电话会发送180响应（Ringing）给那两个代理，也就是直接反向返回。每个代理使用Via头字段来决定去向哪里发送响应，然后把顶部它自己的值删除【这里多个Via构成了一种类堆栈结构，取自己的，下面的是要返回的目的地。】。这样，尽管DNS和寻址服务查找在INVITE请求初始化时候是需要的，而180响应到调用者是不需要寻址或者在代理服务器中保持某种状态。此外还有好处，那就是每个代理看到INVITE请求也同样能够看到相应的响应。</p>
<p>当Alice的软体电话接受到180响应时，它会给Alice发送一个消息，或者用一个呼叫返回ringback的音频或者在Alice的屏幕上显示什么信息。</p>
<p>在这个例子中，Bob决定接听这个电话。当他拿起电话听筒，一个200响应就会发出来，表示电话已经接听了。200响应包含了一个信息体，里面有SDP媒体描述信息，是关于这次Bob愿意和Alice之间的建立的会话类型的。作为结果，这里将会有两种SDP消息交换，一种是Alice发送给Bob的，一种是Bob发送给Alice的。这两种消息交换提供了基本的协商能力，它基于简单的SDP提议/回答模型。如果Bob不想接听这个电话，或者正在忙于接听另外一个电话，一个error错误响应将会发送而不是响应正常200，这样将会导致没有媒体会话建立。SIP完整的响应码介绍在第21节。一个200响应可能看起来如下所示，看起来像是Bob发送的：</p>
<div class="highlight"><pre><span></span> Bob sends it out:
 SIP/2.0 200 OK
 Via: SIP/2.0/UDP server10.biloxi.com
 ;branch=z9hG4bKnashds8;received=192.0.2.3
 Via: SIP/2.0/UDP bigbox3.site3.atlanta.com
 ;branch=z9hG4bK77ef4c2312983.1;received=192.0.2.2
 Via: SIP/2.0/UDP pc33.atlanta.com
 ;branch=z9hG4bK776asdhds ;received=192.0.2.1
 To: Bob &lt;sip:bob@biloxi.com&gt;;tag=a6c85cf
 From: Alice &lt;sip:alice@atlanta.com&gt;;tag=1928301774
 Call-ID: a84b4c76e66710@pc33.atlanta.com
 CSeq: 314159 INVITE
 Contact: &lt;sip:bob@192.0.2.4&gt;
 Content-Type: application/sdp
 Content-Length: 131
 (Bob’s SDP not shown)
</pre></div>
<p>第一行包含了响应的状态码（200），然后是原因（OK）。剩下来的行就是头字段域，Via 、To、From、Call-ID和CSeq头字段是直接从INVITE请求上复制的。（这里有三个Via头字段，一个是Alice的软体电话添加的，一个是atlanta.com代理服务器添加的，一个是biloxi.com代理服务器添加的。）Bob的SIP电话在To头字段那里添加了一个tag参数，这个tag将会把两个终端合并为一个dialog对话，这个对话包含所有将来在这个call里面的所有请求和响应。Contact头字段包含URI，Bob可以直接通过这个值来联系。Content-Type和Content-Lenght是说信息体的情况，这里信息体包含了Bob的媒体的SDP信息。</p>
<p>作为上面例子关于DNS和寻址服务的补充，代理服务器可以灵活地“路由决策”，来决定那儿去发送请求。比如说，如果Bob的SIP电话返回了486（Busy here）响应，biloxi.com代理服务器可以将这个INVITE请求代理到Bob的语音信箱服务器哪里。一个代理服务器当然也能够同一时间发送INVITE到多个地址。这种类型的平行搜索叫做forking。</p>
<p>在上面的例子中，200（OK）在两个代理间原路返回，然后被Alice的软体电话接收。这时软体电话就停止ringback音频，然后显示本次拨号已经被接听了。终于，Alice的软体电话发送了一个确认信息，ACK，到Bob的SIP电话哪里已确认接收到了最终回应信号200。在本例中，ACK信号是直接从Alice的软体电话发送到Bob的SIP电话的，绕开了两个代理。这发生了是因为两个终端已经知道彼此的地址了，从Contact头字段上获知的，通过INVITE/200这个信息交换，而这个在INVITEE初始化之前是不知道的。在两个代理上的查找已经不需要了，所以代理们就从本次呼叫流中舍弃了。这完成INVITE/200/ACK 三次握手就是用来建立SIP会话的。更详细的细节在第13节。</p>
<p>Alice的Bob的媒体会话现在开始了，他们发送媒体包使用的是他们之前通过SDP交换同意的格式。一般来说，端对端的媒体包会选用和SIP信令不同的路径。</p>
<p>在本次会话中，不管是Alice还是Bob都可能决定改变本次媒体会话的属性。这通过re-INVITE包含新的媒体描述来完成。re-INVITE在已经存在的对话中，所以其他party知道该修改现有的会话而不是新建一个会话。其他party发送了200同意更改，请求者对200回应了ACK。如果其他party不同意更改，它会发送一个错误响应比如488（Not Accepable Here），这也会受到一个ACK。然后失败的re-INVITE不会导致已经存在的呼叫失败——该会话继续只用之前协商的属性。更多关于会话修改的细节在第14节。</p>
<p>本次呼叫结束，Bob断开了连接，然后产生了一个 BYE 信息。这个 BYE 会直接发送给Alice的软体电话，同样绕开了代理们。Alice确认接收BYE发送了200响应，这将终止本次会话和本次BYE的交互。没有ACK发送，ACK只是作为INVITE请求中对于一个响应的响应而发送。INVITE之所以这样处理的原因等下再讨论，这和SIP的可靠性机制相关，它能接听电话的时间相关和forking相关。因为这些原因，INVITE方法，不同于其他方法，更多关于会话终止的细节在第15节讨论。</p>
<p>第24.2小节描述了本例中的信息的具体细节。</p>
<p>在某些情况下，这对代理们来说可能有用，在SIP信令传输路径中，在会话期间看到终端们之间的所有信息。比如说如果 biloxi.com 代理服务器希望继续存在于SIP信令路径中，越过INVITE的初始化过程。它将在INVITE请求上添加一个要求分发头字段，叫做Record-Route，该头字段包含的URI是本代理的主机名或IP地址。该信息将会被Bob的SIP电话接收（因为Record-Route头字段在200响应中传回去了），然后该信息在本dialog对话期间被Alice的软体电话存储起来。biloxi.com代理服务将会接收然后代理ACK、BYE和对BYE的200（OK）响应。每个代理独立决定去接收后续信息，那些信息将会经过那些选择接收的那些代理。代理使用这个功能通常用于提供mid-call中间人呼叫功能。</p>
<p>注册是SIP协议的另外一个常见的操作。注册是一种方法可以让biloxi.com服务器知道目前Bob的地址。在初始化的时候，Bob的SIP电话会周期性的发送REGISTER信息到biloxi.com的服务器哪里，人们称之为SIP registrar，SIP注册器。REGISTER信息会将Bob的SIP或SIPS URI（sip:bob@biloxi.com）和他当前已经登录进去的机器（是作为一个SIP或SIPS值在Contact头字段哪里传达的）联系起来。注册器在写这种联系，也叫做绑定，到数据库中，叫做寻址服务。这个寻址服务也可被作为biloxi.com域的代理服务。通常，一个域名的注册服务器和该域名的代理服务器是在一起的，SIP服务器的各种不同类型更多是一种逻辑上的区分，而不是物理上的，这点很重要。</p>
<p>Bob并不仅限于在一台设备上注册，比如他在家的SIP电话和在办公室的都是可以注册的。这些信息被存储在寻址服务哪里，然后允许代理去执行不同的搜索来定位Bob。类似的，多个用户也能同时注册在一台设备上。</p>
<p>寻址服务只是一个抽象的概念。它一般包含一些信息允许代理输入一个URI然后获得零个或者很多个的URIs来告诉代理哪里去发送请求。注册就是一种方式来创建这个信息，但不是唯一的方式。任意映射函数可在管理员的酌情考虑下配置之。</p>
<p>最后，在SIP中有个值得一提的很重要的一点，那就是注册用来分发incoming入口SIP请求，但在是否授权outgoing出口请求上并没有扮演任何角色。授权和认证在SIP中被处理，要某是在请求间基于challenge/response机制，或者使用在第26节中讨论的底层方案。</p>
<p>本注册例子的完整的SIP信息细节在第24.1小节。</p>
<p>SIP的另外一些操作，比如查询SIP服务器或者客户端的能力使用的是OPTIONS方法，或者取消一个挂起的请求使用CANCEL方法，将会在后续章节中介绍。</p>
<h2 id="5-sip">5. SIP协议的结构</h2>
<p>SIP是一个分层结构协议，这意味着它的行为可以描述为一些在很大程度上独立的处理过程，每个处理过程彼此之间都是松散耦合的。协议的行为被描述为不同层是为了更好的称述，允许在单节中对某个通用功能的描述横跨多个SIP元素。它并不是要描述一种实现。当我们说某个元素包含某个层，我们通常指的是它很适合在该层上定义一些规则。</p>
<p>本协议定义的一些元素并不是每一个都包含所有层，更进一步来说，SIP的元素都是逻辑元素，不是物理上的，物理上的实现可以选择成为不同的逻辑元素，也许甚至是事务间的基础。</p>
<p>SIP协议最底层是语法和编码。它的编码具体使用一种augmented BNF【可以参看rfc5234对ABNF的描述】，完整的BNF细节在第25节；SIP消息的结构综述在第7节。</p>
<p>第二层是传输层。它定义了在互联网上，一个客户端client如何发送请求和接收响应以及一个服务器server如何接收请求和发送响应。所有的SIP元素都包含传输层。传输层在第18节中描述。</p>
<p>第三层是事务层。事务是SIP协议一个很基本的组件。一个事务是一个请求有客户端事务（通过传输层）发送给服务端事务，伴随着所有关于该请求的响应，由服务端事务发送返回给客户端。事务层处理应用层的重发，请求和响应的匹配以及应用层的timeout。UAC（user agent client）完成的任何任务都是在一系列事务上发生的。关于事务的讨论的在第17节。User agent【UAC UAS】都包含事务层，也包括有状态代理。无状态代理不包含事务层。事务层有一个客户端组件（叫做客户端事务）和一个服务端组件（叫做服务端事务），它们每个都表示一个最终状态机，在构成处理特定的请求中。</p>
<p>在事务层之上那一层叫做事务用户（TU）。每个SIP实体，除了无状态代理，都是一个事务用户。当一个事务希望发送一个请求，它创建了一个客户端事务实例【注意这里关于SIP协议的讨论，在SIP协议实现中将直接作为类和类的实现关系】然后将一个请求传递给它，伴随着目标地的IP地址和端口号和要发送这个请求的传输层【这里实际上就是在描述要传递给客户端事务的参数】。一个事务用户创建了一个客户端事务当然也能够取消它。当一个client客户端取消一个事务时，它请求服务器停止继续处理，将状态返回到本事务初始化之前的状态，然后产生一个error响应到本事务中。这通过CANCEL请求完成，它有自己的事务，然后去引用哪个被取消的事务【第9节】。</p>
<p>SIP元素，UAC，UAS，无状态代理和有状态代理还有注册机，包含一个core来区分它们彼此。这个core就是事务用户，除了无状态代理。UAC和UAS的core的行为取决于方法，对于所有的方法有一些通用规则【第8节】。对于UAC来说，它的规则管理着请求的构建；对于UAS来说，它的规则管理着请求的处理和响应的生成。因为注册过程在SIP中扮演着重要的角色，一个UAS处理REGISTER请求给了一个专门的名字registrar注册机。第10节描述了UAC和UAS在注册方法上的核心行为。第11节描述了UAC和UAS在OPTIONS方法上的核心行为，用于测定UA的能力。</p>
<p>确实其他一些请求是由dialog发送的。一个对话是存在于两个user agent之间持续一段时间的端对端的SIP关系。对话帮助整理信息的顺序然后在user agent 之间正确的将请求分发出去。INVITE方法是唯一的方法在本标准中去建立一个对话。当一个UAC发送一个请求在对话上下文中，它遵守一些基本的UAC规则，具体在第8节讨论，当然也有一些在对话中的请求规则。第12节讨论了对话和描述了这个过程，对于他们的创建和维持。还有对话中如何构建请求。</p>
<p>SIP协议中最重要的方法就是INVITE方法，它用于建立参与者之间的一个session会话。一个session会话是很多参与者，它们之间存在着媒体流，处于交流的目的。第13节讨论了如何初始化一个会话，这是一个或多个SIP对话的结果。第14节讨论了如何表征这些会话，通过对话中的INVITE请求来修改这些会话。后面第15节还讨论了会话如何终止。</p>
<p>第8，10，11，12，13，14，15节整个都在描述UA 核心过程。（第9节描述了取消，这在UA core和代理 core都有用到）。第16节讨论了代理元素，代理帮助在user agent之间分发消息。</p>
<h2 id="6">6. 术语解释</h2>
<ul>
<li>Address-of-Record 有时简称AOR 或者 aor，是一个SIP或SIPS的URI地址 简单来说就是user用户对外的公共地址，寻址服务在注册时会填充这些信息。</li>
<li>Back-to-Back User Agent 简称 B2BUA 是一个逻辑实体它接收一个请求然后行为好像UAS。在决定请求如何应答上，它就像一个UAC，会产生请求，而不是像代理服务器，它维护着对话状态，必须参与到它所建立的的对话中所有发送过来的请求。因为它是一种UAC和UAS的联合，对于它的行为并没有明确的定义。</li>
<li>Call 一个呼叫是一个正式的词语指的是有些交流是发生在对端，通常用于建立多媒体交谈。</li>
<li>Client client客户端是一个网络上的元素指的它发送SIP请求和接收SIP响应。客户端可能不直接和用户交互，UAC和代理都是clients。</li>
<li>Conference 会议是一个多媒体会话包含多个参与者</li>
<li>Core Core对于特定的SIP实体指定了特定的功能，SIP实体比如说有状态代理，无状态代理，user agent和注册机。所有的Core除了无状态代理，都是事务用户。【简单来说就是SIP协议的核心功能组件，SIP的各个实体都要通过Core来确定不同的功能】</li>
<li>Dialog 对话是一个端对端的SIP关系，存在于两个UA之间一段时间。一个对话由SIP消息确立，比如对于一个INVITE请求的200响应。一个对话由Call-ID，local-tag，remote-tag标记。</li>
<li>Downstream 下游 描述了一种信息流向，指的是在一个事务中，请求从UAC流向UAS的方法。</li>
<li>Final Response 该响应将终止一个SIP事务，作为对应的临时响应将不会终止事务。所有的2xx, 3xx, 4xx, 5xx, 6xx响应都是最终响应。</li>
<li>Header 头字段</li>
<li>Header Field</li>
<li>Header Field value</li>
<li>Informational Response 等同于临时响应</li>
<li>Initiator 谁使用INVITE请求初始化了一个会话或对话</li>
<li>Invitation 一个INVITE请求</li>
<li>Invitee 被邀请者</li>
<li>Location Service SIP重定向服务或者代理服务使用寻址服务来获得被呼叫者的可能地址</li>
<li>Loop 指的是一种异常情况，相同的请求经过某个代理之后，又以相同的姿态回到该代理来。</li>
<li>Loose Routing 【TODO 具体含义要等看到代理那节才清楚】一种特殊的懒散路由 该代理按照本协议标准的定义来处理Route头字段。</li>
<li>Message</li>
<li>Method</li>
<li>Outbound Proxy 出站代理</li>
<li>Parallel Search 指的是代理寻址的并行搜索</li>
<li>Provisinal Response 临时响应 1xx是临时响应 其他都是最终响应</li>
<li>Proxy</li>
<li>Recursion 一个客户端在3xx响应上发生递归，它产生了一个新的请求到一个或多个URI上，这些URI中有值在本3xx响应的Contact头字段上。</li>
<li>Redirect Server 重定向服务是一个UAS它产生3xx响应，将它接收到的请求。重定向到其他client上。</li>
<li>Registrar 注册机是一个server接收REGISTER请求，然后将这些信息放入到寻址服务商，便于它进行域名操作。</li>
<li>Regular Transaction 常规事务指的是除了INVITE ACT CANCEL的其他方法的事务。</li>
<li>Request</li>
<li>Response</li>
<li>Ringback</li>
<li>Route Set 寻址集</li>
<li>Server</li>
<li>Sequential Search 指的是代理的顺序搜索</li>
<li>Session 会话</li>
<li>SIP Transaction SIP事务</li>
<li>Spiral 指的是一个请求到了一个代理，然后又回到了该代理的过程，但这次请求状态不同了。Spiral不是一个异常，不像Loop。</li>
<li>Stateful Proxy 有状态代理</li>
<li>Stateless Proxy 无状态代理</li>
<li>Strict Routing 严格路由分发【具体应该要等待代理那节才能理解】</li>
<li>Target Refresh Request 目标刷新请求 指的是一个请求能够修改本对话的远程目标</li>
<li>Transaction User 事务用户</li>
<li>Upstream 上游 类似上面的下游，这里指的是事务中响应流从UAS流向UAC的方向。</li>
<li>UAC</li>
<li>UAC Core</li>
<li>UAS</li>
<li>UAS Core</li>
<li>UA </li>
</ul>
<h2 id="7-sip">7. SIP消息</h2>
<p>SIP是一个基于文本的使用UTF-8编码的协议。</p>
<p>SIP消息要某是一个请求从client到server，要某是一个响应从server到client。</p>
<p>请求和响应信息都使用的是RFC2822定义的基本格式，即使语法从字符集到语法具体规范有所不同。（SIP允许的头字段在RFC2822头字段里面是不合法的）所有类型的信息都由一个start-line，一个或者多个头字段，一个空行标记头字段的结束，一个可选的信息体组成。</p>
<div class="highlight"><pre><span></span><span class="n">generic</span><span class="o">-</span><span class="n">message</span>  <span class="o">=</span>  <span class="k">start</span><span class="o">-</span><span class="n">line</span>
                    <span class="o">*</span><span class="n">message</span><span class="o">-</span><span class="n">header</span>
                     <span class="n">CRLF</span>
                     <span class="p">[</span> <span class="n">message</span><span class="o">-</span><span class="n">body</span> <span class="p">]</span>
<span class="k">start</span><span class="o">-</span><span class="n">line</span>       <span class="o">=</span>  <span class="n">Request</span><span class="o">-</span><span class="n">Line</span> <span class="o">/</span> <span class="n">Status</span><span class="o">-</span><span class="n">Line</span>
</pre></div>
<p>起始行，每个头字段行，空行都必须以 CRLF 符号终止【也就是 <code>\r\n</code>】。注意即时信息体body没有也需要把那个空行加上。</p>
<p>【上面的内容简单看下即可，大概说的就是上面文字描述的意思，然后后面多看点SIP具体信息，大概心里就有数了。其实基本格式上的规范和HTTP协议很相似，也可能他们都属于RFC2822规范吧】</p>
<h3 id="71">7.1 请求</h3>
<p>SIP的请求可以通过有请求行作为第一行来分辨。一个请求行包含一个方法名，一个请求URI，协议版本号，由单个空格(SP)字符分割。</p>
<p>请求行以CRLF结束【这个上面说过了】，然后请求行里面不允许出现 CR 和 LF 字符，除了最后的CRLF。LWS字符在请求行各元素中不允许出现。【LWS linear whitespace 我查了一下，并不是某个特定的键盘按键字符，具体指的是任意数目的空白SP或者制表符】</p>
<div class="highlight"><pre><span></span><span class="n">Request</span><span class="o">-</span><span class="n">Line</span>  <span class="o">=</span>  <span class="k">Method</span> <span class="n">SP</span> <span class="n">Request</span><span class="o">-</span><span class="n">URI</span> <span class="n">SP</span> <span class="n">SIP</span><span class="o">-</span><span class="k">Version</span> <span class="n">CRLF</span>
</pre></div>
<ul>
<li>Method 本协议定义了六个方法：REGISTER INVITE ACK CANCEL BYE OPTIONS 【这里描述有点简化，具体了解各个方法在后面】扩展协议标准可能还定义了额外的方法【比如rfc3428的MESSAGE方法】</li>
<li>Request-URI 请求URI是SIP或者SIPS的URI，具体在第19.1节中描述，或更加通用的URI在RFC2396中。它指出了本请求将要被寻址到哪里，送给某个用户或者服务。Request-URI一定不能包含未转义的空格字符或者control字符，然后一定不能被 <code>&lt;&gt;</code> 包起来。</li>
</ul>
<p>SIP元素可能支持Request-URIs 不是sip或者sips的scheme，比如说RFC2806的 tel URI schem。SIP元素可能将不是SIP URIs 按照它们自己的安排转成SIP URI或者SIPS URI或者其他scheme。</p>
<ul>
<li>SIP-Version 请求和响应都包含一个SIP的版本号，为了考虑版本顺序，便于管理依赖，升级版本数字。服从本协议的应用发送SIP消息应该包含SIP-Version <code>"SIP/2.0"</code> 。SIP-Version字符串是大小写不敏感的，具体实现发送的时候还是一定要大写。</li>
</ul>
<p>不像 <code>HTTP/1.1</code> ，SIP把这版本数字看做一个字面意义上的字符串，实践上，还是应该没有什么区别的。</p>
<h3 id="72">7.2 响应</h3>
<p>SIP响应可以通过有状态行作为第一行来分辨。一个状态行由协议版本号，跟着一个数字状态码和与之相关的文本组成，每个元素彼此用SP符号分割。</p>
<p>CR和LF符号是不允许的，除了最后的CRLF字符。</p>
<div class="highlight"><pre><span></span><span class="n">Status</span><span class="o">-</span><span class="n">Line</span>  <span class="o">=</span>  <span class="n">SIP</span><span class="o">-</span><span class="k">Version</span> <span class="n">SP</span> <span class="n">Status</span><span class="o">-</span><span class="n">Code</span> <span class="n">SP</span> <span class="n">Reason</span><span class="o">-</span><span class="n">Phrase</span> <span class="n">CRLF</span>
</pre></div>
<p>状态码是一个3位的整数结果码，指出了试图理解和满足请求的结果。Reason-Phrase试图给状态码一个简短的文本描述。状态码是准备给自动机用的，Reason-phrase原因文本是准备给人类使用的。客户端并不要求检查或显示原因文本。</p>
<p>本协议对于原因文本建议的具体用语，在实践中可能选择其他文本，比如说使用在请求的Accept-Language头字段中指示的语言。</p>
<p>状态码的第一个数字位定义了响应的类型。最后两位数字并没有分类的作用。因此，任何响应的状态码在100到199之间的都可认为是 1xx 响应。任何响应的状态码在200到299之间的都可认为是2xx 响应，以此类推。SIP/2.0 的第一位数字允许六个值：</p>
<ul>
<li>1xx 临时响应 请求已接收 继续处理中</li>
<li>2xx 成功响应 行为已成功接收，理解和接受。</li>
<li>3xx 重定向响应 需要进一步的行为来完成本请求</li>
<li>4xx 客户端错误 请求包含错误的语法，服务器不能完成本请求</li>
<li>5xx 服务器错误 服务器对于完成这个看起来是有效的请求处理失败了</li>
<li>6xx 全局失败 请求不能在任何服务器上完成</li>
</ul>
<p>第21节定义了这些类型并分别描述了这些状态码。</p>
<h3 id="73">7.3 头字段</h3>
<p>SIP的头字段和HTTP的头字段在语法和语义上都很相似。具体来说SIP头字段遵从H4.2 定义的语法（对于信息头和头字段扩展到多行的规则）然而，多行扩展规则在HTTP是用隐含的空白和折叠folding，本协议遵从的是RFC2234，只使用明确的空白和作为语法集的一部分的折叠。</p>
<p>H4.2 也定义了多个头字段有相同的头字段名时，它们的值是逗号分隔的，能够合并为一个头字段。这在SIP中也是如此，但具体的规则有所不同，因为使用的是不同的语法。具体来说，任何SIP头字段格式使用如下语法是允许通过逗号分隔列表合并为一个头字段，在相同的头字段名下。</p>
<div class="highlight"><pre><span></span><span class="n">header</span>  <span class="o">=</span>  <span class="ss">"header-name"</span> <span class="n">HCOLON</span> <span class="n">header</span><span class="o">-</span><span class="n">value</span> <span class="o">*</span><span class="p">(</span><span class="n">COMMA</span> <span class="n">header</span><span class="o">-</span><span class="n">value</span><span class="p">)</span>
</pre></div>
<p>Contact头字段允许逗号comma分隔列表除非头字段的值是 <code>*</code> 。</p>
<h4 id="731">7.3.1 头字段的格式</h4>
<p>头字段遵从RFC2822第2.2小节给定的通用头字段格式。每个头字段有一个字段名，后面跟着colon冒号，然后是字段值。</p>
<div class="highlight"><pre><span></span><span class="n">field</span><span class="o">-</span><span class="n">name</span><span class="p">:</span> <span class="n">field</span><span class="o">-</span><span class="n">value</span>
</pre></div>
<p>第25节规定的信息头的正式语法是允许冒号两侧有任意数量的空白的，然而，实践中应该避免字段名和冒号之间的空白，然后在冒号和字段值之间用一个SP即可。</p>
<div class="highlight"><pre><span></span><span class="n">Subject</span><span class="o">:</span>      <span class="n">lunch</span>
<span class="n">Subject</span>   <span class="o">:</span>     <span class="n">lunch</span>
<span class="n">Subject</span>       <span class="o">:</span><span class="n">lunch</span>
<span class="n">Subject</span><span class="o">:</span> <span class="n">lunch</span>
</pre></div>
<p>因此，上面的都是有效的和等同的，但最后的是推荐的格式。</p>
<p>头字段能够扩展到多行，额外的行之前至少应该有一个SP或者HT【制表符】。换行和后续行之前的空白会被认为是一个SP字符。因此下面是等同的：</p>
<div class="highlight"><pre><span></span><span class="n">Subject</span><span class="o">:</span> <span class="n">I</span> <span class="n">know</span> <span class="n">you</span><span class="err">’</span><span class="n">re</span> <span class="n">there</span><span class="o">,</span> <span class="n">pick</span> <span class="n">up</span> <span class="n">the</span> <span class="n">phone</span> <span class="n">and</span> <span class="n">talk</span> <span class="n">to</span> <span class="n">me</span><span class="o">!</span>
<span class="n">Subject</span><span class="o">:</span> <span class="n">I</span> <span class="n">know</span> <span class="n">you</span><span class="err">’</span><span class="n">re</span> <span class="n">there</span><span class="o">,</span>
         <span class="n">pick</span> <span class="n">up</span> <span class="n">the</span> <span class="n">phone</span>
         <span class="n">and</span> <span class="n">talk</span> <span class="n">to</span> <span class="n">me</span><span class="o">!</span>
</pre></div>
<p>有不同字段名的头字段之间的相对顺序是不重要的，然而，<strong>推荐</strong> 那些被代理处理需要的头字段（比如 Via Route Record-Route Proxy-Require Max-Forward Proxy-Authorization ）最好出现在信息的顶部，方便快速分析。相同字段名的头字段们的相对顺序是重要的，多个头字段行有着相同的字段名在信息中可能表示当且仅当整个字段值对于该头字段是一个逗号分隔的列表（也就是它遵从第7.3节定义的语法）。它必须可能将多个头字段行组合成为一个 <code>field-name: field-value</code> 对，通过appending操作将后续的field-value到append第一个，用逗号分隔，然后不改变信息的语义。这个规则是由例外的，比如 <code>WWW-Authenticate</code> <code>Authorization</code> <code>Proxy-Authenticate</code> <code>Proxy-Authorization</code> 头字段，这些名字的多个头字段行在信息中，然而因为它们的语法并不遵从第7.3节的基本格式，它们一定不能合并为一个单一的头字段行。</p>
<p>实现必须能够处理多个头字段行有相同头字段名的，不管是单值单行形式，还是逗号分隔值的形式。</p>
<p>如下头字段行组是有效的和等同的：</p>
<div class="highlight"><pre><span></span>Route: &lt;sip:alice@atlanta.com&gt;
Subject: Lunch
Route: &lt;sip:bob@biloxi.com&gt;
Route: &lt;sip:carol@chicago.com&gt;

Route: &lt;sip:alice@atlanta.com&gt;, &lt;sip:bob@biloxi.com&gt;
Route: &lt;sip:carol@chicago.com&gt;
Subject: Lunch

Subject: Lunch
Route: &lt;sip:alice@atlanta.com&gt;, &lt;sip:bob@biloxi.com&gt;,
&lt;sip:carol@chicago.com&gt;
</pre></div>
<p>下面的块是有效的但是并不等同于其他的【看的出来是顺序不同】：</p>
<div class="highlight"><pre><span></span><span class="nl">Route</span><span class="p">:</span><span class="w"> </span><span class="o">&lt;</span><span class="nl">sip</span><span class="p">:</span><span class="n">alice</span><span class="nv">@atlanta</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="w"></span>
<span class="nl">Route</span><span class="p">:</span><span class="w"> </span><span class="o">&lt;</span><span class="nl">sip</span><span class="p">:</span><span class="n">bob</span><span class="nv">@biloxi</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="w"></span>
<span class="nl">Route</span><span class="p">:</span><span class="w"> </span><span class="o">&lt;</span><span class="nl">sip</span><span class="p">:</span><span class="n">carol</span><span class="nv">@chicago</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="w"></span>

<span class="nl">Route</span><span class="p">:</span><span class="w"> </span><span class="o">&lt;</span><span class="nl">sip</span><span class="p">:</span><span class="n">bob</span><span class="nv">@biloxi</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="w"></span>
<span class="nl">Route</span><span class="p">:</span><span class="w"> </span><span class="o">&lt;</span><span class="nl">sip</span><span class="p">:</span><span class="n">alice</span><span class="nv">@atlanta</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="w"></span>
<span class="nl">Route</span><span class="p">:</span><span class="w"> </span><span class="o">&lt;</span><span class="nl">sip</span><span class="p">:</span><span class="n">carol</span><span class="nv">@chicago</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="w"></span>

<span class="nl">Route</span><span class="p">:</span><span class="w"> </span><span class="o">&lt;</span><span class="nl">sip</span><span class="p">:</span><span class="n">alice</span><span class="nv">@atlanta</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="p">,</span><span class="o">&lt;</span><span class="nl">sip</span><span class="p">:</span><span class="n">carol</span><span class="nv">@chicago</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="o">&lt;</span><span class="nl">sip</span><span class="p">:</span><span class="n">bob</span><span class="nv">@biloxi</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="w"></span>
</pre></div>
<p>一个头字段值得格式是由具体某个头字段名来定义的。它总是要某是一个难懂的TEXT-UTF8八进制序列，要某是空白，标记，分隔符和转义字符的组合。很多已经存在的头字段将会依附一种通用形式的值，由分号分隔，后面是一系列的参数名和参数值：</p>
<div class="highlight"><pre><span></span><span class="nt">field-name</span><span class="o">:</span> <span class="nt">field-value</span> <span class="o">*(;</span><span class="nt">parameter-name</span><span class="o">=</span><span class="nt">parameter-value</span><span class="o">)</span>
</pre></div>
<p>尽管任意数目的参数对可以依附在头字段值上，但给定的参数名一定不要出现多于一次。</p>
<p>当比较头字段时，头字段名总是大小写不敏感的。除非在定义中指出某个特定的头字段，头字段名，参数名和参数值是大小写敏感的。Token标记通常是大小写敏感的，除非特别指出。通过双引号表达的字符串是大小写敏感的，比如：</p>
<div class="highlight"><pre><span></span><span class="nl">Contact</span><span class="p">:</span><span class="w"> </span><span class="o">&lt;</span><span class="nl">sip</span><span class="p">:</span><span class="n">alice</span><span class="nv">@atlanta</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="p">;</span><span class="n">expires</span><span class="o">=</span><span class="mi">3600</span><span class="w"></span>
<span class="nl">CONTACT</span><span class="p">:</span><span class="w"> </span><span class="o">&lt;</span><span class="nl">sip</span><span class="p">:</span><span class="n">alice</span><span class="nv">@atlanta</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="p">;</span><span class="n">ExPiReS</span><span class="o">=</span><span class="mi">3600</span><span class="w"></span>
</pre></div>
<p>是相等的。</p>
<div class="highlight"><pre><span></span><span class="nt">Content-Disposition</span><span class="o">:</span> <span class="nt">session</span><span class="o">;</span><span class="nt">handling</span><span class="o">=</span><span class="nt">optional</span>
<span class="nt">content-disposition</span><span class="o">:</span> <span class="nt">Session</span><span class="o">;</span><span class="nt">HANDLING</span><span class="o">=</span><span class="nt">OPTIONAL</span>
</pre></div>
<p>是相等的</p>
<div class="highlight"><pre><span></span><span class="n">Warning</span><span class="o">:</span> <span class="mi">370</span> <span class="n">devnull</span> <span class="s2">"Choose a bigger pipe"</span>
<span class="n">Warning</span><span class="o">:</span> <span class="mi">370</span> <span class="n">devnull</span> <span class="s2">"CHOOSE A BIGGER PIPE"</span>
</pre></div>
<p>是不相等的。</p>
<h4 id="732">7.3.2 头字段分类</h4>
<p>有些头字段只在请求或者响应中才有意义，它们被分别称为请求头字段和响应头字段。如果一个头字段在信息中和它的分类不匹配（比如一个请求头字段在响应中），它 <strong>一定</strong> 要被忽略。第20节对每个头字段的分类进行了讨论。</p>
<h4 id="733">7.3.3 紧促格式</h4>
<p>SIP提供了一种机制去表达常见的头字段名以一种缩写形式。当信息变得很大时，这对于传输层传输信息可能会有用（比如说用UDP的时候超过了MTU最大传输单位）。这些紧促格式在第20节中定义。一个紧促格式可能任何时候去取代一个头字段名的长名格式，而不会更改信息的语义。一个头字段名在相同的信息中即可能是长名格式，也可能是紧促格式。实现一定要同时接收相同头字段名的长名格式和紧促格式。</p>
<h3 id="74">7.4 信息体</h3>
<p>请求，包括本协议的扩展协议定义的请求，可能包含信息体，除非特别说明。具体信息体的解释在各个请求方法哪里，</p>
<p>对于响应信息来说，请求方法和响应状态码决定了它的类型和信息体的解释。所有响应可能包含信息体。</p>
<h4 id="741">7.4.1 信息体类型</h4>
<p>信息体的互联网媒体类型一定要在 Content-Type 头字段中给定。如果信息体经历了编码比如说压缩，那么它一定要在 Content-Encoding 头字段中说明。否则，Content-Encoding 头字段一定要省略。如果合适的话，信息体的字符集可以由Content-Type头字段的某部分值给定。</p>
<p>由RFC2046定义的多部分信息MIME类型可能在信息体中使用。如果远程实现发送的请求Accept头字段并不含有multipart，实现发送请求包含多部分信息体一定要发送一个会话描述，这个会话描述是一个非多部分信息体。</p>
<p>SIP信息可能含有二进制信息体或者部分，当没有明确的字符集参数提供的时，媒体类型中的text类型默认的字符集是UTF-8。</p>
<h4 id="742">7.4.2 信息体长度</h4>
<p>信息体的长度由Content-Length提供（单位bytes）。第20.12描述了这个头字段必要的内容和细节。</p>
<p>chunked 传输编码，HTTP/1.1使用的一定不能用于SIP（chunked编码修改信息体为了把它转换为一系列的chunks，每一个有它自己的size说明）</p>
<h3 id="75">7.5 构造信息体</h3>
<p>不同于HTTP，SIP实现可以使用UDP或其他不可靠的datagram协议。每个datagram携带一个请求或者响应。第18节说了一些不可靠传输的使用上的约束。</p>
<p>实现处理SIP消息在流向传输中一定要忽略开头的任何 CRLF 作为起始行。</p>
<p>Content-Lenght头字段被用户定位本SIP消息在流的结束，它在SIP消息通过流向传输中一定要展示出来。</p>
<h2 id="8-user-agent">8. 一般User Agent行为</h2>
<p>一个user agent代表了一个终端系统。它包含user agent client (UAC)，它产生请求，和一个user agent server（UAS），它响应请求。一个UAC能够产生请求基于一些外部刺激（用户点击按钮或者PSTN行的信号）然后处理响应。一个UAS能够接收请求然后产生响应基于用户的输入，外部刺激，程序的执行结果或者其他机制。</p>
<p>当一个UAC发送请求，请求通过一些代理服务器，这将把请求转发到UAS。当UAS产生了一个响应，响应也会转发到达UAC。</p>
<p>UAC和UAS程序极大地依赖于这两个因素：第一，基于请求和响应是否在或者不在对话里面；第二，基于请求的方法。对话会在第12节详细地讨论，它们表示一种在UA之间的端对端关系，然后通过特定的SIP方法，比如说INVITE，建立起来。</p>
<p>在本节，我们讨论对UAC和UAS行为来说方法独立的规则，处理的这些请求在对话之外。这当然包括那些建立对话的请求。</p>
<p>对于请求和响应的安全过程在对话之外的在第26节描述。具体来说，就是UAC和UAS存在着一种相互认证机制。也支持一种隐私特性有限集通过用S/MIME来对于信息体进行加密。</p>
<h3 id="81-uac">8.1 UAC行为</h3>
<p>本节讲述了UAC在对话之外的行为。</p>
<h4 id="811">8.1.1 产生请求</h4>
<p>一个UAC构造的有效的SIP请求一定，至少，包含以下头字段：To，From，CSeq，Call-ID，Max-Forwards和Via。所有这些头字段在SIP请求中都是强制性的。这六个头字段是SIP消息的基本构成单元，因为它们一起提供了分发服务大部分最重要的信息，包括信息的目标地，分发响应，限制信息扩散，信息排序和事务的唯一标识。这些头字段还要加上必要的请求行，它包含方法，请求URI和SIP版本号。</p>
<p>对话外发送请求的例子，包含INVITE到建立一个会话（第13节），然后一个OPTIONS请求去查询能力（第11节）</p>
<h5 id="8111-request-uri">8.1.1.1 Request-URI</h5>
<h2 id="9">9. 取消一个请求</h2>
<h2 id="10">10. 注册</h2>
<h2 id="11-options">11. OPTIONS方法</h2>
<h2 id="12-dialogs">12. Dialogs</h2>
<p>dialog对话对于user agent 来说是一个很关键的概念，一个对话表达了某个时间内两个user agent之间的端对端的SIP关系。对话帮助排列两个user agent消息顺序，然后是正确的分发他们之间的请求。对话表达的是一种上下文来解释SIP的各个消息。</p>
<h2 id="13">13. 会话初始化</h2>
<h2 id="14">14. 修改已存在的会话</h2>
<h2 id="15">15. 终止会话</h2>
<h2 id="16">16. 代理总览</h2>
<h2 id="17-transcations">17. Transcations</h2>
<p>SIP 是一个事务处理型协议：各个组件之间的交互发生在一系列的独立的信息交换上。更具体来说，一个SIP Transcation 由一个请求和该请求的任何响应组成，这可能包含零个或更多的临时响应和一个或更多的最终响应。就以一个INVITE请求的事务例子来说（即所谓的INVITE事务），该事务也是包含ACK的，只要最终响应不是2xx。如果响应是2xx的话，ACK会认为不是该事务的一部分。</p>
<p>之所以这样区分是基于传输200响应给发送INVITE的UAC是很重要的。把他们都传输给UAC，UAS这边要负责重发他们（第13.3.1.4小节），UAC这边要负责用ACK来确认他们。（第13.2.2.4小节）因为这个ACK只被UAC转发，所以认为这是属于他自己的事务是很有效的。</p>
<p>事务一边是client，另一边是server。client那边被称之为client transaction，server那边被称之为server transaction。client transaction发送请求，server transaction发送响应。client和server transaction都是逻辑函数嵌入到很多元素中。更确切的，他们存在于user agent和stateful代理服务器哪里。考虑第4节的例子，在这个例子中，UAC执行了client 事务，它的outbound proxy 出站代理执行了server事务。出站代理也执行了client事务，因为它发送了请求到入站代理哪里。入站代理哪里也执行了client事务，因为它发送了请求到UAS哪里。具体如下图所示：</p>
<p><img alt="Jietu20190903-182208" src="/Users/beixi/Desktop/Jietu20190903-182208.jpg"/></p>
<p>无状态代理不含client事务和server事务，事务存在于一边是UA或有状态代理和另一边是UA或有状态代理之间。就SIP事务层面上的考虑，无状态代理可以认为是完全透明的。client事务的目的就是接受某个元素上的请求，client事务就封装在该元素上（该元素被称为事务用户 TU，它可以是个UA或者状态代理），然后就是可靠地将请求传输给server事务。</p>
<p>client事务也负责接收响应然后将它们传给事务用户，过滤掉任何重发或不允许的响应（比如说对ACK的响应）。另外，在INVITE请求案例中，client事务负责产生ACK请求，对于任何最终响应是2xx的响应。</p>
<p>类似的，server事务的目的是接收从传输层而来的请求然后传给事务用户。server事务会过滤掉网路中任何重发的请求。server事务接收从事务用户而来的请求然后从传输层将它们发送到网路中。在哪个INVITE事务案例中，它接收ACK请求对于任何最终响应被期待是2xx 响应。</p>
<p>2xx响应和它的ACK接收需要特别对待。它的响应只被UAS重发，而它的ACK只由UAC生成。这种端对端的处理是需要的，这样一个呼叫者知道所有用户都已经接受呼叫了。因为这种特殊的处理，2xx的重发是由UA core处理的，而不是传输层。类似的2xx的ACK请求生成，也是由UA core处理的。在路由上的代理仅仅只是向前分发2xx响应到INVITE请求和它的相关的ACK。</p>
<h3 id="171-client-transaction">17.1 Client Transaction</h3>
<p>client事务通过维护一个状态机来提供它的功能。</p>
<p>事务用户和client事务交流通过一个简单的接口。当事务用户希望初始化一个新的事务，它新建了一个client事务实例，然后将要发送的SIP请求，还有IP地址，端口号和要发送请求的传输层传给client事务实例。client事务开始执行它的状态机。有效的响应通过client事务的将会传给事务用户。</p>
<p>有两种类型的client事务状态机，有事务用户具体的请求方法决定。一个是针对INVITE请求的client事务，这种类型状态机叫做INVITE client事务。另一个处理除了INVITE和ACK之外的请求请求的client事务，这被叫做non-INVITE client事务。对于ACK并没有client事务，如果事务用户希望发送ACK，它会直接将请求发送给传输层。</p>
<p>INVITE事务和其他方法事务不同是因为它的长期间隔。一般对于INVITE来说用户输入是为了一个响应的。长时间的delay延迟期待着发送一个响应要支持三次握手。另一方面，其他方法的氢气球期待着快速完成，因为非INVITE事务依赖于两次握手，事务用户们对于非INVITE请求应该立刻响应。</p>
<h4 id="1711-invite-client">17.1.1 INVITE client事务</h4>
<h5 id="17111-invite">17.1.1.1 INVITE事务总览</h5>
<p>INVITE事务由三次握手组成。client事务发送INVITE，server事务发送响应，然后client事务发送ACK。对于不可靠传输层（比如UDP），client事务重发请求在一个T1时间间隔，然后后面加倍每次重发。T1是 roud-trip time(RTT) 往返时间估计，它默认是500ms。基本上所有的事务计时器，这里描述的都是以T1来进行扩展的，然后改变T1来吻合它们的值。请求在可靠传输层不会重发。在接收1xx响应之后，所有重发都要终止，然后client等待进一步的响应。server事务可以发送额外的1xx响应，它不是可靠地被server事务传输。最终，server事务决定发送最终响应。对于不可靠传输层，响应会周期性重发，对于可靠传输层，它只发送一次。对于每个最终响应，被client事务接收的，client事务会发送一个ACK，发送这个的目的就是对该响应的重发的熄火。</p>
<h5 id="17112">17.1.1.2 正式描述</h5>
<p>具体过程请参见下图：</p>
<p><img alt="Jietu20190916-115417" src="/Users/beixi/Desktop/Jietu20190916-115417.jpg"/></p>
<p>初始态， <code>calling</code> ，在事务用户跟着INVITE请求初始化一个client事务时一定要进入该状态。client事务一定将请求发送给传输层为了传送（第18节）。如果使用的是不可靠传输层，client事务必须启动 timer A，timerA的值是T1。如果是可靠传输层，那么client事务不应该启动timer A（timer A控制请求的重发）。对于任何传输层，client事务一定要启动timer B，timer B的值是64*T1秒（Timer B控制事务超时）</p>
<p>当timer A到时间，client事务一定要重发请求，通过传输层，然后一定要把计时器的值设为2*T1，重发的正式定义是在事务层的上下文中是将之前发送到传输层的消息再一次送给传输层。</p>
<p>当timer A的2*T1秒时间过了，请求一定还要重发（假设client事务还在这个状态【即calling状态】）。这个过程一定要继续下去，这样请求重发的时间间隔是每次发送的两倍。这样的重发只在client事务还在calling状态下进行。</p>
<p>T1的默认值是500ms。T1是client事务和server事务之间的RTT估计。SIP元素可能使用（尽管不推荐）更小的T1值在封闭的私有网络下（不允许通用的互联网连接）。T1可能选择更大的值，这是推荐的如果确知（连接的高延迟）RTT是更大的值。不管T1的值是多少，本节描述的重发的指数级别的后移一定要使用。</p>
<p>在client事务还在calling状态时，当timer B到时间了，client事务一定要通知事务用户 timeout 已经发生了。client事务一定不能产生ACK。64*T1这个值大概等于在不可靠传输层中发送了七次请求的时间。</p>
<p>如果client事务接收了一个临时的响应，此时的状态还是calling，状态将会过渡到proceeding态。在proceeding态，client事务不应该再重发请求了。更进一步，临时响应一定要传给事务用户。任何更进一步的临时响应一定要传递给事务用户当处于proceeding态时。</p>
<p>不管是calling态还是在proceeding态，接收300-699这些状态码一定将会导致client事务过渡到completed态。client事务一定要将接收到的响应传递给事务用户，client事务一定要产生一个ACK请求，即使传输层是可靠地（根据响应构建ACK请求的指导意见参见17.1.1.3节），然后把ACK发送给传输层。ACK一定要发送给相同的地址，端口号，传输层也是原请求发送的那个。client事务应该启动timer D当它进入completed态，timer D的值对于不可靠传输层至少是32秒，对于可靠传输层是0秒。Timer D反映的是服务事务能够在completed态停留的时间，当是不可靠传输层时。这等于INVITE服务事务的timer H时间，它默认是64*T1。然而而，client事务并不知道服务事务那边用的T1时间是多少，所以一个最小的32s被使用而不是基于T1的Timer D。</p>
<div class="highlight"><pre><span></span><span class="nv">Any</span> <span class="nv">retransmissions</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">final</span> <span class="nv">response</span> <span class="nv">that</span> <span class="nv">are</span> <span class="nv">received</span> <span class="k">while</span> <span class="nv">in</span>
<span class="nv">the</span> <span class="s2">"</span><span class="s">Completed</span><span class="s2">"</span> <span class="nv">state</span> <span class="nv">MUST</span> <span class="nv">cause</span> <span class="nv">the</span> <span class="nv">ACK</span> <span class="nv">to</span> <span class="nv">be</span> <span class="nv">re</span><span class="o">-</span><span class="nv">passed</span> <span class="nv">to</span> <span class="nv">the</span>
<span class="nv">transport</span> <span class="nv">layer</span> <span class="k">for</span> <span class="nv">retransmission</span>, <span class="nv">but</span> <span class="nv">the</span> <span class="nv">newly</span> <span class="nv">received</span> <span class="nv">response</span>
<span class="nv">MUST</span> <span class="nv">NOT</span> <span class="nv">be</span> <span class="nv">passed</span> <span class="nv">up</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">TU</span>.  <span class="nv">A</span> <span class="nv">retransmission</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">response</span> <span class="nv">is</span>
<span class="nv">defined</span> <span class="nv">as</span> <span class="nv">any</span> <span class="nv">response</span> <span class="nv">which</span> <span class="nv">would</span> <span class="nv">match</span> <span class="nv">the</span> <span class="nv">same</span> <span class="nv">client</span> <span class="nv">transaction</span>
<span class="nv">based</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">rules</span> <span class="nv">of</span> <span class="nv">Section</span> <span class="mi">17</span>.<span class="mi">1</span>.<span class="mi">3</span>.
</pre></div>
<h5 id="17113-ack">17.1.1.3 构建ACK请求</h5>
<h3 id="172-server-transaction">17.2 Server Transaction</h3>
<h4 id="1721-invite">17.2.1 INVITE服务事务</h4>
<h4 id="1722-invite">17.2.2 非INVITE服务事务</h4>
<h4 id="1723">17.2.3 匹配请求事务和服务事务</h4>
<h4 id="1724">17.2.4 处理传输异常</h4>
<h2 id="18-transport">18. Transport</h2>
<p>传输层负责在网络传输层上实际的传输请求和响应。这包括决定请求和响应的连接的使用，在定向连接传输层中。</p>
<p>传输层负责管理像TCP和SCTP或者TLS在这些协议之上的传输协议的持久连接，也包括哪些被传输层打开的连接。这包括client的Transport和server的Transport打开的连接，所以连接是被client和server传输函数分享的。这些连接按照一个address，port和连接最远端的传输层协议组成的tuple进行索引。当一个连接被传输层打开，索引就设为目标的IP和端口号还有transport。当连接被传输层接受，索引就设为源IP地址，端口号和transport。注意，因为源端口号经常是短暂的，而它也不能被知道它是否是短暂的还是被进程选择的，被传输层接受的连接经常是不复用的。结果就是两个代理在一个peering（端对端）关系中使用的定向传输将会有两个连接在使用，每个都是一个事务初始化在不同的方向。</p>
<h2 id="19">19. 通用信息组件</h2>
<h2 id="20">20. 头字段</h2>
<h2 id="21">21. 响应状态码</h2>
<h2 id="22-http">22. 使用HTTP认证</h2>
<h2 id="23-smime">23. S/MIME</h2>
<h2 id="24">24. 样例</h2>
            
            
            <hr/>

        </div>
        <section>
        <div class="col-md-2" style="float:right;font-size:0.9em;">
            <h4>首发于：</h4>
            <time pubdate="pubdate" datetime="2019-08-30T00:00:00+08:00">2019年 8月 30日 </time>

<h4>最近更新于：</h4>
<time datetime="2019-08-30T00:00:00+08:00">2019年 8月 30日 </time>

            <h4>分类：</h4>
            <a class="category-link" href="https://docs.cdwanze.work/categories.html#wu-lian-wang-ref">物联网</a>
            <h4>标签：</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="https://docs.cdwanze.work/tags.html#protocol-ref">protocol
                    <span>3</span>
</a></li>
            </ul>
        </div>
        </section>
</div>
</article>
    </div>
    <div class="col-md-1"></div>

</div>


<div id="push"></div>


<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a> and updated by <a href="http://www.cdwanze.work" title="cdwanze Home Page">cdwanze</a></li>
    </ul>
</div>
</footer>

        <script src="https://docs.cdwanze.work/theme/js/jquery.min.js"></script>
    <script src="https://docs.cdwanze.work/theme/js/bootstrap.min.js"></script>
    <script>
        function validateForm(query) {
            return (query.length > 0);
        }
    </script>

    <script>
        function adjust_search_width() {
            var w = document.documentElement.clientWidth;
            if ((w > 755) && (w < 975)) {
                plus_width = w - 755;
                $('.navbar-form .form-control').outerWidth(210 + plus_width);
            } else if (w >= 975) {
                $('.navbar-form .form-control').outerWidth(210 + 220);
            } else if (w <= 755) {
                $('.navbar-form .form-control').css('width', '100%')
            }
        }

        $(document).ready(function () {
            adjust_search_width();
        });

        window.onresize = function () {
            adjust_search_width();
        }

    </script>


    



</body>
</html>