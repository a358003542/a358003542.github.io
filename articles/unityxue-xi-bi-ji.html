<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="msvalidate.01" content="55CB117A61A6F8286173763FB18D9625"/>
    <meta name="google-site-verification" content="r5HyVvY-ZSgf7ctpcpK1aWIaEfKJ0dvAE3E9kW3vXgI" />
    <script data-ad-client="ca-pub-5644206261254049" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
        <meta name="author" content="wanze"/>
        <meta name="copyright" content="wanze"/>

        <meta name="description"
              content="开发环境 安装visual studio 选择安装 使用unity的游戏开发 去unity官网下载安装 unity hub 入门功课 新建一个C#脚本 该脚本名字随意，但需要遵守如下规范： 因为该脚本的名字就是类的名字，所以一般开头大写，然后在写法上遵守驼峰规则。 该脚本的名字和里面类的名字一..."/>


<meta name="keywords" content=", 游戏开发, " />

    <title>unity学习笔记  · 万泽的博客
</title>

        <link href="https://a358003542.github.io/theme/css/font-awesome.css" rel="stylesheet"
              media="screen">
        <link href="https://a358003542.github.io/theme/css/bootstrap.min.css" rel="stylesheet"
              media="screen">

        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/pygments.css" media="screen">
        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/elegant.css" media="screen">
        <link rel="stylesheet" type="text/css"
                  href="https://a358003542.github.io/theme/css/base.css" media="screen">




</head>
<body>

<nav class="navbar">
    <div class="navbar navbar-default" role="navigation">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed"
                    data-toggle="collapse" data-target=".navbar-collapse"
                    aria-expanded="false">
                <span class="sr-only">Navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <a class="navbar-brand" href="https://a358003542.github.io/"><span
                    class=site-name>网站首页</span></a>
        </div>


        <div class="navbar-collapse collapse">
            <form action="https://a358003542.github.io/search.html"
                  onsubmit="return validateForm(this.elements['q'].value);"
                  class="navbar-form navbar-left">
                <div class="form-group">
                    <input type="text" name="q" id="tipue_search_input"
                           class="form-control" placeholder="Search..."
                           style="width:430px;">
                </div>
                <button class="btn btn-default" type="submit">搜索</button>
            </form>


            <ul class="nav navbar-nav nav-pills navbar-right">

                <li >
                    <a  href="/archives.html">所有博文</a></li>
                    
                <li ><a href="/categories.html">博文分类</a></li>
                
                <li><a target="_blank" href="https://github.com/a358003542">我的Github</a></li>

                        <li >
                            <a href="https://a358003542.github.io/about.html">关于本网站</a>
                        </li>
            </ul>


        </div>
    </div>
</nav>


<div class="container-fluid">
    <div class="col-md-1 col-md-1-left"></div>
    <div class="col-md-10">
<article>
<div class="row">
    <header class="page-header col-md-10 col-md-offset-2">
    <h1><a href="https://a358003542.github.io/articles/unityxue-xi-bi-ji.html"> unity学习笔记  </a></h1>
    </header>
</div>

<div class="row">
    <div class="col-md-2 table-of-content">
        <nav>
        <h4>目录</h4>
        <div class="toc">
<ul>
<li><a href="#_1">开发环境</a></li>
<li><a href="#_2">入门功课</a><ul>
<li><a href="#c">新建一个C#脚本</a></li>
<li><a href="#visual-studio">双击脚本自动打开visual studio</a></li>
<li><a href="#_3">将脚本作为组件挂在摄像头上</a></li>
<li><a href="#debug">入门Debug</a></li>
</ul>
</li>
<li><a href="#unity-editor">Unity Editor的使用</a><ul>
<li><a href="#_4">预制件</a></li>
<li><a href="#perfab">解压缩Perfab</a></li>
<li><a href="#1">练习题1</a></li>
<li><a href="#_5">通过代码实例化预制件</a></li>
<li><a href="#_6">如何将某个摄像头调到当前视角</a></li>
</ul>
</li>
<li><a href="#blenderunity">blender和unity的协作</a><ul>
<li><a href="#blender">blender建模</a></li>
<li><a href="#blender_1">blender动画</a></li>
</ul>
</li>
<li><a href="#_7">输入</a><ul>
<li><a href="#input-system">input system</a><ul>
<li><a href="#_8">读取值</a></li>
<li><a href="#_9">判断本帧某个键位是否按下了</a></li>
</ul>
</li>
<li><a href="#inputmouseposition">Input.mousePosition</a></li>
</ul>
</li>
<li><a href="#_10">物理系统</a><ul>
<li><a href="#_11">碰撞器</a><ul>
<li><a href="#_12">碰撞器组件的是否是触发器属性</a></li>
</ul>
</li>
<li><a href="#_13">网格碰撞器</a></li>
<li><a href="#_14">物理材质</a></li>
<li><a href="#_15">触发器</a><ul>
<li><a href="#ontriggerenteroncollisionenter">OnTriggerEnter和OnCollisionEnter</a></li>
</ul>
</li>
<li><a href="#character-controller">Character Controller组件</a><ul>
<li><a href="#isgrounded">isGrounded</a></li>
</ul>
</li>
<li><a href="#raycast">RayCast方法</a></li>
<li><a href="#physicscheckcapsule">Physics.CheckCapsule</a></li>
<li><a href="#_16">图层</a><ul>
<li><a href="#_17">摄像机的剔除遮罩属性</a></li>
<li><a href="#_18">物理系统的图层碰撞矩阵</a></li>
</ul>
</li>
<li><a href="#_19">刚体</a><ul>
<li><a href="#iskinematic">isKinematic</a></li>
<li><a href="#continuous-collision-detection">Continuous Collision Detection</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_20">序列化</a><ul>
<li><a href="#serializefield">SerializeField</a></li>
<li><a href="#scriptableobject">ScriptableObject</a><ul>
<li><a href="#scriptableobject_1">ScriptableObject的唯一性</a></li>
<li><a href="#scriptableobject_2">创建一个ScriptableObject对象</a></li>
</ul>
</li>
<li><a href="#nonserialized">NonSerialized</a></li>
</ul>
</li>
<li><a href="#unity">Unity协程</a><ul>
<li><a href="#unity_1">嵌套Unity协程</a></li>
<li><a href="#unity_2">平行Unity协程</a></li>
</ul>
</li>
<li><a href="#_21">摄像机</a><ul>
<li><a href="#_22">多个摄像机</a></li>
<li><a href="#cameramain">Camera.main</a></li>
<li><a href="#camerascreenpointtoray">Camera.ScreenPointToRay</a></li>
<li><a href="#_23">分屏显示</a></li>
<li><a href="#viewporttoworldpoint">viewportToWorldPoint</a></li>
<li><a href="#cinemachine">cinemachine</a></li>
</ul>
</li>
<li><a href="#_24">脚本</a><ul>
<li><a href="#gameobject">GameObject</a><ul>
<li><a href="#getcomponent">GetComponent方法</a></li>
<li><a href="#_25">引用其他脚本组件</a></li>
<li><a href="#find">Find方法</a><ul>
<li><a href="#_26">更推荐的做法</a></li>
</ul>
</li>
<li><a href="#transform">transform的层级树</a></li>
<li><a href="#findwithtag">FindWithTag方法</a></li>
<li><a href="#sendmessage">SendMessage方法</a></li>
</ul>
</li>
<li><a href="#gameobject_1">常驻GameObject</a><ul>
<li><a href="#dontdestroyonload">DontDestroyOnLoad</a></li>
</ul>
</li>
<li><a href="#updatefixedupdate">Update和FixedUpdate</a></li>
<li><a href="#awakestart">Awake和Start</a></li>
<li><a href="#headerattribute">HeaderAttribute</a></li>
<li><a href="#textareaattribute">TextAreaAttribute</a></li>
<li><a href="#tooltip">Tooltip</a></li>
<li><a href="#transformtransformpoint">Transform.TransformPoint</a></li>
</ul>
</li>
<li><a href="#unity-addressable-asset-system">Unity Addressable Asset system</a><ul>
<li><a href="#_27">异步加载你的场景</a></li>
<li><a href="#buildbuild">build发布前记得运行下build</a></li>
</ul>
</li>
<li><a href="#_28">四元数和欧拉角度</a><ul>
<li><a href="#quaternionangleaxis">Quaternion.AngleAxis</a></li>
</ul>
</li>
<li><a href="#unity_3">基于事件驱动的Unity编程</a><ul>
<li><a href="#_29">事件驱动编程</a></li>
<li><a href="#_30">单例模式示例</a></li>
<li><a href="#_31">和组件绑定的事件</a></li>
<li><a href="#unityaction">UnityAction</a></li>
<li><a href="#unityevent">UnityEvent</a></li>
</ul>
</li>
<li><a href="#ui">UI</a><ul>
<li><a href="#canvas">Canvas</a><ul>
<li><a href="#_32">画布渲染模式</a></li>
</ul>
</li>
<li><a href="#sprite">sprite文件</a></li>
</ul>
</li>
<li><a href="#_33">导航系统</a><ul>
<li><a href="#agent">如何移动一个Agent</a></li>
<li><a href="#_34">巡逻模式</a></li>
<li><a href="#_35">烘焙的时候选择高度网格</a></li>
<li><a href="#navmesh-surface">NavMesh Surface</a></li>
</ul>
</li>
<li><a href="#_36">动画</a><ul>
<li><a href="#_37">新建动画</a></li>
<li><a href="#_38">导入模型动画时的可选配置</a></li>
<li><a href="#animator">Animator组件</a><ul>
<li><a href="#_39">动画状态判断</a></li>
<li><a href="#_40">标签</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_41">材质</a><ul>
<li><a href="#standard">standard着色器</a><ul>
<li><a href="#albedo">albedo</a></li>
<li><a href="#metallic">metallic</a></li>
<li><a href="#smoothness">Smoothness</a></li>
<li><a href="#tiling">tiling</a></li>
<li><a href="#offset">offset</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_42">光源</a></li>
<li><a href="#_43">粒子系统</a><ul>
<li><a href="#_44">新建一个粒子系统</a></li>
<li><a href="#_45">默认模块</a></li>
<li><a href="#_46">发射模块</a></li>
<li><a href="#_47">形状模块</a></li>
</ul>
</li>
<li><a href="#_48">开始菜单</a></li>
<li><a href="#_49">多场景无缝切换</a></li>
<li><a href="#respawn">respawn玩家角色</a></li>
<li><a href="#_50">单元测试</a></li>
<li><a href="#_51">雾效</a></li>
<li><a href="#skybox">skybox</a></li>
<li><a href="#_52">日志</a></li>
<li><a href="#_53">其他</a><ul>
<li><a href="#unityc">查看你使用的Unity的C#版本</a></li>
<li><a href="#visual-studio_1">visual studio快速方法输入</a></li>
<li><a href="#requirecomponent">RequireComponent</a></li>
<li><a href="#_54">默认单位</a></li>
<li><a href="#_55">平台相关编译代码</a></li>
</ul>
</li>
<li><a href="#_56">备用</a><ul>
<li><a href="#_57">移动控制</a></li>
<li><a href="#transformtranslaterigidbodymoveposition">transform.Translate和Rigidbody.MovePosition</a></li>
<li><a href="#_58">地形绘制纹理</a></li>
<li><a href="#fmod">FMOD音效集成</a></li>
<li><a href="#makehuman">Makehuman工具</a></li>
</ul>
</li>
</ul>
</div>
        </nav>
    </div>
    <div class="col-md-8 article-content">

            
<h2 id="_1">开发环境</h2>
<ol>
<li>安装visual studio</li>
<li>选择安装 <code>使用unity的游戏开发</code></li>
<li>去unity官网下载安装 <code>unity hub</code></li>
</ol>
<h2 id="_2">入门功课</h2>
<h3 id="c">新建一个C#脚本</h3>
<p>该脚本名字随意，但需要遵守如下规范：</p>
<ol>
<li>因为该脚本的名字就是类的名字，所以一般开头大写，然后在写法上遵守驼峰规则。</li>
<li>该脚本的名字和里面类的名字一致。</li>
</ol>
<h3 id="visual-studio">双击脚本自动打开visual studio</h3>
<p>可能已经设置好了，如果没有设置好，可以去 <code>Edit-&gt;首选项-&gt;外部工具-&gt;外部脚本编辑器</code> 那里设置。</p>
<p>设置好了就可以双击打开visual studio了。</p>
<h3 id="_3">将脚本作为组件挂在摄像头上</h3>
<p>记得visual studio那边修改名字之后要保存下，然后点击摄像头，添加组件，选择脚本。</p>
<h3 id="debug">入门Debug</h3>
<p>你的脚本类需要继承自 <code>MonoBehaviour</code> ，这样unity才能知道那个是一个脚本类。</p>
<p>Start方法每个组件游戏开始时就会执行，在这个方法里面写上这样的Debug语句：</p>
<div class="highlight"><pre><span></span><code>    void Start()
    {
        Debug.Log("hello world!");
    }
</code></pre></div>
<p>保存运行游戏，如果没有问题的话，你在控制台那边应该看到一个hello world的消息。入门第一课算是完成了。</p>
<p>加分项，熟悉下面的LogFormat方法的用法，以后某些情况会很方便的。</p>
<div class="highlight"><pre><span></span><code>Debug.LogFormat("{0} + {1} = {2}", 2,3,2+3);
</code></pre></div>
<h2 id="unity-editor">Unity Editor的使用</h2>
<p>关于Unity Editor的基本使用请读者自行熟悉软件界面，然后试着自己慢慢搭建起，比如一个平面作为一个基本的游玩空间，平面由四面墙围起来，然后等等其他立方体等等。移动缩放旋转和复制等等。</p>
<p>推荐是找个相关的入门视频看看，当然喜欢自己摸索的多接触接触也就可以了。</p>
<h3 id="_4">预制件</h3>
<p>预制件Perfab非常的有用，可以说是Unity开发里面很重要的一个核心概念了。可以将Perfab理解为编程中的类，而场景中的各个对象在没有perfab之前属于游离的实例，在创建perfab之后才真正可以称之为根据某个perfab类在场景中创建的实例。所以一般来说Unity开发中场景的大部分GameObject都应该perfab化。</p>
<p>嵌套预制件，多个perfab形成嵌套关系并没有改变原perfab和场景中实例间的继承关系。</p>
<p>预制件变体，你可以根据某个perfab来创建某个预制件变体，这些预制件变体更类似于类的继承关系，比如你改变原预制件的某个属性，之后创建的预制件变体的某个属性也会对应发生更改。【变种属性应该继续保持原有的继承更改关系。】</p>
<p><strong>需要注意的是在项目间重复使用，Perfab和Perfab之间和各个资产之间的引用关系必须是一致的，也就是原Asset资产的文件夹层次是保持一致的。</strong></p>
<h3 id="perfab">解压缩Perfab</h3>
<p>是由原场景中GameObject转成Perfab的反向操作，也就是该GameObject成为一个常规的GameObject了。</p>
<h3 id="1">练习题1</h3>
<p>请读者随便新建一个场景，新建一个平面，然后在该平面的两角放置两个立方体，两个立方体是根据一个立方体预制件perfab而来，然后将该立方体拖动为平面的子辈。然后将平面预制件化。然后再根据该平面预制件再新建一个平面。</p>
<p>经过试验我们可以发现，嵌套预制件也有一种继承层次在里面。</p>
<p>比如现在假设立方体盒子的基色是橙色，那么最开始两个平面的所有盒子都是橙色材质。然后现在修改平面预制件里面的右边的盒子颜色为紫色材质。继而出来后会发现两个平面的右边的盒子都变为了紫色。</p>
<p>再继而修改场景中具体某个平面的右边的盒子材质为红色，继而我们发现只有该盒子变为了红色材质。</p>
<p>这个显示结果是符合大家预期的，但这里更深入的是需要理解嵌套预制件的属性继承关系。</p>
<p>以最左角的盒子为例子，它的材质属性场景中没有修改，再继而去找平面的预制件，然后平面预制件也没有修改，再继而去找立方体盒子预制件，最终该盒子的材质属性等于原立方体盒子预制件的属性。</p>
<p>以第二个盒子为例子，它的材质场景中没有修改，平面预制件中修改为了紫色，所以该盒子的材质为紫色。</p>
<p>简单点来说，各个GameObject中的属性查找是：场景中的修改 &gt; 预制件中的属性修改 &gt; 嵌套预制件中的属性。</p>
<h3 id="_5">通过代码实例化预制件</h3>
<div class="highlight"><pre><span></span><code>Instantiate(GameObject perfab);
</code></pre></div>
<p>最常见的例子就是发射子弹或者射弓箭，子弹一开始没有在场景中，然后需要合适的时候再实例化子弹预制件。</p>
<p>该函数还可以接受几个可选参数，用来控制新生成实例的位置，转向和parent属性：</p>
<div class="highlight"><pre><span></span><code>public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent);
</code></pre></div>
<h3 id="_6">如何将某个摄像头调到当前视角</h3>
<p>首先在编辑器上调整好开发者视角，然后选中某个摄像头，然后选择 <code>游戏对象-&gt; align with view</code> 。</p>
<h2 id="blenderunity">blender和unity的协作</h2>
<p>虽然Unity的ProBuilder和PloyBrush提供了一定的模型建立和地形构建的能力，但这主要还是用于原型开发，一般建模当然还是推荐在blender上完成，然后可能Unity的terrian地形工具搭建某些简单的地形有用，不过就成熟的项目来说地形构建也推荐是通过blender建模来实现。</p>
<p>首先Unity的地形工具是有局限性的，某些封闭的如洞穴场景或者如同minecraft需要和地形的元素进行交互的场景是不应该使用Unity的terrian地形工具的，而应该通过blender建模来导入到Unity场景中来。其次即使是那些似乎看起来Unity地形工具勉强能够应付的场景，如果后续对地形在表现细节上有更多的要求，那么也应该通过blender建模来实现。</p>
<h3 id="blender">blender建模</h3>
<p>blender建模导入Unity下面说一下基本的流程思路，可能有时会有一些细节上的问题。</p>
<ol>
<li>按A全选你想要导出的元素，主要是网格体和骨架。选择导出到FBX，然后选择网格体，如果有骨骼的话也推荐将骨架选上。然后导出。</li>
<li>将FBX文件移动到你的Unity项目中，Unity会自动检测导入，但一般来说你还需要对模型导入配置参数进行一些调整。比如材质，比如如果是人形模型，而你希望根据该人形模型构建动画还需要自动创建Avatar。</li>
<li>FBX模型最好是另外单独一个地方存放，导入的模型参数配置好之后，拖入场景，然后拖动制成Perfab预制件，然后解压缩预制件，再对该预制件进行一些你想要的修改，比如有的加上碰撞器和行为脚本之类的。在更新预制件。</li>
</ol>
<h3 id="blender_1">blender动画</h3>
<p>blender里面的动画导出到Unity也是类似上面的导出FBX，实际上就是导出的你的模型的骨架的一些移动变换数据，然后Unity接受成为动画Clips。</p>
<ol>
<li>按A全选你想要导出的元素，主要是网格体和骨架。选择导出到FBX，然后选择骨架，和导出一般模型不同，如果你只希望导出动画的话这里只选择骨架即可。</li>
<li>FBX动画文件导入Unity项目中，然后对动画Animation这一栏一些参数做出一些调配，还有Avatar选择Copy from之前本模型创建的那个Avatar。</li>
</ol>
<p>个人测试相同的人形模型差异不太大的话即使是原来不同的Avatar动画文件里面的内容也是可以复制，大体可以参考的。这一块主要是动画姿态的不匹配问题，如果是自己很粗略弄的动画反倒是泛用性会很强，而那些动捕或者调配的很好的姿态，泛用性会很差，比如一个女性角色的走路姿态套用到一个男性角色上然后出来的效果你懂的。</p>
<p>简单的Unity动画就在Unity那边编辑即可，但有些动画文件很复杂，而Unity那边的动画文件编辑功能并不是很强大，可能还是要继续再blender那边修改之后再应用到Unity那边。</p>
<p>最后提醒一点blender那边的骨架的各个名字最好先就定义好，从blender到unity预制件这条线路各个骨架的名字基本上不会再修改了，修改只会造成各种麻烦。</p>
<h2 id="_7">输入</h2>
<h3 id="input-system">input system</h3>
<p>new unity input system 更多地多设备输入兼容。文档在 <a href="[Installation guide | Input System | 1.1.0-preview.3 (unity3d.com)](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/manual/Installation.html)">这里</a> 。</p>
<p>激活新的输入系统： <code>Edit-&gt;Project settings-&gt;Player-&gt; Active Input Handling</code> 。</p>
<p>添加Player Input 组件</p>
<p>编写Action输入键位绑定</p>
<p>如果设置的是Send Message，则假设有Move Action，则对应该GameObject的<code>OnMove</code> 方法，Move发送的是一个Vector2值。x对应的是该GameObject Right方向上的位移，y对应的是该GameObject forward方向上的位移，有一个中间值(0.7,0.7) ，是45度的方向，你可以简单理解为right方向移动了0.7个单位，forward方向移动了0.7个单位，0.7这个数字的含义表示目标方向的移动长度还是大约1个单位。</p>
<p>另外一个是单键位绑定，返回的是float值，1表示键位触发。</p>
<p>如果设置的是InVoke Unity Events，则需要下面写上对应Action的回调方法，似乎InVoke Unity Events功能更强大一些，其支持对按键动作多种状态的判断。</p>
<div class="highlight"><pre><span></span><code>    <span class="k">public</span> <span class="k">void</span> <span class="nf">OnFire</span><span class="p">(</span><span class="n">InputAction</span><span class="p">.</span><span class="n">CallbackContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">phase</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">case</span> <span class="n">InputActionPhase</span><span class="p">.</span><span class="n">Performed</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">interaction</span> <span class="k">is</span> <span class="n">SlowTapInteraction</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">StartCoroutine</span><span class="p">(</span><span class="n">BurstFire</span><span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">context</span><span class="p">.</span><span class="n">duration</span> <span class="p">*</span> <span class="n">burstSpeed</span><span class="p">)));</span>
                <span class="p">}</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="n">Fire</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="n">m_Charging</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="k">case</span> <span class="n">InputActionPhase</span><span class="p">.</span><span class="n">Started</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">interaction</span> <span class="k">is</span> <span class="n">SlowTapInteraction</span><span class="p">)</span>
                    <span class="n">m_Charging</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="k">case</span> <span class="n">InputActionPhase</span><span class="p">.</span><span class="n">Canceled</span><span class="p">:</span>
                <span class="n">m_Charging</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>上面Started最先触发，然后再触发Performed。如果你的context设置了SlowTapInteraction也就是一定时间的按键判断等，这块后面再详细了解。</p>
<p><strong>NOTICE:</strong>  详细阅读上面的case判断，如果不加上case判断，一般的行为会触发三次，一次started = 1，一次performed = 1，一次canceld = 0。 </p>
<h4 id="_8">读取值</h4>
<p>上面started，performed和canceld只是针对更复杂的按键情况，如果只是一般的使用则如下读取值然后大致类似传统输入系统那样去做即可。</p>
<p>首先Move和Look读取Vector2的值：</p>
<div class="highlight"><pre><span></span><code>Vector2 m_Movement = context.ReadValue&lt;Vector2&gt;();
</code></pre></div>
<p>然后对于一般按键值读取为bool值：</p>
<div class="highlight"><pre><span></span><code>bool m_Attack = context.ReadValueAsButton();
</code></pre></div>
<p>按照传统输入系统的方法读取值会在Update方法那边编写，现在在回调方法上对应地如上写上读取值之后，就类似传统输入在Update方法那里获取到目标值了，然后后面的都是类似的了。</p>
<h4 id="_9">判断本帧某个键位是否按下了</h4>
<p>这个键位判断不需要去设置Actions的配置对于任何按键都可以如下直接去判断。</p>
<div class="highlight"><pre><span></span><code>  Keyboard.current.space.wasPressedThisFrame
</code></pre></div>
<h3 id="inputmouseposition">Input.mousePosition</h3>
<p>获取当前鼠标在屏幕上的坐标，返回一个Vector3值，z值总为0，x和y都等于0时表示左下角，右上角是 <code>(Screen.width, Screen.height)</code> 。</p>
<h2 id="_10">物理系统</h2>
<h3 id="_11">碰撞器</h3>
<h4 id="_12">碰撞器组件的是否是触发器属性</h4>
<p>默认是否，如果勾选，则该碰撞器不具有物体碰撞功能而只有碰撞事件触发功能，也就是你可以穿模进去了。比如某些液体就可以勾选这个选项这样玩家既可以进入该液体同时也可以跟踪玩家进入该液体的事件。</p>
<h3 id="_13">网格碰撞器</h3>
<p>网格碰撞器虽然对物体边界的模拟虽然更精细了，但一般都不推荐使用，因为它非常的消耗性能。我们看到即使是最常见的玩家角色，角色控制器组件也只是简单用一个胶囊碰撞器进行了碰撞模拟。</p>
<h3 id="_14">物理材质</h3>
<p>碰撞器的那个材质属性是来设置物理材质用的，物理材质可以通过新建物理材质来创建。</p>
<ul>
<li>dynamic friction 动态摩擦</li>
<li>static friction 静态摩擦</li>
<li>bounciness 反弹力 0不反弹，1没有动量损失</li>
<li>Friction Combine 摩擦力如何组合，取最小值，取最大值或者取平均值</li>
<li>Friction Combine 反弹力如何组合，取最小值，取最大值或者取平均值</li>
</ul>
<h3 id="_15">触发器</h3>
<p>触发器如果被满足条件的碰撞器发生碰撞则会调用下面三个方法：</p>
<div class="highlight"><pre><span></span><code>OnTriggerEnter(Collider other)
OnTriggerStay(Collider other)
OnTriggerExit(Collider other)
</code></pre></div>
<h4 id="ontriggerenteroncollisionenter">OnTriggerEnter和OnCollisionEnter</h4>
<p>OnTriggerEnter 的触发条件是：</p>
<ul>
<li>两个GameObject都有碰撞器组件，其中某个GameObject的碰撞器必须勾选了<code>isTrigger</code> ，其中某个GameObject必须刚体组件。但是如果两个碰撞器都勾选了 <code>isTrigger</code> ，也不会触发。</li>
<li>然后就是两个碰撞器发生碰撞则会触发事件。</li>
</ul>
<p>OnCollisionEnter的触发条件较为宽松，两个GameObject的碰撞器或者刚体发生碰撞则会触发。</p>
<p>个人编写了一个测试场景，OnTriggerEnter的触发情况确实如上所述，还必须要求某个GameObject有刚体组件。</p>
<p>但是我碰到了这样一种情况，那就是基于Unity Standard Assets的FPSController和另外一个单纯的平面trigger进行交互，两个都没有刚体也出发了OnTriggerEnter方法，<strong>经过个人试探 Unity2019.4.19f1c1这边的情况是Chatacter Controller和随便一个trigger发生碰撞就会触发OnTriggerEnter方法，并没有刚体的要求</strong>。</p>
<h3 id="character-controller">Character Controller组件</h3>
<p>一般第一人称或第三人称角色控制玩家会需要更灵活地控制角色，这种情况下玩家角色如果加入物理系统的刚体会有一种操作上的不顺畅感，但此时仍然希望保留碰撞的物理效果，可以加入Character Controller组件来实现这点。</p>
<p>我们看到角色控制器下面有三个参数：center控制胶囊碰撞体的中心位置，半径控制胶囊碰撞体的宽度，height控制胶囊碰撞体的高度。大体可以猜到角色控制器就是通过这个胶囊碰撞体来和环境交互的。</p>
<h4 id="isgrounded">isGrounded</h4>
<p>本角色控制器组件在上一次移动中是否接触到了地面。</p>
<h3 id="raycast">RayCast方法</h3>
<div class="highlight"><pre><span></span><code>public static bool Raycast(Vector3 origin, Vector3 direction, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal);
</code></pre></div>
<p>从origin向这direction方向发射一个射线，如果射线和某个碰撞体相交则返回true，否则返回false。</p>
<p>这个射线投射很有用，物理系统里面的很多功能都是基于这个射线投射，比如碰撞判断。此外还可以基于这个射线投射来构建出很多有用的功能：</p>
<ul>
<li>比如想要确定玩家当前的选择交互对象，视窗中心射出一个射线，和什么GameObject相交则认为该GameObject是当前玩家的选择对象。</li>
<li>然后再比如射击游戏可以用射线投射来模拟射击动作，并利用RayCatHit返回对象来获取被击中物体的很多信息，从而来更好地构建射击动作。</li>
</ul>
<p>RayCast参数还有好几种形式，这个就参看官方文档了，不在这里赘述了。</p>
<h3 id="physicscheckcapsule">Physics.CheckCapsule</h3>
<p>这个可以用来测试玩家角色是否接触地面，具体这个方法参数官方文档读起来也不是很直观，具体来说其定义了这样一个胶囊：</p>
<p><img alt="img" src="https://a358003542.github.io/images/2021/unity_capsule.png"/></p>
<p>其中的layer层一般将地形GameObject放入该层。</p>
<div class="highlight"><pre><span></span><code>public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal);
</code></pre></div>
<h3 id="_16">图层</h3>
<p>图层的创建和将某个GameObject分配给某个图层在Unity Editor那边操作熟悉下即可。</p>
<p>图层在某些特定的地方会很有用，比如摄像机渲染和物理系统的射线碰撞判断，否则不要创建一些无谓的图层。</p>
<h4 id="_17">摄像机的剔除遮罩属性</h4>
<p>Culling Mask 用来设置本摄像机想要渲染的图层，默认是Everything。</p>
<p>现在假设有两个摄像机，一个摄像机对着一个红色的立方体，该红色的立方体在RED图层；另外一个摄像机对着蓝色的立方体，该蓝色的立方体在BLUE图层。第一个摄像机的剔除遮罩没有选择BLUE图层，则该摄像机的渲染图像里面没有蓝色的立方体；第二个摄像机的剔除遮罩没有选择RED图层，则该摄像机的渲染图像里面没有红色的立方体。</p>
<h4 id="_18">物理系统的图层碰撞矩阵</h4>
<p>在 <code>Edit-&gt;Project settings-&gt;Physics</code> 那里，有一个Layer collision Matrix，用来设置你的项目里面各个图层中的各个GameObject是否有物理系统的碰撞判断。</p>
<p>此外物理系统的射线投射函数<code>Raycast</code> 里面有个 <code>layerMask</code> 参数就是设置你希望该射线和那些图层交互的。比如：</p>
<div class="highlight"><pre><span></span><code>int layerMask = 0;
</code></pre></div>
<p>则射线不会和任何东西发生碰撞。</p>
<p>如果：</p>
<div class="highlight"><pre><span></span><code>int layerMask = 1&lt;&lt;8;
</code></pre></div>
<p>则射线会和第8图层的GameObject发生碰撞。</p>
<p>如果：</p>
<div class="highlight"><pre><span></span><code>int layerMask = ~(1&lt;&lt;8);
</code></pre></div>
<p>则射线会和其他图层的GameObject发生碰撞除了第8图层。</p>
<p>看到这里读者可能已经明白了，一共32个图层，第一图层是 <code>00...00001</code> ，第二图层是<code>000...00010</code> ，比如我现在希望取第一图层和第二图层，就是 <code>00...0001 | 000...00010</code>  ，也就是 <code>00...11</code> 。</p>
<p>但个人还是不喜欢这种写法，还是推荐多使用 <code>LayerMask.GetMask</code> 这个方法，这个方法接受一个图层或者多个图层的名字，然后返回也就是类似上面描述的layermask的数值：</p>
<div class="highlight"><pre><span></span><code>LayerMask.GetMask("UserLayerA", "UserLayerB");
</code></pre></div>
<h3 id="_19">刚体</h3>
<h4 id="iskinematic">isKinematic</h4>
<p>是否是运动学刚体，如果勾选了，则力，碰撞和joint将不再影响刚体，刚体的移动仅仅动画或者脚本【transform.position】来控制。</p>
<h4 id="continuous-collision-detection">Continuous Collision Detection</h4>
<p>防止碰撞器快速移动穿过彼此，可以将碰撞属性检测设置为连续或者连续动态。</p>
<p>设置为连续可以防止刚体穿过任何静态碰撞器。</p>
<p>设置为连续动态可以防止刚体穿过任何支持刚体碰撞检测的物体。</p>
<h2 id="_20">序列化</h2>
<p>序列化是理解Unity Editor如何工作的关键，这当然对你后面更好地使用Unity Editor从而更好地进行游戏开发很重要，但更重要的是Unity Editor可以看作利用Unity技术实现的第一个游戏，因此Unity Editor广泛使用的序列化技术对你的游戏代码开发同样具有参考价值，这点我们后续会看到。</p>
<p>推荐读者参考阅读 <a href="https://blogs.unity3d.com/2014/06/24/serialization-in-unity/">这篇文章</a> 。</p>
<p>以下是Unity序列化技术中涉及到的一些场景：</p>
<ul>
<li>Unity Editor会将属性面板的一些属性进行序列化存储起来。</li>
<li>perfab预制件也是一种序列化手段。</li>
<li>当unity实例化一个对象时，首先是把该对象序列化，然后新建一个对象，然后反序列化获得的数据打入新的对象中。</li>
<li>Unity Editor执行保存动作也加载场景是利用了yaml进行的序列化和反序列化动作。</li>
<li>Unity Editor的热重载：代码发生变动，首先序列化所有编辑器窗体，再销毁窗体，再更新旧的C#代码，再加载新的C#代码，再重新创建窗体。</li>
</ul>
<p>Unity会对以下属性进行序列化：</p>
<ul>
<li>public</li>
<li>[SerializeField] 属性</li>
<li>not static</li>
<li>not readonly</li>
<li>not const</li>
<li>unity能够序列化的</li>
</ul>
<p>unity能够序列化的属性：</p>
<ul>
<li>自定义的非抽象类有[Serializable] 标注，比如：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="na">[Serializable]</span>
<span class="k">class</span> <span class="nc">Trouble</span>
<span class="p">{</span>
   <span class="k">public</span> <span class="n">Trouble</span> <span class="n">t1</span><span class="p">;</span>
   <span class="k">public</span> <span class="n">Trouble</span> <span class="n">t2</span><span class="p">;</span>
   <span class="k">public</span> <span class="n">Trouble</span> <span class="n">t3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>自定义的结构有[Serializable] 标注</li>
<li>由UntiyEngine.Object衍生出来的类</li>
<li>C#的基本数据类型（int, float, double, bool, string etc.）</li>
<li>可以序列化对象组成的array</li>
<li><code>List&lt;T&gt;</code>  T是可序列化的类型。</li>
</ul>
<h3 id="serializefield">SerializeField</h3>
<p>上面序列化一节提到，一个私有字段如果加上 <code>[SerializeField]</code> 标识，Unity对该私有字段也将使用序列化技术。</p>
<p>以编辑器脚本的某个公有字段来说，unity会将其序列化存储在硬盘中从而实现热重载，也就是下次启动游戏之后还会将你修改的这些参数填上去。如下加入 SerializeField 之后，该私有字段一样也会进入unity的序列化管理。</p>
<div class="highlight"><pre><span></span><code>[SerializeField] private AssetReference _persistentManagersScene = default;
</code></pre></div>
<h3 id="scriptableobject">ScriptableObject</h3>
<p>ScriptableObject继承自UntiyEngine.Object，按照上面序列化一小节的描述，ScriptableObject是可序列化的对象。</p>
<p>ScriptableObject的作用是充当一个数据容器。Unity的预制件实例化，里面的数据将会产生多个副本，所以对于重复使用的公有数据一般是推荐使用ScriptableObject来存储数据，然后预制件来访问这些数据。</p>
<h4 id="scriptableobject_1">ScriptableObject的唯一性</h4>
<p>ScriptableOjbect的唯一性是根据你创建的asset文件唯一性来的，只要保证是引用的同一asset文件，则生成类的实例都是一样的，个人测试也是实例id都是一样的。</p>
<p>如果是和Unity Addressable Asset system相结合，如果你的ScriptableObject是通过 <code>LoadAssetAsync</code> 加载进来的，那么在引用Asset的时候实际上都是在使用一个ScriptableObject，你可以将这个ScriptableObject看作类似perfab预制件一样的东西，直接使用该数据对象就是直接使用预制件，都是在用同一个东西。</p>
<p>而如果你调用 <code>InstantiateAsync</code> 来对ScriptableObject进行了实例化，则就是不同的数据对象了。<a href="https://docs.unity3d.com/cn/2019.4/Manual/class-ScriptableObject.html">参考网页</a>。</p>
<p>经过个人试验发现：</p>
<div class="highlight"><pre><span></span><code>        bool t1 = _menuToLoad[0] == _menuToLoad[1];
        bool t2 = _menuToLoad[1] == _menuToLoad[2];
        Debug.Log($"{_menuToLoad[0].GetHashCode()}");
        Debug.Log($"{_menuToLoad[1].GetHashCode()}");
        Debug.Log($"{_menuToLoad[2].GetHashCode()}");
        Debug.Log($"test:      {t1}");
        Debug.Log($"test:      {t2}");

        return;
</code></pre></div>
<p>上面代码<code>_menuToLoad</code> 列表一号和二号是不同的scriptableobject，二号和三号是相同的scriptableobject。然后scrptableobject的相等性可以使用 <code>==</code> 运算符来进行，然后通过HashCode发现相同的scriptableobject的哈希值也是相同的。</p>
<h4 id="scriptableobject_2">创建一个ScriptableObject对象</h4>
<div class="highlight"><pre><span></span><code>[CreateAssetMenu(fileName = "PersistentManagers", menuName = "Scene Data/PersistentManagers")]
public class PersistentManagersSO : GameSceneSO { }
</code></pre></div>
<p>fileName是点击菜单按钮之后默认保存的文件名，menuName是在Unity Editor对应的菜单按钮位置，上面的例子是：<code>资源-&gt;创建-&gt;场景数据-&gt;PersistentManagers</code> 。</p>
<h3 id="nonserialized">NonSerialized</h3>
<p>有的时候某些public属性你不需要系列化则可以加上修饰头 <code>[NonSerialized]</code> 。</p>
<div class="highlight"><pre><span></span><code>    [NonSerialized]
    public int p = 5;
</code></pre></div>
<h2 id="unity">Unity协程</h2>
<p>如果读者之前接触过协程概念，对于这里的协程的理解会很快，但有一点是需要特别强调的。那就是Unity的协程更多的是一个Unity自身基于逐帧运算然后做出来的概念，和很多编程语言上的协程概念比较起来，其底层甚至可能都不依赖于线程切换。</p>
<p>C#语言那边有异步编程，其使用的async func 和await之类的和python的异步编程很像，这些才是严格意义上的协程概念，Unity协程只是利用了C#的 <code>IEnumerator</code> 和 <code>yield return</code> 构建起来的类似python的可迭代对象，然后在这个可迭代对象之上构建出来的Unity协程概念。</p>
<p>具体Unity协程的编写如下：</p>
<div class="highlight"><pre><span></span><code><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>

<span class="n">IEnumerator</span> <span class="nf">CoroutineExample</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span>
    <span class="c1">// do something </span>
    <span class="k">yield</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
    <span class="c1">// still do something</span>
    <span class="k">yield</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>启动一个Unity协程：</p>
<div class="highlight"><pre><span></span><code><span class="n">StartCoroutine</span><span class="p">(</span><span class="n">CoroutineExample</span><span class="p">(</span><span class="m">1</span><span class="p">));</span>
</code></pre></div>
<p>该CoroutineExample协程会在遇到yield return 那里停止执行，然后下一帧再回来继续执行本协程。</p>
<p>此外可以如下启动协程：</p>
<div class="highlight"><pre><span></span><code>StartCoroutine("CoroutineExample", 1);
</code></pre></div>
<p>这种指定协程名字符串的启动后面可以指定名字要求停止某个协程：</p>
<div class="highlight"><pre><span></span><code>StopCoroutine("CoroutineExample")
</code></pre></div>
<p>你还可以让某个协程暂停执行多少秒：</p>
<div class="highlight"><pre><span></span><code>yield return new WaitForSeconds(.1f);
</code></pre></div>
<h3 id="unity_1">嵌套Unity协程</h3>
<p>参考了  <a href="https://www.alanzucconi.com/2017/02/15/nested-coroutines-in-unity/">这篇文章</a> 。</p>
<p>如下：</p>
<div class="highlight"><pre><span></span><code>yield return StartCoroutine(AnotherCoroutine())
</code></pre></div>
<p>这种形式，父协程要等待子协程完成才会继续往下走，也就是对于父协程来说，子协程的整个执行过程是同步的。因为子协程仍然是通过 StartCoroutine启动的，其内部的执行是异步的。</p>
<h3 id="unity_2">平行Unity协程</h3>
<div class="highlight"><pre><span></span><code>IEnumerator A()
{

    // Starts B, C, and D as coroutines and continues the execution
    Coroutine b = StartCoroutine( B() );
    Coroutine c = StartCoroutine( C() );
    Coroutine d = StartCoroutine( D() );

    // Waits for B, C and D to terminate
    yield return b;
    yield return c;
    yield return d;

}
</code></pre></div>
<p>B C D这几个子协程从启动开始就执行了，说的再直白点就是正常启动协程则一下就启动起来了，根本花费不了什么时间。</p>
<p>上面两种情况可以总结为那就是嵌套Unity协程中，父协程是同步的。所谓同步就是Unity会一直在这里执行，而Unity协程所谓的异步指的是内部执行了很小碎片的不怎么花费时间的动作，然后就yield return了，然后再等待下一帧再继续执行，并不阻塞主程序。</p>
<p>我们看到Unity协程解决的主要是帧动作太多的问题，通过Update等函数我们可以设计每一帧进行某个动作，然后我们发现对于很多问题并不需要每一帧都做，通过Unity协程可以解决这个问题；还有些过程可能横跨多个帧，但其内部动作可以分解为很多小动作，然后每帧再分别执行这些小动作即可，这可以通过Unity协程解决。</p>
<p>但Unity协程不能解决某个动作就是花费时间太长，从而造成你的游戏进程阻塞这个问题，这还是需要靠多线程或异步来解决，Unity协程在这里的作用主要就是每帧来检查一下这个费时的异步动作完成了没有。</p>
<h2 id="_21">摄像机</h2>
<h3 id="_22">多个摄像机</h3>
<p>Unity可以添加多个摄像机组件，摄像机有个参数叫做深度，这个深度值最大的摄像机将是最终显示的那个摄像机【如果两个摄像机在显示上都是全覆盖的】。</p>
<h3 id="cameramain">Camera.main</h3>
<p>如果你的主摄像机有标签 <code>MainCamera</code> ，则可以通过 <code>Camera.main</code> 来调用。</p>
<h3 id="camerascreenpointtoray">Camera.ScreenPointToRay</h3>
<p>定义了一个射线，从摄像机出发射向屏幕的某个坐标点。</p>
<div class="highlight"><pre><span></span><code>public Ray ScreenPointToRay(Vector3 pos);
</code></pre></div>
<p>该pos的z值将忽略。</p>
<h3 id="_23">分屏显示</h3>
<p>摄像机的Viewport矩形x和y值决定了显示的起始位置，x值是横向，y值是竖向。比如(0,0) 是最左边那里，<code>(0.5,0)</code> 是横向宽度50%竖向继续0%那里。然后w是显示的宽度，0.5就是显示宽度为整个宽度的50%。h是显示高度。</p>
<p>调配两个摄像头的Viewport矩形参数，一个(0,0)显示宽度0.5，显示高度1；一个(0.5,0)显示宽度0.5，显示高度1就可以达到一种横向分两个屏幕显示的效果。</p>
<p>继续调配这个Viewport矩形参数还可以做到另外一个摄像头专门在显示界面右上角来显示，一种类似小地图的功能。</p>
<h3 id="viewporttoworldpoint">viewportToWorldPoint</h3>
<p>根据摄像机视图空间的一个Vector3坐标转成游戏场景中的Vector3坐标。</p>
<div class="highlight"><pre><span></span><code>Vector3 p = camera.ViewportToWorldPoint(new Vector3(1, 1, camera.nearClipPlane));
</code></pre></div>
<p>其中Vector3的x和y如果是 <code>(0,0)</code> 则是左下角，如果是 <code>(1,1)</code> 则是右上角，这个z值设置为 <code>camera.nearClipPlane</code> 是摄像机的近裁剪平面，还有一个远裁剪平面，z值也可以设置为0就是紧贴着摄像机。</p>
<h3 id="cinemachine">cinemachine</h3>
<p>cinemachine不是要取代原Unity的摄像机组件，而是新增了一个cinemachine brain组件用于控制原Unity摄像机的位置和Aim，同时还提供了其他一些额外的功能，比如摇动效果。</p>
<p>利用cinemachine创建一个第三人称跟踪式摄像头是很方便的，而后续更多的运镜，包括摇摄，跟摄，多个摄像头视角转换都可以很容易办到。</p>
<p>一般使用就使用virtual camera，其他camera只是在特定应用场景下才好用，可能额外增加的一些特性限定并不适合你的应用需求。</p>
<p>Follow控制的摄像头的跟随对象，Body控制的是摄像头跟随跟随对象的移动行为，但是要注意3rd person follow 似乎还会有额外的摄像头旋转动作。</p>
<p>loot at控制的摄像头的瞄准对象，Aim控制的是摄像头的旋转行为，有可以根据用户行为来旋转摄像头，但只是针对的旧版本的输入控制，如果你希望自己实现根据用户的操作来旋转摄像头，最好是自己编写脚本，那么Aim填上do nothing，免得干扰。</p>
<p>body的Framing transposer很灵活和全面，很好用，摄像头偏移，距离，damping，dead zone，soft zone等概念都是可以调整的。</p>
<ul>
<li>dead zone cinemachine会保证那个黄点也就是关注点在dead zone之内</li>
<li>soft zone 如果黄点在dead zone则不会有动作，如果黄点在soft zone 则摄像头会开始调整，摄像头调整可块可慢，具体可根据damping这个值来设置。</li>
</ul>
<h2 id="_24">脚本</h2>
<h3 id="gameobject">GameObject</h3>
<p>一个空的GameObject就是一个容器，其可以用于在Unity Editor的大纲视图中进行层级管理。一个GameObject下面管理的多个物体，如果将这个GameObject拖动到项目文件夹视图下，则将会创建一个Perfab预制件。预制件Perfab可以重复只用，并且改变基础Perfab属性会影响所有相关场景中的由此Perfab实例化的对象。</p>
<p>一个GameObject里的组件如果调用<code>gameObject</code> 属性，比如transform，或者脚本类this，都会指向这个目标容器GameObject。</p>
<div class="highlight"><pre><span></span><code>this.gameObject;
this.transform.gameObject;
</code></pre></div>
<p>脚本作为组件绑定在某个GameObject上，如上在脚本中调用 <code>this.gameObject</code> 则会引用该GameObject。</p>
<p>所有的GameObject，即使是一个空的GameObject也会有transform属性。</p>
<h4 id="getcomponent">GetComponent方法</h4>
<p>这个方法在 <code>GameObject.GetComponent</code> 上，也就是Unity上的所有游戏对象都是可以调用这个方法的，这既包括脚本组件对象，也包括transform对象。</p>
<p>然后GetComponent方法主要是找目标组件和本脚本组件或者其他组件在同一GameObject之下的情况，当然你也可以直接引用本GameObject来调用这个方法：<code>gameObject.GetComponent</code> 。返回的是找到的第一个相同类型的目标组件，如果没有找到则返回null。</p>
<div class="highlight"><pre><span></span><code>_rb = this.GetComponent&lt;Rigidbody&gt;();
</code></pre></div>
<p>上面假设本脚本和某个刚体组件同在一个GameObject之下，则如上引用该目标组件。其实你在Unity Editor看到的其他组件说白了也是一些脚本，只是说之前Unity官方或者其他库预先帮你写好了。脚本也可以不绑定在GameObject上，这个后面会提到，其叫做 ScriptableObject。</p>
<h4 id="_25">引用其他脚本组件</h4>
<p>现在假设你的GameObject下面有多个脚本组件，则引用另一个脚本组件代码如下：</p>
<div class="highlight"><pre><span></span><code>gameManager = this.GetComponent&lt;GameBehavior&gt;();
</code></pre></div>
<p>上面的意思是本GameObject下还有一个脚本类，其类名叫做 <code>GameBehavior</code> ，那么那个刚体组件呢，其对应的就是还有另外一个脚本，其类名叫做Rigidbody。请注意，这里的讨论只是在试图澄清组件和脚本类之间的关系，并不是在说如何使用其他类里面的数据，Unity对于交互数据更推荐使用ScriptableObject或者其他方法来处理，一般来说脚本类里面只放着行为逻辑。</p>
<h4 id="find">Find方法</h4>
<p>Find方法可以用于查找不是本GameObject的其他GameObject，具体名字就是Unity面板上显示的那个名字。</p>
<div class="highlight"><pre><span></span><code><span class="k">private</span> <span class="n">GameObject</span> <span class="n">directLight</span><span class="p">;</span>
<span class="k">private</span> <span class="n">Transform</span> <span class="n">lightTransorm</span><span class="p">;</span>

<span class="n">directLight</span> <span class="p">=</span> <span class="n">GameObject</span><span class="p">.</span><span class="n">Find</span><span class="p">(</span><span class="s">"Directional Light"</span><span class="p">);</span>
<span class="n">lightTransorm</span> <span class="p">=</span> <span class="n">directLight</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;();</span>
<span class="n">Debug</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="n">lightTransorm</span><span class="p">.</span><span class="n">localPosition</span><span class="p">);</span>
</code></pre></div>
<p><strong>WARNING：</strong> Find方法是对所有已经加载的场景中激活的所有对象的遍历搜索动作，开销会很大，没有特别的理由不要使用Find方法，更推荐的其他GameObject引用参看下面。</p>
<h5 id="_26">更推荐的做法</h5>
<p>在实践中如上使用Find方法其实并不是很好用，更推荐的做法是将你需要定位的GameObject做成你的脚本类的公有属性或者序列化属性，值得一提的是这种做法可用于定位目标GameObject，也可用于定位目标组件，目标组件在十万八千里远或者就在旁边都可以这样用。</p>
<div class="highlight"><pre><span></span><code>public YouTargetClass object_name;
</code></pre></div>
<p>然后在编辑器上选中目标对象或者拖动目标对象到目标输入框。你给定的类名一定要是你想定位的目标的类，这样选择框才会弹出对应的候选项。</p>
<p>这种做法的好处就是编辑器友好和简单，又能少写代码又简单当然是推荐使用的了。一般大部分应用场景都可以用这个推荐做法来解决引用目标对象的问题，只可能在某些极个别的情况需要代码查找。</p>
<h4 id="transform">transform的层级树</h4>
<p>unity的每一个gameObject都有transform这个属性，这个transform是有一个内在的层级树在里面的，这个层级树也就是里面的parent和child概念是直接对应你在大纲视图上看到的GameObject的层级的。</p>
<p>你可以通过transform的层级数来定位某个gameObject的transform，然后通过 <code>.gameObject</code> 这个属性来获得具体该gameObject对象。</p>
<p>你可以通过如下语句来迭代某个GameObject下的子节点：</p>
<div class="highlight"><pre><span></span><code><span class="k">foreach</span> <span class="p">(</span><span class="n">Transform</span> <span class="n">child</span> <span class="k">in</span> <span class="n">parent</span><span class="p">){</span>
    <span class="c1">// do something</span>
<span class="p">}</span>
</code></pre></div>
<p>然后有 <code>transform.parent</code> 来返回本transform的父节点transform对象。更多的方法请参看 Transform 类。</p>
<h4 id="findwithtag">FindWithTag方法</h4>
<p>正如上面的讨论，但在某些情况下你确实需要使用Find来查找，那么推荐你使用 <code>FindWithTag</code> 方法，然后你想要查找的目标GameObject上添加一个专门的标签，这样效率会高很多。</p>
<h4 id="sendmessage">SendMessage方法</h4>
<p>非常有用的一个方法，请注意看官方文档下面的这个例子，两个class是作为同一GameObject的两个脚本组件挂在上面的，确切来说本GameObject上所有MonoBehaviour也就是脚本组件都会被通知到，如果脚本组件有目标方法，则会执行该方法。</p>
<div class="highlight"><pre><span></span><code>using UnityEngine;

public class Example : MonoBehaviour
{
    void Start()
    {
        // Calls the function ApplyDamage with a value of 5
        // Every script attached to the game object
        // that has an ApplyDamage function will be called.
        gameObject.SendMessage("ApplyDamage", 5.0);
    }
}

public class Example2 : MonoBehaviour
{
    public void ApplyDamage(float damage)
    {
        print(damage);
    }
}
</code></pre></div>
<h3 id="gameobject_1">常驻GameObject</h3>
<p>你可能希望某些GameObject常驻在游戏里面然后多个场景调用。一个做法是不摧毁原场景，设置一个常驻场景作为该GameObject所在地，这可以通过规范你的项目场景加载卸载逻辑来实现。还有一个做法如下：</p>
<h4 id="dontdestroyonload">DontDestroyOnLoad</h4>
<p>当加载一个新的场景时会把原场景的所有对象destroy掉，如果加入如下代码：</p>
<div class="highlight"><pre><span></span><code>DontDestroyOnLoad(this.gameObject);
</code></pre></div>
<p>则本脚本绑定的那个GameObject在场景切换时将不会被删除掉。</p>
<h3 id="updatefixedupdate">Update和FixedUpdate</h3>
<p>Update是每帧执行，一般键盘输入放在这里。</p>
<p>FixedUpdate是每隔一定固定时间段执行，一般物理模拟内容放在这里。</p>
<p>此外还需要了解 <code>Time.deltaTime</code> ，其返回的是上一帧到这一帧的时间间隔。以FixedUpdate为例，其内每次调用 Time.deltaTime都是相同的某个时间段，而对于Update则没有这个规律。</p>
<h3 id="awakestart">Awake和Start</h3>
<p>Awake和Start在脚本组件启动时都会被调用一次，Awake先于Start，脚本组件即使没有Enabled，场景启动时Awake也会执行，而Start只有在该脚本组件Enabled的情况下才会执行。</p>
<p>此外还有一个OnEnable方法，它在Awake之后，如果脚本Enabled则会调用。</p>
<h3 id="headerattribute">HeaderAttribute</h3>
<p>在Unity编辑器那边新增一个标题头</p>
<div class="highlight"><pre><span></span><code>    [Header("Persistent managers Scene")]
</code></pre></div>
<h3 id="textareaattribute">TextAreaAttribute</h3>
<p>在Unity编辑器那里新增一个可编辑文本区域。</p>
<div class="highlight"><pre><span></span><code>    [TextArea] public string description;
</code></pre></div>
<h3 id="tooltip">Tooltip</h3>
<p>给Unity编辑器的某个字段增加一个提示信息。</p>
<div class="highlight"><pre><span></span><code>[Tooltip("Time that this gameObject is invulnerable for, after receiving damage.")]
</code></pre></div>
<h3 id="transformtransformpoint">Transform.TransformPoint</h3>
<div class="highlight"><pre><span></span><code>public Vector3 TransformPoint(Vector3 position);
</code></pre></div>
<p>根据某个Transform的local space偏移值Vector3 position，获得目标值的世界坐标值Vector3。</p>
<h2 id="unity-addressable-asset-system">Unity Addressable Asset system</h2>
<p>Unity的官方包，在包管理里面搜索<code>addressables</code> 。这个包可以让你访问资产Asset通过地址访问的方式来进行，从而增加资源访问的灵活性。原asset bundle管理方案已经处于废弃状态。</p>
<p>在 window-&gt;addressables groups 那里新增一个group。</p>
<p>然后将资源拖动到这里，第一列就是后面你要使用引用的名字，默认的名字是根据你的资源的本地目录来的，你也可以修改为你想要的名字。</p>
<p>在脚本中使用资源如下，接受的参数是该资产的名字。</p>
<div class="highlight"><pre><span></span><code>using UnityEngine.AddressableAssets;
Addressables.LoadAssetAsync&lt;GameObject&gt;("AssetAddress");
Addressables.InstantiateAsync("AssetAddress");
</code></pre></div>
<p>如果是<code>AssetReference</code> 配置好的资产则可以直接如下调用，：</p>
<div class="highlight"><pre><span></span><code>_menuLoadChannel.LoadAssetAsync&lt;LoadEventChannelSO&gt;().Completed += LoadMainMenu;
</code></pre></div>
<p>一般的使用大体如下：</p>
<div class="highlight"><pre><span></span><code><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine.AddressableAssets</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">AddressablesExample</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>

    <span class="n">GameObject</span> <span class="n">myGameObject</span><span class="p">;</span>

        <span class="p">...</span>
        <span class="n">Addressables</span><span class="p">.</span><span class="n">LoadAssetAsync</span><span class="p">&lt;</span><span class="n">GameObject</span><span class="p">&gt;(</span><span class="s">"AssetAddress"</span><span class="p">).</span><span class="n">Completed</span> <span class="p">+=</span> <span class="n">OnLoadDone</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnLoadDone</span><span class="p">(</span><span class="n">UnityEngine</span><span class="p">.</span><span class="n">ResourceManagement</span><span class="p">.</span><span class="n">AsyncOperations</span><span class="p">.</span><span class="n">AsyncOperationHandle</span><span class="p">&lt;</span><span class="n">GameObject</span><span class="p">&gt;</span> <span class="n">obj</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// In a production environment, you should add exception handling to catch scenarios such as a null result.</span>
        <span class="n">myGameObject</span> <span class="p">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">Result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_27">异步加载你的场景</h3>
<p>addressables 系统可用于异步加载你的场景，非常的方便。</p>
<div class="highlight"><pre><span></span><code>using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;
using UnityEngine.SceneManagement;
using UnityEngine.ResourceManagement.ResourceProviders;

Addressables.LoadSceneAsync("sceneName", LoadSceneMode.Additive).Completed += SceneLoadComplete;
// if scene is a AssetReference
scene.LoadSceneAsync(LoadSceneMode.Additive).Completed += SceneLoadComplete;

private void SceneLoadComplete(SceneInstance obj)
{
    if (obj.Status == AsyncOperationStatus.Succeeded)
    {
        Debug.Log("scene load succeeded.")
        // do something.
    }

}
</code></pre></div>
<p>卸载场景如下：</p>
<div class="highlight"><pre><span></span><code>private AsyncOperationHandle&lt;SceneInstance&gt; handle;
handle = obj;

Addressables.UnloadSceneAsync(handle).Completed += SceneUnloadComplete;
</code></pre></div>
<p>上面不管是加载还是卸载一旦启动就异步进行了，Completed事件加入回调是一种方法，但你也可以用Unity的协程方法来检查之：</p>
<div class="highlight"><pre><span></span><code>private IEnumerator LoadingProcess()
{
    if (obj.Status == AsyncOperationStatus.Succeeded)
    {
        Debug.Log("scene load succeeded.")
        // do something.
    }
    yield return null;
}
</code></pre></div>
<p>如果大体每一帧都会检测一次加载是否Succeeded。</p>
<h3 id="buildbuild">build发布前记得运行下build</h3>
<p>你的项目build独立运行记得将在那个窗口的build子菜单那里点击new build一个资源。</p>
<h2 id="_28">四元数和欧拉角度</h2>
<p>旋转Editor看到的x y z的值就是所谓的欧拉角度，但是如果你要给tranform.rotation赋值的话则需要使用四元数（Quaternion）。</p>
<div class="highlight"><pre><span></span><code>transorm.rotation = Quaternion.Euler(0,0,0);
</code></pre></div>
<p>上面的过程也可以看做将一个欧拉角度数组转换成Quaternion四元数再赋值给rotation。</p>
<p>四元数访问对应的欧拉角度如下：</p>
<div class="highlight"><pre><span></span><code>transform.localEulerAngles
</code></pre></div>
<p>在用一个Vector3变量表示游戏里面的方向的时候，现在假定都是全局坐标，则 <code>(0,0,1)</code> 也就是所谓的forward方向，即物体的z轴指向表示forword方向，此外还有 <code>(0,1,0)</code> 表示物体的Vector3.up方向，即物体的Y轴指向。x轴就是x轴和我们一般常识没有太多出入。</p>
<p>到Vector2坐标输入又有所不同，其x值对应的是水平方向，可以认为影响的是x值，而y值对应的是垂直方向，可以认为影响的是y值。</p>
<p>继续学习，这个四元数确实还是很让人困惑的，手册里面说Unity一般期待四元数是normalized，这个懂点线性代数的大概清楚就是这个矢量的模规约为1。具体调用是 <code>quaternion.normalized</code> ，将会返回一个magnitude等于1的四元数。</p>
<p>然后看到四元数乘以一个Vector3，参考 <a href="https://answers.unity.com/questions/186252/multiply-quaternion-by-vector.html">这个网页</a> 。一个Vector3乘以一个四元数实际上是将这个Vector3进行了该四元数对应的旋转操作，也就是返回的也是一个Vector3变量。那么这又到了这个问题上，四元数表示的是一个什么旋转动作。比如说 <code>Quaternion.Euler(0,90,0)</code>  意思是绕着y轴旋转90度，y轴是垂直向上的，绕着y轴旋转90度大概就是一个物体在xy平面的旋转动作。</p>
<h3 id="quaternionangleaxis">Quaternion.AngleAxis</h3>
<p>绕某个轴旋转多少角度。</p>
<div class="highlight"><pre><span></span><code>transform.rotation = Quaternion.AngleAxis(30, Vector3.up);
</code></pre></div>
<h2 id="unity_3">基于事件驱动的Unity编程</h2>
<p>作为和桌面端程序类似的存在，成熟的Unity游戏编程必然是基于事件驱动的编程模式。这对于大中小型Unity项目都是有用的和必须的。</p>
<p>C#那边已经有成熟的事件驱动编程解决方案了，拿过来用就是了。因为Unity那边又新增了UnityAction之类的语法糖，但从 <a href="https://www.jacksondunstan.com/articles/3335">这篇文章</a> 来看，其效率反而不如C#自带的事件驱动解决方案，除非在某些Unity Editor定制人物上，才一定要使用UnityAction之类的，那个时候再使用。</p>
<p><strong>更新：</strong> ScriptableObject最好只是作为数据文件存在，否则在Build那边会有一些问题，之前C#那边已经讨论过事件驱动编程了，下面将这些讨论粘贴过来，在Unity那边同样也是可以用的。</p>
<h3 id="_29">事件驱动编程</h3>
<p>事件驱动编程模式或者说委托代理模式，其将构建一个事件通道作为第三中间人，事件发送方只负责告诉该第三人事件发生了，事件发送方并不关心这个第三人等下要将这些事件通知给谁。而事件接收方也不知道事件发送方是谁，它只管听第三人也就是事件通道的，事件通道说事件触发了，然后事件接收方再决定做某些事情。</p>
<p>此外编程上还有一个观察模式，观察模式的事件发送方和事件接受方彼此是知道的，事件发生了事件发送方会直接通知各个事件接收方事件发生了。参考了 <a href="https://hackernoon.com/observer-vs-pub-sub-pattern-50d3b27f838c">这篇文章</a> 。</p>
<p>按照上面的说法，我们最好是构建出一个EventChannel类，由这个EventChannel来负责触发事件，由这个EventChannel负责传递函数参数和通知事件接收方事件发生了。</p>
<p>在实践中的一个编码规范是参数最好把事件的发送人和发送的参数作为两个参数。大概如下：</p>
<div class="highlight"><pre><span></span><code>public delegate void EventHandler&lt;TEventArgs&gt;(object? sender, TEventArgs e);
</code></pre></div>
<p>是的，C#就已经定义了这个EventHandler委托，于是利用这个EventHandler我们就可以如下定义事件了：</p>
<div class="highlight"><pre><span></span><code>public event EventHandler&lt;SomeEventArgs&gt; someEvent;
</code></pre></div>
<p>下面是定义该事件的参数传递规范：</p>
<div class="highlight"><pre><span></span><code>    <span class="k">public</span> <span class="k">class</span> <span class="nc">SomeEventArgs</span> <span class="p">:</span> <span class="n">EventArgs</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="nf">SomeEventArgs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
            <span class="k">this</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>下面定义了一个事件通道基类：</p>
<div class="highlight"><pre><span></span><code>    <span class="k">public</span> <span class="k">enum</span> <span class="n">Status</span> <span class="p">{</span> <span class="n">Started</span><span class="p">,</span> <span class="n">Stopped</span> <span class="p">};</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">BaseEventChannel</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">event</span> <span class="n">EventHandler</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Event</span><span class="p">;</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">RaiseEvent</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">T</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Event</span><span class="p">?.</span><span class="n">Invoke</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">AddHandler</span><span class="p">(</span><span class="n">EventHandler</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">handler</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Event</span> <span class="p">+=</span> <span class="n">handler</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">RemoveHandler</span><span class="p">(</span><span class="n">EventHandler</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">handler</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Event</span> <span class="p">-=</span> <span class="n">handler</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="k">public</span> <span class="k">class</span> <span class="nc">SomeEventArgs</span> <span class="p">:</span> <span class="n">EventArgs</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="n">Status</span> <span class="n">status</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="nf">SomeEventArgs</span><span class="p">(</span><span class="n">Status</span> <span class="n">status</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">status</span> <span class="p">=</span> <span class="n">status</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">SomeEventChannel</span> <span class="p">:</span> <span class="n">BaseEventChannel</span><span class="p">&lt;</span><span class="n">SomeEventArgs</span><span class="p">&gt;</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">Engine</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="n">SomeEventChannel</span> <span class="n">someEventChannel</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SomeEventChannel</span><span class="p">();</span>

        <span class="k">protected</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">OnSomeEvent</span><span class="p">(</span><span class="n">SomeEventArgs</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">someEventChannel</span><span class="p">.</span><span class="n">RaiseEvent</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">OnSomeEvent</span><span class="p">(</span><span class="k">new</span> <span class="n">SomeEventArgs</span><span class="p">(</span><span class="n">Status</span><span class="p">.</span><span class="n">Started</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Stop</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">OnSomeEvent</span><span class="p">(</span><span class="k">new</span> <span class="n">SomeEventArgs</span><span class="p">(</span><span class="n">Status</span><span class="p">.</span><span class="n">Stopped</span><span class="p">));</span>
        <span class="p">}</span>

    <span class="p">}</span>
</code></pre></div>
<p>具体调用程序大体如下：</p>
<div class="highlight"><pre><span></span><code> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>

        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Engine</span> <span class="n">engine</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Engine</span><span class="p">();</span>
            <span class="n">engine</span><span class="p">.</span><span class="n">someEventChannel</span><span class="p">.</span><span class="n">AddHandler</span><span class="p">(</span><span class="n">OnEngineStatusChanged</span><span class="p">);</span>
            <span class="n">engine</span><span class="p">.</span><span class="n">someEventChannel</span><span class="p">.</span><span class="n">AddHandler</span><span class="p">(</span><span class="n">OnEngineStatusChanged2</span><span class="p">);</span>

            <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
            <span class="n">engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>

            <span class="n">engine</span><span class="p">.</span><span class="n">someEventChannel</span><span class="p">.</span><span class="n">RemoveHandler</span><span class="p">(</span><span class="n">OnEngineStatusChanged2</span><span class="p">);</span>
            <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
            <span class="n">engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">OnEngineStatusChanged</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">SomeEventArgs</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">$</span><span class="s">"{sender} is now {args.status}"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">OnEngineStatusChanged2</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">SomeEventArgs</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">$</span><span class="s">"Report2: {sender} is now {args.status}"</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="p">}</span>
</code></pre></div>
<p>就上面这个程序小片段没这个问题，但对于稍大点的应用程序，则需要保证某一特定事件通道的唯一性。有以下做法，并没有那种优于那种一说：</p>
<ul>
<li>一是靠程序员自我编码规范，比如事件和组件是特有的绑定关系，这样你在编码的时候就会很少犯错，因为你总是在想这个组件实体触发了什么事件，自然会做好组件实体的唯一性和对目标事件的引用。</li>
<li>让事件通道成为全局变量从而全局唯一。</li>
<li>从事件通道的编码上实现单例模式</li>
<li>将你的事件通道和外部的数据文件等建立某种唯一关系等。</li>
</ul>
<h3 id="_30">单例模式示例</h3>
<p>本小节单例模式实现主要参考了 <a href="https://csharpindepth.com/articles/singleton">这个网页</a> 。</p>
<div class="highlight"><pre><span></span><code>    <span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">SomeEventChannel</span> <span class="p">:</span> <span class="n">BaseEventChannel</span><span class="p">&lt;</span><span class="n">SomeEventArgs</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">SomeEventChannel</span> <span class="n">instance</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SomeEventChannel</span><span class="p">();</span>
        <span class="k">static</span> <span class="nf">SomeEventChannel</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// Make sure it's truly lazy</span>
        <span class="k">private</span> <span class="nf">SomeEventChannel</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// Prevent instantiation outside</span>

        <span class="k">public</span> <span class="k">static</span> <span class="n">SomeEventChannel</span> <span class="n">Instance</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">instance</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>

    <span class="p">}</span>
</code></pre></div>
<p>具体在引用的时候要如下这样使用了：</p>
<div class="highlight"><pre><span></span><code>        public SomeEventChannel someEventChannel = SomeEventChannel.Instance;
</code></pre></div>
<h3 id="_31">和组件绑定的事件</h3>
<p>在实践中有一种情况，那就是事件是和某一个组件是绑定的一对一关系，那么自然这个事件就是单例的。而这个事件作为某个组件的属性在单例的处理上就会稍微简单一点，这个组件事件也没必要发送sender这个参数了，因为事件发起人肯定是本组件this。出于代码简洁的考虑，可以引入组件事件的概念：</p>
<div class="highlight"><pre><span></span><code>namespace System
{
    public delegate void VoidComponentEventHandler();
    public delegate void ComponentEventHandler&lt;TEventArgs&gt;(TEventArgs e);
}

public class ComponentEventBase&lt;T&gt;
{
    public event ComponentEventHandler&lt;T&gt; Event;

    public void RaiseEvent(T args)
    {
        Event?.Invoke(args);
    }

    public void AddHandler(ComponentEventHandler&lt;T&gt; handler)
    {
        Event += handler;
    }
    public void RemoveHandler(ComponentEventHandler&lt;T&gt; handler)
    {
        Event -= handler;
    }
}


public class VoidComponentEvent
{
    public event VoidComponentEventHandler Event;

    public void RaiseEvent()
    {
        Event?.Invoke();
    }

    public void AddHandler(VoidComponentEventHandler handler)
    {
        Event += handler;
    }
    public void RemoveHandler(VoidComponentEventHandler handler)
    {
        Event -= handler;
    }
}
</code></pre></div>
<div class="highlight"><pre><span></span><code>public VoidComponentEvent myEvent1 = new VoidComponentEvent();
public VoidComponentEvent myEvent2 = new VoidComponentEvent();
</code></pre></div>
<h3 id="unityaction">UnityAction</h3>
<p>UnityAction带来的便利就是Unity Editor那边是支持显示一个按钮方便手工触发该事件的，除此之外UnityAction就是一个有着特定名字的C#委托，并没有什么特殊的。</p>
<h3 id="unityevent">UnityEvent</h3>
<p>UnityEvent如上的讨论，在效率上反而不如C#原生的事件，但你给你的组件脚本上随便如下添加：</p>
<div class="highlight"><pre><span></span><code>UnityEvent OnSomeEvent;
</code></pre></div>
<p>那么在Unity Editor那里就会多出一个<code>OnSomeEvent</code> 选单，这个选单你可以随意添加很多行为，其他脚本的其他方法都可以随意拖动过来，UnityEvent带来的就是这个好处。一般来说熟悉C#编程的Unity开发人员在这种程序行为定义的地方是不推荐采用拖动的方式的，还是直接用代码编写吧。</p>
<p>具体这块应用场景主要对应上面和组件绑定的事件的讨论，个人对于代码并没有太极端的微优化喜好，所以在这种和组件绑定的事件应用场景下，简单使用UnityEvent也是可以的，更多情况请参见官方手册。</p>
<h2 id="ui">UI</h2>
<h3 id="canvas">Canvas</h3>
<p>Unity的UI是基于画布Canvas构建的，其他UI元素都需要在Canvas之上，或者说所有的UI元素都需要是Canvas的子对象。</p>
<p>Unity的UI可以有多个Canvas画布，出于性能上的考虑推荐总是变化的UI元素放在一个单独的画布上，因为画布的某部分发生了变化会重新绘制全部内容。</p>
<h4 id="_32">画布渲染模式</h4>
<ul>
<li>Screen Space-Overlay 【屏幕空间-覆盖】默认的渲染模式，在场景中的UI对象位置和具体的UI显示没有关系。Unity内置的图层UI，一般UI元素都放在这一层，在场景中选择隐藏UI图层也是没有问题的【运行游戏时仍然会在】。</li>
<li>Screen Space-Camera 【屏幕空间-摄像机】这种模式使用摄像机来渲染UI。一般这种情况最好专门再添加一个摄像机专门用来渲染画布。</li>
<li>World Space 【世界空间】这种情况下画布是作为场景中一个游戏对象和其他游戏对象没有区别地混在一起的。比如游戏角色头顶上的问号。</li>
</ul>
<h3 id="sprite">sprite文件</h3>
<p>UI里面有些地方用的是sprite文件对象，如果你直接导入png图片的话会发现没有对应的选项，需要将导入的png图片的属性那里更改为sprite才可以。</p>
<p>一般来说游戏的UI会放在你的常驻场景里面，和你的其他游戏管理逻辑放在一起，而不是某单个level场景里面。</p>
<h2 id="_33">导航系统</h2>
<p>Unity内置了一个路径导航系统，首先你需要将你的地形 GameObject 进行烘焙：</p>
<ol>
<li>选择你的地形GameObject，选择Static菜单的Navigation Static【在烘焙NavMesh的时候只收集标记为Navigation Static的游戏对象数据】</li>
<li>选择Window-&gt;AI-&gt;导航，选择烘培Bake Tab，然后点击烘培。</li>
<li>你将会在目标场景地图下面看到新建了一个NavMesh对象。</li>
</ol>
<p>导航系统中你想要移动的目标对象需要绑定Nav Mesh Agent组件。</p>
<p>导航系统中你需要定义一系列的导航路径点，空的GameObject即可。</p>
<h3 id="agent">如何移动一个Agent</h3>
<p>实际会很简单，就是设定destination属性即可。</p>
<div class="highlight"><pre><span></span><code>agent.destination = transform.position;
</code></pre></div>
<h3 id="_34">巡逻模式</h3>
<p>一个agent的巡逻模式可以通过如下类似编码来实现：</p>
<div class="highlight"><pre><span></span><code>    <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">agent</span><span class="p">.</span><span class="n">remainingDistance</span> <span class="p">&lt;</span> <span class="m">0.2f</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">agent</span><span class="p">.</span><span class="n">pathPending</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">MoveToNextPatrolLocaton</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
        <span class="k">private</span> <span class="k">void</span> <span class="nf">MoveToNextPatrolLocaton</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">locations</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">agent</span><span class="p">.</span><span class="n">destination</span> <span class="p">=</span> <span class="n">locations</span><span class="p">[</span><span class="n">locationIndex</span><span class="p">].</span><span class="n">position</span><span class="p">;</span>

        <span class="n">locationIndex</span> <span class="p">=</span> <span class="p">(</span><span class="n">locationIndex</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span> <span class="p">%</span> <span class="n">locations</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<p>上面的 <code>agent.pathPending</code> 的意思是当前路径还没有计算好，取值否表示一定要先等路径计算好然后剩余距离只有多少之后继续移动到下一个导航点。</p>
<h3 id="_35">烘焙的时候选择高度网格</h3>
<p>如果不选择高度网格的话，角色会有一定的悬空浮动问题。高度网络在运行时会占用一些内存和处理资源，只有在必要的时候才开启这个选项。</p>
<h3 id="navmesh-surface">NavMesh Surface</h3>
<p>这个组件需要在 <a href="https://github.com/Unity-Technologies/NavMeshComponents">这里</a> 额外下载安装，它可以作为组件附加在游戏对象上，然后可以针对某种特定的NavMesh Agent定义可行走区域。</p>
<h2 id="_36">动画</h2>
<h3 id="_37">新建动画</h3>
<p>制作动画片段：</p>
<ol>
<li>新建一个Animations文件夹等下放动画片段资源</li>
<li>选中你想要有动画效果的那个组件，选定window-&gt;Animation-&gt;Animation。</li>
<li>选择启用关键帧记录模式，然后在每个帧上修改物体组件的某个属性</li>
</ol>
<p>动画的开头和结尾常常有卡顿现象，哪怕你设置的旋转动作是0度到360度数值上是无缝对接的，仍然会有卡顿现象，你可以在曲线那里看到数值的变动是有一个切线变化率的，每一个帧都有两个切线，左切线是进入，右切线是离开，从头帧到结尾帧要想不卡顿，左右两个切线斜率必须是相同的，也就是co-linear的。</p>
<p>对于旋转动作可以将头尾两帧的双切线都改为线性。对应官方文档的 Broken-Linear模式。这样帧与帧之间是线性变化的，也就不存在那个变动斜率问题了。</p>
<h3 id="_38">导入模型动画时的可选配置</h3>
<ul>
<li>Loop Time 循环时间：动画是否循环播放</li>
<li>Root Transform Rotation 根变换旋转  Bake into pose 烘焙成动作 。下面三个根变换相关的选项都是在说你是否希望动画会实际影响模型的这些属性，比如这里就是你是否希望动画会影响模型的旋转属性，如果勾选了烘焙成动作，则动画不会影响角色的根旋转。比如说直走，则动画导入勾选这个选项。</li>
<li>Root Transform Position (Y) - 烘焙成动作。动画剪辑不会影响游戏对象的高度。大部分游戏动画剪辑都会启动此设置，只有跳跃才应该将此设置关闭，不过跳跃动画有的也只是一种原地跳姿态，然后再实际动画中用脚本去移动游戏对象。</li>
<li>Root Transform Position (XZ) - 烘焙成动作。一般角色的IDLE状态会希望启用此选项。</li>
</ul>
<p>我看到有的推荐将这三个选项都勾选上，也就是动画剪辑完全不会影响游戏对象的根运动，游戏对象的移动旋转都由脚本控制。</p>
<h3 id="animator">Animator组件</h3>
<p>控制GameObject的动画组件，需要指定动画控制器，也就是AnimationController。</p>
<p>Apply root motion：应用根运动。是从动画本身控制角色的移动和旋转还是从脚本。</p>
<p>脚本那边设置这个参数是通过 <code>animator.applyRootMotion</code> 。</p>
<p>如果脚本定义了 <code>OnAnimatorMove</code> 方法，则applyRootMotion不起作用。</p>
<p>更新模式：</p>
<ul>
<li>Normal 法线 Animator和Update同步更新</li>
<li>Animate Physics Animator和FixUpdate同步更新，即和物理系统步调一致</li>
</ul>
<p>剔除模式：</p>
<ul>
<li>总是动画化，即使在屏幕外也不剔除。</li>
</ul>
<h4 id="_39">动画状态判断</h4>
<p>动画状态判断推荐使用 <code>animator.StringToHash("State")</code> 来获取一个int型hash值然后进行状态判断。</p>
<p>具体比较是：</p>
<div class="highlight"><pre><span></span><code>CurrentStateInfo = animator.GetCurrentAnimatorStateInfo(0);
Animator.StringToHash("Run") == CurrentStateInfo.shortNameHash;
</code></pre></div>
<p>默认的图层索引是0，上面CurrentStateInfo就是当前的动画状态，<code>CurrentStateInfo.shortNameHash</code> 就是当前动画状态的短名字的Hash值，短名字的意思就是你的动画控制器那边显示的名字是Run则就是Run，前面没有默认的图层名字。</p>
<h4 id="_40">标签</h4>
<p>动画控制器的标签也是一个有用的字段方便进行一些动画控制上状态的逻辑管理。</p>
<h2 id="_41">材质</h2>
<h3 id="standard">standard着色器</h3>
<h4 id="albedo">albedo</h4>
<p>反射率，定义了材质的基本颜色，纹理也是放在这里设置的。</p>
<h4 id="metallic">metallic</h4>
<p>金属的，定义了材质的金属表现。</p>
<h4 id="smoothness">Smoothness</h4>
<p>平滑度，定义了材质的表面光滑性。一般为了看上去更真实不应该设置为0或1而是某个中间值。</p>
<h4 id="tiling">tiling</h4>
<p>平铺，定义了纹理在表面平铺重复的次数。</p>
<h4 id="offset">offset</h4>
<p>偏移，定义了纹理在表面平铺的偏移量。</p>
<h2 id="_42">光源</h2>
<p>默认的定向光可以类比太阳光，点光源可以类比灯泡，聚光灯可以类比汽车的前照灯。</p>
<p>需要强调一点的是Unity里面的灯光是游戏对象的组件，当你在空白地方新建一个灯光的时候，实际上是新建了一个空白对象然后包含了一个灯光组件。前面提到的各个灯光类型比如定向光点光源都是灯光组件的类型变量控制的，这都是可以调整的。</p>
<p>以新建一个路灯为例子，路灯有杆子和上面的立方体，给上面的立方体一个灯光组件就有了一个类似路灯的效果。</p>
<p>最后要提醒一点的是灯光只是让这个对象在发光，要让这个对象看起来在发光还需要给这个对象添加对应的发光材质。</p>
<h2 id="_43">粒子系统</h2>
<p>粒子系统可以制作出很多种效果，比如爆炸，火焰，烟雾，烟花，施法效果等。粒子系统就是空间中的一个点，从这个点出发发射一些粒子对象，从而制造出一些视觉效果。</p>
<h3 id="_44">新建一个粒子系统</h3>
<p>新建一个粒子系统，右键在世界大纲视图下新建-&gt;效果-&gt;粒子系统。你也可以将粒子系统作为某个对象的组件添加进去。</p>
<p>从粒子系统属性面板可以看到很多属性调配参数，这些更规范的叫法叫做模块，默认启用的模块有默认模块和发射模块和形状模块。除了默认模块其他模块都是可选可启用也可停用的。这么多模块和参数，慢慢熟悉吧。</p>
<h3 id="_45">默认模块</h3>
<p>显然至少默认模块的一些参数要先熟悉清楚。</p>
<ul>
<li>Duration 持续时间 粒子系统的运行时间</li>
<li>Looping 是否循环播放</li>
<li>Prewarm 预热 粒子系统从上次的循环中开始播放</li>
<li>Start Delay 启动延迟 发射粒子之前等待的时间，不能和预热共存。</li>
<li>Start Lifetime 每个粒子的存活时间，单位是秒</li>
<li>Start Speed 粒子的初始速度</li>
<li>Start Size 粒子的初始大小</li>
<li>Start Rotation 粒子的初始旋转角度</li>
<li>翻转旋转 某些粒子向反方向旋转</li>
<li>Start Color 粒子的起始颜色</li>
<li>重力修改器 应用于粒子的重力修改器</li>
<li>模拟空间 指定坐标是本地局部坐标系还是世界坐标系</li>
<li>模拟速度 微调粒子系统的播放速度</li>
<li>时间差 粒子系统的时间是基于缩放时间还是非缩放时间</li>
<li>缩放模式 缩放是基于游戏对象的父对象还是发射器的形状</li>
<li>唤醒时播放 创建粒子系统时就开始辐射粒子</li>
<li>发射器速度 速度的计算是基于对象的变换还是它的刚体</li>
<li>最大粒子 粒子可以存在的最大数目，如果达到最大数目，粒子系统将暂停新粒子生成。</li>
<li>自动随机种子 每次播放粒子系统选择不同的随机种子</li>
<li>停止行动 选择粒子系统停止播放时执行什么动作</li>
</ul>
<h3 id="_46">发射模块</h3>
<ul>
<li>Rate over time 随单位时间产生的粒子数，即每秒发射的粒子数目</li>
<li>Rate over distance 每Unit单位发射的粒子数目</li>
<li>bursts 爆发，突变。在某个特定时间内突然发射额外的粒子</li>
</ul>
<h3 id="_47">形状模块</h3>
<p>这个确定的是发射器，或者说发射的粒子们组成的形状。</p>
<h2 id="_48">开始菜单</h2>
<p>开始菜单就是另外一个场景地图，其是一个2d场景地图，在开发的时候视图中间偏左有个选项，激活了场景处于2d视图中。然后就是在这个场景中添加一些UI元素即构成了开始菜单。</p>
<h2 id="_49">多场景无缝切换</h2>
<h2 id="respawn">respawn玩家角色</h2>
<p>一般都是如下respawn玩家角色：</p>
<div class="highlight"><pre><span></span><code>        player.transform.position = spawnPoint.position;
        player.transform.rotation = spawnPoint.rotation;
</code></pre></div>
<p>Unity游戏开发一书就是这样写的，然而现在不可以了。 <a href="https://www.youtube.com/watch?v=FPU3uR3HYGo">这个视频</a> 说了需要把项目设置的Physics的 <code>Auto Sync Transforms</code> 勾选上，一试果然就可以了。看了下Unity文档，Unity的物理系统默认没有勾选上，也就是你的transform属性硬修改Unity的物理系统是没有跟上同步的，然后Unity文档又说了这个自动勾选上开销会有一些，所以最好在需要硬修改的地方加上：</p>
<div class="highlight"><pre><span></span><code>        player.transform.position = spawnPoint.position;
        player.transform.rotation = spawnPoint.rotation;
        Physics.SyncTransforms();
</code></pre></div>
<h2 id="_50">单元测试</h2>
<p>按照C#的方法，自动创建了一个单元测试项目。即使是空白单元测试也会报错：</p>
<div class="highlight"><pre><span></span><code>CS0006 could not found file Assembly-CSharp.dll
</code></pre></div>
<p>大概这个错误，我好不容易才在 <a href="https://developercommunity.visualstudio.com/t/vs-doesnt-put-binaries-of-unity-project-to-output/785717">这个网页</a> 知道Unity项目在visual studio中默认是不自动完成生成项目的，你需要在：</p>
<div class="highlight"><pre><span></span><code>工具 -&gt;  选项 -&gt; 适用于Unity的工具 -&gt; 杂项 -&gt; 禁止完整生成项目
</code></pre></div>
<h2 id="_51">雾效</h2>
<p>在 window-&gt;渲染-&gt;照明设置那里勾选雾，则可以为你的场景打开雾效。</p>
<h2 id="skybox">skybox</h2>
<p>天空盒就是在天空那个巨大盒子上应用你想要的材质。可以新建一个材质，然后这个材质在stardard着色器那里选择skybox，从而快速创建一个skybox材质，然后在 window-&gt;渲染-&gt;照明设置 那里应用该skybox材质。</p>
<h2 id="_52">日志</h2>
<p>早期调试Debug.Log基本上只是一个打印信息功能，但后面随着项目完善Debug日志就要开始慢慢规范了，也需要考虑下面方法来显示不同信息：</p>
<div class="highlight"><pre><span></span><code>Debug.LogError
Debug.LogWarning
</code></pre></div>
<p>在终端可见的这些日志信息对于正式游戏运行版本也是有的，还有游戏调试版本也会显示这些日志信息，具体日志文件在那里请参阅  <a href="https://docs.unity3d.com/Manual/LogFiles.html">官方文档的这里</a> 。</p>
<p>Windows下玩家的日志在：<code>%USERPROFILE%\AppData\LocalLow\CompanyName\ProductName\Player.log</code> 。</p>
<h2 id="_53">其他</h2>
<h3 id="unityc">查看你使用的Unity的C#版本</h3>
<p>这个其实很重要的，最好先查看清楚，免得后面因为一些版本细节问题纠结半天。目前笔者使用的是Unity2019.4，从 <a href="https://docs.unity3d.com/2019.4/Documentation/Manual/CSharpCompiler.html">这个网页</a> 来看，它使用的是 .net 4.6，使用的C#版本是7.3，并不是C#8，有些差异还是需要特别注意的。</p>
<p>之前的一个问题解释清楚了，我这边使用的是.net framework4.6，并没有 <code>System.HashCode</code> 这个方法。</p>
<h3 id="visual-studio_1">visual studio快速方法输入</h3>
<p><code>Ctrl+Shift+M</code> 在visual studio 上调出Unity快速方法输入。</p>
<h3 id="requirecomponent">RequireComponent</h3>
<div class="highlight"><pre><span></span><code>[RequireComponent(typeof(PlayerInput))]
public class PlayerScript : MonoBehaviour
{
//
}
</code></pre></div>
<p>脚本将会自动添加给本GameObject添加某个组件来确保本GameObject的组件依赖正确。</p>
<h3 id="_54">默认单位</h3>
<p>Unity术语里面长度用的是 1unit，比如velocity 用的每秒移动的unit。比如1unit等于多少并没有一个准数的，要看你自己那边的建模规范。</p>
<h3 id="_55">平台相关编译代码</h3>
<div class="highlight"><pre><span></span><code>#if UNITY_EDITOR

#endif
</code></pre></div>
<p>这段宏定义了中间的一些代码调用Unity Editor的脚本，也就是依赖Unity Editor环境的。</p>
<h2 id="_56">备用</h2>
<h3 id="_57">移动控制</h3>
<p><code>Input.GetAxis(axis_name)</code> 获取当前控制轴的值，比如Horizontal axis 方向left和 a键为-1，right和d为1。</p>
<h3 id="transformtranslaterigidbodymoveposition">transform.Translate和Rigidbody.MovePosition</h3>
<p>经过试验结论如下，在速度特别快的情况下两个都可能发生避开物理碰撞系统而发生穿模，速度很低的情况下两个也都不会穿模。不过在速度中等的情况下，用Transform的translate方法移动物体仍时不时会避开物理刚体碰撞系统，而在这种情况下刚体的MovePosition就表现要好一下。</p>
<p>此外FixUpdate的固定时间设定也会很好地防止物体移动速度不可捉摸的突变情况。</p>
<h3 id="_58">地形绘制纹理</h3>
<p>主要是编辑图形层那里，显示创建图层，再是添加图层。在这些图层里面利用不同的笔刷进行绘制。</p>
<p>笔刷的不透明度是笔刷的力度。</p>
<h3 id="fmod">FMOD音效集成</h3>
<p>FMOD集成音效</p>
<h3 id="makehuman">Makehuman工具</h3>
<p>Makehuman工具</p>

        </div>
        <section>
        <div class="col-md-2" style="float:right;font-size:0.9em;">
            <h4>首发于：</h4>
            <time pubdate="pubdate" datetime="2021-05-25T19:41:10.504103+08:00">2021年 5月 25日 </time>

            <h4>最近更新于：</h4>
            <time datetime="2021-05-25T19:41:10.504103+08:00">2021年 5月 25日 </time>


            <h4>分类：</h4>
            <a class="category-link" href="https://a358003542.github.io/categories.html#you-xi-kai-fa-ref">游戏开发</a>

        </div>
        </section>
</div>
</article>
    </div>
    <div class="col-md-1"></div>

</div>


<div id="push"></div>
<button id="gotop" type="button" class="btn btn-default">
    <span class="glyphicon glyphicon-arrow-up" aria-hidden="true"></span>
</button>

<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a> and updated by <a href="https://github.com/a358003542" title="wanze Home Page">wanze</a></li>
    </ul>
</div>
</footer>

        <script src="https://a358003542.github.io/theme/js/jquery.min.js"></script>
    <script src="https://a358003542.github.io/theme/js/bootstrap.min.js"></script>

    <script src="https://a358003542.github.io/theme/js/moment.min.js"></script>

    <script src="https://a358003542.github.io/theme/js/base.js"></script>



</body>
</html>