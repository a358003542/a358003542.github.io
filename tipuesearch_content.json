{
    "pages":[
        {
            "title":"页面未找到... wanze的博文\r\n",
            "text":"\n\n\n\n\n\n\n\n\n\n\n\n页面未找到... wanze的博文\r\n\n\n\n\n\n\n\r\n        #gotop {\r\n            display:none;\r\n        }\r\n    \n\n\n\n\n\n\nNavigation\n\n\n\n\n网站首页\n\n\n\n\n\n\n搜索\n\n\n\n所有文章\n文章分类\n文章标签\n\n关于本网站\n\n\n\n\n\n\n\n\n\n\n页面不存在!\n\n\n\n\n不好意思，您试图查看的页面不存在。可能该页面并不存在或者已经不存在了或者已经被移动了。\n你可以试着下面的搜索栏来查找该文章看看。\n\n\n\n\n搜索\n\n\n\n\n\n\n\n\n\n\n\n\n\nPowered by Pelican. Theme: Elegant by Talha Mansoor and updated by wanze\n\n\n\n\n\n\n\n",
            "tags":"",
            "url":"https://a358003542.github.io/404.html"
        },
        {
            "title":"关于本网站",
            "text":"来到 网站   希望 网站 文章 。   作者   DISQUS   评论 配置 很 ， GFW 原因 会 网页 加载 慢 ， 舍弃 。   ， 作者 ， 作者 邮箱 ：   a358003542 @ outlook .   LISENSE   网站 文章 版权 作者 ， 读者 阅读 学习 研究 ， 极小 复制粘贴 ， 请勿 抄袭 。 【 读者 私底下 一个 人 自我 学习 保存 ， 。 】",
            "tags":"others",
            "url":"about.html"
        },
        {
            "title":"奇点书虫",
            "text":"屏幕 上 汇出 轨道 路线图 ， 竟然 横跨 大半个 星系 ， 终点 一个 漩涡 般的 奇点 。   开启 光速 运动 模式 ， 休眠 仓 。 飞船 好像 道光 打出 一个 完美 椭圆 轨道 线 。   飞船 很 靠近 漩涡 般的 奇点 。   开启 手动 飞行 ， ， 成功 穿过 奇点 一件 令人 提心吊胆 事情 。   精神 高度 紧张 ， 眼睛 浮现 技术参数 ， 时不时 飞行 上 调整 。   飞船 晃 ， 变得 好像 飞行 方向 漫无目的 漂游 。   飞船 上 重力 系统 失效 ， 实际上 穿越 奇点 最 关键 几秒 飞船 上 智能 程序 会 飞船 都 调为 停电 状态 。 慢慢 飞船 上 智能 程序 打开 路灯 。 安提娜 说道 ： 长官 ， 飞船 系统 都 运行 ， 重力 系统 几分钟 后 恢复 ， 穿越 奇点 很 顺利 。   那颗 悬 心 变得 愉悦 ， 回应 ： 好 ， 谢谢 ， 安提娜 。   飞船 重力 系统启动 ， 站 正 去 喝杯 饮料 ， 一个 东西 撞 飞船 ， 声音 很 沉重 。   奇点 书虫 相遇 ， 很 偶然 ， 称之为 奇点 书虫 缘分 。   还 名字 ， 实际上 不 官方 名字 ， 看 形状 一个 老 乌龟 ， 一个 惯于 沉默 老 乌龟 。 一个 太空 中 漂浮 老 乌龟 ， 上天 旨意 ， 客厅 养 ， 马上 一个 神奇 能力 ， 飞船 客厅 变得 很大 很大 ， 飞船 外面 来看 ， 安提娜 报告 飞行数据 来看 异样 。   老 乌龟 刚上 飞船 都 很 好奇 ， 左 东 闻闻 ， 安分 不少 ， 安提娜 说话 抬起 头 很感兴趣 样子 ， 一段时间 倦怠 。 客厅 上 读书 ， 老 乌龟 竟然 凑 上 ， 听 还 显得 很 兴奋 摇尾巴 ， 好玩 。   奇点 上 观察 繁重 ， 无暇顾及 老 乌龟 ， 偶尔 老 乌龟 倦怠 懒懒 样子 ， 不 太 在意 ， 穿过 客厅 ， 听到 一个 奇怪 声音 ， 声音 好像 飞船 外面 传过来 ， 吓了一跳 ： \" 人类 ， 读书 听 ， 信息 ， 信息 。 \"   相处 时光 中 ， 很 艰难 只 老 乌龟 交流 ， 终于 拼凑出 事实 ： 大概 很久很久 ， 估计 不 太 ， 两个 环绕 运动 行星 ， 轨道 竟然 发生 偏离 发生 碰撞 ， 碰撞 过后 两个 行星 环绕 而行 ， 撒下 一圈 行星 带 ， 老 乌龟 行星 带 一个 石头 。   发现 老 乌龟 世界 信息 很 痴迷 ， 痴迷 不 像是 一种 喜好 ， 更 像是 吃 东西 。 老 乌龟 长时间 吃 不到 信息 会 陷入 类似 石头 那种 都 不动 状态 ， 吃 很多 信息 ， 精神 会 变好 ， 还 变得 很 健谈 ， 健谈 指 来说 。 从安 提娜 扫描 数据 来看 ， 吃 信息 身体 石头 般的 构造 类似 血管 般的 东西 ， 流动 。   说起 老 乌龟 取名字 ， 大概 教 安 提娜 互动 ， 有趣 发现 整晚 整晚 听 书 ， 加上 想到 吃 信息 这件 事 ， 实在 配 上书 虫 称号 。",
            "tags":"novel",
            "url":"articles/qi-dian-shu-chong.html"
        },
        {
            "title":"2020随笔",
            "text":"5 - 20   \" 无巧不成书 。 \" 常见 俗语 里 大 智慧 ， 值得 反复 思考 。   \" 先写 ， 再 写 好 。 \"   学习 别人 写 好 要素 ， 要素 组合 ， 称之为 美的 组合 术 。   5 - 1   人 再 孤独 ， 都 一个 朋友 ， 朋友 。   4 - 28   当多 谈论 些 天人感应 ， 少谈些 周易 预测 。 周易 预测 是术 ， 术 自得其乐 授之于 ， 天人感应 才 周易 预测 ， 天人感应 就算 术 无咎 ， 但若失 而独 谈论 术 ， 危险 。   4 - 12   人子 生活 本身 一种 创造 ， 天人合一 ， 如同 上天 创造 生活 。   4 - 7   心即 理 ， 心 私欲 阻隔 ， 便是 天理 。 — — 王阳明   【 批判 参考 】   终极 — — 造物主 — — ， 去 创造 。 去 创造 ， 才能 经验 造物主 。 — — 《 神 对话 【 批判 参考 】   4 - 6   小说家 来说 一个 好 追求 作品 都 一个 世界 一个 世界观 中 。   【 银河帝国 前 两部 观感 】   去掉 标签 崇拜 因素 ， 单从 作品 本身 角度 来说 ， 阅读 体验 来说 故事 太 过于 碎片 化 ， 情节 对话 推动 ， 文学 角度 来说 作者 文学 功力 还 很 稚嫩 。 长篇 还 没 看 ， 也许 会 改观 ， 时间 ， 读过 两部 来说 ， 只能 说 70 分 ， 一读 。   说 基地 心理 史学 推演 种 宿命论 ， 科幻 作品 本质 上 仍 文学作品 ， 科幻 因素 表现 文学作品 主题 加上 去 ， 说 科幻 科幻 ， 主题 无关 科幻 甜点 ， 加多 反而 会坏 菜 味道 ， 加 少量 调剂 入 不了 读者 内心 。 浸透 读者 内心 久久 不能忘怀 科幻 创新 文学作品 主题 相互 相成 。   4 - 5   对比 国外 新闻 网站 ， 大 纪元 网站 有失 偏颇 ， 明眼人 一眼 看 ， 网站 不 做 讨论 。 美国之音 网站 新闻 大概 有失 偏颇 ， 有失 偏颇 更 是因为 站 美国 立场 上 ， 有失 偏颇 国内 新闻 网站 有失 偏颇 站 国内 立场 上 等同 ， 接受 。 BBC 新闻 华尔街日报 阅读 发现 两个 网站 新闻 站 美国 立场 上 站 英国 立场 上 很 那种 文章 ， 两个 网站 国内 网络 监察 封杀 国内 网络 监察 更 针对 内容 中共 控制 。 网站 自我 内容 审查 ， facebook youtube 内部 内容 审查 ， 不 接受 中共 控制 ， 中共 网络 监察 封杀 。 类比 梵蒂冈 基督教 不 接受 中共 教区长 任命 指派 ， 基督教 中共 打压 状态 ， 中共 控制 东西 本性 都 不好 。   凡事 皆 可不 。   4 - 4   大部分 人 来说 ， 逝者 点上 一支 蜡烛 作出 形式 仪式 都 ， 在生活中 多行 一善 对人少 做 一恶 极其 困难 。 想 上天 肯定 愚蠢 仪式 形式 欺骗 ， 善恶 赏罚 高明 糊弄 。 世界 愚蠢 邪恶 从来 都 改变 ， 突发事件 ， 人 愚蠢 邪恶 ， 影响 。 少 谈点 类 废话 ， 冷冷地 看着 微笑 好 。   4 - 2   人 身上 某种 神性 ， 神性 来自 宇宙 本身 ， 人 归根结底 宇宙 一部分 ， 神性 人 宇宙 某种 律动 需求 。 中国 人 更 熟悉 词汇 那种 天人合一 精神 需求 。   机器学习 算法 都 给定 一个 标签 ， 就算 将来 高级 机器人 智能算法 ， 给定 机器人 一个 目的 。 机器人 动物 某种 目的 效益 解释 ， 设计 多种 机器 智能 类似 动物 。 人 机器 智能 区别 在于 人能 创造 ， 创造 局限 数据 层面 层面 创造 ， 将来 几千年 后 机器 智能算法 模拟 。 最 核心 区别 ， 人 创造 意义 ， 机器 智能 困难 ， 未来 几万年 更 远 未来 ， 机器 智能 创造 意义 ， 请 人类 公民 身份 ， 人 智能 无 区别 ， ， 神性 ， 宇宙 上 天大 计划 一部分 。   正是 人 智能 创造 意义 ， 更 具体来说 ， 目的 追寻 ， 目的 本身 意味着 意义 ， 基于 天人合一 内在 精神 需求 ， 宇宙 发展 角度 出发 ， 某种 美学 角度 出发 ， 更 底层 不 谈及 不 自觉 大脑 活动 ， 创造 活动 ， 最小 理念 模版 ， 起源 原型 ， 变种 原型 再 加工 再 创造 ， 内在 精神 需求 — — 看起来 最 现实主义 人 身上 不 例外 — — 都 人 谈及 神性 。   4 - 1   故事 故事 实在 道理 ， 历史 故事 科幻小说 ， 剖开 本质 ， 会 发现 过往 诸多 事才 事 内核 。 小说 故事 相 梦 来说 更 清晰 连贯 ， 其本质 都 ， 过往 诸多 事 要素 再 整理 再 创造 。 阿西莫夫 《 银河帝国 一书 心理 史学 历史 标的 ， 脱离 不了 现有 历史 发展 模式 。 第一篇 有太多 苏格拉底 论辩 痕迹 ， 后续 发展 类比 基督教 黑暗 中世纪 历史 。   人 创造 活动 要素 都 先起 始于 一个 现实 中 原型 ， 再 修改 加工 ， 解构 重组 。 后续 工作 ， 最 起源 原型 变种 类似 进化树 ， 变异 创造 活动 作者 世界观 架构 中 都 变种 作者 创造 世界 中 融洽 。   谈及 现实 原型 更 确切 表述 起源 原型 ， 最 原型 人 创造 。 并不比 变种 创造 多出 某种 现实性 。 现实 评判 约束 人 创造 活动 不 理解 人 创造 活动 ， 现实 转眼 即逝 特性 显得 很 之外 ， 理解 现实 本身 人 创造 能力 上 。   起源 原型 很多 便利 ： 更 易于 别人 接受 ， 创造 消耗 精力 少 基本上 从外 世界 现有 原型 中 抽取 而成 ， 外 世界 本身 一个 融洽 体系 ， 起源 原型 内部 组件 融洽 。   起源 原型 再 创造 变种 原型 一个 很 消耗 精力 活动 ， 做 不好 会 不 别人 接受 ， 内部 组件 很难 融洽 协调 。 创造 一个 成功 变种 原型 会 一件 很 事 ， 不 避讳 词 ， 创造 正是 人之为 人 处 。   一个 好 世界 设计 显露出 世界 运动 目的 方向 ， 世界 意义 启迪 。 深信 现有 世界 某种 purpose 。   3 - 30   阅读 阿西莫夫 《 银河帝国 ， 提到 多个 行星 会 自转 速率 ， 日夜 颠倒 ， 一律 采用 银河 标准 时间 。 同意 多个 行星 间 会 采用 某种 银河 标准 时间 ， 具体来说 地球 纪年 法将会 全 地球 文明 圈 通用 ， 不 会 日夜 颠倒 ， 天 概念 会 遵从 当地 标准 ，   多个 行星 中 会 采用 历法   。   3 - 23   人 寻求 快乐 本性 ， 这本 好 说 。 智慧 去 追求 ， 追求 说 更 直白 一点 追求 无痛苦 。   生活 道路 ， 保证 某种 光荣 结局 ， 由此 出发 ， 深刻 轻浮 ， 方向 ， 都 人 。   人为 过往 纠结 都 愚蠢 ， 智慧 思绪 只 在于 未来 无痛苦 ， 快乐 痛苦 都 ， 负 全责 ， 谁又能 再 提出 半点 责难 。 说 处境 ， 清晰 审慎 现有 ， 坦然 接受 加诸 于身 运命 ， 例外 。   温故而知新 ， 为师 。 — — 孔子 谈 学习   3 - 18   谈论 自由 ， 更 源于 不 自由 ； 谈论 自由 意志 ， 更 源于 不得不 遵从 意志 。 言语 命令 ； 欲念 本能 ， 称得上 自由 意志 。   上天 无所不知 无所不能 ， 好 坏 ， 容忍 人 无边 自由 意志 ， 如果说 上天 容许 少许 人 自由 意志 ， 无关紧要 。 智者 努力 聆听 上天 言语 遵从 上天 意志 ， 无非 自保 自求多福 。 善恶 也许 只 人 一念之间 ， 都 逃不过 上天 眼睛 管理 。   言语 分为 三种 ： 天言 ， 己言 ， 人 言 。 人 言 讨论 某种 现象 ， 参考 ， 放在 身上 出错 ； 己言 个体 人 知识 能力 局限性 ， 己言 带有 很大 局限性 ； 唯有 天言 ， 无所不知 上天 言语 ， 值得 去 努力 聆听 遵从 。   3 - 17   规划 时间 ， 过好 精神 生活 。   3 - 16   一个 人 只能 活在 意识 之中 。 — — 叔本华   发生 事情 都 发生 意识 。 — — 叔本华   — — 古希腊 铭言   闲暇 时光 人生 精华 。 — — 叔本华   人 幸福 在于 无拘无束 施展 人 才能 。 — — 亚里士多德   离开 世界 ， 世界 照样 愚蠢 邪恶 ， 刚 来到 世界 发现 两样 。 — — 伏尔泰   3 - 15   冥想 散步 有益 活动 ， 记得 常做 。   3 - 2   看待 别人 ， 看待 ； 看待 上 ， 事实 ， 持有 何种 观点 。 荣誉 成就 事实 有助于 自我 良善 观点 ， 荣誉 成就 事实 都 不值一文 。   接下来 做 何种 事情 。   2 - 13   摘自 【 叔本华 - 人生 智慧 】   \" 菲利斯丁 \" 性格 特征 枯燥无味 气质 滞钝 ， 活像 动物 。 感官 乐趣 耗竭 ， 东西 刺激 、 使 喜欢 ， 社交生活 瞬间 一种 负担 ， 玩牌 提不起 兴趣 。 ， 虚荣 留给 快感 ， 自以为是 享受 快乐 ， 财富 、 地位 、 影响 权力 上 优越 ， 常替 权势 人 奔走 ， 自觉 沐浴 光耀 扬扬自得 ， 英国人 所称 势利 鬼 ， 可悲 ！   ， \" 菲利斯丁 \" 本质 推出 ， \" \" ， 肉体 ， 才智 ， 寻找 活动 。 绝不会 朋友 具备 才能 ； 后者 使 自卑感 一份 不愿 、 深深 嫉妒 ， 碰上 才能 人 ， 只会 厌恶 ， 痛恨 。 心中 才智 嫉妒 会 转成 秘密 怨恨 。 仍 为此 改变 价值观念 ， 符合 才智 之士 标准 ， 依然 喜欢 地位 、 财富 、 权力 影响力 ， 希望 样样 都 擅长 ， 眼中 ， 世界 上 利益 。   所提 种种 乃是 知识 欲 。 菲利斯丁 苦恼 ， 在于 缺乏 理念 ， ， 逃避 \" 厌倦 \" ， 需 现实 弥补 空虚 心灵 。 ， 现实 令人 失望 充满 危险 ， 丧失 现实 兴趣 ， 疲惫 会 乘虚而入 。 理念 世界 无限 平静 世界 ， 远离 世间 忧患 烦扰 。   2 - 3   猎魔 人 小说 湖中 女士 ： 本来 想 三星 ， 系列 终章 虽有 四星 。 如果说 火 洗礼 90 分 ， 雨燕 之塔 88 分 ， 湖中 女士 评分 80 分 。 姑且 不说 做梦 桥段 凑 字数 嫌疑 ， 说 说 本作 最 核心 东西 ， 不快 失望 ， 从火 洗礼 感受 神作 气息 ， 而本作 只 感受 地摊 爽文 气息 。 通向 心目 中 大结局 ， 作者 希望 矫揉造作 ， 过程 中 ， 很多 桥段 设计 粗陋 低劣 ， 背后 明眼人 一眼 中 作者 欲念 人 不快 偏见 喜好 ， 对比 米 尔瓦 安 古兰 作者 设计 桥段 待遇 ， 只好 抱歉 问候 作者 一句 ， 喜欢 十几岁 少女 。   2 - 1   生活 一个 鼓吹 成功 时代 ， 大 成功 大 计划 聒噪 琐粹 日常 新闻 鲜明 对比 。 想 至少 人 ， 批评 三分钟 热度 ， 包括 自我 评判 ， 某时 疏忽 潜意识 自我 投射 ， 。   宇宙 中 长远 计划 不感兴趣   。 就让 定下 下个 三分钟 计划 ， 倾注 热情 ， 脑海 里 超过 三分钟 计划 都 通通 见鬼 去 ， 成功 都 见鬼 去 ， 都 滚 世界末日 去 。 【 三分钟 一个 代指 ， 代指 短 一个 兴趣 使然 时间段 】   自由 ， 我要 时时 提醒 一点 好 不 忘 自我 本性 。 自由 更 深切 含义 凡事 皆 可不 。   猎魔 人 系列小说 特色 看不到 一个 好人 ， 希里 客观 角度 出发 杀生 太 ， 正 猎魔 人 慢慢 走希里 主线 ， 小说 横 捭阖 ， 少 杰洛特 线 那种 思辨 纠葛 ， 小说 性 提升 ， 文学性 慢慢 减分 。 杰洛特 第一 男主角 ， 这句 话 ： 一个 人类 。 一个 英雄式 主角 冷冷地 看着 乱世 ， 更 关切 报酬 ， 心愿 I       choose     。 猎魔 人 小说 两部 故事 推向 结局 ， 文学性 却是 杰洛特 几部 ， 打动 心 ， 在我心中 留下 文学 形象 杰洛特 几部   1 - 25   头脑 中有 高 道理 ， 却 一句 话 都 说不出来 。   长远 计划 有限 时光 无限 时空 都 无 意义 ， 时光 有限 ， 长远 计划 太 过于 遥远 ； 时空 无限 ， 渺小 计划 。 眼中 当下 计划 ， 投入 精力 去 。 遗忘 ， ， 都 无时无刻 不地 透漏 计划 。   1 - 14   说 ， 编程 一种 乐趣 ， 年龄 见鬼 去 ， 万物 易变 万物 皆 死 世界 ， 乐趣 永存 。   1 - 10   不 不 未来 ； 不 眼目 中 、 口舌 中 ， 不 想象 中 。 ， 。   1 - 4   爱 ！   1 - 1   昙花一现 外 现实 世界 来说 ， 非 做 事 ， 几件 最 做 事情 。",
            "tags":"essay",
            "url":"articles/2020-essay.html"
        },
        {
            "title":"CPP语言学习笔记",
            "text":"前言   教程 参考   github 样例 项目   阅读 更 。   本文 假定 读者 学会 C语言 ， 请 先 学习 C语言 ， 不 冲突 。 读者 参看 笔者 写   C语言 学习 笔记 一文   。   CPP 语言 开发 环境   CPP 语言 开发 环境 推荐 visual   studio 。     world   # include   < iostream >   int   main   (   void   )   {     namespace   std   ;   cout   < <   \"   world ! \"   ;   cout   < <   endl   ;   return   0   ;   }   头文件 扩展名   cpp 新 风格 头文件 扩展名 ，   iostream     iostream   ， . h . hpp ，   namespace   std   。 旧 风格 大体 类似 C语言 带上   . h   后缀 。   命名 空间   算是 C语言 很大 一个 不同点 ， 命名 空间 概念 熟悉 编程 人 来说 一个 默认 概念 ， 大体 类似 python 模块 名 ， 编程语言 类似 概念 。 ：   Microflot   : :     (   \" \"   ) ;   GooGloo   : :     (   \" \"   ) ;   一个 调用 命名 空间 Microflot 函数 ， 一个 调用 GooGloo 命令 空间 函数 。   world 程序     namespace   std ;   写 ：   # include   < iostream >   int   main ( void )   {   / /   namespace   std ;   std : : cout   < <   \"   world ! \" ;   std : : cout   < <   std : : endl ;   return   0 ;   }   类似 python       import   *   函数 名 都 给导 进来 ， cin ， cout 。 一种 推荐 做法 ：     std   : :   cout   ;     std   : :   endl   ;   大体 类似 python       import   cout   ， 导入 函数 名 。   cout 对象   cout 一个 对象 ， 内部 方法 打印 字符串 。   cout   < <   \" string \" ;   代码 过程 cout 对象 调用 插入 运算符   < <   ， 执行 操作 字符串 插入 输出 流中 。   std : : endl 一个 C++ 符号   【 换行符 ？ 】 ， 插入 输出 流将 导致 屏幕 光标 换行 。   cout   < <   25   ;   ，   cout 打印 int 数值 。   声明 变量   cpp c 语言 区别 cpp 推荐 首次 变量 声明 文件 开头 。   # include   < iostream >   int   main   (   void   )   {     namespace   std   ;   int   x   ;   int   y   ;   cout   < <   \"   input     x   :   \"   ;   cin   > >   x   ;   cout   < <   \"   input     y   :   \"   ;   cin   > >   y   ;   cout   < <   \" x   +   y   =   \"   < <   x   +   y   < <   endl   ;   return   0   ;   }   cin   cout 相 C语言 一套 实在 ， cout 简单 字符串 拼接 操作 。   定义 函数   # include   < iostream >   int   add   (   int   a   ,   int   b   )   {   return   a   +   b   ;   }   int   add   (   int   ,   int   ) ;   int   main   (   void   )   {     namespace   std   ;   int   x   ;   int   y   ;   cout   < <   \"   input     x   :   \"   ;   cin   > >   x   ;   cout   < <   \"   input     y   :   \"   ;   cin   > >   y   ;   cout   < <   \" x   +   y   =   \"   < <   add   (   x   ,   y   )   < <   endl   ;   return   0   ;   }   cpp c 语言 函数 定义 函数 原型 声明 这块 来说 区别 太 大 。 熟悉 C语言 这块 简单 温习 下 好 。   CPP 数据类型   整型 ： short ， int ， long     long   long   。 说服力 理由 应 int 。   char 类型 ： char 类型 用于 存储 一个 字节 大小 字符 ， 用于 存储 short 更 小 整型 。   bool 类型 ： true     false   符号 常量 修饰符 ： const   浮点数 类型 ： float 、 double 、 long   double 。   1 ． 编写 一个 小 程序 ， 用户 一个 整数 指出 身高 （ 单位 英寸 ） ， 身高 转换 英尺 英寸 【 取 整部 分为 英尺 余下 英寸 】 。 程序 下划线 字符 指示 输入 位置 。 ， 一个 const 符号 常量 转换 因子 。   inch2foot . cpp   # include   < iostream >   # include   < cmath >   const   int   CONVERSION   =   12   ;   int   main   (   void   )   {     namespace   std   ;   int   height _ inch   ;   cout   < <   \"   input     height       inch :   \"   ;   cin   > >   height _ inch   ;     (   height _ inch   %   CONVERSION   = =   0   )   {   cout   < <   \"   height       \"   < <   height _ inch   /   CONVERSION   < <   \"   foots . \"   < <   endl   ;   }     {   cout   < <   \"   height       \"   < <   height _ inch   /   CONVERSION   < <   \"   foots     \"   < <   height _ inch   %   CONVERSION   < <   \" inchs . \"   < <   endl   ;   }   return   0   ;   }   3 ． 编写 一个 程序 ， 用户 以度 、 分 、 秒 方式 输入 一个 纬度 ， 以度 单位 显示 纬度 。 1 度为 60 分 ， 1 分 等于 60 秒 ， 请以 符号 常量 方式 值 。 输入 值 ， 应 一个 独立 变量 存储 。 程序运行 时 情况 ：   _ degress . cpp   # include   < iostream >   # include   < cmath >   const   float   CONVERSION   =   60   ;   int   main   (   void   )   {     namespace   std   ;   int   degrees   ;   int   minutes   ;   int   seconds   ;   float   result   ;   cout   < <   \" Enter   a   latitude     degrees ,   minutes ,     seconds : \"   < <   endl   ;   cout   < <   \" First ,   enter     degrees :   \"   ;   cin   > >   degrees   ;   cout   < <   \" Next ,   enter     minutes     arc :   \"   ;   cin   > >   minutes   ;   cout   < <   \" Finally ,   enter     seconds     arc :   \"   ;   cin   > >   seconds   ;   result   =   degrees   +   minutes   /   CONVERSION   +   seconds   /   (   CONVERSION   *   CONVERSION   ) ;   cout   < <   degrees   < <   \"   degrees ,   \"   < <   minutes   < <   \"   minutes ,   \"   < <   seconds   < <   \"   seconds   =   \"   < <   result   < <   \"   degrees . \"   < <   endl   ;   return   0   ;   }   5 ． 编写 一个 程序 ， 用户 输入 全球 人口 美国 人口 （ 国家 人口 ） 。 信息 存储 long   long 变量 中 ， 程序 显示 美国 （ 国家 ） 人口 占 全球 人口 百分比 。 程序 输出 应 类似 ：   usa _ population . cpp   # include   < iostream >   # include   < cmath >   int   main   (   void   )   {     namespace   std   ;   long   long   word _ population   ;   long   long   usa _ population   ;   float   population _ ratio   ;   cout   < <   \" Enter     world ' s   population :   \"   ;   cin   > >   word _ population   ;   cout   < <   \" Enter     population       US :   \"   ;   cin   > >   usa _ population   ;   population _ ratio   =   (   float   )   usa _ population   /   word _ population   *   100   ;   cout   < <   \" The   population       US     \"   < <   population _ ratio   < <   \" %       world   population . \"   < <   endl   ;   return   0   ;   }   7 ． 编写 一个 程序 ， 用户 欧洲 风格 输入 汽车 耗油量 （ 100 公里 消耗 汽油 量 （ 升 ） ） ， 转换 美国 风格 耗油量 — 每加仑 英里 。 ， 单位 计量 外 ， 美国 方法 （ 距离 / 燃料 ） 欧洲 方法 （ 燃料 / 距离 ） 。 100 公里 等于 62.14 英里 ， 1 加仑 等于 3.875 升 。 ， 19mpg 合 12.4 l / 100km ， 27mpg 合 8.71 / 100km 。   _ usa _ mpg . cpp   # include   < iostream >   # include   < cmath >   int   main   (   void   )   {     namespace   std   ;   float   eu _ fuel   ;   int   usa _ mpg   ;   const   float   KILOMETER _ CONVERT _ MILES   =   0.6214   ;   const   float   GALLON _ CONVERT _ LITERS   =   3.875   ;   cout   < <   \" Please   input         car     fuel [ unit   liter ]     running   100   kilometers :   \"   ;   cin   > >   eu _ fuel   ;   usa _ mpg   =   (   int   ) (   100   *   KILOMETER _ CONVERT _ MILES   )   /   (   eu _ fuel   /   GALLON _ CONVERT _ LITERS   ) ;   cout   < <   \" The   mpg     car     usa   standard     :   \"   < <   usa _ mpg   < <   endl   ;   return   0   ;   }   long   totals [ 500 ]   =   { 0 } ;   / / 初始化 一个 500 元素 数组 ， 索引 0 元素 设值 0 ， 元素 自动 设值 0 。   ：   long   totals [ 500 ]   =   { }   ;   / /   元素 都 自动 设值 0 。   字符串 类型 ， C 意义 上 来说 字符串 类型 ， C语言 风格 字符串 略过 讨论 ， C++ 添加 string 类 ， 包含 头文件 string ， string 类 。   string   str1 ;   str1   =   \" abc \" ;   熟悉 C语言 风格 字符串 一个 区别 ， 初始化 字符串 变量 ， 不 操作 数组 长度 东西 ， 好 改进 ！   C语言 风格 字符串 不 一个 字符串 值 赋值 一个 字符串 ， string 类 做 ：   string   str1 ;   string   str2   =   \" abc \" ;   str1   =   str2 ;   cout   < <   str1   +   str2 ;   还 加法 字符串 拼接 ， 终于 ， 类似 python 字符串 操作 C语言 还要 人 头疼 好久 终于 顺畅 。   cout   < <   str1 . size ( ) ;   / /   返回 3   请求 行 输入 历史 原因   cin . getline ( charstr ,   max _ size )   更 接近 C语言 中 熟知 那种 概念 ， 而友元 函数   getline ( cin ,   string )   反而 更 接近 C++ 风格 ， cin C++ 概念 ， 会 预期 cin 类 方法 会 对接 string 接口 ， 历史 兼容 原因 ， 没什么 特别 理由 弄 反常规 。   C++ 结构 东西 来说 C语言 讨论 太 大 区别 ， C++ 结构 体 string 类 成员 对象 。 特别 C语言 字符串 数组 实际上 字符串 内存 存储单元 ， 字符串 不定 长 ， 字符串 数组 存放 指针 ， 结构 数组 ， C语言 结构 体是 ， 就可以看 做 一个 内存 存储单元 ， 结构 数组 一个 一个 结构 体而 指向 结构 体 指针 。 结构 体 数组 引用 语句   struct _ array [ 0 ] .   。   C++ Union enum 枚举 C语言 讨论 太 大 区别 。   C++ 指针 相关 内存 管理 malloc C语言 讨论 太 大 区别 ， C++ 编程 程度 上 弱化 指针 概念 ， 很多 地方 C++ 编程 不 指针 ， 内存 管理 不 推荐 malloc 函数 推荐 delete 运算符 。   C++ 类型 结构 声明 一个 内存 块 ， 给定 指针 名来 指向 ， 引用 。   typeName   *   pointer _   =     typeName ;   int   *   pn   =     int ;   * pn   =   1 ;   cout   < <   * pn ;   东西 只能 指针 ， 参考资料 1 说 东西 更 确切 来说 数据 对象 ， 变量 数据 对象 。 不管怎么 说 ， 就是指 内存 里 东西 。   delete 运算符 只能 用于 讨论 指针 。 所示 ：   int   *   pn   =     int ;   delete   pn ;   创建 数组 结构 有所不同 ， 数组 为例 ， 常规 声明 数组 静态 联编 （ static   binding ） ， 编译 阶段 数组 申请 分配 好 内存 ； 创建 数组 只 运行 阶段 才 创建 ， 运行 阶段 没 数组 创建 ， 称为 动态 联编 （ dynamic   binding ） 。 数组 动态 数组 。   例子 演示 动态 数组 ， 运行 时 用户 指定 数组 大小 ， 运行 时 给定 值 ：   # include   < iostream >   # include   < string >   int   main   (   void   )   {     namespace   std   ;   int   x   ;   cout   < <   \"   input     array   length :   \"   ;   cin   > >   x   ;   int   *   parray   =     int   [   x   ] ;     (   int   i   =   0   ;   i   <   x   ;   i   ++   )   {   cin   > >   parray   [   i   ] ;   }     (   int   i   =   0   ;   i   <   x   ;   i   ++   )   {   cout   < <   parray   [   i   ]   < <   endl   ;   }   delete   [ ]   parray   ;   return   0   ;   }   动态 数组   delete   运算符 语句 加上   [ ]   。   指针 C语言 东西 ， 回顾 提醒 ，   arr [ 1 ]     * ( arr + 1 )   一个 ，   arr [ 0 ]     * arr   一个 。   指针 数组 这块 东西 很多 ， 都 C语言 知识点 ， 略过 讨论 ， 读者 自觉 这块 欠缺 ， 请 C语言 教材 补习 。   一个 动态 字符串 ， 或者说 动态 字符 数组 ， 。 string 类 内部 做 ， 没 去 重复 造 轮子 ， string 类 。   结构 参照 讨论 ， 类似 动态 结构 。 动态 结构 倒 说 结构 定义 动态 ， 结构 体 定义 做 。   C语言 存储 类型 自动 存储 静态 存储 ， 简单 来说 自动 存储 变量 存活 程序 自动 管理 ， 静态 存储 变量 程序运行 期 都 存活 。 一块 C++ C语言 ， C++ 讨论 运算符 提出 一个 新 存储 类型 ， 动态 存储 。 delete 运算符 管理 内存 池 静态 变量 自动 变量 内存 池是 分开 ， 自由 存储空间 或堆 。 动态 存储 变量 delete ， 内存 泄漏 ， 内存 泄露 程序 内存 没法用 ， 点本 程序运行 内存 耗尽 ， 内存 程序 崩溃 。 参考资料 说 泄漏 导致 操作系统 应用程序 崩溃 。   类似 string 类 ， C++ vector 类来 动态 数组 ， 类似 string 类 讨论 ， 利用 delete 某种 动态 数组 效果 ， 重复 造 轮子 ， 请用 vector 类 ， vector 类 内部 做 。 动态 数组 例子 写成 vector 版本 ：   # include   < iostream >   # include   < string >   # include   < vector >   int   main   (   void   )   {     namespace   std   ;   int   x   ;   cout   < <   \"   input     array   length :   \"   ;   cin   > >   x   ;   vector   <   int   >   vec   ;     (   int   i   =   0   ;   i   <   x   ;   i   ++   )   {   int   tmp   ;   cin   > >   tmp   ;   vec   .   push _ back   (   tmp   ) ;   }     (   int   i   =   0   ;   i   <   x   ;   i   ++   )   {   cout   < <   vec   [   i   ]   < <   endl   ;   }   return   0   ;   }   vector 类 很多 用法 ， 重点 。 vector 初始化 不 指定 长度 参数 ， push _ back 方法 新增 元素 。   vector 类 动态 数组 ， 效率 低 ， C++ 一个 新 类 array 类 ， 内部 存储 数组 存储 风格 ， 效率 等价 ， 类 ， 便捷 操作方法 。 方法 时间 再 慢慢 。   编写 一个 C++ 程序 ， 下述 输出 示例 所示 请求 显示信息 ：   ， 程序 接受 名字 包含 多个 单词 。 ， 程序 向下 调整 成绩 ， 下调 一个 字母 。   xiti _ c4 _ 1 . cpp   # include   < iostream >   # include   < string >   int   main   (   void   )   {     namespace   std   ;   string   _   ;   string   _   ;   char   grade   ;   int   age   ;   cout   < <   \" What           \"   ;   getline   (   cin   ,   _   ) ;   cout   < <   \" What           \"   ;   getline   (   cin   ,   _   ) ;   cout   < <   \" What   letter   grade       deserve   \"   ;   cin   .     (   grade   ) .     ( ) ;   cout   < <   \" What       age   \"   ;   cin   > >   age   ;   cout   < <   \" Name :   \"   < <   _   < <   \" ,   \"   < <   _   < <   endl   ;   cout   < <   \" Grade :   \"   ;   cout   .   put   (   grade   +   1   ) ;   cout   < <   endl   ;   cout   < <   \" Age :   \"   < <   age   < <   endl   ;   return   0   ;   }   编写 一个 程序 ， 用户 输入 其名 ， 输入 其姓 ； 程序 一个 逗号 空格 姓 名 组合 ， 存储 显示 组合 。 请 char 数组 头文件 cstring 中 函数 。 程序运行 时 情形 ：   xiti _ c4 _ 3 . cpp   # include   < iostream >   # include   < cstring >   int   main   (   void   )   {     namespace   std   ;   char   _   [   20   ] ;   char   _   [   20   ] ;   char     [   40   ] ;   cout   < <   \" What           \"   ;   cin   .   getline   (   _   ,   20   ) ;   cout   < <   \" What           \"   ;   cin   .   getline   (   _   ,   20   ) ;   strcpy _ s   (     ,   _   ) ;   strcat _ s   (     ,   \" ,   \"   ) ;   strcat _ s   (     ,   _   ) ;   cout   < <   \" Here ' s     information     a   single   string :   \"   < <     < <   endl   ;   return   0   ;   }   结构 CandyBar 包含 3 成员 。 第一个 成员 存储 糖块 品牌 ； 第二个 成员 存储 糖块 重量 （ 小数 ） ； 第三个 成员 存储 糖块 卡路里 含量 （ 整数 ） 。 请 编写 一个 程序 ， 声明 结构 ， 创建 一个 名为 snack CandyBar 变量 ， 成员 初始化 \" Mocha   Munch \" 、 2.3 350 。 初始化 应 声明 snack 时 。 ， 程序 显示 snack 变量 内容 。   xiti _ c4 _ 5 . cpp   # include   < iostream >   # include   < string >     namespace   std   ;   struct   CandyBar   {   string     ;   float   weight   ;   int   calories   ;   } ;   int   main   (   void   )   {   CandyBar   snack   =   {   \" Mocha   Munch \"   ,   2.3   ,   350   } ;   cout   < <   \" CandyBar   \"   < <   snack   .     < <   \"   weight :   \"   < <   snack   .   weight   < <   \"     calories :   \"   < <   snack   .   calories   < <   endl   ;   return   0   ;   }   结构 CandyBar 包含 3 成员 ， 讨论 。 请 编写 一个 程序 ， 创建 一个 包含 3 元素 CandyBar 数组 【 动态分配 数组 ， 声明 一个 包含 3 元素 CandyBar 数组 】 ， 初始化 选择 值 ， 显示 结构 内容 。   xiti _ c4 _ 6 . cpp   # include   < iostream >   # include   < string >     namespace   std   ;   struct   CandyBar   {   string     ;   float   weight   ;   int   calories   ;   } ;   int   main   (   void   )   {   CandyBar   *   psnack   =     CandyBar   [   3   ] ;   psnack   [   0   ] .     =   \" aaa \"   ;   psnack   [   0   ] .   weight   =   2.3   ;   psnack   [   0   ] .   calories   =   5   ;   psnack   [   1   ]   =   {   \" bbb \"   ,   2.5   ,   6   } ;   psnack   [   2   ]   =   {   \" ccc \"   ,   2.6   ,   7   } ;     (   int   i   =   0   ;   i   <   3   ;   i   ++   )   {   cout   < <   \" CandyBar   \"   < <   psnack   [   i   ] .     < <   \"   weight :   \"   < <   psnack   [   i   ] .   weight   < <   \"     calories :   \"   < <   psnack   [   i   ] .   calories   < <   endl   ;   }   delete   [ ]   psnack   ;   return   0   ;   }   William   Wingate 比萨饼 分析 服务 。 披萨 饼 ， 都 记录 信息 ：   披萨 饼 公司 名称 ， 多个 单词 。   披萨 饼 直径 。   披萨 饼 重量 。   请 设计 一个 存储 信息 结构 【 请 结构 分配内存 ， 请 vector 动态 数组 】 ， 编写 一个 结构 变量 程序 。 程序 请求 用户 输入 信息 ， 显示 信息 。 请 cin （ 方法 ） cout 。   xiti _ c4 _ 7 . cpp   # include   < iostream >   # include   < string >   # include   < vector >     namespace   std   ;   struct   Pizza   {   string     ;   float   diameter   ;   float   weight   ;   } ;   int   main   (   void   )   {   int   x   ;   cout   < <   \"   input     array   length :   \"   ;   (   cin   > >   x   ) .     ( ) ;   vector   <   Pizza   * >   vec   ;     (   int   i   =   0   ;   i   <   x   ;   i   ++   )   {   Pizza   *   ppizza   =     Pizza   ;   cout   < <   \" Please   input     pizza   :   \"   ;   getline   (   cin   ,   ppizza   - >     ) ;   cout   < <   \" Please   input     pizza   diameter :   \"   ;   (   cin   > >   ppizza   - >   diameter   ) .     ( ) ;   cout   < <   \" Please   input     pizza   weight :   \"   ;   (   cin   > >   ppizza   - >   weight   ) .     ( ) ;   cout   < <   \" - - - - - - - - - - - - - - - - - \"   < <   endl   ;   vec   .   push _ back   (   ppizza   ) ;   }     (   int   i   =   0   ;   i   <   x   ;   i   ++   )   {   cout   < <   \" CandyBar   \"   < <   vec   [   i   ]   - >     < <   \"   weight :   \"   < <   vec   [   i   ]   - >   diameter   < <   \"     calories :   \"   < <   vec   [   i   ]   - >   weight   < <   endl   ;   }     (   int   i   =   0   ;   i   <   x   ;   i   ++   )   {   delete   vec   [   i   ] ;   }   return   0   ;   }   CPP 程序逻辑   这块 C++ C语言 内容 基本上 没什么 区别 ， 大多 略过 ， 做 习题 算是 学到 东西 再 。   CPP 函数   估计 这块 C++ C语言 差异 太 大 ， 做 习题 下 。   CPP 类   附录   cin 详解   cin   > >   Enter   Space   Tab   结束 ， 适合 char ， 无 空格 string 单个 值 int   float 输入 。 实践 换行符 缓冲区 ， 缓冲区 消掉 更好 输入 体验 ， 采用 表达方式 ：   ( cin   > >   ) . ( )   ， 是因为   cin   > >     会 返回 cin 对象 ， 调用     方法 消掉 换行符 。   cin .     cin . getline   都 用于 字符 数组 行 输入 ，   方法 丢弃 缓冲区 换行 结束符 ， cin . 一个 重载 变体 ，   cin . ( char   & ch )   ， 用于 读取 第一个 字符 ， 假设 缓冲区 下 一个 字符 换行符 ，   cin . ( )   换行符 读取 。   getline 函数   ， cin . getline 区别   getline ( cin ,   string )   getline 会 读入 C++ string 类 ， C 风格 字符 数组 。   cout 详解   cout   < <     cout . put ( char   & ch )   输出 一个 字符 ， 输入 整型 会 显示 字符 。   参考资料   C++   Primer   Plus   第六版 中文版",
            "tags":"cpp_language",
            "url":"articles/cpp-language-learning-notes.html"
        },
        {
            "title":"ceph学习笔记",
            "text":"ceph 简介   ceph 系统 一种 分布式 存储 解决方案 ， 多台计算机 配置 ， 搭建 ceph 集群 提供 块 设备 存储 、 对象 存储 文件系统 服务 。   ceph 项目 设计 思想 很 先进 ， 源于 Sage   Weil 加州大学 攻读 博士 期间 一篇 论文 。 ceph 项目 简单 来说 目的 应对 PB 级别 存储 需求 ， ceph 设计 上 存储 理论 上限 。   ceph 官网 所言 ：   Ceph     a   unified ,   distributed   storage   system   designed     excellent   performance ,   reliability     scalability .   ceph 一个 分布式 存储系统 ， 提供 优良 性能 ， 可靠性 可扩展性 。 可靠性 ceph 存储系统 会 尽可能 保证数据 丢失 ， 可扩展性 包括 系统 规模 存储容量 扩展 。 ceph 运维上 还 提供 自动化 运维 特性 ， 包括 数据 自动 replication ； 自动 - balancing ； 自动 failure   detection 自动 failure   recoery 。   ceph 存储系统 结构   ceph 存储系统 图 所示 分为 四个 层次 ：   最底层 RADOS 基础 存储系统 ， 存储 ceph 系统 用户 数据 最终 都 一层 存储 。 理解 RADOS 理解 ceph 系统 关键 。   基础 库 librados ， 一层 底层 RADOS 系统 抽象 封装 ， 向上 提供 API 。   高层 接口 ， 一层 RADOS   GW 、 RBD 、 ceph   FS 。 提供 对外 网关 接口 ， 块 设备 接口 文件系统 接口 。   应用层 ， 基于 librados 高层 接口 开发 方法 ， 云 对象 存储 ， 云 硬盘 。   RADOS 存储系统 结构   RADOS 基础 存储系统 结构 图 所示 ：   RADOS 系统 很多 OSDs ， 称之为 OSD   deamon 进程 ， ceph   osd   daemon   功能 存储 数据 ， 数据 复制 、 恢复 、 回填 、 再 均衡 检查 osd   daemon 心跳 ceph   monitor 提供 监控 信息 。 ceph   monitor   维护 展示 集群 状态 图表 。   PG （ Placement   Group ） RADOS 存储系统 中 ， 最终 存储 一个 size 最小 对象 Object ， 上层 文件 最终 分成 一系列 Object 。 PG 用来 （ 基于 CRUSH 算法 ） 组织 Object 位置 映射 ， 一个 Object 只能 映射 一个 PG ， Object PG 映射 多个 OSDs 上 ， 牵涉到 数据分布 均匀 性 数据 修复 。   ceph 存储 集群   ceph 存储 集群 部署 配置 好 一个个 ceph 节点 ， 网络 ， ceph 存储 集群 。 一个 ceph 存储 集群 至少 一个 ceph   monitor   两个 ceph   osd   daemon （ OSDs ） 。 ceph 文件系统 客户端 还 ceph   metadata   server （ MDS ） 。   ceph   status     ceph   - s   ：   查看 ceph 集群 状态   安装 前 预检   预检 操作系统 ceph 版本号 兼容性   预检 硬件 ， 最小 ceph 测试环境 三台 机器 。 官方 文档 admin 节点 【 执行 ceph - deploy 操作 节点 】 mon 节点 一台 机器 上 。   admin 节点 安装 ceph - deploy   NOTICE :   内容 来自 ceph 中文 文档 。   红帽 包 管理工具 （ RPM ）     Red   Hat   （ rhel6 、 rhel7 ） 、 CentOS   （ el6 、 el7 ）   Fedora   19 - 20   （ f19   -   f20 ）   上 执行 步骤 ：     RHEL7   上 ，   subscription - manager   注册 目标 机器 ， 确认 订阅 ，   启用 安装 依赖 包 \" Extras \" 软件 仓库 。   ：   sudo   subscription - manager   repos   - - enable = rhel - 7 - server - extras - rpms     RHEL6   上 ， 安装 启用   Extra   Packages     Enterprise   Linux   ( EPEL )   软件 仓库 。   请 查阅   EPEL   wiki   获取 更 信息 。     CentOS   上 ， 执行 命令 ：   sudo   yum   install   - y   yum - utils   &&   sudo   yum - config - manager   - - add - repo   https : / / dl . fedoraproject . org / pub / epel / 7 / x86 _ 64 /   &&   sudo   yum   install   - - nogpgcheck   - y   epel - release   &&   sudo   rpm   - - import   / / pki / rpm - gpg / RPM - GPG - KEY - EPEL - 7   &&   sudo   rm   / / yum . repos . d / dl . fedoraproject . org *   软件包 源 软件 仓库 。 文本编辑 器 创建 一个   YUM   ( Yellowdog   Updater ,   Modified )   库 文件 ， 路径   / / yum . repos . d / ceph . repo   。 ：   sudo   vim   / / yum . repos . d / ceph . repo   内容 粘帖 进去 ，   Ceph   最新 主 稳定版 名字 替换   { ceph - stable - release }   （   firefly   ） ， Linux 发行版 名字 替换   { distro }   （   el6     CentOS   6   、   el7     CentOS   7   、   rhel6     Red   Hat   6.5   、   rhel7     Red   Hat   7   、   fc19     Fedora   19   、   fc20     Fedora   20   ） 。 保存   / / yum . repos . d / ceph . repo   文件 中 。   [ ceph - noarch ]   = Ceph   noarch   packages   baseurl = http : / / download . ceph . / rpm - { ceph - release } / { distro } / noarch   enabled = 1   gpgcheck = 1   type = rpm - md   gpgkey = https : / / download . ceph . / keys / release . asc   更新 软件 库 安装   ceph - deploy   ：   sudo   yum   update   &&   sudo   yum   install   ceph - deploy   Note   欧洲 镜像   eu . ceph .   下载 软件包 ， 只 需   http : / / ceph . /   替换成   http : / / eu . ceph . /   即可 。   关闭 ceph 节点 防火墙   systemctl   stop   firewalld   systemctl   disable   firewalld   systemctl   status   firewalld   配置 ceph 节点 主机名   hostnamectl   - - static   set - hostname   { host _ }   修改 ceph 节点   / / hosts   文件 ， 确保 添加 类似 内容 ：   { public _ network _ ip _ 1 }   { host _ _ 1 }   { public _ network _ ip _ 2 }   { host _ _ 2 }   配置 NTP   安装 NTP 服务   节点 安装 ntp ：   sudo   yum   - y   install   ntp   ntpdate   节点 备份 原 ntp 配置文件 ：   cd   /   &&   mv   ntp . conf   ntp . conf . bak   ceph1 ntp 服务端 节点 ， ceph1 上 新建 新 NTP 配置文件 ， 内容 类似 ：   restrict   127.0 . 0.1   restrict   : : 1   restrict   192.168 . 3.0   mask   255.255 . 255.0   / /   ceph1   网段 掩码   server   127.127 . 1.0   fudge   127.127 . 1.0   stratum   8   ceph2 ceph3 类似 新增 NTP 配置文件 内容 类似 ：   server   192.168 . 3.166   NTP 服务 启动   ceph1 启动 ntp 服务 ：   systemctl   start   ntpd   systemctl   enable   ntpd   systemctl   status   ntpd   ceph1 之外 节点 强制 同步 时间 ：   ntpdate   ceph1   ceph1 之外 节点 写入 硬件 时钟 ， 重启 失效 ：   hwclock   - w   ceph1 之外 节点 启动 crontab 并作 配置 ：   yum   install   - y   crontabs   chkconfig   crond     systemctl   start   crond     crontab   - e   编辑 配置 ， 强制 节点 十分钟 ceph1 同步 时间 ：   * / 10   *   *   *   *   / usr / bin / ntpdate   192.168 . 3.166   创建 部署 ceph 用户   内容 复制 ceph 中文 文档 ， 一个 可选项 操作 ， 暂时 先 放在 ， 留 作 参考 。   创建 部署   Ceph   用户   ceph - deploy   工具 普通用户 登录   Ceph   节点 ， 用户 拥有 无 密码   sudo   权限 ， 安装 软件 配置文件 过程 中 ， 不必 输入 密码 。   新版   ceph - deploy   支持   - - username   选项 提供 无 密码   sudo   用户名 （ 包括   root   ，   不 建议   做 ） 。   ceph - deploy   - - username   { username }   命令 时 ， 指定 用户 无 密码   SSH   连接   Ceph   节点 ，   ceph - deploy   中途 提示 输入 密码 。   建议 集群 内     Ceph   节点 上   ceph - deploy   创建 一个 特定 用户 ，       \" ceph \"   名字 。 全 集群 统一 用户名 可简化 操作 （ 非 必需 ） ， 知名 用户名 ， 黑客 会 做 暴力破解 （   root   、   admin   、   { productname }   ） 。 后续 步骤 描述 创建 无   sudo   密码 用户 ， 取 名字 替换   { username }   。   Note     Infernalis   版   ， 用户名   \" ceph \"   保留   Ceph   守护 进程 。   Ceph   节点 上   \" ceph \"   用户 ， 升级 前 先 删掉 用户 。     Ceph   节点 创建 新 用户 。   ssh   user @ ceph - server   sudo   useradd   - d   / home / { username }   - m   { username }   sudo   passwd   { username }   确保   Ceph   节点 上 新创建 用户 都   sudo   权限 。   echo   \" { username }   ALL   =   ( root )   NOPASSWD : ALL \"   |   sudo   tee   / / sudoers . d / { username }   sudo   chmod   0440   / / sudoers . d / { username }   配置 ssh 免密 登录   配置 ceph1 节点 所有主 / 客户机 节点 免密 （ 包括 ceph1 ） 。   ssh - keygen   - t   rsa     i     { 1 .. 3 } ;     ssh - copy - id   ceph $ i ;   关闭 SELinux   节点 都 做 ， 临时 关闭 ：   setenforce   0   还 配置 永久 关闭 ， 重启 后 生效 ， 修改   / / selinux / config   ：   SELINUX = disabled   配置 epel 源   sudo   yum   install   - y   epel - release   配置 ceph 镜像 源   修改   / / yum . repos . d / ceph . repo   ， 内容 ：   [ Ceph ]   = Ceph   packages     $ basearch   baseurl = http : / / download . ceph . / rpm - nautilus / el7 / $ basearch   enabled = 1   gpgcheck = 1   type = rpm - md   gpgkey = https : / / download . ceph . / keys / release . asc   priority = 1   [ Ceph - noarch ]   = Ceph   noarch   packages   baseurl = http : / / download . ceph . / rpm - nautilus / el7 / noarch   enabled = 1   gpgcheck = 1   type = rpm - md   gpgkey = https : / / download . ceph . / keys / release . asc   priority = 1   [ ceph - source ]   = Ceph   source   packages   baseurl = http : / / download . ceph . / rpm - nautilus / el7 / SRPMS   enabled = 1   gpgcheck = 1   type = rpm - md   gpgkey = https : / / download . ceph . / keys / release . asc   priority = 1   运行 ：   sudo   yum   clean     &&   sudo   yum   makecache   网络 环境 预检   centos7 默认 firewalld ， 内容 iptables ， 过时 ， 防火墙 关闭 ， 内容 不用 看 ， 看 下 简单 下 ceph 底层 网络 端口 情况 。   集群 节点 机器 ping 得通 ：   ping   短 主机名   ceph mon 默认 监听 端口   6789   ， 只管 public   network ， 用到   { iface }   public   network   interface ， 所用   { ip - address }     public   network   IP   address 。 所用 netmask public   network   { netmask }   。   sudo   iptables   - A   INPUT   - i   { iface }   - p   tcp   - s   { ip - address } / { netmask }   - - dport   6789   - j   ACCEPT   ceph osd ceph 节点 上 6800 端口 找 可用 端口 ， 默认   6800 : 7300   ， 一个 osd 三个 端口 ：   一个 用于 clients monitors 通信   一个 用于 osds 通信   一个 用于 心跳 通信 （ heartbeating ）   端口 都 限于 ceph 节点 Host 机器 上 ， 重复 ， osd 重启 端口 未 释放 ， 确保 富余 端口号 。   公网 私网 分离 ， clients 会 公网 连接 osds ， osds 之间 会 私网 连接 。 iptables rules 分开 。   sudo   iptables   - A   INPUT   - i   { iface }   - m   multiport   - p   tcp   - s   { ip - address } / { netmask }   - - dports   6800 : 6810   - j   ACCEPT   请 确保 6810 osd 数量 。   ceph mds   server 监听 public   network   6800   第一个 可用 端口 。 类似 只管 public   network ， 用到   { iface }   public   network   interface ， 所用   { ip - address }     public   network   IP   address 。 所用 netmask public   network   { netmask }   。   sudo   iptables   - A   INPUT   - i   { iface }   - m   multiport   - p   tcp   - s   { ip - address } / { netmask }   - - dports   6800 : 6810   - j   ACCEPT   ceph . conf 配置   ceph . conf 配置 定义 ceph 集群 信息 ， ：   集群 id   fsid   认证 配置   集群 成员   host   names   host   addresses   keyrings 路径   journals 路径   data 路径   runtime 配置   文件 查找 先后顺序 所示 ：   $ CEPH _ CONF   环境变量   - c   path / path   - c 命令行 参量   / / ceph / ceph . conf   系统 默认 路径   ~ / . ceph / config   本地用户 路径   . / ceph . conf   当前工作 路径   原则上 配置文件 管理 集群 daemons ， daemon 进程 上 ， 查找 顺序 限于 机 查找 ， 也就是说 ， ceph 集群 配置 统一 工作 ， 额外 管理 。   配置 覆盖   配置 覆盖   [ global ]   - >   [ mon ]   - >   [ mon . a ]   ， daemon 类似 。   global   [ global ]   public   network   =   { public - network / netmask }   #   诸如 10.0 . 0.0 / 24 格式   cluster   network   =   { cluster - network / netmask }   #   定义 cluster   network ， osds 会 心跳 ， osds 之间 replication   recovery 通信 都 走 cluster   network 。   网络 配置 最小   网络 配置 最小 ceph deamon 进程 ceph . conf 文件 找到   host   变量 ， host 变量 hostname   hostname   - s   。 ceph 集群 指明 monitor ip   address 端口 。   daemon   section 下 设置   host   ， mon mon   section 下 设置   mon   addr   变量 。   daemon   addr   不 设置 ， 还 不 情况 下 不 设置 。   硬盘 文件系统 配置   osd   daemon 一个 单独 硬盘 上 ， 一个 硬盘 上 做 多个 osd ， 先 做 分区 工作 。   生产 上 推荐   XFS   文件系统 格式 。   ext4   文件系统 格式 ， ceph . conf 配置 osd   section 上 推荐 加上 一行 ：   filestore   xattr     omap   =   true   ceph 官方 手册 说   btrfs   文件格式 好话 ， 说 测试 推荐 文件系统 格式 。   mon 配置   ceph mons 维护 一个   master   copy     cluster   map ， ceph   client   找到 ceph   monitors   ，   ceph   osd   daemons   ，   ceph   mds   servers   连接 一个 ceph   monitor   提出   cluster   map 。 cluster   map   CRUSH   算法 ， ceph   client 找到 对象 位置 。   生产 环境 ceph 集群 最少 三个 monitor   daemon ， 测试环境 只设 一个 mon 。   mon   daemon   默认 数据 放在   / var / lib / ceph / mon / $ cluster - $ id   。   mon 部署 流程   ceph - deploy 工具 不去 细节 ， mon 部署 都 流程 走一遍 ， 包括 cephx 认证 配置 东西 。   出于 简洁性 步骤 将会   ceph . conf   配置 更改 操作步骤 略去 ， 请 读者 自行 补充 。   集群 创建 一个   keyring     mon   生成 一个 secret   key   ceph - authtool   - - create - keyring   / tmp / ceph . mon . keyring   - - gen - key   - n   mon .   - - cap   mon   '   * '   生成 一个 administrator   keyring   生成   client . admin   用户 ， 用户   keyring   中 。   ceph - authtool   - - create - keyring   / / ceph / ceph . client . admin . keyring   - - gen - key   - n   client . admin   - - set - uid = 0   - - cap   mon   '   * '   - - cap   osd   '   * '   - - cap   mds   ' '     client . admin   key 添加   ceph . mon . keyring     ceph - authtool   / tmp / ceph . mon . keyring   - - import - keyring   / / ceph / ceph . client . admin . keyring   生成 mon   map ， 保存   / tmp / monmap   至少 一个   hostname     ip - address   参数 ， fsid 参数 ， 集群 名字 默认   ceph   。   monmaptool   - - create   - - add   { hostname }   { ip - address }   - - fsid   { uuid }   / tmp / monmap   确保 mon   data   文件夹   sudo   mkdir   / var / lib / ceph / mon / { cluster - } - { hostname }     mon   map   keyring 添加 进来   ceph - mon   - - mkfs   - i   { hostname }   - - monmap   / tmp / monmap   - - keyring   / tmp / ceph . mon . keyring   创建 一个 空白     文件   sudo   touch   / var / lib / ceph / mon / ceph - node1 /   启动 mon   sudo   / / init . d / ceph   start   mon . node1   mon 之间 同步   当有 多个 mon ， mon 之间 会 最新 cluster   map ， 取出 最新 cluster 信息 。 同步 过程 中 ， mon 之间 会 三种 角色 ：   Leader   Leader 第一个 拥有 最新 cluster   map   Provider   Provider 最新 cluster   map ， 第一个 。   Requester   Requester cluster   map 掉队 ， 同步操作 。   osd 配置   一个 osd 实际上 一个 ceph - osd   deamon Guest 机上 一个 存储点 ， 一个 Guest 机上 设置 多个 存储点 ， 只 一个 ceph - osd   deamon 。   生产 环境 一个 节点 （ Guest 机器 ） 一个 osd   daemon ， 一个 存储 盘 。   设置 日志 尺寸 所示 ：   [ osd ]   osd   journal   size   =   10000   osd   daemon   默认 数据 放在   / var / lib / ceph / osd / $ cluster - $ id   。   osd   data   改变 值 ， 推荐 系统盘 osd 盘 分开 ， osd 盘 挂载 点 先 挂载 好 。   sudo   mkfs   - t   { fstype }   / dev / { disk }   sudo   mount   - o   user _ xattr   / dev / { hdd }   / var / lib / ceph / osd / ceph - { osd - number }   osd 心跳   osd 之间 会 检查 心跳 （ 6 秒 ） ， 心跳 周期 参数   osd   heartbeat   interval   设置 。 一个 osd   deamon   20 秒 内 返回 心跳 信息 ， 会 osd   deamon     。 时间   osd   heartbeat   grace   设置 。 mon 接受 osd   deamon     信息   三次   才 会 osd   deamon 。 次数   mon   osd   min     reports   ， 默认 一个 osd 报告 ，   mon   osd   min     reporters   设置 报告 数目 。   osd 之间 沟通 心跳 ， 一个   osd 没 办法 osd 心跳 沟通 ， 每过 30 秒 其会 mon 请求 最新 cluster   map ， 时间   osd   mon   heartbeat   interval   设置 。   mon ， 一个 osd   deamon   时间 内 mon 报告 ， 会 。 很多 报告 事件 ， 再 详细 讨论 。   osd 日志   日志 大小 至少   (   drive   speed   *   filestore   max   sync   interval   )   *   2   ， 最 常见 实践 日志 文件 弄个 分区 （ SSD ） ， 分区 都 挂载 用做 存储 日志 。   日志 设置   osd   journal   默认 路径 ：   / var / lib / ceph / osd / $ cluster - $ id / journal   日志 大小 设置   osd   journal   size   默认 大小 ：   0   ...   ，   想要 日志 设置 值 。   osd   journal   size   =   { 2   *   ( expected   throughput   *   filestore   max   sync   interval ) }   期待 吞吐量 取 硬盘 吞吐量 网络 吞吐量 最小值 。   认证 配置   认证 配置 都 全局 放在 global   section 。   认证 配置 默认 开启   cephx   认证 。 生产 环境 肯定 开启 。 测试 ， 开启 ， 习惯 认证 配置 。   开启 cephx   创建 一个   client . admin   keyring   ceph   auth   - - create   client . admin   mon   '   * '   mds   '   * '   osd   '   * '   - o   / / ceph / ceph . client . admin . keyring   一步 目标 点   / / ceph / ceph . client . admin . keyring   不 做 。   monitor 集群 创建 monitor   secret   key ， 一部分 mon 配置 中 。   ceph - authtool   - - create - keyring   / tmp / ceph . mon . keyring   - - gen - key   - n   mon .   - - cap   mon   '   * '   创建   monitor   secret   key 复制到 mon mon   data 去 。   osd 生成 一个 secret   key   ceph   auth   - - create   osd . { $ id }   mon   '   rwx '   osd   '   * '   - o   / var / lib / ceph / osd / ceph - { $ id } / keyring   mds 生成 一个 secret   key   ceph   auth   - - create   mds . { $ id }   mon   '   rwx '   osd   '   * '   mds   '   * '   - o   / var / lib / ceph / mds / ceph - { $ id } / keyring   术语   FQDN   fqdn   Full   Qualified   Domain   Name   全称 域名 ， 全称 域名 包含 两 ： hostname domain   。 fqdn hostname 都 node001 ... ， ceph - ansible 代码 地方 会 区分 。   hostname   最 常见 一个 概念 ， vagrant 机器 ， 说 hostname 或者说   hostname   - s   或者说   host   都 指   node001 ...   。 虚拟机 hostname ping 得通 ， 配置 hostname 一个 名字 ， 会 网络 含义 ， 不管怎么 说 ， 物理 机 ， 请 确保 目标 物理 机 hostname ping 得通 ， 免得 不必要 麻烦 。   METAVARIABLE   ceph . conf 变量 ， ceph 会 自动 填充 给与 合适 值 。   $ cluster   扩展 ceph 集群 名字 ， 默认   ceph   $ type   扩展   mds     osd     mon   ， 取决于 daemon 进程 配置文件 。   $ id   扩展 daemon identifier ， 比如说   osd.0   ， 该值   0   。   $ host   扩展 daemon 进程 host 变量值 ， 说 daemon 进程 ceph . conf 都 找到 host 变量   $   等价   $ type . $ id   运行 时 更改 配置   ceph     { daemon - type } . { id     * }   injectargs   - - { }   { }   [ - - { }   { } ]   配置 名有 加上   _     -   。   运行 时 查看 配置   ceph   daemon   { daemon - type } . { id }   config   show   |     安装 diamond 模块   https : / / github . / python - diamond / Diamond   diamond 用来 收集 信息 ， 发出 信息格式 ：   servers . wanze - ubuntu . iostat . sda6 . writes _ merged   60.000   1469329380   path   值   时间 戳   格式 通用性 ， carbon 接受 信息格式 ， 写 额外 数据 发送 格式 。   diamond 依赖   configobj     psutil   两个 模块 。 configobj 还 依赖 模块 ， psutil 安装 花费 一点 功夫 ， 安装   gcc   yum   install   gcc     python - devel   yum   install   python - devel   diamond 安装 4.0 . 451 ， 安装 上 ， 模块 安装 后会 虚拟环境 下 创建 额外 功能 文件夹 文件 ， 详细 。   bin / diamond   虚拟环境 下 执行 脚本 ， 类似 不 说 。   / diamond   放着 diamond 配置 ， 后续 python 模块 配置 都 推荐 类似 放在 。   share / diamond   放着 diamond 资源   类似 虚拟环境 文件夹 设置 ：   var / run   放着 pid 文件   var / log   放着 日志 文件   storage /   下 carbon graphite - web 都 会 往里面 塞 内容 ， 内容 存储 地方 。   虚拟环境 下 运行   diamond   命令 ， 指定 配置文件 。   / opt / sdsom / venv / / diamond   下   diamond . conf .   改名   diamond . conf   （ 先 编写 ， 安装 时 批量 地方 塞 配置文件 。 ）   #   Pid   file   pid _ file   =   / opt / sdsom / venv / var / run / diamond . pid   #   Directory     load   collector   modules     collectors _ path   =   / opt / sdsom / venv / share / diamond / collectors /   #   Directory     load   collector   configs     collectors _ config _ path   =   / opt / sdsom / venv / / diamond / collectors /   #   Directory     load   handler   configs     handlers _ config _ path   =   / opt / sdsom / venv / / diamond / handlers /   #   Directory     load   handler   modules     handlers _ path   =   / opt / sdsom / venv / share / diamond / handlers /   原则上 文件 都 放入   / opt / sdsom / venv   ， 先 暂时 写 死 ， 配置文件 自动 基于 模块 填充 生成 机制 。   ###   Defaults   options       Handlers   [ [ default ] ]   [ [ ArchiveHandler ] ]   #   File     write   archive   log   files   log _ file   =   / opt / sdsom / venv / var / log / diamond / archive . log   host 变量 sdsom 模块 修改 ， 测试 简单 填写 127.0 . 0.1 即可 。 port carbon 。   [ [ GraphiteHandler ] ]   ###   Options     GraphiteHandler   #   Graphite   server   host   host   =   127.0 . 0.1   #   Port     send   metrics     port   =   6601   [ [ GraphitePickleHandler ] ]   ###   Options     GraphitePickleHandler   #   Graphite   server   host   host   =   127.0 . 0.1   #   Port     send   metrics     port   =   6602   默认 信息 收集器 开启 ：   [ [ CPUCollector ] ]   enabled   =   True   [ [ DiskSpaceCollector ] ]   enabled   =   True   [ [ DiskUsageCollector ] ]   enabled   =   True   [ [ LoadAverageCollector ] ]   enabled   =   True   [ [ MemoryCollector ] ]   enabled   =   True   [ [ VMStatCollector ] ]   enabled   =   True   先 暂时 留 一两个 测试 即可 。   [ handler _ rotated _ file ]   class   =   handlers . TimedRotatingFileHandler   level   =   DEBUG   formatter   =   default   #   rotate     midnight ,     day       7   days   args   =   ( ' / opt / sdsom / venv / var / log / diamond / diamond . log ' ,   ' midnight ' ,   1 ,   7 )   文件夹 手工 创建 下 ：   mkdir   - p   / opt / sdsom / venv / var / log / diamond   mkdir   - p   / opt / sdsom / venv / var / run   配置 完 ， 开启 一个 diamond 进程 ， 后续 supervisor 管理 开启 。   diamond   - c   / opt / sdsom / venv / / diamond / diamond . conf   去 看 下 创建 pid 文件 日志 文件 。 关闭 diamond 进程 kill 掉 进程 号 即可 。   carbon whisper 合作 收集 存储 信息   ：   carbon 虚拟环境 下 安装 额外 安装 参数 配置 。   pip   install   - - install - option = \" - - prefix = / opt / sdsom / venv \"   - - install - option = \" - - install - lib = / opt / sdsom / venv / lib / $ { PYTHON _ VESRSION } / site - packages \"   carbon - 0.9 . 15 . tar . gz   依赖于   Twisted   ， 先 安装 。 最新 版本 twisted 不 支持 python2.6 。 （ 依赖于 zope . interface ， 很大 网络 上 安装 ）   依赖于   txAMQP - 0.6 . 2 . tar . gz   网络 上 安装 。   额外 创建   storage   文件夹 提及 。 额外 创建 conf 文件夹 ， 配置文件 ， 后续 建议 都 统一   / carbon /   文件夹 去 。   examples   文件夹 还 不 。   bin python 执行 脚本 文件 ，   carbon - cache   whisper 交互 ， aggregator relay 高级 功能 ， 后续 慢慢 。   validate - storage - schemas . py   carbon - cache . py   carbon - aggregator . py   carbon - client . py   carbon - relay . py   还 安装   whisper   模块   虚拟环境 文件夹 下 conf 文件夹 有个 carbon . conf . ， 改名 carbon . conf ， 稍微 做 修改 ：   GRAPHITE _ ROOT   =   / opt / sdsom / venv /   LOG _ DIR   =   / opt / sdsom / venv / var / log / carbon /   PID _ DIR   =   / opt / sdsom / venv / var / run   类似 还 创建 一个   storage - schemas . conf   文件 。   启动 carbon - cache 进程 执行 ：   carbon - cache . py   start     status   stop   子 命令 。   去 storage 去 看 下 输出 wsp 文件 。   本地 安装 graphite - web   pip   install   - - install - option = \" - - prefix = / opt / sdsom / venv \"   - - install - option = \" - - install - lib = / opt / sdsom / venv / webapp \"   graphite - web - 0.9 . 15 . tar . gz   webapp 实际上   graphite - web   一个 django   app 。   安装 django   sdsom 代码 基于 django （ 1.5 . 1 ） graphite - web 依赖于   django - tagging   ( 0.3 . 1 )   ， 先 限定 版本号 。   graphite - web   数据库 创建   django - admin . py   syncdb   - - pythonpath   . / webapp   - - settings   graphite . settings   graphite - web   shell 调试   django - admin . py   shell   - - pythonpath   . / webapp   - - settings   graphite . settings   第一次 shell   测试   新 引入 一个 依赖 包   pytz     graphite . render . attime   import   parseATTime     graphite . render . datalib   import   fetchData     django . conf   import   settings   import   pytz   tzinfo   =   pytz . timezone ( settings . TIME _ ZONE )   _ time   =   parseATTime ( ' ' ,   tzinfo )   series   =   fetchData ( { ' startTime ' :   parseATTime ( ' - 30min ' ,   tzinfo ) , ' endTime ' : _ time , ' ' : _ time , ' localOnly ' : True } , ' servers . localhost . iostat . sda2 . iops ' )   res   =   [ i     i     series [ 0 ] ]   > > >   res   [ None ,   None ,   2.727 ,   None ,   None ,   None ,   None ,   1.24 ,   None ,   None ,   None ,   None ,   2.63 ,   None ,   None ,   None ,   None ,   1.097 ,   None ,   None ,   None ,   None ,   1.077 ,   None ,   None ]   开启 graphite - web   django - admin . py   runserver   - - pythonpath   . / webapp   - - settings   graphite . settings   0.0 . 0.0 : 8080   信息   graphite - web     local _ settings   参数 很 ， 设置 ， 其会 graphite 模块 加载 settings 时 自动 加载 。   graphite - web   外 网 网页 实际上 就可以看 ， 显示 图片 还 安装 cairocffi 模块 ， 模块 安装 依赖 东西 （ libffi - devel 系统 包等 ） ， 项目 架构 来说 。   graphite - web   官方 文档 推荐 做法 提供 render   api 获取数据 ，   fetchData   区别 ， fetch 少 缓冲 cache 层 ， 还少 不太 包装 。   仅仅只是 利用 fetchData 模块 ， 后续 安装 参数 改为 ：   pip   install   - - install - option = \" - - prefix = / opt / sdsom / venv \"   - - install - option = \" - - install - lib = / opt / sdsom / venv / lib / python2.7 / site - packages \"   graphite - web - 0.9 . 15 . tar . gz   graphite 模块 安装 进去 。   仅仅只是 利用 fetchData 函数 ， 最 后续 加上 Cache 层 ， 没 apache 服务 ， 设置 wsgi sdsom django 框架 集成 。 实际上 graphite - web 模块 django 层 抽离 ， 懒得 做 。   术语 解释   rados   lspools   ：   列出 pool 情况   ceph   osd   tree   :   列出 osd 情况   ceph   metadata   server   ceph 文件系统 存储 元 数据 。 元 数据 服务器 POSIX 文件系统 用户 不 Ceph 集群 负担 前提 下 ， 执行 诸如 ls 、 find 命令 。   RBD   rados   block   device   ceph 对外 提供 块 设备 服务   MDS   ceph 文件系统 依赖 元 数据服务   CRUSH   ceph 数据分布 算法   唯一 标识符   Unique   identifier     fsid   集群 唯一 标识 ，   uuidgen   命令 生成 一个 fsid ， 写入 ceph 配置文件 中 ， 默认   / / ceph / ceph . conf   。   集群 名字   Cluster   Name   ceph 集群 都 名字 ， 默认   ceph   监视器 名字   Monitor   Name   集群 监视器   公网 集群 内 网   ceph 默认 一个 网络 ， public   network ， 推荐 设置 两个 网卡 （ 会 带来 性能 极大 提升 ） ， 一个 网卡 ：   public   network ，   一个 网卡 ：   cluster   network 。 cluster   network 连外 网 ， 会 点 。 cluster 网卡 速度 很快 ， osd 之间 通信 传输数据 才 会 高效 ， 10Gbps 推荐 。   cluster   network osds 通信用 ， ceph 组件 都 依赖于 public   network 。   Map 监控 信息   Montior   Map ：   包含 集群   fsid   、 位置 、 名字 、 地址 端口 ， 包括 版本 、 创建 时间 、 修改 时间 。 查看 监视器 图 ，   ceph   mon   dump   命令 。   OSD   Map ：   包含 集群   fsid   、 创建 时间 、 修改 时间 、 存储 池 列表 、 副本 数量 、 归置 组 数量 、 OSD   列表 状态 （     、     ） 。 查看 OSD 运行图 ，   ceph   osd   dump   命令 。   PG   Map ：   包含 归置 组 版本 、 时间 戳 、 最新   OSD   运行图 版本 、 占 满率 、 归置 组 详情 ， 归置 组   ID   、     set   、   acting   set   、   PG   状态 （   active + clean   ） ， 存储 池 数据 情况 统计 。   CRUSH   Map ：   包含 存储设备 列表 、 故障 域 树状 结构 （ 设备 、 主机 、 机架 、 行 、 房间 、 ） 、 存储 数据 时 利用 树状 结构 规则 。 查看   CRUSH   规则 ， 执行   ceph   osd   getcrushmap   - o   { filename }   命令 ；   crushtool   - d   { comp - crushmap - filename }   - o   { decomp - crushmap - filename }   反编译 ；   cat   编辑器 查看 。   MDS   Map ：   包含   MDS   图 版本 、 创建 时间 、 修改 时间 ， 还 包含 存储 元 数据 存储 池 、 元 数据 服务器 列表 、 元 数据 服务器         。 查看   MDS   图 ， 执行   ceph   mds   dump   。   cephx 认证 系统   ceph cephx 认证 系统 认证 用户 守护 进程 。   Cephx   共享 密钥 认证 ， 客户端 监视器 集群 都 客户端 密钥 副本 。 认证 协议 使 参与 不用 展现 密钥 相互 认证 ， 集群 确信 用户 拥有 密钥 、 用户 集群 密钥 副本 。     cephx   ， 管理员 先 设置 好 用户 。 图解 里 ，   client . admin   用户 命令行 调用 生成 一个 用户 密钥 ，   Ceph   认证 子系统 生成 用户名 密钥 、 副本 存 监视器 用户 密钥 回 传给   client . admin   用户 ， 也就是说 客户端 监视器 共享 密钥 。   参考资料   ceph     scratch   ceph 浅析 上   ceph 浅析 中   ceph 中文 文档   鲲鹏 分布式 存储 解决方案 参考 文档",
            "tags":"others",
            "url":"articles/cephxue-xi-bi-ji.html"
        },
        {
            "title":"centos7系统学习",
            "text":"安装 系统   centos7 安装 难点 硬盘分区 上 ， 加上 最新 uefi 启动 方式 ， 新 讨论 。   记得 早起 折腾 ubuntu 系统 时 ， 一个 影响 linux 系统 安装 预先 分出 一个 swap 分区 ， 内存 两倍 ， 还 不 太 懂 ， 《 鸟哥 私房 菜 里 描述 ，   服务器 内存 都 十几 G - 64G 内存 ， 公式 — — 分出 3 - 4Gswap 分区 。   硬件 linux 下 名字   下 ， 参考   鸟哥 私房 菜 第二章   ，   硬盘 USB 模拟 硬盘   ：   / dev / sd [ a - p ]   CDROM DVDROM   :   / dev / scd [ 0 - 1 ]   ,   / dev / cdrom （ cdrom ）   ,   / dev / sr [ 0 - 1 ]   打印机   ：   / dev / lp [ 0 - 2 ]   ,   / dev / usb / lp [ 0 - 15 ]   鼠标   ：   / dev / input / mouse [ 0 - 15 ]   ,   / dev / mouse   ( 鼠标 )   分区 推荐   鸟哥 私房 菜 推荐 ， 随便 玩玩 ， 工作 服务器 ， 推荐 多分 几个 区 ：   / boot   /   / home   / var   swap   firewall - cmd   防火墙 策略管理 命令 ：   firewall - cmd   ，     - - list -   列出 开启 端口号 情况 ，   - - add - port   开放 端口号 ， ：   firewall - cmd   - - add - port = 80 / tcp   更 细节 请 参看   篇文章   ， 常用 用法 简要 。   firewall - cmd   - - - active - zones   #   查看 活动 区域   firewall - cmd   - - zone   =   work   - - add - interface   =   eth0   #   区域 指定 网卡 界面   #   默认 zone public   firewall - cmd   - - zone   =   work   - - list - ports   #   列出 开放 端口   firewall - cmd   - - zone   =   work   - - add - port   =   8080   / tcp   #   区域开发 端口   firewall - cmd   - - zone   =   work   - - add - service   =   ssh   #   区域开发 服务   #   类似   - - remove - prot     - - remove - service   firewall - cmd   - - - services   #   列出 可用 服务   NOTICE :   提及 操作 不 加   - - permanent   参数 临时 ， 重启 firewalld 服务 会 配置 丢失 。   systemd   systemd linux 初始化 系统 渐趋 主流 ， 比原 upstart 更 快 启动 速度 。 尽可能 启动 更少 进程 尽可能 更 进程 并行 启动 。 提高 并发 启动 加速 系统启动 好 ， systemd 脚本 编写 人员 系统 启动 单元 服务 之间 依赖 关系 很 。   systemd 参考手册 强烈推荐   金步国 翻译 systemd 中文 手册   。   systemd 服务   systemctl   命令 管理 ， 实际上 systemd ， 取代 inid pid 1 进程 ， 很多 进程 都 启动 ， 还 systemctl 重启 电脑 ， systemd 服务 多么 底层 ：   systemctl   reboot   systemctl   poweroff   system systemd 服务 脚本 放在   / usr / lib / systemd / system   ， 用户 systemd 服务 脚本 放在   / usr / lib / systemd / user   。 放在   / / systemd / system     / / systemd / user   。   也就是说 linux 系统 初始化 进程 systemd ， 后续 基本上 服务 进程 都 systemd 管理 ， 系统资源 systemd 都 单元 Unit 。 一种 分为 12 种 单元 ：   Service   最 常用 单元 类型 ， 一个 后台 服务 进程 。   Target     [ Target ]   配置 选项 ， 作用 依赖 汇成 一组 单元 ， 一组 单元 取 一个 名字 ， 这组 单元 启动 单元 依赖 关系 。   Device   硬件 设备   Mount   文件系统 挂载 点   Automount   自动 挂载 点 ， 当该 自动 挂载 点 访问 时 ， systemd 执行 定义 挂载   Path   文件 路径   Scope   systemd 启动 外部 进程   Slice   进程 组   Snapshot   systemd 快照   Socket   套 接字   Swap   swap 文件   Timer   定时器     systemctl   list - units   列出 系统 运行 unit 。   列出 一个 systemd 服务 脚本 例子 ，   Unit     Install   配置 节 都 ， 服务 脚本 特 有的是   Service   配置 节 。   [ Unit ]   Description = nginx   -   high   performance   web   server   Documentation = http : / / nginx . org / en / docs /   After = network . target   remote - fs . target   nss - lookup . target   [ Service ]   Type = forking   PIDFile = / usr / local / nginx / logs / nginx . pid   ExecStartPre = / usr / local / nginx / sbin / nginx   - t   - c   / usr / local / nginx / conf / nginx . conf   ExecStart = / usr / local / nginx / sbin / nginx   - c   / usr / local / nginx / conf / nginx . conf   ExecReload = / bin / kill   - s   HUP   $ MAINPID   ExecStop = / bin / kill   - s   QUIT   $ MAINPID   PrivateTmp = true   [ Install ]   WantedBy = multi - user . target   配置文件 放在   / usr / lib / systemd / system   ， 希望 配置 单元 开机 启动 ， 运行   systemctl   enable   . service   配置 单元 激活 开机 启动 ， 创建 一个 符号 链接   / / systemd / system   。 撤销 开机 启动   systemctl   disable   . service   。   Unit 配置 节   Unit   -   Description   描述 文字   Unit   -   Documentation   单元 文档   Unit   -   Requires   设置 单元 依赖 关系 。 列出 单元 启动 失败 ， After 中 列出 单元 ， 单元 启动 。 依赖 单元 显式 停止 ， 单元 会 停止 。   Unit   -   Wants   设置 单元 依赖 关系 ， 相当于 Requires 弱化 版本 ， 依赖 单元 尽可能 启动 ， 单元 不 启动 不 影响 单元 启动 。   Unit   -   After   强制 单元 先后顺序 ， 指本 单元 强制 列表 中 单元 。   Unit   -   Before   强制 单元 先后顺序 ， 指本 单元 强制 列表 中 单元 ， 两个 单元 都 启动 时 ， 单元 会 延迟 单元 启动 完毕 再启动 。   Install   配置 节   systemctl   enable disable 才 Install 配置 节 ， 常看到 选项 ：   [ Install ]   WantedBy = multi - user . target   相当于 multi - user . target 配置 上 加上   Wants = 单元   ， multi - user . target 启动 单元 启动 ， 默认 linux 启动 单元 default . target ， default . target multi - user . target 。   Install   -   WantedBy   Service 配置 节   Service   -   Type   启动 类型 ， simple ：   默认值 ， 启动 服务 ；   forking ： fork 方式 启动 进程 ； oneshot ： 一次性 进程 ； dbus ： dbus 启动 ； notify ： 服务 启动 完毕 ， 通知 systemd ， 向下 执行 。   Service   -   PIDFile   pid 文件 路径   Service   -   ExecStartPre   启动 前 动作   Service   -   ExecStart   启动 动作   Service   -   ExecReload   reload 动作   Service   -   ExecStop   停止 动作   Service   -   PrivateTmp   临时 空间   Service   -   ExecStartPost   启动 后 动作   system 常规 启动 流程   cryptsetup - pre . target   |   (   low - level   v   API   VFS   mounts :   (   cryptsetup   devices ... )   mqueue ,   configfs ,   |   |   debugfs ,   ... )   v   |   |   cryptsetup . target   |   |   (   swap   |   |   remote - fs - pre . target   |   devices ... )   |   |   |   |   |   |   |   |   |   v   |   v   local - fs - pre . target   |   |   |   ( network   file   systems )   |   swap . target   |   |   v   v   |   |   |   v   |   remote - cryptsetup . target   |   |   |   (   low - level   (   mounts     |   |   |   |   |   services :   udevd ,   fsck   services ... )   |   |   remote - fs . target   |   |   tmpfiles ,   random   |   |   |   /   |   |   seed ,   sysctl ,   ... )   v   |   |   /   |   |   |   local - fs . target   |   |   /   |   |   |   |   |   |   /   \\ ____ | ______ | _______________   ______ | ___________ /   |   /   \\   /   |   /   v   |   /   sysinit . target   |   /   |   |   /   ______________________ / | \\ _____________________   |   /   /   |   |   |   \\   |   /   |   |   |   |   |   |   /   v   v   |   v   |   |   /   (   (   |   (   |   | /   timers ... )   paths ... )   |   sockets ... )   |   |   |   |   |   |   |   |   v   v   |   v   |   |   timers . target   paths . target   |   sockets . target   |   |   |   |   |   |   v   |   v   \\ _______   |   _____ /   rescue . service   |   \\ | /   |   |   v   v   |   basic . target   rescue . target   |   |   |   ________ v ____________________   |   /   |   \\   |   |   |   |   |   v   v   v   |   display -   (   system   (   system   |   manager . service   services   services )   |   |   required     |   |   |   graphical   UIs )   v   v   |   |   multi - user . target   emergency . service   |   |   |   |   \\ _____________   |   _____________ /   v   \\ | /   emergency . target   v   graphical . target   Mount 单元   参考 查阅 ， 内容 复制   金步国 systemd . mount   中文 手册   名称   systemd . mount   —   挂载 单元 配置   大纲   mount   . mount   描述     \"   . mount   \"   后缀 单元 文件 ，   封装 一个   systemd   管理 文件系统 挂载 点 。   本手册 列出 专用 此类 单元   配置 选项 ( 亦 称 \" 配置 指令 \" \" 单元 属性 \" ) 。   systemd . unit   ( 5 )   中 描述 通用 单元 类型 配置 选项 ，   位于   [ Unit ]     [ Install ]   小节 。   此类 单元 专用 配置 选项 位于   [ Mount ]   小节 。   相关 选项 还 包括 ：   systemd . exec   ( 5 )   中 选项 定义   mount ( 8 )   命令 执行 环境 ；   systemd . kill   ( 5 )   中 选项 定义 进程 结束 方式 ；   systemd . resource - control   ( 5 )   中 选项 定义 进程   资源 。   ，   User =     Group =   选项   mount   单元 意义 。   systemd   只   mount ( 8 )   传递   What =     Where =   值 。   调用 方式 下 ，   mount ( 8 )   将会 忽略   / / fstab   中 选项 ，     UID = 0   运行 。   mount   单元 名称 封装 文件系统 挂载 点 路径 命名 。     / home / lennart   挂载 点 单元 名称   home - lennart . mount   。   路径名 转换 单元 名 细节 ， 详见   systemd . unit   ( 5 )   手册 。   ， mount   单元 模版 实例 化而来 ，   创建 软 连接 方法 同一个   mount   单元 赋予 多个 别名 。     mount   单元 都 附带 一个 可选   automount   单元 ，   自动 需 挂载 并行 挂载 。 参见   systemd . automount   ( 5 )   手册 。   系统 运行 时 创建 挂载 点 ( 独立 单元 文件   / / fstab   之外 )   systemd   监控 ，   看上去 常规   mount   单元 没 差别 。     / proc / / mountinfo   详细 解释 参见   proc   ( 5 )   ， 虚拟 文件系统 拥有 特别 功能 ，     mount   单元 修改 禁用 。   ： / sys ,   / proc ,   / dev ,   / tmp ,   sys / fs / cgroup ,   / dev / mqueue ,   / proc / sys / fs / binfmt _ misc   …   详见   API   File   Systems   自动 依赖   隐含 依赖   依赖 关系 自动 隐含 ：     mount   单元 挂载 点 文件系统 层次 树中 位于 一个   mount   单元 挂载 点 之下 ，   ， 将会 两个 单元 中 自动 添加   Requires =   ,   Before =   ,   After =   依赖 。   基于 块 设备 文件系统 挂载 点将 自动 依赖 底层 块 设备 单元   BindsTo =     After =   依赖 。   挂载 点 传统 文件系统 限额 ， 将会 自动 添加   systemd - quotacheck . service     quotaon . service     Wants =     Before =   依赖 。   执行 环境 资源 控制   隐含 依赖 关系 参见   systemd . exec   ( 5 )     systemd . resource - control   ( 5 )   手册 。   默认 依赖   设置   DefaultDependencies =   ，   mount   单元 将会 自动 添加 依赖 关系 ：   挂载 点 ( 网络 本地 ) 都 自动   Before = umount . target     Conflicts = umount . target   依赖 ， 确保 关机 前 卸载 。   本地 文件系统 挂载 点 自动   After = local - fs - pre . target   依赖 。   ， 设置   nofail   挂载 选项 ， 本地 文件系统 挂载 点 还 自动   Before =   local - fs . target   依赖 。   网络 文件系统 挂载 点 自动   After = remote - fs - pre . target   ,   After = network . target   ,   After = network - online . target   ,   Wants = network - online . target   依赖 。   ， 设置   nofail   挂载 选项 ， 网络 文件系统 挂载 点 还 自动   Before =   remote - fs . target   依赖 。   判断 文件系统 本地 网络 依据 文件系统 类型 (   xfs ,   ext4   本地 ，   cifs ,   nfs   网络 ) ，   情况 下 判断 不 可靠 (   iSCSI   基于 网络 块 设备 ) ，   标明 网络 依赖 ， 单元 文件 中   _ netdev   挂载 选项 ，   强迫   mount   单元 视为 基于 网络 文件系统 挂载 点 。   fstab   mount   单元 单元 文件 配置 ，     / / fstab   文件 ( 参见   fstab   ( 5 )   手册 ) 配置 。   / / fstab   中 挂载 点将 每次 加载   systemd   配置 时 ( 包括 系统启动 时 )   动态 自动 转化   mount   单元 。   一般来说 ，   / / fstab   配置 挂载 点 首选 方法 ，   详见   systemd - fstab - generator   ( 8 )   手册 。     systemd - fstab - generator   检测 NFS 挂载 点   bg   挂载 选项 ( 参见   nfs   ( 5 )   手册 ) ，     systemd - fstab - generator   将会 自动   bg   替换   \"   x - systemd . mount - timeout = infinity , retry = 10000   \"   ，     systemd   执行   bg   选项 中 隐含 控制 逻辑 。   场景 需求 ， 建议 设置   \"   nofail   \"   ，   设置 超时 重试 值 ， 利用   \"   x - systemd . automount   \"   选项 ，     \"   bg   \"   选项 。     / / fstab   中 程序 识别   systemd   专用 挂载 选项 ，   创建 挂载 点 相关 依赖 关系 。   本地 文件系统 挂载 点 ，   systemd   将会 自动   local - fs . target   中 创建 指向 挂载 点   Wants =     Requires =   依赖 ；   网络 文件系统 挂载 点 ，   systemd   将会 自动   remote - fs . target   中 创建 指向 挂载 点   Wants =     Requires =   依赖 ；   究竟   Wants =     Requires =   依赖 ，   取决于 设置   nofail   选项 。   x - systemd . requires =   设置 一个 单元 (   device     mount   单元 )   Requires =     After =   依赖 ，   参数 三者 ：   一个 单独 单元 名称 、   一个 绝对路径 设备 节点 、   一个 绝对路径 挂载 点 。   选项 指定 多个 单元 依赖 。 选项 两种 挂载 点 特别 有用 ：   ( 1 ) 额外 辅助 设备 ， 日志 存储 设备 上 日志 文件系统   ( 2 ) 事先 挂载 点 ， 融合 多个 挂载 点 叠合 文件系统   (   Overlay   Filesystem   ) 。   详见   systemd . unit   ( 5 )   手册 。   x - systemd . =   ,   x - systemd . =   设置 一个 单元 (   mount   单元 )   Before =     After =   依赖 。   参数 一个 单独 单元 名称 一个 绝对路径 挂载 点 。   选项 指定 多个 单元 依赖 。   选项 具备 特征 挂载 点 特别 有用 ：   挂载 点 带有   nofail   标记 、   异步 方式 挂载 (   async   ) ( 默认 异步 ) 、   特定 单元 启动 才能 挂载 ( 启动   local - fs . target   挂载 ) 。     Before =     After =   解释 ， 详见   systemd . unit   ( 5 )   手册 。   x - systemd . requires - mounts - =   设置 一个 挂载 点   RequiresMountsFor =   依赖 。   参数 一个 绝对路径 挂载 点 ，   选项 指定 多个 挂载 点 依赖 。   详见   systemd . unit   ( 5 )   手册 。   x - systemd . device - bound   文件系统 所在 块 设备 升级   BindsTo =   依赖 。   选项 仅   mount ( 8 )   手动 挂载 时才 意义 ， 默认   Requires =   依赖 。   ，   / / fstab   中 条目   mount   单元 来说 ，   自动 隐含 设置 选项 。   x - systemd . automount   创建 一个   automount   单元 ，   详见   systemd . automount   ( 5 )   手册 。   x - systemd . idle - timeout =   设置   automount   单元 闲置 时 长 。   参见   TimeoutIdleSec =   选项 ( 参见   systemd . automount   ( 5 )   手册 ) 。   x - systemd . device - timeout =   设置 等候 依赖 设备 可用 状态 时 长 ，   超时 放弃 挂载 。     \"   ms   \" ,   \"   s   \" ,   \"   min   \" ,   \"   h   \"   时间 单位 后缀 。   省略 后缀 单位 秒 。   ， 选项 仅 用于   / / fstab   文件 ，   用于 单元 文件 中   Options =   选项 。   x - systemd . mount - timeout =   设置   / / fstab   中 挂载 点 超时 时 长 。   超过 指定 时间 仍 未 挂载 成功 ， 将会 放弃 挂载 点 。   省略 后缀 单位 秒 。     \"   s   \" ,   \"   min   \" ,   \"   h   \" ,   \"   ms   \"   时间 单位 后缀 。   ， 选项 仅 用于   / / fstab   文件 ，   用于 单元 文件 中   Options =   选项 。   参见 下文   TimeoutSec =   选项 。   x - systemd . makefs   指定 文件系统 格式化 设备 。   设备 \" 非空 \" ( 已 含有 签名 ) ，   将会 跳 格式化 操作 。   ， 选项 已 格式化 设备 。   选项 仅 用于   / / fstab   文件 ， 用于 单元 文件 中   Options =   选项 。   参见   systemd - makefs @ . service   ( 8 )   手册 。   wipefs   ( 8 )   用来 擦除 块 设备 上 已有 签名 ，   x - systemd . makefs   强制 再次 格式化 已 格式化 设备 。   x - systemd . growfs   文件系统 扩展 占用 块 设备 上 空间 。   文件系统 占满 空间 ， 执行 操作 。   ， 选项 扩展 文件系统 。   选项 仅 支持 特定 文件系统 ，   详见   systemd - makefs @ . service   ( 8 )   手册 。   选项 仅 用于   / / fstab   文件 ， 用于 单元 文件 中   Options =   选项 。   _ netdev   文件系统 类型 判断 网络 文件系统 (   xfs ,   ext4   本地 ，   cifs ,   nfs   网络 ) ，   网络 可用 才能 启动 。   情况 下 判断 不 可靠 (   iSCSI   基于 网络 块 设备 ) ，   选项 强迫 文件系统 标记 网络 文件系统 。   网络 文件系统   mount   单元 安排   remote - fs - pre . target     remote - fs . target   之间 启动 (   local - fs - pre . target     local - fs . target   之间 ) ，   自动   After = network - online . target   ,   Wants = network - online . target   ,   After = network . target   依赖 。   noauto   ,   auto   noauto   不 挂载 点   local - fs . target   /   remote - fs . target   依赖 中 ，   不 系统启动 时 自动 挂载 ( 单元 依赖 挂载 ) 。 默认值   auto   自动 挂载 点 目标 单元 依赖 中 ( 系统启动 时 自动 挂载 ) 。   ，   noauto   选项 仅 作用   mount   单元 ，   x - systemd . automount   选项 ，     automount   单元 会 目标 单元 依赖 中 。   nofail   仅   local - fs . target   /   remote - fs . target   中 对此 挂载 点   Wants =   依赖 ( 默认   Requires =   ) ，   启动 顺序 上 ，   mount   单元 排 目标 单元 。   意味着 ， 启动 流程 等待 挂载 点 ， 在乎 挂载 点 挂载 成功 。   x - initrd . mount   initramfs 中 额外 挂载 文件系统 ，   参见   initrd - fs . target   解释 ( 参见   systemd . special   ( 7 )   手册 ) 。   一个 挂载 点 封装 一个   mount   单元 中 ，   配置   / / fstab   文件 中 ， ：   ( 1 ) 单元 文件 位于   / usr   中 ，     / / fstab   文件 为准 ( 无视 单元 文件 ) 。   ( 2 ) 单元 文件 位于   /   中 ，   单元 文件 为准 ( 无视   / / fstab   文件 ) 。   意味着 同一个 挂载 点 来说 ，   /   中 单元 文件 优先级 、   / / fstab   文件 次之 、   / usr   中 单元 文件 优先级 最低 。   选项     mount   单元 文件 都 包含 一个   [ Mount ]   小节 ，   用于 包含 单元 封装 挂载 点 信息 。     [ Mount ]   小节 中 选项 ，   单元 共享 ， 详见   systemd . exec   ( 5 )     systemd . kill   ( 5 )   手册 。   只 列出 仅能 用于   [ Mount ]   小节 选项 ( 亦 称 \" 指令 \" \" 属性 \" ) ：   What =   绝对路径 形式 挂载 对象 ： 设备 节点 、 LOOP 文件 、 资源 ( 网络资源 ) 。   详见   mount ( 8 )   手册 。   一个 设备 节点 ， 将会 自动 添加 对此 设备 节点 单元 依赖 ( 参见   systemd . device   ( 5 )   手册 ) 。   这是 一个 必需 设置 。 ， 选项 中   \"   %   \"   系列 替换 标记 ，   百分号 ( % )   \"   %%   \"   。   Where =   绝对路径 形式 挂载 点 目录 。   ， 设 一个 软 连接 ( 指向 一个 目录 ) 。   挂载 时此 目录 不 ， 尝试 创建 。   ，   设置 绝对路径 单元 文件 名称 应 ( 见 上文 ) 。   这是 一个 必需 设置 。   Type =   字符串 形式 文件系统 类型 。 详见   mount ( 8 )   手册 。 这是 一个 可选 设置 。   Options =   一组 逗号 分隔 挂载 选项 。 详见   mount ( 8 )   手册 。   这是 一个 可选 设置 。 ， 选项 中   \"   %   \"   系列 替换 标记 ，   百分号 ( % )   \"   %%   \"   。   SloppyOptions =   设         Options =   中 文件系统 不 支持 挂载 选项 ，   导致 挂载 失败 ( 相当于   mount ( 8 )     - s   命令行 选项 ) 。   默认值     禁止   Options =   中   文件系统 不 支持 挂载 选项 ( 会 导致 挂载 失败 ) 。   LazyUnmount =   设置 延迟 卸载 。   设     文件系统 挂载 点 分离 ，   等待 设备 不再 忙碌 ，   才 会 清理 对此 文件系统 引用 ( 卸载 ) 。   相当于   umount ( 8 )     - l   选项 卸载 。   默认值     ForceUnmount =   设置 强制 卸载 。   设     强制 卸载 ( 仅 建议 用于   NFS   文件系统 ) 。   相当于   umount ( 8 )     - f   选项 卸载 。   默认值     DirectoryMode =   自动 创建 挂载 点 目录 ( 包括 上级 目录 ) 时 ，     权限 模式 ( 八进制 表示法 ) 。   默认值   0755   TimeoutSec =   多长时间 挂载 动作 。   超时 视为 挂载 失败 ，   运行 命令 都   SIGTERM   信号 终止 ；   等待 时长 命令 仍 未 终止 ，     SIGKILL   信号 强制 终止   ( 详见   systemd . kill   ( 5 )   中   KillMode =   选项 ) 。     \" ms \" ,   \" s \" ,   \" min \" ,   \" h \"   时间 单位 后缀 。   省略 后缀 单位 秒 。   设为 零 永不 超时 。   默认值   DefaultTimeoutStartSec =   选项 值 ( 参见   systemd - system . conf   ( 5 )   手册 ) 。   参见   systemd . exec   ( 5 )     systemd . kill   ( 5 )   更 设置 。   参见   systemd   ( 1 )   ,   systemctl   ( 1 )   ,   systemd - system . conf   ( 5 )   ,   systemd . unit   ( 5 )   ,   systemd . exec   ( 5 )   ,   systemd . kill   ( 5 )   ,   systemd . resource - control   ( 5 )   ,   systemd . service   ( 5 )   ,   systemd . device   ( 5 )   ,   proc   ( 5 )   ,   mount   ( 8 )   ,   systemd - fstab - generator   ( 8 )   ,   systemd . directives   ( 7 )   Timer 单元   Timer 单元 针对 服务 进程 配置 定时 很 ， 大体 crontab 类似 功能   服务 文件 修改   推荐 配置文件 外移 ， 服务 文件 设置 好 没 修改 ， 服务 文件 修改 ：   systemctl   daemon - reload   日志 管理   systemd 统一 管理 日志 ， 可用   jourlnalctl   命令 查看 。 点名 看 服务 Unit ：   jourlnalctl   - - unit = nginx   启动 服务   启动 服务 重启 服务 暂停 服务 想 都 很 熟悉 ：   systemctl   start   . service   systemctl   stop   . service   systemctl   restart   . service   centos7 配置 dns   发现 centos7 配置 dns 重启   network   服务 配置 会 丢失 ，   / / NetworkManager / NetworkManager . conf   main 加上   dns   =     重启   systemctl   restart   NetworkManager . service   再 如同 修改   / / resolv . conf   。   配置 语言   查看 操作系统 语言   cat   / / locale . conf     localectl   status   列出 可用 语言   locale   - a     localectl   list - locales   |   grep   zh   修改 操作系统 语言   sudo   localectl   set - locale   LANG = zh _ CN . utf8   参考资料   鸟哥 私房 菜   systemd 入门教程 命令   systemd 详解   浅析   Linux   初始化   init   系统 - systemd",
            "tags":"linux",
            "url":"articles/centos7xi-tong-xue-xi.html"
        },
        {
            "title":"linux系统基础知识",
            "text":"debian 系 rpm 系   Linux 主流 包 管理系统 分为 debian 系 rpm 系 两个 。 CentOS Redhat rpm 系 ； ubuntu debian 系统 debian 系 。 ubuntu 中 第一个 学习 命令   apt   命令 ， 系统软件 安装 卸载 更新 工作 ； centos 第一个 学习 命令   yum   命令 ， apt 命令 类似 一系列 系统 软件包 管理 操作 。   yum 命令 rpm 命令   yum   install     安装 软件   yum   groupinstall     安装 软件 组 。   yum   update   更新 系统 软件包   yum   remove     卸载 软件   yum   groupremove     卸载 软件 组   yum   clean   清除 系统 软件包 管理 相关 缓存   rpm   - i   . rpm   本地 安装 rpm 包 ， 会 加上   - vh   选项 显示 更 安装 信息 安装 进度 。   rpm   - qa |   grep     搜索 本地 安装 名字 带有 rpm 包 ，   apt 命令 dpkg 命令   系统 安装 好 第一件 做 事 选 一个 好 源 ， 安装 更新 。 系统 设置 → 软件 更新 ， \" 下载 \" 软件 源 服务商 ， 搜索 一个 速度 最快 源 。 终端 中 执行 命令 升级 系统 软件包 ：   apt   update   更新 源   apt   upgrade   升级 源下 安装 软件 （ 很多 软件 升级 推荐 命令 ：   （   apt   dist - upgrade   不 出错 些 。 ）   apt   install     安装 软件   apt   autoremove   清理 软件 残余   apt   autoclean   清理 安装 软件 留下 缓存   apt   remove     删除 软件   apt   purge     删除 软件 包括 软件 配置   设置 root 用户 密码   Centos Ubuntu 安装 好 ， 创建 一个 用户 密码 ， root 用户 密码 设置 。 终端 输入 ：   sudo   passwd   root   设置 好 密码 ， 输入 ：   su   root 账户 ， 输入 ：   exit   退出 root 用户 。   passwd 命令 还 修改 用户 密码 ：   sudo   passwd   youname   。   一种 情况 忘 用户 密码 包括 root 密码 ， 操作 修改 root 密码 ：   系统 重启 菜单 选项 ，   e   grub 编辑 模式 ， kenerl 一行 再   e   编辑 该行 ， 行尾 加上   single   ，   Enter 确认 ，   b   单用户 维护 模式 ，   passwd   命令 修改 root 密码   （ 此条 参考 vbird 第五章   ） 。   最 命令   打开 终端 ， 一个 美元   $   符号 ， 输入   su   命令 ， root 账户 ， 开头 一个   #   符号 ，   $   普通用户 ，   #   超级 用户 。 一个 波浪 号   ~   ， 波浪 号 用户 目录 ，   ~   目录   / home / wanze   。   Linux 系统 最 常用 两个 命令   ls     cd   。   ls   命令 会 列出 当前目录 包含 文件夹 文件 ，     cd   folder _   文件夹 。 再 输入   cd   ， 会 回到 家 目录 。 等于 执行   cd   ~   。   cd 命令 还   cd   .   ， 点 当前目录 ，   cd   ..   返回 上 一级 目录 。   cd   /   ， 跳 系统   /   目录 下 。   命令 学会 用熟 ， 请 读者   - -   学习 ：   cp   复制 文件 命令     查看 系统 命令 位置   touch   创建 文件 已 文件 更新 时间 戳   rm   删除 文件 ，   - r   选项 删除 一个 文件夹 ， 文件夹 文件夹 文件 。   mkdir   创建 文件夹 ， 加上   - p   选项 创建 多层 目录 。   rmdir   删除 文件夹 ， 加上   - p   选项 删除 多层 目录 ， 保证 文件夹 空 。   mv   文件 ， 命令 重命名 操作 。   shell   shell 好像 一个 包装 层 ， shell Linux 操作系统 核心 kernel ， 进去 ， 将会 一个 艰深 领域 ， 计算机硬件 ， 驱动程式 Linux 系统 设计 核心 ， 知识 都 专业 ， 人 不 深究 。   Shell 提供 操作系统 核心 （ 称为 kernel ） 用户 之间 交互 程序 ， 参见 下图 。 kernel 启动 时 装入 内存 , 管理系统 关机 为止 。 负责 建立 控制 进程 ， 管理 内存 、 文件系统 、 通信 。 实用程序 ， 包括 Shell 在内 都 存储 硬盘 上 。 kernel 程序 硬盘 中 装入 内存 ， 运行 ， 程序运行 结束 后 回收 程序 占用 系统资源 。 Shell   是从 登录 开始运行 实用程序 ， 用户   Shell   脚本 命令行 方式 输入 命令 ， 翻译 命令 用户 kernel 交互 。   系统 Bourne   Shell （ bash   shell ） 。 本文 提到 shell 指 bash   shell ， shell 不 讨论   PATH 变量   输入 ls 命令 ， shell   PATH   变量 搜索 相关 命令 文件 所在 。 读者 查看 变量 ：   echo   $ PATH   安装 软件 ， shell 却 发现 找 不到 ， 软件 可执行文件 目录 系统   PATH   环境 下 找到 。 语法 ：   PATH   =   $ PATH : / / / bin   管道   简单 shell ， 简单 下 管道 重定向 两个 概念 ， 最 简单 一行 bash 命令 会 涉及 两个 概念 。   管道 最 简单 理解 第一个 shell 命令 输出 流 流向 一个 shell 命令 中 输入 。 比如说 火狐 浏览器 卡住 （ 随便 举个 例子 ， 没 。 。 ） ， 看 pid kill 掉 ， 查看 ：   ps   aux   |   grep   firefox     |   管道 概念 ，   ps   aux   命令 ， 输出 送入   grep   命令 中 去 ， 抓取 包含 firefox 字符 匹配 行 。   重定向   kernel 一个 进程 都 默认 都 0 ， 1 ， 2 三个 文件 说明符 。 0 标准 输入 ， 1 标准 输出 ， 2 标准 错误 输出 。 标准 输出 指 输出 终端 ， 标准 错误 输出 输出 终端 。   文件 说明符 分配 非 终端 ， I / O 重定向 。 Shell 关闭 标准 输出 ， 标准文件 说明符   1 （ 终端 ） 分配 文件 ， 输出 定向 文件 ；   文件 说明符 0 ， 标准 输入 定向 ； 文件 说明符 2 重定向 标准 错误 输出 。   >   重定向 操作 。   > >   文件 追加 操作 ， 相当于 文件 操作   a   操作 。   最 简单 重定向 ：   cat   * . txt   >   test . txt   目录 下 glob 抓取 txt 文件 都 合并 成 一个 字符串 流 ， 重定向 送入 test . txt 文件 中 去 。   cat   * . txt   命令 神奇 处 ， 神奇 Linux 终端 文件 glob 操作   *   （ 任意 数目 任意 字符 ）     （ 一个 任意 字符 ） 支持 。   echo   * . txt   命令 查看 。   再学 几个 命令   clear   终端 清屏 ， 内容 清除 ， 终端 都 带有 记忆 功能 回滚 功能 ， 向上 滚 ， 看 内容 。   history   显示 登录 用户 执行 命令 ， 登录 用户 家 目录 下   . bash _ history   文件 内容 。   cat   cat 命令 简单 用法 ：   cat   test . txt   ， 查看 文本文件 内容 ， cat 命令 来自 英文单词 ( concatenate ) ， 英文单词 通用 联接 ， 延伸 计算机领域 单词 就是指 两个 字符 联接 成 一个 。 cat 命令 功能 两个 更 字符 流 文件 联接 一个 字符 流 ， 默认 显示 终端 上 ， 重定向 字符 流 流向 文件 保存起来 。     命令 常用 接受 管道 传过来 字符 流 信息 ， 延缓 打印 读者 阅读 。   额外 值得一提的是   windows 下   powershell ， 管道 ：   type   test . txt   |     head   打印文件 前 几行 内容 ，   - n   指定 打印 行 。   tail   打印文件 后 几行 内容 ，   - n   指定 打印 行 。 tail 一个 用法 ，   加上   - f   选项 跟踪 打印文件 附加 内容 。   uname   命令 输入 简单 返回 \" Linux \" 字符串 ， 用处 不 大 。 查看 uname 命令 信息 得知 命令 返回 电脑 操作系统 ， 硬件 架构 ， 内核 版本号 信息 。 ：   = > uname   - s   # 内核 名字   Linux   = > uname   - n   # 主机 名字   wanze - ubuntu   = > uname   - r   # 内核 发行 号   3.13 . 0 - 36 - generic   = > uname   - m   # 硬件 架构   i686   = > uname   - p   # 处理器 类型   i686   = > uname   - o   # 操作系统 名字   GNU / Linux   whoami   whoami 返回 登录 用户 名字 ， 等价   id   -   。   文件 用户   小节 参考   阮 一峰 inode 文章   。   Linux 系统 一句 很 有名 一句 话 ，   一切都是 文件   。 文件 分为 ：   文件 、 目录 文件 、 字符 设备 文件 、 块 设备 文件 、 链接 文件 、 套 接字 文件 。   Linux 操作系统 找 文件 ，   / / passwd   文件 。 文件名 ， 一连串 字符串 ， 找个 inode 号 ， inode 号 获取 inode 信息 ， inode 信息 ， 找到 文件 所在 block ， 读出 数据 。   Linux 文件名 两种 写法 ， 一种 绝对路径 ， 一种 相对路径 。 绝对路径   /   开头 文件名 ，   .     ..   开头 相对路径 写法 。 相对路径 shell 工作 目录 ， pwd 命令 查看 shell 当前工作 目录 。   pwd 命令   pwd 命令 用来 查看 当前工作 目录 文件系统 中 路径 。   ：   /   Linux 文件系统 地方 。   ~   shell 登录 用户 家 目录 所在 ， shell   $ HOME   变量 值 。   .   相对路径 写法 ， 当前目录 。   ..   相对路径 写法 ， 上 一级 目录 。   stat 命令   stat   命令 用来 查看 文件 信息 。   [ root @ host   ~ ] #   stat   /   File :   ` / '   Size :   4096   Blocks :   8   IO   Block :   4096   directory   Device :   802h / 2050d   Inode :   37   Links :   76   Access :   ( 0755 / drwxr - xr - x )   Uid :   (   0 /   root )   Gid :   (   0 /   root )   Access :   2017 - 09 - 05   01 : 35 : 41.983000000   - 0400   Modify :   2017 - 09 - 21   15 : 10 : 57.103000000   - 0400   Change :   2017 - 09 - 21   15 : 10 : 57.103000000   - 0400   信息   Inode   inode 号 （ 看作 电脑 文件名 ） 之外 ， 信息 都 存放 Inode   table   。 大体 ： 文件大小 ， 文件类型 ， 权限 ， 所有者 id ， 群 id ， access   time （ 上 打开 时间 ） ， modify   time （ 上 修改 时间 ） ，   change   time （ 上 inode 信息 读写 权限 更改 时间 ） 。   文件 例子 ， Links 1 ， 目录 文件 Links 1 ， 含义 硬 连接 （ hard   link ） 指向 ， 一般来说   2 + n ， n 目录 子目录 数目 ， Linux 下 新建 文件夹 都 预先 包含   .     ..   两个 子 文件夹 ， 用途 读者 猜到 ， 做 相对路径 （ 参考   网页   ） 。 讨论 硬 连接 会 讨论 硬 连接 文件夹 ， 硬 连接 文件夹 会 破坏 Linux 层级 文件系统 。   [ root @ host   ~ ] #   stat   / / passwd   File :   ` / / passwd '   Size :   986   Blocks :   8   IO   Block :   4096   regular   file   Device :   802h / 2050d   Inode :   17775   Links :   1   Access :   ( 0644 / - rw - r - - r - - )   Uid :   (   0 /   root )   Gid :   (   0 /   root )   Access :   2017 - 09 - 21   11 : 23 : 26.112000000   - 0400   Modify :   2017 - 09 - 21   11 : 23 : 26.112000000   - 0400   Change :   2017 - 09 - 21   11 : 23 : 26.113000000   - 0400   块 设备 文件 ， 其是 一个 文件系统 ， 大小 查看 加上   - f   选项 。   [ root @ host   ~ ] #   stat   / dev / sda   File :   ` / dev / sda '   Size :   0   Blocks :   0   IO   Block :   4096   block   special   file   Device :   6h / 6d   Inode :   9005   Links :   1   Device   type :   8 , 0   Access :   ( 0660 / brw - rw - - - - )   Uid :   (   0 /   root )   Gid :   (   6 /   disk )   Access :   2017 - 09 - 05   01 : 36 : 41.869000000   - 0400   Modify :   2017 - 09 - 05   01 : 36 : 41.869000000   - 0400   Change :   2017 - 09 - 05   01 : 36 : 41.869000000   - 0400   [ root @ host   ~ ] #   stat   - f   / dev / sda   File :   \" / dev / sda \"   ID :   0   Namelen :   255   Type :   tmpfs   Block   size :   4096   Fundamental   block   size :   4096   Blocks :   Total :   61502   Free :   61465   Available :   61465   Inodes :   Total :   61502   Free :   60924   ls 命令   ls 命令 最 常用 两个 选项   - a     - l   ， 一个 显示 隐藏 文件 （ Linux 系统 中 文件名   .   开头 隐藏 文件 ） ， 一个 显示 更 更 信息 。     - i   选项 显示文件 Inode 号 。   Linux 系统 最 精彩 管道 重定向 概念 小 程序 小 工具 揉合 一个 协作 整体 ， 先举个 简单 例子 看 下 ：   ls   * . txt   将会 一个 文件夹 后缀 txt 文件名 字符 流 扫描 ， 字符 流 包含 目标 文件 文件名 管道 进一步 操作 。   ls   - - sort   选项 用来 排序 ， 很 有用 ， ， 管道 传递 sort 命令 进一步 排序 操作 。 所示 ：   ls   * . txt   |   sort   ls 抓取 文件 字符 流 操作 ， 所示 ：     i     $ (   ls   * . txt   |   sort   )   ;     echo   $ i   ;     ;   ​   段 代码   $ i   一个个 文件 字符 流 。   - l 选项 详解   先看 例子 ：   - rw - rw - r - -   1   wanze   wanze   41034   8 月   27   15 : 19   wisesystem . xoj   drwxrwxr - x   4   wanze   wanze   4096   5 月   28   18 : 50   yEd   lrwxrwxrwx   1   wanze   wanze   22   9 月   11   18 : 37     git   链接   - >   / home / wanze / 桌面 / git   最 先 第一 栏看 懂 ， 文件 所有者 文件 群 再 讨论 。   第一 栏 文件属性 开头   d   文件 目录 文件 ，   -   文件 文件 ， 开头   l   文件 链接 文件 （ 讨论 软 连接 相关 ） 。 三个 rwx 文件 所有者 文件 可读 写 执行 ， 控制 执行 ， 就要 属性 改为 rw - ， 文件 权限 控制 更 详细 讨论 。   第二 栏是 hard   links 连接 ， 提到 。   第三 栏是 文件 所有者 ， 第四 栏是 文件 群 ， 第五 栏是 文件大小 。 第六 栏是 文件 修改 日期 建档 日期 。   UID GID   用户 shell 登录 Linux 系统 ， 一个 login 接口 ， 输入 用户名 密码 才能 操作 。   系统 会   / / passwd   找 有没有 用户名 ， ， UID GID 取出 ， shell 家 目录 一并 设置 。   UID   / / shadow   文件 内容 核对 密码 。 密码 核对 成功 ， 成功 登入 shell 。   / / passwd   内容 大体 所示 ：   root : x : 0 : 0 : root : / root : / bin / bash   bin : x : 1 : 1 : bin : / bin : / sbin / nologin   含义 ：   : x : UID : GID : 信息 : home 目录 :   shell   shell 有个 特别 值 ：   / sbin / nologin   登录 。   ， 系统   / / passwd   登录 用户 GID 查看   / / group   用户 所属 群组 信息 。   root : x : 0 :   bin : x : 1 : bin , daemon   一行 含义 ：   : x : GID : 群组 所含 用户 ， 逗号 隔开   useradd usermod 命令   useradd usermod 两个 命令 很多 选项 类似 ， 简单 创建 一个 新 用户   useradd   _ user _   很多 选项 设置 useradd 设置 ，   usermod   命令 设置 。     - d   用于 设置 新 用户 家 文件夹 。   - m   选项 只能   - d   选项 所示 ：   usermod   user _   - md   / newhome / newpath   用户 原家 目录 移到 新 位置 （ 请 参看   网页   ） 。   userdel 命令   userdel 用于 删除 用户 数据 ，   / / passwd   / / shadow   群组 相关 数据 。 加上   - r   选项 ， 将会 用户 家 目录 一并 删除 。   groupadd groupmod 命令   类似 groupadd groupmod ， groupdel 命令 。   su 命令 sudo 命令   su 命令 用于 切换 身份 ， 最 常用 一个 选项   - c   ， 用于 用户 身份 执行 命令 。   su   root   - c   \" ls   / root \"   su 命令 新 切换 用户 密码 ， sudo 命令 只 密码 即可 ， 不 root 用户 密码 没关系 。 Linux 系统   / / sudoers   文件 管理 sudoer 权限 ， 用户 sudoer ， 其是 运行 sudo 命令 。   sudo   - u   root   ls   / root     - u   指定 用户 ， 默认 root 用户 ，   - u   root   不 写 。   用户 sudoer   运行   visudo   命令 ， 跳 文件 ， 找到 一行 ：   ##   Allows   people     group   wheel     run     commands   #   % wheel   ALL = ( ALL )   ALL   第二行   #   去掉 ， 目标 用户 wheel 群组 中 去 ：   usermod   - aG   wheel   user _   目标 用户 执行 sudo 命令 。   NOTICE   ：   做 不 成功 ， 想要 用户名 加上 去 ， 大体 ：   user _   ALL = ( ALL )   ALL   chown chgrp 命令   讲到 Linux 系统 中 文件 都 两个 属性 ： 文件 所有者 ， 群是 。 登录 用户 （ 或者说 进程 执行 用户 ） 文件 所有者 ， 再 来看 文件 权限 前三位 rwx 写 ， 可读 可读 ， 写 写 。 权限 管理 第一步 先 管理 好 文件 所有者 群 。   chown   user _   filename   #   改变 文件 所有者   chgrp   group _   filename   #   改变 文件 群   两个 命令 都 接受   - R   选项 递归 修改 目录 目录 下 文件 文件属性 。   chmod 命令   chmod 命令 改变 文件 权限 。 用法 ：   chmod   a + x   filename   chmod   755   filename   命令 接受   - R   选项 递归 修改 目录 目录 下 文件 文件属性 。   权限 两种 方法 ：   r   ead 、   w   rite 、 执行 (   x   ) 。   a   ， ，   u   ser （ 所有者 ） ，   g   roup （ 群 ）   o   thers （ 用户 ） 。   +     -   加 权限 减 权限 （   =   设定 值 ） 。   第二个 方法 权限 rwx 分为 三位 ， r 数字 4 ， w 数字 2 ， x 数字 1 ， 比如说 数字 7 rwx ， 比如说 数字 6   rw -   ， 比如说 数字 5   r - x   。   目录 文件 权限 含义   文件 权限 含义 很 ， 目录 文件 权限 含义 直白 。   目录 文件 读 ls 命令 列出来 。   目录 文件 写 文件夹 新建 文件 或子 文件夹 ， 删除 文件 ， 包括 更名 。   目录 文件 执行 cd 目录 。 用户 cd   / root   文件夹 去 。 cd 进去 ， 文件 执行 ，   web   服务器 服务 文件夹 时 ， rx 权限 ， w 权限 ， 小心 ， 母 文件夹 权限 没 设置 好 ， x 权限 ， 会 导致 web   服务器 权限 ： Permission   denied   错误 。   硬 连接 软 连接   硬 连接 （ hard   link ） 谈论 ， 提到 一个 文件 Links 1 ， 讨论 创建 硬 连接 创建 一个 新 文件名 指向 同一个 inode 节点 ， 硬 连接 。 硬 连接 跨 文件系统 ， 连接 目录 。   软 连接 符号 连接 ， 软 连接 相当于 新建 一个 快捷方式 文件 。 硬 连接 局限 ， 连接 目录 ， 实践 中 常用 软 连接 。 软 连接 创建 一个 链接 文件 。   ln 命令 默认 创建 硬 链接 ，   - s   参数 创建 符号 连接 。   ln   - s   源文件   目标 文件   ​   tar 命令   打包 解压 文件 tar 命令 ， 支持 gzip bzip2 两种 格式 。   常见 打包 解压 ：   tar   - cf   archive . tar   foo   bar   tar   - xf   archive . tar     - c   创建 打包 文件 ，   - f   选项 指定 文件名 ， 跟着   archive . tar   文件名 ， 跟着 想 打包 进 压缩文件 文件 文件夹 名 。   解压 文件 带上   - x   选项 ， 带上 一个   - v   选项 linux 命令 中 常见 verbose 模式 ， 显示 更 打印信息 。   tar 命令 还 支持 格式 打包 解压 ， gzip 格式 ， 就要 带上   - z   选项 ， 文件名   . tar . gz   ， 记住 打包 解压 都 带上 选项 。   bzip2 格式 ， 就要 带上   - j   选项 ， 文件名   . tar . bz2   。   - - exclude   选项 ：   压缩 文件夹 排除 掉 文件夹 子 文件夹 ， 更 确切 表述   PATTERN   排除 ， 排除 文件 。 类似 排除 选项 很多 ， 最 简单 子 文件夹 名字 写上去 ， 排除 子 文件夹 。   - C   选项 ：   很 有用 一个 选项 ， 想要 解压 内容 文件夹 下 选项 。   - - strip - components   选项 ：     - C   选项 单独 一个 ， 想 解压 一个 压缩包 ， 文件夹 目录   what2.2 /   ， 假设 指定 解压   / root   test 文件夹 ， test 文件夹 还会 创建   what2.2 文件夹 再 内容 。   - - strip - components     - C   一个 很 有用 用法 ，   重命名 输出 文件夹   ， 选项 用处 输出 文件夹 路径名 剔除 掉 几个 ：   ， 文件夹 路径名 expython 开头 ， 定制 输出 test 文件夹 ， 剔除 文件 文件 路径名 第一个 ， expython / ， 重命名 输出 文件夹 功能   （ 参考   网页   ） 。   tar   - zxvf   expython - 0.2 . 2 . tar . gz   - C   . / test   - - strip - components   1   ps 命令   ps 查看 系统 运行 进程 命令 ， 用法 ：   ps   [ option ]   进程 卡住 ， 运行   ps   aux   查看 进程 进程 号 （ PID ） ， kill （ kill 命令 ， 杀死 进程 。 ） 就行了 。   ssh 登录   SSH 协议 用于 计算机 之间 加密 远程 登录 。 小节 参考   阮 一峰 ssh   remote   login   一文   。   ssh 登录 操作系统 都 便捷 工具 ， 推荐 读者 先 工具 ， 讨论 ssh 命令 用法 概念 。   ssh 登录 命令 格式 :   ssh   username @ host   ssh 默认 端口号 22 ，   - p   指定 端口号 。 username 远程 计算机 用户名 ， host 远程 计算机 ip 地址 。   默认 情况 下 ssh 登录 远程 终端 输入 远程 计算机 密码 ， 一种 公钥 上 传到 远程 计算机 方法 不用 输入 密码 登录 。 生成 公钥 :   ssh - keygen   - t   rsa   生成 公钥 文件 文件   $ HOME / . ssh   （ windows 系统 下 登录 用户 家 目录 下 ） ， 其为   id _ rsa . pub   ， 一个   id _ rsa   私钥 文件 。 公钥 文件 上 传上去 即可 :   ssh - copy - id   username @ host   懒得 记   ssh - copy - id   命令 ，   id _ rsa . pub   公钥 文件 内容 ， 复制粘贴 远程 计算机 （ 想 登录 登录 用户 ） 登录 用户 家 目录 下   . ssh   （ 新建 ） 文件夹 下   authorized _ keys   文件 （ 新建 ） 。   免 密码 ssh 登录 ， Github 走 ssh 通道 免 密码 方式 ， 类似 计算机 公钥 文件 内容 设置 。   ssh 连接 长时间   ssh 连接 远程 主机 ， 执行 长时间 命令 ， 一段时间 没去 终端 窗口 ， ssh 连接 会 自动 中断 ， 终端 远程 相关 进程 会 kill 掉 。 会 返回   Broken   pipe   错误 。   一个 简单 解决方案 远程 主机 上 执行 命令 ， 命令 加上   nohup   命令 ， 类似 格式 :   nohup   thecommand   更 好地解决 方案   screen   小 工具 ， 远程 screen 命令 开启 一个 执行 shell 命令 全屏 窗口 （ 自动 关闭 ） ， 本地 终端 窗口 关闭 ， 远程 主机 相关 进程 会 运行 。 screen 命令 常见 用法 :   screen 命令   screen   - S     创建 一个 screen 进程 ， 取个 名字 ， screen 进程 名字 。   screen   - ls   电脑 都 screen 进程 。   screen   - r   thename _ _ thepid   重连 screen 进程 ， 默认 只能 Detached （ 失连 ） 进程 。   exit   退出   Ctrl + a   再 d   断 ， screen 进程 还 。   screen   - wipe   清除 Dead screen 进程 。   screen   - D   - r   screen 进程 断开连接 ， 显示 Attached ， 选项 组合 强制 screen 进程 失连 ， 再重 。   设置 后台 服务   写 一个 后台 服务 脚本 ， Linux 系统 一个 后台 服务 。 小节 参考   网页   。   # ! / bin / sh   ###   BEGIN   INIT   INFO   #   Provides :   shadowsocks   #   Required - Start :   $ remote _ fs   $ syslog   #   Required - Stop :   $ remote _ fs   $ syslog   #   Default - Start :   2   3   4   5   #   Default - Stop :   0   1   6   #   Short - Description :   Example   initscript   #   Description :   The   shadowsocks   service   ###   END   INIT   INFO   PROG _ BIN   =   ssserver   PIDFILE   =   / var / run / shadowsocks . pid   OPTIONS   =   \" - - pid - file   $ PIDFILE   - c   / / shadowsocks / config . json \"   RETVAL   =   0   start   ( )   {   echo   - n   $   \" Starting   $ 0   :   \"   $ PROG _ BIN   $ OPTIONS   - d   start   RETVAL   =   $   return   $ RETVAL   }   stop   ( )   {   echo   - n   $   \" Stopping   $ 0   :   \"   $ PROG _ BIN   $ OPTIONS   - d   stop   RETVAL   =   $   return   $ RETVAL   }   status   ( ) {     [   - e   $ PIDFILE   ]   ;     echo   $ 0     running ,   pid   =   `   cat   $ PIDFILE   `     echo   $ 0     stopped   RETVAL   =   1   return   $ RETVAL   fi   RETVAL   =   0   return   $ RETVAL   }   #   See         called .   case   \"   $ 1   \"     start   )   start   ; ;   stop   )   stop   ; ;   status   )   status   ; ;   reload   |   restart   )   stop   start   RETVAL   =   $   ; ;   *   )   echo   $   \" Usage :   $ 0   { start | stop | restart | reload | status } \"   RETVAL   =   2   esac   exit   $ RETVAL   服务 脚本 放入   / / init . d   去 。     service     start +   调用 服务 脚本 。   服务 脚本 开机 自启动 ， 推荐   chkconfig +   命令 做 。   chkconfig   - - add     添加 服务 chkconfig 管理 。   chkconfig   - - del     删除 服务   chkconfig   - - level   < 级别 >       设置 服务 启动 级别   启动 级别 ：   等级 0 ： 关机   等级 1 ： 单用户 模式   等级 2 ： 无 网络连接 多用户 命令行 模式   等级 3 ： 网络连接 多用户 命令行 模式   等级 4 ：   等级 5 ： 带 图形界面 多用户 模式   等级 6 ： 重新启动   ​   常用 级别 设置   35   chkconfig   - - level   35       网络 配置   IP地址   IP地址 32 位 二进制 ， 十进制 最小   0.0 . 0.0     255.255 . 255.255   。 NetID HostID ， 网域 NetID 。   IP地址 分类 ：   以二 進位 說明   Network   第一 個 數字 定義 ：   Class   A   :   0xxxxxxx . xxxxxxxx . xxxxxxxx . xxxxxxxx   = = >   NetI _ D   開頭   0   | - - net - - | - - - - - - - - - host - - - - - - - - - - - - |   Class   B   :   10xxxxxx . xxxxxxxx . xxxxxxxx . xxxxxxxx   = = >   NetI _ D   開頭   10   | - - - - - - net - - - - - - - | - - - - - - host - - - - - - |   Class   C   :   110xxxxx . xxxxxxxx . xxxxxxxx . xxxxxxxx   = = >   NetI _ D   開頭   110   | - - - - - - - - - - - net - - - - - - - - - - - | - host - - |   Class   D   :   1110xxxx . xxxxxxxx . xxxxxxxx . xxxxxxxx   = = >   NetI _ D   開頭   1110   Class   E   :   1111xxxx . xxxxxxxx . xxxxxxxx . xxxxxxxx   = = >   NetI _ D   開頭   1111   五種 分級 十進位 ：   Class   A   :   0 . xx . xx . xx   ~   127 . xx . xx . xx   Class   B   :   128 . xx . xx . xx   ~   191 . xx . xx . xx   Class   C   :   192 . xx . xx . xx   ~   223 . xx . xx . xx   Class   D   :   224 . xx . xx . xx   ~   239 . xx . xx . xx   Class   E   :   240 . xx . xx . xx   ~   255 . xx . xx . xx   系统 ABC 三个 等级 。   IP 两种 IP ，   一种   公网 IP   ， 一个   私网 IP   。   私网 IP 三个 等级 之下 所示 ：   Class   A ： 10.0 . 0.0   -   10.255 . 255.255   Class   B ： 172.16 . 0.0   -   172.31 . 255.255   Class   C ： 192.168 . 0.0   -   192.168 . 255.255   ​   子网掩码   子网掩码 概念 确实 难 理解 ， 关键 太 拘泥于 特例 细节 ， 鸟哥 最 说 ， 子网掩码 东西 分割 网域 ， 一个 网域 定义   Network   网域 最小 IP   Netmask   子网掩码   Broadcast   广播 地址   ​   描述 ， 最 常见   192.168 . 0.0 / 24   24 指 子网掩码 24 1 。 表达 定义 完整 网域 ：   192.168 . 0.0   -   192.168 . 0.255   最 核心 知识 ， 子网掩码 重要性 在于 给定 IP ， 子网掩码 推断出 网域 Network Broadcast 。 子网掩码 最 常见 24 1 16 1 ， 都 ， 不定 。   路由   理论 上 位于 网域 内 计算机 才 文件 交互 ， 网域 之间 计算机 信息 都 路由 IP 分发 信息 互通 目的 。 一块 刚 会 很 生疏 ， 建议 跟着 鸟哥 私房 菜 这幅 图 好好 route 流程 ：   机器 上 都 一个 路由表 ， 假设 PC1 要传 资料 PC11 ， 其会 分析 路由表 ， 发现 目标 IP IP 一个 网域 ， 区域 网 功能 传输数据 。   发现 目标 IP IP 不再 网域 ， 机会 查询 路由表 ， 相关 设定 ， 封包 发送给 默认 路由器 （ gateway ） ， 类似 ， gateway 类似 转发 工作 。   route 命令   route 命令 查看 主机 路由表 设置 。 会加个   - n   参数 ， 其会 主机名 IP 形式 显示 。   查看 路由表 先 第一 栏   Destination   目标   第三 栏   Genmask   子网掩码 组合 网域 概念 （ windows 下 route   PRINT   第一 栏 第二 栏 ） ， 网关   0.0 . 0.0   缺省值 ， 本机 网卡 interface 发送 。   FLAG 标志   U   路由 可用 ， G   路由 网关 Gateway ，   H   改行 路由 一个 主机 一个 网域 。   路由表 规则 ：   依据 网络 界面 IP 路由   手工 设定 路由 ， 设定 路由 网卡 设备 IP broadcast 。   动态 路由 生成   ​   route   add   - net   192.168 . 5.0   netmask   255.255 . 255.0   dev   etho03   网卡 界面 设置     / / sysconfig / network - scripts / ifcfg - XXX   配置 ：   DEVICE = 網卡 代號   BOOTPROTO =   dhcpHWADDR = 網 卡卡 號 ( MAC )   IPADDR = IP 位址   NETMASK = 子 網路 遮罩   ONBOOT = 預設 啟動此 介面   GATEWAY = 通訊閘   DEVICE ： 這個 設定 值後面 接 裝置 代號 與 檔名   ( ifcfg - eth0 )   那個 裝置 代號 才行 ！ 否則 會 裝置 名稱 找 不到 困擾 。   BOOTPROTO ： 啟動 該 網路 介面 時 ， 何種 協定 ？   手動 給予   IP   環境 ， 請輸入   static       ， 自動   IP   時候 ，   請輸入   dhcp   ( 寫錯 字 ， 因為 這是 最 關鍵 字 ！ )   GATEWAY ： 代表 『 整個 主機 系統   default   gateway 』 ，   ， 設定 這個 項目 時 ， 請 特別 留意 ！ 有重 複 設定 情況 發生 喔 ！ 當你有   ifcfg - eth0 ,   ifcfg - eth1 ....   多個 檔案 ， 一個 檔案 設定   GATEWAY   即可     / / resolv . conf   设置 DNS 规则 ：   nameserver   DNS IP     / / hosts   设置 ：   私有 IP   主機 名稱   別名     / / sysconfig / network   设置 ：   NETWORKING = 網路   NETWORKING _ IPV6 = 支援 IPv6 否 ？   HOSTNAME = 主機名     / / services   记录 記錄 架構   TCP / IP   總 總協定 ， 包括   http ,   ftp ,   ssh ,   telnet   服務 所定 義的   port   number   ， 都 這個 檔案 規劃 出來 。 想要 自訂 一個 新 協定 與   port   對 應 ， 改 這個 檔案 ；     / / protocols   定义出   IP   封包 协定 相关 资料 ， 包括   ICMP / TCP / UDP   這 封包 协议 定义 。   重启 网络   / / init . d / network   restart   這個   script   最 ！ 因為 一口 氣 啟動 整個 網路 參數 ！   他會 主動 去 讀取 網路 設定 檔 ， 很快 恢 復 系統 預設 參數值 。   ifconfig 命令   ifconfig 命令 用来 查看 网络 配置 信息 ， 信息 含义 ：   -   eth0 ： 網 路卡 代號 ，   lo   這個   loopback   ；   -   HWaddr ： 網 路卡 硬體 位址 ， 俗稱   MAC   ；   -   inet   addr ： IPv4     IP   位址 ， 後 續   Bcast ,   Mask   分別 代表   Broadcast   與   netmask   喔 ！   -   inet6   addr ：   IPv6   版本   IP   ， 我們 沒有 ， 略過 ；   -   MTU ： 第二章 談到   [ MTU ] ( http : / / linux . vbird . org / linux _ server / 0110network _ basic . php # tcpip _ link _ mtu )   ！   -   RX ： 一行 代表 是網 路由 啟動 為止 封包 接收 情況 ，   packets   代表 封包 數 、 errors   代表 封包 發生 錯誤 數量 、   dropped   代表 封包 於 問題 遭 丟棄 數量   -   TX ： 與   RX   ， 為網 路由 啟動 為止 傳 送情 況 ；   -   collisions ： 代表 封包 碰撞 情況 ， 發生 太 ，   網路 狀況 不太好 ；   -   txqueuelen ： 代表 用來 傳輸 資料 緩衝區 儲存長 度 ；   -   RX   bytes ,   TX   bytes ： 總 接收 、 傳送 位元 組總量   ifup ifdown 命令   ifup   { interface }   ifdown   { interface }   启用 关闭 网络 界面 。 两个 命令 去 修改 提到   / / sysconfig / network - scripts /   网卡 界面 配置文件 。   修改 主机名   centos7 新 一个 命令 很 修改 主机名 ，   hostnamectl   ， 主机名 几个 类似 ：   静态 主机名   static   瞬态 主机名   transient   灵活 主机名   pretty   hostnamectl   status   hostnamectl   set - hostname   < hostname >   第二个 命令 设置 主机名 ， 指定 一个 设置 加上 选项 ：   - - pretty   ,   - - static   ,     - - transient   。   df 命令   Linux 系统 中 一切都是 文件 ， 包括 硬盘 光盘 。 硬盘 挂载 系统 中 目录 下才 ，   /   自动 挂载 。 计算机 额外 加上 硬盘 ， 会 自动 挂载 ， 不 。 挂载 操作 。   执行 挂载 操作 ， 可先用 df 命令 来看 计算机 磁盘 挂载 情况 。   [ root @ host   ~ ] #   df   Filesystem   1K - blocks   Used   Available   Use%   Mounted     / dev / sda2   9952216   2879484   6547532   31%   /   tmpfs   258184   0   258184   0%   / dev / shm   / dev / sda1   289293   141262   132671   52%   / boot   Filesystem 目标 文件系统 ， 1K - blocks 列出 目标 文件系统 大小 ， 单位 KB ， Used ， Available 可用 。 Use% 百分比 ， Mounted   目标 文件系统 挂载 点 。   blkid 命令   blkid 命令 列出 目标 文件系统   UUID   号 ， 文件系统 类型 。 mount 命令 调用 。   [ root @ host   / ] #   blkid   / dev / sda1   / dev / sda1 :   UUID = \" ec5c9ab8 - b71e - 46e6 - aac9 - 5ccc757a02d2 \"   TYPE = \" ext3 \"   [ root @ host   / ] #   blkid   / dev / sda1 :   UUID = \" ec5c9ab8 - b71e - 46e6 - aac9 - 5ccc757a02d2 \"   TYPE = \" ext3 \"   / dev / sda2 :   LABEL = \" ROOTPART \"   UUID = \" 971ffe7e - 0c71 - 40c1 - 97a9 - bdb6b167d4b7 \"   TYPE = \" ext4 \"   mount 命令   mount 命令 挂载 文件系统 ， 挂载 点 ， 挂载 目录 空 文件夹 ， 原空 文件 内容 挂载 后 访问 。   mount   - l   #   列出 计算机 挂载 情况   mount   - t   文件系统 类型   UUID = \" * * * \"   挂载 点   #   挂载 操作   mount   - t   文件系统 类型   文件系统 名   挂载 点   开机 自动 挂载   开机 自动 挂载 设置 修改   / / fstab   文件 。   UUID = 971ffe7e - 0c71 - 40c1 - 97a9 - bdb6b167d4b7   /   ext4   defaults , discard , noatime   1   1   UUID = ec5c9ab8 - b71e - 46e6 - aac9 - 5ccc757a02d2   / boot   ext3   defaults   1   2   对照 例子 ，   / dev / sda1   挂载   / boot   。 三项 很 清晰 ， UUID 号 改为 目标 文件系统 名如   / dev / sda1   。   重点 讲下 第四 列 ， 第五 列 第六 列 ：   第四 列是 设置 目标 文件系统 挂载 参数 ， mount 命令   - o   选项 指定 。   async / sync   推荐 设置 async   auto / noauto   主动 测试 挂载 ， 默认 auto 。   rw / ro   ro 不 写入   exec / noexec   执行   user / nouser   nouser 用户 不 挂载   defaults   rw ， exec ， auto ， nouser ， async 参数 ， 设置 defaults 即可 。   备份 相关 ， 第五 列 设置 0 。   第六 列 ， fsck 检查 分区 ， 设置 0 即可 。   ​   unmount 命令   卸载 命令   unmount   目标 文件系统 名 挂载 点   lsof 命令   最先 接触 lsof 命令 需求 ： 查看 端口号 占用 ， 希望 释放 端口号 ， kill 掉 进程 即可 。   lsof   - i   : 1080   lsof   命令 倒 查看 端口号 设置 ， 完整 名字 list   open   files ， 列出 系统 打开 文件 。 linux 系统 中 ，   皆 文件   ， 查看 打开 文件 信息 很多 有用 系统 运行 情况 信息 。   命令 方法 很多 ， 请 读者 参看   网页     网页   。   telnet 命令   telnet 命令 查看 TCP 端口 访问 。   telnet   ip 地址   port 端口   nmap 命令   扫描 目标 主机 端口号 ， 参考   网页   。   最 常见 需求 查看 目标 主机 端口号 打开 ：   nmap   ip 地址   curl 命令   最 用法   curl   _ url   看作 一个 简单 版 web   browser ， 其内 选项 很多 ， HTTP method 方法 选择 ， user - agent cookie 设定 都 。   查看 更 信息 读者 参考   网页   。   查看 本机 外网 ip   curl   ifconfig . sh     httpbin 网站 ：   curl   httpbin . org / ip   离线 安装 rpm 包   推荐 安装   yum - utils   软件包 ：   yum   install   yum - utils   利用 提供   yumdownloader   命令 下载 rpm 包 。   下载 相关 依赖 本地 安装   安装 rpm 包 ， 依赖 ，   fedoraproject   下载 epel 安装包 ， 干脆 yum   安装   epel - realse   ， 还 安装 提及   yum - utils   ， 运行 ：   yum   install   - - downloadonly   - - downloaddir = .   . rpm   ...   自动 下载 补齐 rpm 包 还 确实 依赖 ， 本地 安装 语句 面 网络 安装 rpm 包了 。   本地 安装   免 网络 本地 安装 rpm 包 ， 自动 解决 相互依赖 。   yum   localinstall   - C   - - disablerepo = *   . rpm   ...   centos6 centos7 区别   小节 参考   篇文章     篇文章   。   默认 文件系统 ext4 xfs 。     / bin   / sbin   / lib   / lib64   移到   / usr   下 。 （ 区别 较大 ）   防火墙 iptables firwalld 。 （ 区别 较大 ）   默认 数据库 mysql mariadb ， 单纯 不用 太 。   python2.6 升级 python2.7 ， 这是 极好 。   修改 主机名 推荐   hostnamectl   。   语言 字符集 管理 配置文件   / / local . conf   修改 时 区 推荐   timedatectl   命令 。   修改 地区 推荐   localectl   命令 。   服务 管理 推荐   systemctl   命令 ， service 命令 。 chkconfig 推荐 systemctl 命令 。   systemctl   restart / start / stop   service _   systemctl   enable / disable   service _   强制 终止 进程 ，   \\ verb + kill   - 9   PID +   ， 推荐 ：   systemctl   kill   - - singal = 9   PID   ifconfig 命令 单独 安装 （ net - tools ） ， 推荐 ip 命令 。   U盘 安装 ubuntu   安装 请 先 硬盘 中 资料 做 调整 ， 空 出 一个 大于 20G 硬盘 做 将来 安装 ubuntu 根目录 地方 。 还 一个 内存 两倍 硬盘分区 下 linux 系统 swap 交换 分区 。 （ 更 还 开个 分区 / home 不 讨论 。 ）   ubuntu 官 网上 下载 系统 光盘 映像 。   ultroiso 软件 （ 类似 功能 软件 行 ） （ ultroiso 选择 最新 版本 ， ubuntu10.10 要用 9.3 版本 之上 ） 光盘 映像 写入 U盘 中 去 。   重启 计算机 ， BIOS 稍作 改动 使 计算机 U盘 启动 。   安装 过程 ， 过程 都 直观 ， 硬盘分区 设置 上 选择 高级 手动 ， 分 20G 硬盘 ／ 加载点 ， 设置 格式化 成 ext4 日志 系统 （ 文件系统 ext3 行 ） 。 设置 交换 分区 ， 安装 。   ubuntu 下 ISO 文件 硬盘 安装 win7 系统   gparter 分区   先 mount   文件 复制到 d 盘   执行   sudo   update - grub   重启 新 恢复模式 下 即可 .   Virtualbox   网络连接 模式   小节 参考   网页   。   NAT 模式   网络地址 转换 ， 理解 Guest 机 发送 IP 包 主机 （ 类似 做 路由器 功能 ） 分发 再 。   网桥 模式   模式 理解 ， 虚拟机 类似 一台 真实 机器 Host 同等 地位 接入 网络 ， 内网 不 分发 IP地址 功能 模式 不 可行 。   Host - 模式   理解 Guest Host 上 模拟 一张 网卡 ， 虚拟机 都 连接 这张 网卡 上 。 虚拟机 访问 。 虚拟机 主机 之间 ， 虚拟机 外网 之间 都 设置 访问 。   共享 文件夹 设置   安装 增强 功能 ， virtualbox 设置 好 共享 文件夹 ， 记得 客机 系统 ， 还 加载 文件夹 ：   sudo   mount   - t   vboxsf   share   / home / wanze / share     share   名字 virtualbox 设置 名字 ， 挂载 文件夹 请 客机 系统 新建 一个 。   找 不到 错误   章节 加上 内容 ， 都 说 ， No   Such   file 报错 ， 软件包 依赖 出 。 讨论 Ubuntu 系统 （ debian 系 ） ， Centos （ RPM 系 ） ， 包 名字 ， 想 读者 灵感 。   ffi . h   参考   网页   。   报错 ：   fatal   error :   ffi . h :   No     file     directory   解决方案 ：   sudo   apt -   install   libffi - dev   opensslv . h   报错 ：   fatal   error :   openssl / opensslv . h :   文件 目录   解决方案 ：   sudo   apt   install   libssl - dev   参考资料   网络 ， 别人 博客 知识 引用 文章 中 列出来 列出来 ， Linux 系统 很多 知识 很多 网页内容 都 很 接近 ， 实在 不 原创 ， 并用 网络 词来 。 谢谢 博客 网页 编写者 ， 劳动 传播 知识 ， 提升 IT 从业者 技能 解决 很多 ， 人类 IT 技术 。 也许 赚 一分钱 ， 半点 名利 ， 做出 贡献 遗忘 ， 都 上帝 嘉许 。   有名 鸟哥 linux 私房 菜 基础 篇 网络 篇 。 请 参看   鸟哥 文章 官网   。 基础 篇   / linux _ basic   ， 网络 篇   / linux _ server   。   unix 编程 艺术   unix 编程 艺术   [ 美 ]   Eric   S · Raymond   ,   姜宏   ( 译者 ) ,   何源   ( 译者 ) ,   蔡晓骏   ( 译者 )",
            "tags":"linux",
            "url":"articles/linux-system-basic.html"
        },
        {
            "title":"blender入门操作学习",
            "text":"视图 导航   blender 下   .   聚焦 选中 物体 。   视图 导航 缩放   鼠标 滚轮   。   视图 正面 平移 blender   Shift + 鼠标 中 键   。   blender 视图 旋转   鼠标 中 键   。   blender 小 数字键 视图 导航 上 都 特别 用途 ， 说   .   聚焦 选中 物体 ，   0   相机 视图 ，   5   透视 视图 正交 视图 切换 ， 数字 都 用途 ， 视图 调整 ， 不 一一 介绍 ， 读者 熟悉 即可 。 按下   `   获取 视图 导航 pie 面板 。   选择 操作   左键 点击 物体 选择 物体 ， 点到 空白 位置 去 选择 。 多选 按住 shift 点击 物体 ， 去 选择 很 好 ， 推荐 多选 喜欢 点选 介绍 C 圈选 。   按下   A   选择 ， 按下   Alt + A   去 选择 。   按下   B   矩形 选择 ， 鼠标 左键 ， 执行 矩形 选择 ， 按下 鼠标 中 键 ， 执行 去 选择 操作 。 选择 完 鼠标 右键 退出 选择 模式 。   按下   C   圆圈 选择 ， 鼠标 左键 ， 执行 圆圈 选择 ， 按下 鼠标 中 键 ， 执行 去 选择 操作 。 选择 完 鼠标 右键 退出 选择 模式 。   旋转 缩放 操作   选择 物体 ， 按下   G   随意 物体 模式 ， 物体 会 鼠标 随意 ， 按下   G   ， 按下   X   ， X 轴 ， 轴 类似 。 过程 中 下 鼠标 右键 ， 取消 ， 点击 鼠标 左键 确认 。   按下   G     Shift + z   z 轴 锁定 模式 ， z 轴 随意 ， 一个 垂直于 z 轴 平面 。   按下   G   点击 鼠标 中 键 ， 三轴 吸附 模式 ， 看 鼠标 方向 。   按下   R   随意 旋转 模式 ， 按下   R   ， 再 下   X   X 轴 旋转 ， 类似 操作 讨论 ， 不 赘述 。   按下   S   物体 比例 整体 缩放 ， 按下   S   ， 再 下   X   物体 X 轴 缩放 。 按下   Shift + z   会 z 面 缩放 。   物体 内部 Local 坐标系   讨论 X 轴 全局 XYZ 轴 ， 选择 物体 Local 坐标系 ， 很多 坐标系 选择 。   物体 游标 面板   按下   Shift + S   打开 物体 游标 快捷 pie 面板 ， 选择 游标 选中 项 ， 游标 世界 原点 物体 游标位置 。   下   shift   点击 鼠标 右键 ， 会 设置 游标 此处 。 添加 物体 将会 游标 处 添加 。   旋转 缩放 点   默认 边界 框 中心点 ， 设置 3d 游标 ， 3d 游 标点 旋转 动作 。   操作   左 工具 面板 右 属性 面板   blender   按下   T   打开 左 面板 ， 按下   N   打开 右 面板 。   快捷 复制 物体   按下   Shift + D   快捷 复制 物体 ， 点击 鼠标 右键 取消 过程 ， 物体 复制 。   快捷 添加 物体   按下   Shift + A   打开 快捷 添加 物体 菜单 。   删除 对象   说 对象 物体 ， 删除 动作 很 很多 地方 都 通用 。 按下   X     Delete   ， 推荐   X   ， 情景 下有 更 选项 。   操作 面板 最大化   blender 操作 面板 按下   Ctrl + space   最大化 效果 。   打开 物体 渲染 方式 面板   选择 物体 按下   z   打开 物体 多种 渲染 方式 面板 ， 线框 、 实体 、 渲染 材质 预览 。 线框 查看 模式 很 选择 实体 下 难以 选择 物体 。   添加 物体 后 额外 参数 修改   添加 物体 额外 参数 修改 ， 很 关键 参数 尽可能 模型 尺寸 接近 真实世界 尺寸 。 建模 网格 不 太细 ， 表面 细分 修饰 （ subsuface   modifier ） 。   collections   选中 物体 按下   M   物体 新 collection ， 大纲 面板 创建 collection 。 公用 物体 collection 外围 。 大纲 删除 collection 删除 物体 。   collections 勾选 去 勾 选会 影响 视图 操作 渲染 画面 ， 眼睛 图标 打开 关闭 只 影响 视图 操作 ， 不 影响 渲染 画面 。   modeling 工作 空间   最 Layout 工作 空间 ，   Tab   切换 物体   物体 模式     编辑 模式   。 modeling 工作 空间   Tab   切换 物体 模式 编辑 模式 。   modeling 工作 空间 建模 两个 原因 ， 一是 modeling 工作 空间 下 编辑 界面 操作 针对性 优化 ， modeling 工作 空间 选择 添加 ， 选项 网格 体 ； modeling 工作 空间 下 选中 物体 物体 编辑 模式 ， 编辑 模式 下 添加 操作 扩展 物体 都 会 一个 物体 ， 离开 编辑 模式 物体 模式 旋转 操作 会 一个 物体 效果 。   物体 模式 下 选择 多个 物体 再 编辑 模式 ， 物体 都 编辑 ， 物体 之间 顶点 连接 操作 。 物体 模式 下 选择 两个 物体 ，   Ctrl + J   合并 两个 物体 。   编辑 模式 下 谈及 选择 操作 都 可用 。 编辑 模式 选项 右边 ， 切换 点 选择 模式 ， 选择 模式 和面 选择 模式 。 按着   Shift   执行 多选 动作 ， 提到 三种 选择 模式 多选 ， 按着   Shift   多选 。   编辑 模式 下   Alt + 鼠标 左键   会 执行 loop 选择 ， 大概 水平线 全选 垂直线 全选 。 按下   Ctrl + I   翻转 选择 。 希望 临时 隐藏 节点 ， 按下   H   会 临时 隐藏 选择 节点 ，   按下   Alt + H   会 显示 隐藏 节点   。 按下   Ctrl + L   会 执行 关联 节点 全选 动作 。   衰减 编辑   快捷键   O   启用 衰减 编辑 模式 。 假设 不 启用 衰减 编辑 ， 拖动 节点 ， 节点 会 拖动 ， 启用 衰减 编辑 模式 ， 内 包含 节点 都 类似 拖动 ， 拖动 比例 衰减 编辑 模式 选项 而定 。   说 衰减 编辑 影响   PageUp     PageDown   两个 按键 调节 。   吸附 编辑   节点 ， 希望 节点 吸附 物体 面上 ， 选择 吸附 编辑 吸附 到面 选项 ， 勾选 项目 中 独立 元素 ， 衰减 编辑 模式 下 中受 影响 节点 会 吸附 动作 。   表面 细分 修饰 器   表面 细分 修饰 器 用来 进一步 细分 模型 面 。 修饰 器是 临时 ， 回滚 ， 网格 节点 上 细分 。   实体化 修饰 器   加厚 细面   X射线 透视 视图     Alt + Z   开启 X射线 透视 视图 ， 视图 下 很 选择 覆盖面 节点 。   复制 节点 分离   选中 节点 复制 节点   Shift + D   ， 按下 快捷键   P   来讲 新 选中 节点 分离 成 一个 新 物体 。   挤出 区域 （ extrude ）   效果 选择 一个 面 ， 该面 挤出 。 挤出 操作 点击 小图标 ， 沿该 面 垂直线 法线 挤出 ， 点击 白圈 任意 点 任意 方向 拖动 挤出 。 挤出 过程 右键 取消 挤出 面 ， 取消 取消 动作 。   选中 一个 面 ， 按下   E   ， 快速 执行 法线 挤出 动作 。 来自 面 上下文 菜单 快捷键 ， 下   Ctrl + 鼠标 右键   ， 快速 执行 任意 位置 挤出 动作 。   按住 挤出 工具栏 会弹 出 额外 几个 选项 ， 挤出 面是 法线 挤出 ， 很 有用 。   环切 （ loop   cut ）   环切 会 新切 出 一个 面 。   环切 拖动 调整 位置 。   Sculpting 工作 空间   按键   F   调整 影响 区域 大小 。   雕刻 模式 一般来说 推荐 购买 一个 手绘 板   手绘 板 设置 上 按键 推荐 换成 鼠标 中 键 ， 按着 浏览 物体 。   自由 线   画线 凸起来 线 ， 按住   Ctrl   画线 凹 进去 线 。   光滑   区域 光滑   膨胀   区域 膨胀   渲染   默认 eve 渲染 引擎 ， 更好 渲染 引擎 cycles 引擎 ， 开销 会 更 大 。   渲染 调配 好 光源 参数 。   Ctrl + Alt + 0   【 数字 0 】   摄像头 观察 位置   参考资料   Blender   Beginner   Tutorial   Series   Blender   Fundamentals   2.8",
            "tags":"blender",
            "url":"articles/blenderru-men-cao-zuo-xue-xi.html"
        },
        {
            "title":"odoo学习笔记",
            "text":"WARNING   警告 ， 文档 归档 ， 年久失修 ， 内容 已 过于 陈旧 ， 放在 权做 读者 参考 。   历史   Odoo 前身   Tiny   ERP ， 最初 比利时 Fabien   Pinckaers   创建 。   2009 年 ， 发布 5 版 ， 公司 风投 ， 盈利 增长 ， 软件 更名 OpenERP 。 OpenERP 名字 最为 熟知 ， 软件 包含 几百个 模块 ， 财务管理 、 采购 / 销售 管理 、 库存 管理 人力 资源管理 、 销售点 管理 、 项目管理 都 。   2014 年 9 月 ， 软件 发布 8 版 ， 版本 优化 web   client 一块 基础 上 ， 大 功能 。 Website   builder 模块 ， 公司 快速 架构 出 网站 ； e - commerce 模块 公司 快速 搭建 销售 平台 ； business   intelligence 模块 ， 辅助 生成 高质量 演示 图形 等等等等 。 OpenERP 名字 很 好 软件 雄心壮志 ， 软件 更名   Odoo   名字 。   2017 年 10 月份 odoo 发布 最新 稳定版 ， odoo11 版 ， 本文 基于 odoo11 版来 讨论 。   该软件 架构 基于 web   client / server 模型 ， 公司 内部 涉及 信息流 都 整合 ， 包括 具体实施 层面 ， 包括 分析 决策 层面 。 预见 将来 Odoo 开发 快速 公司 构建 出 一个 生态 :   商业 智能化   信息时代 到来 ， 商业 不可避免 走向 信息化 ， 智能化 。 最新 ERP Ⅱ 概念 包含 内容 所示 :   Business   Intelligence   商业智能 ， 关注 分析 数据 ， 数据 知识 这一 过程 。   e - Commerce   电子商务 ， 关注 对外 战略 。   Enterprise   asset   management   企业 资产 管理 ， 持续 管理 公司 资产 生命周期 ， 强有力 分析 工具 提高 资产 使用率 削减 成本 。   Procurement ( SRM )   采购 ， 最大化 节约 成本 支持 终端 终端 采购 ， 物流 过程 。   Production ( PLM )   生产 ， 管理 优化 生产能力 物料 资源 。 MRP 升级版 。 （ MRP ERP 前身 ， 美国 生产 企业 解决 物料 需求 提出 ， 解决 :   生成 产品 ， ABC 物料 ？ ） 谈论 PLM 解决 物料 需求 ， 解决 生产 时间 ， 优化 生产能力 目的 。   Distribution ( SCM )   配送 ， 控制 仓库 流程 ， 使 补给 需求 更改 做出 快速 。   Accounting   会计 ， 自动化 财务管理 ， 确保 管理 便捷 绩效 做出 实时 。   Human   Resource   人资 ， 维护 一个 完整 雇员 数据库 ， 更好 雇员 。   Corporate   performance     governance   公司 表现 监管 ， 公司 各个部门 更 高 控制 ， 目标 流水线 作业 。   Customer   services ( CRM )   客服 ， 获取 维护 客户 关系 ， 充分利用 客户 体验 知识 管理 评估 。 （ BI 模块 很 紧密 ）   Sales   销售 ， 定单 确认 ， 下单 ， 货运 开发票 。   Odoo 框架 简介   一副 图 很 好 Odoo 技术 框架 :   PostgreSQL 数据库   Object   Relation   Mapping   熟知 SQL   ORM 包装 层 。 Odoo   psycopg2   接口 之外 ， ORM 层 Odoo 写 。   Base   Module   Distribution   官方 模块   Report   Engine   负责 生成 报表 。 支持 报表 格式   PDF , OpenOffice , HTML   三种 。   Workflow   Engine   工作 流 引擎 。 支持 任意 复杂度 工作 流 。   WebService   提供 网络 调用 接口 。 支持   Net - RPC 、 XML - RPC   两种 。 Odoo flask Werkzeug WSGI 层 包装 ， jinja2 模板 工具 。 剩下 框架 Odoo 写 。   python 版本   python3 ，   .   安装 配置   odoo git 仓库 大 ， 推荐 下载 odoo 发布 压缩包 文件 源码 。 讨论 是从 源码 安装 过程 。 数据库 相关 配置 难点 ， 会 再 详细 讨论 。 本文 叙述 更 偏向 centos7 ， 源码 安装 本身 基于 linux 系统 大 环境 ， linux 发行版 安装包 支持 差异 外 ， 差别 太大 。     yum   update   yum   install   epel - release   yum   groupinstall   Development   tools   PostgreSQL 数据库   PostgreSQL 很 有名 一个 开源 数据库 ， 最初 加州大学 伯克利分校 计算机系 开发 ， sqlite3 区别 采用 client / server 模型 ， Odoo 搭建 PostgreSQL 基础 之上 ， 继承 client / server 模型 。 Odoo PostgreSQL 数据库 版本号 很 ， 最新 。   yum   install   postgresql - server   yum   install   postgresql - contrib   postgresql - setup   initdb   最 安装 先 暂时 ， 数据库 配置 再进一步 讨论 。   Postgresql 数据库 学习 ， 读者 简单 参考 写   postgresql 数据库   一文 。   python 虚拟环境 配置   一块 odoo 关系 太 大 ， 请 读者 自行 调配 。   安装 odoo 依赖   常规 pip 安装 即可 ， 系统 依赖 ， 请 确保 安装 大 环境   python3     python3 - dev   ， 内容 ：   centos   centos 统一 描述 ， 请 确保 软件包 都 安装 上 ：   -     :   libxml2   yum   :     :   libxml2   state   :   present   -     :   libxml2 - devel   yum   :     :   libxml2 - devel   state   :   present   -     :   libxslt   yum   :     :   libxslt   state   :   present   -     :   libxslt - devel   yum   :     :   libxslt - devel   state   :   present   -     :   libevent   yum   :     :   libevent   state   :   present   -     :   libevent - devel   yum   :     :   libevent - devel   state   :   present   -     :   libjpeg - devel   yum   :     :   libjpeg - devel   state   :   present   -     :   openldap - devel   yum   :     :   openldap - devel   state   :   present   -     :   cyrus - sasl - devel   yum   :     :   cyrus - sasl - devel   state   :   present   ubuntu   python - ldap   模块 安装 参考   网页   ， 请 确保 两个 软件包 都 安装 （ 会 提示 找 不到 lber . h 错误 ） :   sudo   apt -   install   libldap2 - dev   sudo   apt -   install   libsasl2 - dev   psycopg2 模块 请 确保 软件包 安装 :   sudo   apt -   install   libpq - dev   几个 软件包 确保 安装 ， libxml2 lxml 模块 。   sudo   apt -   install   libxml2 - dev   sudo   apt -   install   libxslt1 - dev   pillow 模块 安装 软件包 :   sudo   apt -   install   libjpeg - dev   nodejs   centos 只 简单 yum 命令 安装 ， 安装 npm 工具 自动 装上 。   yum   install   nodejs   npm   install   - g     安装 odoo   odoo 源码 addon 生态 较大 ， 推荐 不   python   setup . py   install   方式 安装 ， odoo 源码 运行 脚本 启动 。 推荐 方式 ， setup 文件夹 odoo 文件 重命名   odoo - bin   移 项目 主目录 上 ， 运行 ：   python   odoo - bin   调试 修改 都 。   数据库 配置   数据库 创建 一个 系统 登录 用户 同名 用户 ， 其要 创建 数据库 权限 ， 数据库 权限 。 odoo 默认 用户 postgresql 数据库 交互 （ 参考   网页   ） 。 postgres 用户名 ， root 用户名 都 不 。   sudo   - u   postgres   createuser   $ USER   用户 不 ， PostgreSQL 将会 报错 :   createdb :       connect     database   template1 :   FATAL :   role   \" wanze \"       exist   Odoo 框架 用户 还 创建 数据库 权限 。 去 做 :   sudo   - u   postgres   psql   postgres   ALTER   USER   wanze   CREATEDB ;   用户 创建 数据库 权限 ， 这块 内容 参考   网页   。   系统 提示   . psql _ history   文件 ， 简单 touch 即可 。   pg _ hba . conf   postgresql 很多 连接 配置 出 都   pg _ hba . conf   文件 没 配置 好 ， 更 细节 请 参看 写   postgresql 数据库   一文 。   默认 配置 ：   local       peer   #   IPv4   local   connections :   host       127.0 . 0.1 / 32   ident   #   IPv6   local   connections :   host       : : 1 / 128   ident     文章   说 两项 改成   md5   ，   postgresql   docker 版   默认 配置 改成 md5 ， 刚 改成 md5 好 ， odoo 运行 后 改回 ident 发现 能行 。   记住 odoo 系统 用户名 登录 postgresql ， 数据库 一个 系统 内 ， 两行 连接 配置 ， 推荐 改成   md5   。   重启 PostgreSQL 服务器 :   sudo   service   postgresql   restart   初步 启动   运行   python   odoo - bin   - -   会 很多 选项 ， 简单 熟悉 。   - c   CONFIG ,   - - config = CONFIG   读取 配置文件 ， 很 常见   - s     - - save   ， 保存 运行 命令行 配置 ， 下次 简单   python   odoo - bin   运行 。 配置文件 用户 家 目录 下   . odoorc     . openerp _ serverrc   文件   。   - - pidfile = PIDFILE   指定 进程 pid 文件 ， 很 常见 。   - - addons - path = ADDONS _ PATH   用户 自定义 addons 时 有用   设置 插件 addons 路径 ， 默认 会 源码 addons 文件夹 加上 去 ， 会 出错 。 设置 源码 addons 文件夹 。 设置 多个 addons 路径 语法 :   - - addons - path = addons ,   myaddons   ， 用于 加载 定义 模块 。   - - http - interface = HTTP _ INTERFACE   指定 http 端口 ， 默认 0.0 . 0.0 ， 设置 localhost   - p   PORT ,   - - http - port = PORT   http 服务 默认 端口号   8069   。   - - logfile = LOGFILE   日志 文件 保存 ， 日志 打印 很多 选项 ， 时间 再 研究 。   - u   UPDATE ,   - - update = UPDATE   升级 模块   - D   DATA _ DIR ,   - - data - dir = DATA _ DIR   设置 odoo data 存放   - - db - filter = REGEXP   正则表达式 过滤 web   UI 可用 数据库   - d   DB _ NAME ,   - - database = DB _ NAME   odoo 数据库   - r   DB _ USER ,   - - db _ user = DB _ USER   odoo 连接 数据库 用户名   - w   DB _ PASSWORD ,   - - db _ password = DB _ PASSWORD   odoo 连接 数据库 密码   windows 下 源码 安装   windows 下有 exe 安装包 ， 其会 开启 一个 odoo 后台 常驻 服务 ， windows 下 早期 开发 工作 ， 本地网络 调试 都 会 便利 。 源码 启动 odoo 经验 说 ：   exe 安装 postgresql 数据库 还 ， 数据库 配置 都 ， 一块 忽略 。   nodejs 安装 npm 安装 不 说 。   odoo python 包 依赖 安装 ， 安装 官方 文档 介绍 ， 官方 文档 ：   加上 pypiwin32 包   原 requirements . txt   包 尝试 ， 几个 包 pip 安装 成功 ， 推荐     安装包 ， 版本 稍微 高 一点点 没事 ：   ` ` `   greenlet   lxml   MarkupSafe   Pillow   pyldap   reportlab   ` ` `   官方 文档 说   psutils     psycopg2   pip 安装 成功 。 下载 whl 包 安装 即可 ：   ` ` `   pip   install   . whl   ` ` `   所述 ， setup 文件夹   odoo   文件 重命名   odoo - bin   运行   python   odoo - bin   即可 。   说   - - save   选项 会 当前目录 输出 一个   odoo . conf   文件 ， 读者 配置 好 数据库 设置 ， 几个   ：   ` ` `   pg _ path   =   安装 postgresql bin 目录   db _ host   =   localhost   db _   =   False   db _ password   =   openpgpwd   db _ port   =   5432   db _ sslmode   =   prefer   db _ user   =   openpg   ` ` `   odoo . conf   数据库 相关   db _ user   数据库 连接 时 用户名 ，   db _ password   数据库 连接 时 密码   db _ host   数据库 host   db _ port   数据库 端口号   默认   5432   db - filter   正则表达式 过滤 ， 不 匹配 数据库 将会 隐藏 （   % h   hostname   % d   domain     ( i ) % d   ( i )   忽略 大小写 ，   % d   匹配 域名 名 ， 比如说   odoo .   匹配 数据库   odoo     Odoo   。 ）   db _ template   默认   template1   网络 相关   日志 相关   翻译 相关   邮箱 相关   email _   odoo 发送 邮件 时 显示 邮箱地址   默认   False   smtp _ server   smtp 服务 地址   smtp _ port   smtp 服务 端口号   smtp _ ssl   smtp 服务 开启   ssl   smtp _ user   登录 smtp 服务 用户名   smtp _ password   登录 smtp 服务 密码   ; 用于 导入 导出 csv 文件 默认 分隔符   csv _ internal _ sep   =   ,   ; data 目录 ， 用于 存放 session 信息 、 附件   data _ dir   =   C : \\ Users \\ shun \\ AppData \\ Local \\ OpenERP   S . A . \\ Odoo   ; 模块 加载 demo 数据   demo   =   { }   ; 导入 数据 时 选项 ， 导入 期间 程序 宕机 ， 状态 下 。 指定 一个 存储 导入 状态 文件名 。   import _ partial   =   ; 一个 处理器 物理 内存   limit _ memory _ hard   =   None   ; 一个 处理器 虚拟内存   limit _ memory _ soft   =   None   ; 一个 处理器 接受 请求 数   limit _ request   =   None   ; 一个 请求 最 占用 处理器 时间   limit _ time _ cpu   =   None   ; 一个 请求 最长 实时 时间   limit _ time _ real   =   None   ; 显示 数据库 列表   list _ db   =   True   ; log 写入 db ir _ logging 表   log _ db   =   False   ; 保存 数据库 中 日志 记录 级别   log _ db _ level   =   warning   ; 指定 模块 日志 级别 ， 一组 module : log _ level ， 默认值 : INFO （ 模块 默认 日志 级别 INFO 级别 ）   log _ handler   =   : INFO   ; 日志 级别 , 可选值 包括 debug _ rpc _ answer , debug _ rpc , debug , debug _ sql , info , warning , error , critical   log _ level   =   info   ; 指定 用来 存储 日志 文件   logfile   =   D : \\ Program   Files   ( x86 ) \\ Odoo   10.0 \\ server \\ odoo . log   ; 按天 存放 日志 ， 保留 最新 30 天   logrotate   =   False   ; 长 连接池 端口号   longpolling _ port   =   8072   ; 计划 线程 数   max _ cron _ threads   =   2   ; 强制 保存 virtual   osv _ memory 表中 记录 最长 时间 ， 小时 单位   osv _ memory _ age _ limit   =   1.0   ; 强制 一个 virtual   osv _ memory 表 记录 数   osv _ memory _ count _ limit   =   False   ; 数据库 可执行文件 路径   pg _ path   =   D : \\ Program   Files   ( x86 ) \\ Odoo   10.0 \\ PostgreSQL \\ bin   ; 存储 服务器 pid 文件名   pidfile   =   None   ; 反向 代理 模式   proxy _ mode   =   False   ; 压缩 报表   reportgz   =   False   ; 指定 用于 SSL 连接 证书 文件   secure _ cert _ file   =   server . cert   ; 指定 用于 SSL 连接 主 密钥 文件   secure _ pkey _ file   =   server . pkey   ; server 模块 , 逗号 分隔   server _ wide _ modules   =   None   ; 日志 发送给 系统日志 服务器   syslog   =   False   ; 提交 YAML XML 测试 数据库 更改   test _ commit   =   False   ; YAML 单元测试   test _ enable   =   False   ; YML 测试 文件   test _ file   =   False   ; 报表 范例 存放 位置   test _ report _ directory   =   False   ; 系统 提供 一个 参照 时区   timezone   =   False   ; 模块 翻译 , 默认   translate _ modules   =   [ ' ' ]   ; 数据库 unaccent 功能   unaccent   =   False   ; 安装 时 模块 不 加载 演示 数据   _ demo   =   False   ; 处理器 数量   workers   =   None   ; 禁止 XML - RPC 协议   xmlrpc   =   True   ; 指定 XML - RPC 协议 IP地址 ， 空时 绑定 现有 IP   xmlrpc _ interface   =   ; XML - RPC 协议 TCP 端口   xmlrpc _ port   =   8069   ; 禁止 XML - RPC 协议   xmlrpcs   =   True   ; 指定 XML - RPC 协议 IP地址 ， 空时 绑定 现有 IP   xmlrpcs _ interface   =   ; XML - RPC 协议 TCP 端口   xmlrpcs _ port   =   8071   作者 ： itrojan   链接 ： https : / / www . jianshu . / p / 8fa53743bac8   來源 ： 简书   著作权 作者 。 商业 转载 请 作者 授权 ， 非商业 转载 请 注明 出处 。   初入 odoo   章节 浅显 讲 刚 odoo 界面 熟悉 ， 更 多用户 操作 开发者 知识 都 再 慢慢 讨论 。   数据库 管理 界面   数据库 管理 界面   / web / database / manager   ， 新建 数据库 （ create ） ； 复制 数据库 （ duplicate ） ； 删除 数据库 （ drop ） ； 备份 数据库 （ backup ） ； 恢复 数据库 （ restore ） 。   注销 Administor 账户 ， 会 一个 登录 界面 。   登录 界面   登录 界面   / web / login   ， 数据库 管理 操作 。   Administrator 首选项   右上角 Administrator → 首选项 设置 网站 语言 ， 时 区 ， 管理员 头像 ， 管理员 邮箱 个性 签名 。   导入 一个 翻译   左侧 翻译 一栏 ， 点击 导入 一个 翻译 即可 加载 一个 翻译 。   新 Demo 用户   左侧 用户 一栏 ， 点击 创建 一个 新 用户 ， 创建 一个 新 用户 界面 。 新建 用户 先 手工 设置 密码 ， 模块 安装 会 用户 设置 权限 ， 网页 导航条 用户 。 比如说 新 Demo 用户 管理员 权限 ， 设置 选项 。   模块 管理   模块 安装 模块 ， 模块   __ manifest __. py   设置   ' application ' :   True   ， 模块 一个 。   模块   安装 ， 更新 ， 卸载 操作 。 卸载 模块 ， 会 数据库 关联 数据 清空 掉 ， 卸载 模块 前 建议 先 备份 数据库 ， 这花 不了 时间 。   修改 公司 信息   最 左上角 ， 鼠标 划过 会 编辑 公司 数据 信息 ， 点击 修改 公司 信息 界面 :   设置 公司 Logo ， 名字 ， 地址 ， 网站 。 设置 选单 还 设置 币种 ， 币种 设置 会 影响 会计 模块 默认 币种 。 信息 设置 填上 都 填上 。   进销存 财务 系统 抽象 讨论   进销存 财务 软件系统 大多 融为一体 。 进销存 块 最 软件 仓库 管理软件 ， 采购 销售 慢慢 加上 去 。 理解 很 ， 仓库 管理 看作 最底层 模块 ， 采购 销售 之上 模块 ， 采购 销售 财务 很多 信息 交流 。 图 所示 :   简单 来说 采购 销售 一笔 成交 订单 都 两个 信息流 ， 一个 仓管 ； 一个 财务 。 信息流 过程 系统 自动化 。 采购 部门 例子 系统 内部 信息流 自动化 过程 。   采购 部门 为例   采购 部门 职能 接受 部门 采购 ， 定期 汇总 做成 采购计划 ； 采购计划 会 供应商 询价 、 议价 ； 下 采购 单 ； 跟踪 供货商 发货 ； 货到 后 验货 、 入库 。 供应商 换货 、 退货 。   看 采购计划 ， 公司 各个部门 都 采购 部门 发送 采购 需求 ， 部门 模块 会 情况 自动 发送 采购 需求 功能 ， 仓管 最小 库存 原则 ， 再 销售 部门 紧急 需求 （ 原则上 部门 不 紧急 需求 发送给 仓管 ， 由仓管 最小 库存 原则 发送 采购 需求 ， 部门 特别 紧急 需求 采购 部门 发送 采购 需求 。 还 公司 部门 情况 种类 繁多 库存 小 情况 ， 采购 部门 发送 需求 ） 。 信息 采购 需求 发送 机制 公司 情况 优化 。   采购 需求 ， 系统 具备 自动 整理 功能 ， 供应商 分类 ， 紧急 程度 插队 机制 。 采购 人员 初步 整理出来 采购 需求 ， 信息 自动 生成   询价单   ， 系统 提供 电邮 ， 打印 询价单 功能 ， 供应商 洽谈 视频 功能 。 询价 结束 对方 同意 采购员 点击 信息 发送给 采购 部门 经理 ， 经理 确认 ，   采购 单   自动 生成 。   采购 单 确认 ， 讲 信息流 分成 仓管 财务 两边 。 看仓管 ， 货物 还 没 送到 ， 仓管 将要 货物 ， 预先 仓库 整理 ， 快速 存放 工作 。 货物 送到 采购员 验收 ， 验收 确认 采购 单上 单击   收货   ， 点击   入库   操作 ， 货物 正式 入库 ， 仓管 产品 ， 单价 ， 重量 体积 都 自动 存放 软件系统 仓管 一栏 。   财务 ， 采购 单 ， 财务   接受 发票   ， 点击   确认 生效   ， 这是 信息 送到 财务 去 。 财务 付款 事宜 。 财务 付款 完 采购员 会 采购 单 。   谈论 采购 部门 为例 流程 ， 流程 死 ， 不 最优 。 公司 情况 功能 需求 底层 信息 流程 做出 调整 优化 。   创建 addon   开发 前   Odoo 开发 一条 黄金 准则 修改 现有 模块 ， 特别 官方 内置 模块 。 做会 原始 模块 代码 修改 混为一谈 ， 很难 软件 升级 管理 。 创建 新 模块 （ 原有 模块 基础 之上 ） 修改 扩展 功能 目的 。 Odoo 提供 一种 继承 机制 ， 第三方 模块 扩展 现有 模块 ， 官方 来自 社区 ， 继承 修改 任意 层次 ， 数据模型 业务 逻辑 用户界面 。   快速 生成 模块 骨架   快速 生成 一个 模块 骨架 :   python   odoo - bin   scaffold   mymodule   myaddons   位置 新建 一个 myaddons 文件夹 ， myaddons 文件夹 下 创建 一个 名字 mymodule 模块 骨架 。 创建 好 读者 翻 。 官方 推荐 模块 结构 所示 ：   addons / < _ module _ > /   | - -   __ init __. py   | - -   __ manifest __. py   | - -   controllers /   |   | - -   __ init __. py   |   ` - -   controllers . py   | - -   demo /   |   | - -   < main _ model > _ data . xml   |   ` - -   < inherited _ main _ model > _ demo . xml   | - -   models /   |   | - -   __ init __. py   |   | - -   modles . py   | - -   security /   |   | - -   ir . model . access . csv   | - -   static /   |   | - -   img /   |   | - -   lib /   |   ` - -   src /   |   | - -   js /   |   | - -   css /   |   | - -   /   |   ` - -   xml /   ` - -   views /   | - -   templates . xml   | - -   views . xml   一个 泛泛 而论 情况 ， 文件夹 文件 不 。 内容 进一步 。   推荐 模型 定义 python 文件 都 放入 models 文件夹 中 ， 简要 介绍 ：   demo 文件夹   ， 放着 demo . xml   controllers 文件夹 ， http 路径 控制   views 文件夹 ， 网页 视图 模板   static 文件夹 ， 网页 资源 ， 子 文件夹 : css ， js ， img ， lib 。   Odoo 模块 文件   模块 Odoo 框架 模块 还 新建 一个   __ manifest __. py   文件 。   scaffold 自动 创建   __ manifests __. py   文件 大致 内容 :   depends   模块 依赖 关系 ， 指本 模块 Odoo 框架 内 模块 依赖 。 模块 实在 没什么 依赖 ，   base   模块 填上去 。   data   模块 加载 数据文件 ， 别看 数据文件 ， 不怎么 ， Odoo 视图 ， 动作 ， 工作 流 ， 模型 对象 大部分 内容 都 数据文件 定义 。 xml csv 文件 放置 再 讲 。   demo   定义 数据文件 情况 下 加载 ， demonstration 模式 下 才 会 加载 ， 新建 数据库 勾 选上 加载 演示 数据 选项 。   大体 类似 pypi 包 常见 setup . py   文件 内容 ：     模块 名字   summary   简短 介绍   description   详细 介绍   author   模块 作者   website   模块 网站   category   模块 分类   version   模块 版本号   license   模块 版权 信息 ， 默认 AGPL - 3   installabel   默认 True ， 可设 False 禁用 模块   auto _ install   默认 False ， 设为 True ， 依赖 模块 ， 依赖 模块 都 安装 ， 模块 自动 安装 ， 模块 胶合 ( glue ) 模块 。   application   默认 False ， 设为 True ， 模块 一个 。 模块 建议 设置 True ， Odoo 后 点击 本地 模块 ， 默认 搜索 过滤     ， 主 模块 会 显示 。   安装 自定义 模块   说 设置   - - addons - path = addons ,   myaddons   ， 加载 自定义 模块 。 安装 安装 模块 两样 ， 清除 搜索 栏 输入 搜索 关键词 ， 模块 面板 。 模块 第一次 安装 ，   激活 开发者 模式   ，   更新 列表   ， 找到 想要 模块 。   自定义 模块 简单 内容 修改 ， 重启 odoo 即可 当即 生效 ， 模块 数据库 模型 定义 改动 额外 文件 添加 ， 还 更新 模块 。   第一个 模块   python   odoo - bin   scaffold     myaddons   controllers   修改 controllers   controllers . py   文件 ：     odoo   import   http   class   First   (   http   .   Controller   ) :   @ http   .   route   (   ' / / / '   ,   auth   =   ' public '   )   def   index   (     ,   * *   kw   ) :   return   \" Hello ,   world \"   请 读者 安装 所说 安装 更新 自定义 模块 （ 激活 开发者 模式 ， 更新 模块 列表 ， 安装 模块 ） 。   先   / / /   来看 效果 。 controllers 文件 大体 类似 django views . py 文件 ， 定义 视图函数 。   ， 一行   world 文字 ， 祝你好运 。   views   views 文件夹 内容 更 类似 django 模板 文件 ， odoo 自定义 QWeb 模板 语法 ， 会 详细 讨论 。 先 修改   __ manifest __. py   文件 中 data 属性 ， 好 目标 模板 文件 加载 进来 （ 最新 scaffold   命令 写 好 ） ：   ' data ' :   [   #   ' security / ir . model . access . csv ' ,   ' views / views . xml ' ,   ' views / templates . xml ' ,   ] ,   templates . xml 文件 内容 ：   < odoo >   < template   id =   \" index \"   >   < title >   第一个 模块   < / title >   < t   t - foreach =   \" fruits \"   t - =   \" fruit \"   >   < p > < t   t - esc =   \" fruit \"   / > < / p >   < / t >   < / template >   < / odoo >   Qweb 模板 语言 ， 提及 简单 下 :   < t   t - foreach = \" [ 1 ,   2 ,   3 ] \"   t - = \" i \" >   < p > < t   t - esc = \" i \" / > < / p >   < / t >   输出 :   < p > 1 < / p >   < p > 2 < / p >   < p > 3 < / p >     < t   t - esc = \" i \" / >   先 计算   i   值 ， 打印 。   controllers main . py 文件 ， 模板 文件 。     odoo   import   http   class   First   (   http   .   Controller   ) :   @ http   .   route   (   ' / / / '   ,   auth   =   ' public '   )   def   index   (     ,   * *   kw   ) :   return   http   .   request   .   render   (   \" . index \"   ,   {   ' fruits '   :   [   ' apple '   ,   ' banana '   ,   ' pear '   ] } )   调用   http . request . render   函数 ， 猜到 一个 网页 模板 渲染 输出 函数 。 这次 运行 加上   - u     update   目标 模块 。   models   熟悉 django 同学 models 东西 ， odoo 写 ORM 接口 ， 废话少说 ， 看 代码 写法 ：     odoo   import   models   ,   fields   ,   api   class   Fruits   (   models   .   Model   ) :   _   =   ' . fruits '     =   fields   .   Char   ( )   security   security 文件夹 一个   ir . model . access . csv   文件 ， 对模型 访问 权限 管理 ， 加上 记录 ：   id , , model _ id : id , group _ id : id , perm _ read , perm _ write , perm _ create , perm _ unlink   access _ _ fruits ,   access _ _ fruits , model _ _ fruits , , 1 , 0 , 0 , 0   group _ id : id   留空 ， 用户 模型 读 权限 。     __ manifest __. py   文件 挂 上 ：   ' data ' :   [   ' security / ir . model . access . csv ' ,   ' views / views . xml ' ,   ' views / templates . xml ' ,   ] ,   demo     demo . xml   上 加上 演示 数据 ， 测试 写得 模块 。   < odoo >   < record   id =   \" apple \"   model =   \" . fruits \"   >   < field   =   \" \"   >   apple   < / field >   < / record >   < record   id =   \" banana \"   model =   \" . fruits \"   >   < field   =   \" \"   >   banana   < / field >   < / record >   < record   id =   \" pear \"   model =   \" . fruits \"   >   < field   =   \" \"   >   pear   < / field >   < / record >   < / odoo >   定义数据 方式 对接 模型 定义 ，   model   ，   field   = \" \"   值 记录 值 。     controllers . py   改成 :     odoo   import   http   class   First   (   http   .   Controller   ) :   @ http   .   route   (   ' / / / '   ,   auth   =   ' public '   )   def   index   (     ,   * *   kw   ) :   Fruits   =   http   .   request   .   env   [   ' . fruits '   ]   return   http   .   request   .   render   (   \" . index \"   ,   {   ' fruits '   :   Fruits   .   search   ( [ ] ) } )     templates . xml   改成 样子 :   < odoo >   < template   id =   \" index \"   >   < title >   第一个 模块   < / title >   < t   t - foreach =   \" fruits \"   t - =   \" fruit \"   >   < p > < t   t - esc =   \" fruit . id \"   / >   < t   t - esc =   \" fruit . \"   / > < / p >   < / t >   < / template >   < / odoo >   读者 重启动 odoo   server 来看 显示 效果 （ 请 创建 一个 新 数据库 开启 演示 模式 ） 。   美化 网页   odoo 内置 模块   website   ， 利用 进一步 开发 出和原 odoo 网页 统一 风格 网页 界面 。     __ manifest __. py     \" depends \"   属性 改为 :   ' depends ' :   [ ' website ' ] ,   controllers 加上   website = True   设置 。   @ http . route ( ' / / / ' ,   auth = ' public ' ,   website = True )   模块 文件 修改 :   < odoo >   < template   id =   \" index \"   >   < t   t - call =   \" website . layout \"   >   < t   t - set =   \" title \"   >   第一个 模块   < / t >   < div   class =   \" oe _ structure \"   >   < div   class =   \" container \"   >   < t   t - foreach =   \" fruits \"   t - =   \" fruit \"   >   < p > < t   t - esc =   \" fruit . id \"   / >   < t   t - esc =   \" fruit . \"   / > < / p >   < / t >   < / div >   < / div >   < / t >   < / template >   < / odoo >   重启 odoo   server ， 升级 模块 看 （ 更新 manifest template ） 。   网站 左边   HTML 编辑 主题 选择 ， 顶上 右边 编辑 模型 。   ：   HTML 编辑 功能 实验 升级 模块 后 会 丢失 。   url   route 参数   @ http   .   route   (   ' / academy / < > / '   ,   auth   =   ' public '   ,   website   =   True   )   def   teacher   (     ,     ) :   return   ' < h1 >   { }   < / h1 > '   .   format   (     )   东西 django 很 类似 ， 先 略过 ， 再 详细 查阅 讨论 ， 定制   odoo   自带 商业系统 弄清楚 。   data 文件   odoo 视图 xml 数据文件 ， 一块 较为 陌生 ， 再 熟悉 。   < odoo >   < operation / >   ...   < / odoo >   odoo 标签 下 数据 送给 odoo 数据 。   其后   operation   ：   record   数据库 数据 更新 新增 操作   model   操作 模型   id   （ external   id ， external   id   存储   ir . model . data   字符串 ， 用于 快速 引用 某条 记录 。 ）   field   用来 record 定义 字 段 数据   delete   用来 数据库 删除 数据   function   模型 上 调用 方法   快捷 标签   menuitem   快速 定义 一个   ir . ui . menu   记录 ， 一个 菜单 。   template   快速 创建 一个   QWeb   视图 ， 继承 视图 修改 操作 推荐 template 。   id   ( external   id   或者说   xml   id )   inherit _ id   （ 继承 ， external   id ）   report   快速 创建 一个   ir . actions . report   记录 。   定制 odoo   本文 讨论 深度 定制 odoo 现有 商业 体系 。   一个 菜单 （ 菜单 有子 菜单 ） ， 菜单 模型 记录 。 菜单 odoo 框架 中是 生成 ？ 谈到 odoo 模型 对象 实际上 SQL 表格 一条 记录 ， odoo 框架 显示 菜单 一个 odoo 中 一个 模型 对象 ， 表格   ir _ ui _ menu   （ 模型 名   IrUiMenu   ，   _     ir . ui . menu   ） ， xml 中 声明   menuitem   标签 ， 细节 下 再 讲 。 菜单 连接 一个 动作 ， 用户 点击 菜单 ， 动作 将会 触发 。   动作 对象 存放   ir _ act _ window   （ 模型 名是   IrActionsActWindow   _     ir . actions . act _ window   ） 表格 中 。 动作 触发 接下来 视图 。   视图 变动 ， 视图 都 存放   ir _ ui _ view   （ 模型 名是   View   _     ir . ui . view   ） 表格 中 ， 找到 视图 模型 视图 类型 ， 视图 类型 默认 列表 ， 表单 ， kanban 。 视图 解析 过程 查找 目标 视图   primary   视图   arch   内容 ， 目标 视图 parent ， parent 视图 解析 ， 目标 视图 parent ， arch 内容 ， 子 视图 展开 。   ：   select   *     public . ir _ ui _ view     model   =   ' res . company '   ;   会 找到   res . company   相关 视图 ， 显示 目标 类型 动作   view _ mode   字段 最 优先 显示 方案 。   研究 对象 模型 ， 视图 ， 菜单 ， 动作 ， 实际上 都 odoo 模型 ， 对象 值 存放 SQL 表格 里 ， 程序 一系列 索引 ， 取值 操作 ， 最终 生成 显示 ， 大概 odoo 框架 发生 故事 概貌 。   定制 菜单   修改   views / views . xml   文件 定义 菜单 对象 ：   菜单   < ! - -   菜单   - - >   < menuitem   id =   \" menu _ qingjia \"   =   \" 请假 \"   sequence =   \" 0 \"   > < / menuitem >   < menuitem   id =   \" menu _ qingjia _ qingjiadan \"   =   \" 请假单 \"   parent =   \" menu _ qingjia \"   > < / menuitem >   < menuitem   id =   \" menu _ qingjia _ qingjiadan _ qingjiadan \"   parent =   \" menu _ qingjia _ qingjiadan \"   action =   \" action _ qingjia _ qingjd \"   > < / menuitem >   动作   < ! - -   打开 请假单 动作   - - >   < act _ window   id =   \" action _ qingjia _ qingjd \"   =   \" 请假单 \"   res _ model =   \" qingjia . qingjd \"   view _ mode =   \" tree , form \"   / >   menuitem     菜单 视图 中 显示 名字 。   sequence   显示 排序 。   parent   菜单 父 菜单 。 是子 菜单 指定 ， 顶级 菜单 不 指定 。   action   指定 菜单 连接 动作 。 连接 动作 属性 不用 指定 ， 系统 会 引用 动作 属性 。 菜单 动作 关联 。 ， 子 菜单 数据模型 关联 。   act _ window     act _ window 动作 UI 中 显示 名字 （ 类似 QT 中 动作 菜单 中 项目 情况 ） 。   res _ model   act _ window 动作 数据模型 （ 动作 数据模型 关联 ）   view _ mode   act _ window 动作 打开 后 支持 视图 模式 。   定制 视图   视图 定义 动作 设置 ：   < act _ window   id =   \" action _ qingjia _ qingjd \"   =   \" 请假单 \"   res _ model =   \" qingjia . qingjd \"   view _ mode =   \" tree , form \"   / >   设置   view _ mode   ， 定义 视图 声明 好 模型 名 即可 。   表单 视图   < ! - -   表单 视图   - - >   < record   id =   \" qingjia _ qingjd _ form \"   model =   \" ir . ui . view \"   >   < field   =   \" \"   >   qing   jia   dan   form   < / field >   < field   =   \" model \"   >   qingjia . qingjd   < / field >   < field   =   \" arch \"   type =   \" xml \"   >   < form >   < header >   < button   =   \" btn _ confirm \"   type =   \" workflow \"   states =   \" draft \"   string =   \" 发送 \"   class =   \" oe _ highlight \"   / >   < button   =   \" btn _ accept \"   type =   \" workflow \"   states =   \" confirmed \"   string =   \" 批准 \"   class =   \" oe _ highlight \"   / >   < button   =   \" btn _ reject \"   type =   \" workflow \"   states =   \" confirmed \"   string =   \" 拒绝 \"   class =   \" oe _ highlight \"   / >   < field   =   \" state \"   widget =   \" statusbar \"   statusbar _ visible =   \" draft , confirmed , accepted , rejected \"   class =   \" oe _ highlight \"   type =   \" workflow \"   / >   < / header >   < sheet >   < group   =   \" group _ top \"   string =   \" 请假单 \"   >   < group   =   \" group _ left \"   >   < field   =   \" \"   / >   < field   =   \" beginning \"   / >   < / group >   < group   =   \" group _ \"   >   < field   =   \" manager \"   / >   < field   =   \" ending \"   / >   < / group >   < / group >   < group   =   \" group _ \"   >   < field   =   \" reason \"   / >   < / group >   < / sheet >   < / form >   < / field >   < / record >   tree 视图   < ! - -   tree 视图   - - >   < record   id =   \" qingjia _ qingjd _ tree \"   model =   \" ir . ui . view \"   >   < field   =   \" \"   >   qing   jia   dan   tree   < / field >   < field   =   \" model \"   >   qingjia . qingjd   < / field >   < field   =   \" arch \"   type =   \" xml \"   >   < tree >   < field   =   \" \"   / >   < field   =   \" beginning \"   / >   < field   =   \" ending \"   / >   < field   =   \" state \"   / >   < / tree >   < / field >   < / record >   定义 模型     odoo   import   models   ,   fields   ,   api   class   Qingjd   (   models   .   Model   ) :   _   =   ' qingjia . qingjd '     =   fields   .   Many2one   (   ' res . users '   ,   string   =   \" 申请人 \"   ,   required   =   True   )   days   =   fields   .   Float   (   string   =   \" 天数 \"   ,   required   =   True   )   startdate   =   fields   .   Date   (   string   =   \" 日期 \"   ,   required   =   True   )   reason   =   fields   .   Text   (   string   =   \" 请假 事由 \"   )   def   send _ qingjd   (     ) :     .   sended   =   True   return     .   sended   def   confirm _ qingjd   (     ) :     .   state   =   ' confirmed '   return     .   state   _   定义 模型 SQL 表格 名字 ，     odoo 模型 还 一个 字段 ， 很多 显示 搜索 都 依赖于 。   required   设置 True 字 段 必填 项   string   不写 第一个 参数 ， 字段 用户界面 显示 文字   default   默认值   Char   定义 一个 字符串 输入 字 段 ， Char ( )   函数 接受 选 参数 ，   string   模型 用户 名字 ；   required   ；     用户 UI 界面 下 信息 ；   index   布尔值 ， 默认 False ， True 数据库 中为 这列 创建 一个 索引 ( index ) 。   Boolean   布尔值   Integer   整数 值   Float   浮点 数值   Text   大段 文本 输入   Selection   几个 值 选择   Html   Date   Datetime   Many2one   关系         字 段   One2many   关系       字 段   pgadmin3 介绍 中 ， 创建 表头 字 段 :   id   表格 中 一条 记录 独特 id   create _ date   创建 日期   create _ uid   创建   write _ date   修改 日期   write _ uid   修改   odoo8 推出 新 ORM   api 语法 ， 详细 讨论 。 这块 内容 参考   odoo     api   guideline   项目 。   Recordset   新 API 引入 一个 核心 概念   Recordset   ， Recordset 东西 ？ 讲 一个 模型 （ 类 ） 对象 （ 实例 ） 集合 一个 Recordset 对象 。 — — 这是 recordset 情况 ， 一个 限定 条件 其内 元素 必定 模型 ， 集合 情况 删除 过滤 掉 元素 （ 记录 ） recordset 对象 。   官方 文档 描述 ， 一个 Recordset 对象 排序 模型 对象 集合 。 还 指出 还 存放 重复 元素 ， 会变 。 名字 猜 Recordset 对象 支持 集合 操作 ， 事实 确实 。   Recordset 支持 运算 :   record     recset1   #   include   record       recset1   #     include   recset1   +   recset2   #   extend   recset1   |   recset2   #   union   recset1   &   recset2   #   intersect   recset1   -   recset2   #   difference   recset . copy ( )   #   copy     recordset   (   a   deep   copy )   操作   +   还 保留 次序 ， recordset 排序 ， 次序 :     record     recordset :   print ( record )   次序 集合 set 不 ？ 进一步 讨论 。   @ api . multi   默认 ， 返回 一个   RecordSet ， 返回 RecordSet ， 额外 操作 。   @ api .   加上 装饰器 ， 方法     模型   RecordSet   一条 记录 （ multi 装饰器 基础 上 ， 装饰器 ， 自动 循环 每条 记录 ） 。   @ api   .     def   _ toggle _   (     ) :     .   _   =       .   _   return   True   @ api   .   multi   def   _ clear _   (     ) :   _ recs   =     .   search   ( [ (   ' _ '   ,   ' = '   ,   True   ) ] )   _ recs   .   write   ( {   ' active '   :   False   } )   return   True   domain 语法   小节 参考   网页   。   Odoo domain 语法 ， 好像 一个 过滤器 ， SQL SELECT 语句 。 最 语句 形式   [ ( ' field _ ' ,   ' operator ' ,   ) ]   field _   目标 模型 field 名字 。   operator   一个 字符串 ， 可用 值 :   =   ! =   >   > =   <   < =     ilike   ,   \" \" ,   \"   \" ,   \" parent _ left \" ,   \" child _ \" ,   \" parent _ \" 。 parent chind 某种 记录 关系 ， 先 暂时 略过 。 意义 都 很 。     field _ 类型 值 。   圆括号 包围 语句 几个 逻辑 运算符 连接 :   &   |   !   ，   &   默认 逻辑运算 连接符 ， 两个 圆括号 表达式 逻辑运算 连接符 ， 视作 其间   &   。 形式 大概 类似 :   [ ( ' field _ name1 ' ,   ' operator ' ,   ) ,   ' ! ' ,   ( ' field _ name2 ' ,   ' operator ' ,   ) ,   ' | ' ,   ( ' field _ name3 ' ,   ' operator ' ,   ) , ( ' field _ name4 ' ,   ' operator ' ,   ) ]   多个 逻辑 运算符 情况 ，   !   先 解析 ， 只 作用 第一个 元素 ；   &     |   作用 两个 元素 。 一个 简单 解析 步骤 先   !   解析 进去 ， 解析 ， 再   |   解析 进去 ， 相当于 一个 并联 电路 接进来 ， 过滤 条件 一个 大 串联 过滤 线路 。 表达式 解析 :   1 表达式     2 表达式 否     3 表达式 4 表达式   domain :   domain   =   [ ( ' _ ' ,   ' = ' ,   True ) ,   ' | ' ,   ( ' user _ id ' ,   ' = ' ,   ' . env . uid ' ) ,   ( ' user _ id ' , ' = ' , False ) ]   解析 :   _ True     user _ id   . env . uid     user _ id False   search 方法   一个 recordset 对象 调用 search 方法 返回 一个 recordset 对象 。   search 方法 接受 一个 参数 ， 参数 谈论 基于 odoo   domain 语法 过滤器 表达式 。   表达式 :   . env [ ' res . users ' ] . search ( [ ( ' login ' ,   ' = ' ,   ' admin ' ) ] )   含义 调用   res . users   表格 或者说 recordset ， 执行 search 方法 ， 选中 record login 字 段 等于 admin 。   接下来 执行 search 方法 ， 返回 _ recs 一个 recordset 对象 ， recordset 对象 执行   write   方法 ， 接受 一个 字典 值 ， 更改 SQL 表格 表头 （ 属性 ） ， 改为 值 。 值得一提的是 ， recordset 调用 write 方法 会 recordset 内 record 都 修改 操作 。   讲   super ( )   继承 修改 原 模型 方法 ， 请 看 例子 :   @ api   .     def   _ toggle _   (     ) :       .   user _ id   ! =     .   env   .   user   :   raise   Exception   (   ' Only     responsible       ! '   )     :   return   super   (   TodoTask   ,     )   .   _ toggle _   ( )     @ api .   自动 遍历 目标 recordset ， 方法 一个 record 。 程序 逻辑 很 简单 ， 用户名 登录 用户 （ todo   task 管理 管理 计划 ） ， 将会 报错 。 调用 方法 。   write 方法   _ recs . write ( { ' active ' :   False } )     api .   方法 下 ， 属性 修改 都 Record write :   @ api .   def   dangerous _ write ( ) :   . x   =   1   . y   =   2   . z   =   4   推荐   write   操作 ：   def   _ write   (     ) :     rec       :   rec   .   write   ( {   ' x '   :   1   ,   ' y '   :   2   ,   ' z '   :   4   } )   #     def   _ write2   (     ) :   #           records     .   write   ( {   ' x '   :   1   ,   ' y '   :   2   ,   ' z '   :   4   } )   . env   . env . user   用户   . env . lang   语言   . env [ ' res . users ' ]   获取 模型 对象   . env . cr . execute   执行 sql 语句   继承 修改 odoo   扩展 现有 模块   现有 模块 ， 推荐 做法 新建 一个 模块 扩展 修改 现有 模块 目的 。 具体方法 python 中 类   _ inherit   属性 。 标识 将要 扩展 模块 。 新 模型 继承 父 模型 特性 ， 只 声明 想要 修改 就行了 。 继承 机制 修改 模型 视图 业务 逻辑 原 模块 全方位 修改 。   实际上 ， Odoo 模型 定义 模型 之外 ， 都 注册 中心 注册 ， 全局 环境 一部分 ，   . env [ model   ]   引用 。 引用   res . partner   模型 ， 写作   . env [ ' res . partner ' ]   。   模块 增加 field   代码   _ inherit   继承 原 模块 ， 再 增加 field :     odoo   import   models ,   fields ,   api   class   TodoTask ( models . Model ) :   _ inherit   =   ' todo . task '   user _ id   =   fields . Many2one ( ' res . users ' , string = ' Responsible ' )   date _ deadline   =   fields . Date ( ' Deadline ' )     res . users     res . partner   雇员 合作伙伴 ， 再 摸清楚 ， 先 简单 看作 一个 SQL 表格 ， Many2one 讲过 给定 SQL 表格 生成 一个 下 拉 选单 ， 引用 SQL 表格 表头 属性 ， 一个 细节 讨论 。   不管怎么 说 ， 新建 一个 模块   todo _ user   ， 描述 模块 设置 配置 好 ， 原 模块   todo _ app   todo . task 模型 增加 新 两个 field ， 两个 新 表头 。   修改 已有 field   继承 机制 ， 上 类似 ， 只 修改 希望 更改 field 属性 即可 。 :     =   fields . Char ( = \"   I     \" )   原 模型 namefield 额外 增加 信息 。   重载 原 模型 方法   读者 想到 ， 类似 继承 机制 下 ， 重写 原 模型 方法 重载 方法 。 事实上 确实 做 ， 讲 一种 优雅 继承 原 模型 方法 ，   super ( )   调用 父类 方法 。   例子 :   @ api   .   multi   def   _ clear _   (     ) :   domain   =   [ (   ' _ '   ,   ' = '   ,   True   ) ,   ' | '   ,   (   ' user _ id '   ,   ' = '   ,   ' . env . uid '   ) ,   (   ' user _ id '   ,   ' = '   ,   False   ) ]   _ recs   =     .   search   (   domain   )   _ recs   .   write   ( {   ' active '   :   False   } )   return   True   视图 继承 修改   小节 参考   篇文章   ， 一个 简单 例子 所示 ：   < template   id =   \" product _ item _ hide _ _ price \"   inherit _ id =   \" website _ sale . products _ item \"   >   < xpath   expr =   \" / / div [ hasclass ( ' product _ price ' ) ] / b \"   position =   \" attributes \"   >   < attribute   =   \" t - \"   >   product . price   >   0   < / attribute >   < / xpath >   < / template >   大体 分为 三步 ：   推荐   template   标签 创建 一个   QWeb   对象     inherit _ id   描述 继承 关系   修改 ， 修改 三种 方法 ， 描述 。   xpath + expr   xpath   expr   xpath 语法 定位 ， 找到 第一个 用于 修改 操作 。   field +   field       过滤 属性 ， 找到 第一个 field 操作     第一个 元素 属性 操作   position   position   选中 节点 操作   inside   默认 ， 附加 选中 节点 上   replace   替换     选中 节点 兄弟 节点 附加 进来     选中 节点 兄弟 节点 插入   attributes   attributes   修改 选中 节点 属性 值   跟着   < attribute >   标签 。   定制 odoo 实战   寻根问底 第一 谈   res . company   模型   select   *     public . ir _ ui _ menu     parent _ id     null   ;     settings   - >   4   ， ：   select   *     public . ir _ ui _ menu     parent _ id   =   4   ;     User   &   Company     id     7   ，   找到   Company   子 菜单   id   54 ， action   \" ir . actions . act _ window , 44 \"   ，       44   号   动作 ， ：   select   *     public . ir _ act _ window     id   =   44   ;   动作   模型   res . company   。 启动   view _ mode   定义 显示 方案 。 视图   select   *     public . ir _ ui _ view     model   =   ' res . company '   ;   会 找到   res . company   相关 视图 。   假设 我要 定义 res . company   视图 ， 激活 开发者 模式 ， 目标 视图 ， 点击   Fields   View   Get   ，   form   开头 ， 表单 视图 。 ：   select   , arch _ db     public . ir _ ui _ view     model   =   ' res . company '     type   =   ' form '   order     priority   ;   视图 名字 描述 记忆 ， xml 引用 external   id ， priority 字段 定义 继承 关系 顺序 。   第一个 视图 内容 ：   < xml   version = \" 1.0 \" >   < form   string =   \" Company \"   >   < sheet >   < field   =   \" logo \"   widget =   \" image \"   class =   \" oe _ avatar \"   / >   < div   class =   \" oe _ title \"   >   < label   =   \" \"   class =   \" oe _ edit _ \"   / >   ( ... ) \"   内容 还 定义 完 ， 短 ， xml 查找 定义 ， 查找 xml 。 两个 xml ：   < xml   version = \" 1.0 \"   encoding = \" UTF - 8 \" >   < odoo >   < data >   < record   id =   \" view _ company _ form \"   model =   \" ir . ui . view \"   >   < field   =   \" \"   >   res . company . form   < / field >   < field   =   \" model \"   >   res . company   < / field >   < field   =   \" arch \"   type =   \" xml \"   >   < form   string =   \" Company \"   >   < sheet >   < field   =   \" logo \"   widget =   \" image \"   class =   \" oe _ avatar \"   / >   < div   class =   \" oe _ title \"   >   < label   =   \" \"   class =   \" oe _ edit _ \"   / >   < h1 >   < field   =   \" \"   / >   < / h1 >   < / div >   < notebook   colspan =   \" 4 \"   >   < page   string =   \" General   Information \"   >   < group >   < group >   < field   =   \" partner _ id \"   readonly =   \" 1 \"   required =   \" 0 \"   groups =   \" base . group _ _ \"   / >   < label   =   \" street \"   string =   \" Address \"   / >   < div   class =   \" o _ address _ format \"   >   < field   =   \" street \"   placeholder =   \" Street ... \"   class =   \" o _ address _ street \"   / >   < field   =   \" street2 \"   placeholder =   \" Street   2 ... \"   class =   \" o _ address _ street \"   / >   < field   =   \" city \"   placeholder =   \" City \"   class =   \" o _ address _ city \"   / >   < field   =   \" state _ id \"   class =   \" o _ address _ state \"   placeholder =   \" State \"   options =   ' { \" _ open \" :   True } '   / >   < field   =   \" zip \"   placeholder =   \" ZIP \"   class =   \" o _ address _ zip \"   / >   < field   =   \" country _ id \"   placeholder =   \" Country \"   class =   \" o _ address _ country \"   options =   ' { \" _ open \" :   True } '   / >   < / div >   < field   =   \" report _ header \"   placeholder =   \" e . g .   Global   Business   Solutions \"   / >   < / group >   < group >   < field   =   \" website \"   widget =   \" url \"   placeholder =   \" e . g .   www . odoo . \"   / >   < field   =   \" phone \"   / >   < field   =   \" email \"   / >   < field   =   \" vat \"   / >   < field   =   \" company _ registry \"   / >   < field   =   \" currency _ id \"   options =   \" { ' _ create ' :   True ,   ' _ open ' :   True } \"   id =   \" company _ currency \"   / >   < field   =   \" parent _ id \"   groups =   \" base . group _ multi _ company \"   / >   < field   =   \" sequence \"   invisible =   \" 1 \"   / >   < field   =   \" report _ footer \"   placeholder =   \" e . g .   Your   Bank   Accounts ,       line \"   / >   < / group >   < group   =   \" social _ media \"   / >   < / group >   < / page >   < / notebook >   < / sheet >   < / form >   < / field >   < / record >   < record   id =   \" action _ view _ company _ form _ link _ 2 _ currencies \"   model =   \" ir . ui . view \"   >   < field   =   \" \"   >   res . company . form   < / field >   < field   =   \" model \"   >   res . company   < / field >   < field   =   \" inherit _ id \"   ref =   \" base . view _ company _ form \"   / >   < field   =   \" arch \"   type =   \" xml \"   >   < xpath   expr =   \" / / field [ @ id = ' company _ currency ' ] \"   position =   \" \"   >   < label   =   \" id \"   invisible =   \" 1 \"   / >   < p   class =   \" text - muted \"   >   < a   href =   \" \"   type =   \" action \"   =   \" % ( base . action _ currency _ _ form ) d \"   >   Activate     currencies   < / a >   .   < / p >   < / xpath >   < / field >   < / record >   对照   Fields   View   Get   看 ， 大体 内容 。 再 分析 第二个 xml 视图 继承 修改 动作 。 去 ，   < field   = \" currency _ id \"   插入 内容 。   pruchase 模块 研究   删除 询价单 子 菜单   创建 采购 单 即可 ， 不 询价单 ， 询价单 子 菜单 去除 。 找到 采购 子 菜单 id   号   265 ， ：   select   *     public . ir _ ui _ menu     parent _ id   =   265   ;   目标 子 子 菜单 ：   id   parent _ left   parent _     active   sequence   parent _ id   web _ icon   action   278 ; 206 ; 207 ; \" Requests     Quotation \" ; t ; 0 ; 265 ; \" \" ; \" ir . actions . act _ window , 375 \"   子 子 菜单 menuitem 记录 删除 掉 ， 查询 xml 语句 ：   < menuitem   action =   \" purchase _ rfq \"   id =   \" menu _ purchase _ rfq \"   parent =   \" menu _ procurement _ management \"   sequence =   \" 0 \"   / >   ：   < delete   id =   \" purchase . menu _ purchase _ rfq \"   model =   \" ir . ui . menu \"   > < / delete >   采购 订单 生成 采购 单   发现 点击 生成 询价单 ， 希望 编辑 采购 单 ， 取消 询价单 功能 。   376   动作 采购 单 。 采购 订单 试图 还 进一步 研究 ， 研究 模型   purchase . order   。   先 查看 视图 情况 ：   select   *     public   .   ir _ ui _ view     model   =   ' purchase . order '   ;   深感 自如 定制 ， 还 欠缺 一点 火候 ， 学习 odoo 内部 视图 模型 机制 ， 再 回到 。   学习 odoo 内部 机制   controller   class   Academy   (   http   .   Controller   ) :   @ http   .   route   (   ' / / teachers / '   ,   auth   =   ' public '   ,   website   =   True   )   def   index   (     ,   * *   kw   ) :   Teachers   =   http   .   request   .   env   [   ' academy . teachers '   ]   return   http   .   request   .   render   (   \" . index \"   ,   {   ' teachers '   :   Teachers   .   search   ( [ ] ) } )     http . request . env   获取 模型 对象 ， 调用   search   方法 获取 记录 。     http . route   装饰器 指定 url 分发 规则 ， auth 指定 认证 规则 ， website QWeb 模版 。     http . request . render   模版 渲染 网页 ， 第一个 参数 模块 名字 加上 template   id 选定 模版 ， 字典 值来 返回 参数 供 网页 模版 调用 。   url 接受 参数 类型 限定 ，   @ http   .   route   (   ' / academy / < int : id > / '   ,   auth   =   ' public '   ,   website   =   True   )   def   teacher   (     ,   id   ) :   return   ' < h1 >   { }   (   { }   ) < / h1 > '   .   format   (   id   ,   type   (   id   )   .   __ __   )   指定 odoo 内部 模型 ：   @ http   .   route   (   ' / / < model ( \" academy . teachers \" ) : teacher > / '   ,   auth   =   ' public '   ,   website   =   True   )   def   teacher   (     ,   teacher   ,   * *   kw   ) :   return   http   .   request   .   render   (   ' . biography '   ,   {   ' person '   :   teacher   } )   security   id , , model _ id : id , group _ id : id , perm _ read , perm _ write , perm _ create , perm _ unlink   access _ _ teachers ,   access _ _ teachers , model _ academy _ teachers , , 1 , 0 , 0 , 0   id 名字 都 特别 限定 死 ， 关键   model _ id : id   字 段 ， 名字   model _ < model _ >     model _     request . env   定义 模型   . env   引用 都 ，   model _   将点 号 换成 下划线 。   template   QWeb 学习 ， QWeb 原 html 标签 写 上 ， 区别   t -   开头   QWeb   属性 ，   t   标签 条件 渲染 中 渲染 ：   t -   < t   t - = \" condition \" >   < p > Test < / p >   < / t >   条件 符合 ， 输出 ：   < p > Test < / p >   ：   < div   t - = \" condition \" >   < p > Test < / p >   < / div >   输出 ：   < div >   < p > Test < / p >   < / div >   t - call   < t   t - call = \" website . layout \"   >   调用 子 模板 ，   循环 渲染   < t   t - foreach =   \" teachers \"   t - =   \" teacher \"   >   < p > < t   t - esc =   \" teacher . id \"   / >   < a   t - attf - href =   \" / / { { slug ( teacher ) } } \"   >   < t   t - esc =   \" teacher . \"   / >   < / a >   < / p >   < / t >   参数 递归 ， 递归 值   t -   指定 ， 获取 数值 。   t - esc   接受 一个 表达式 ， 估值 打印 出其 内容 。   t - attf - *   渲染 属性 ， 其值 字符串   format   语句 。   库存 管理   创建 供应商   创建 产品 ：   库存 产品 ， 消耗 产品 ， 服务 类产品   供应链   制造 ：   内部 制造 内部 服务 ； 购买 ， 采购 订单 供应商 处 购买 ； MTS   仓库 足够 货物 客户 ，   在手 产品 ， 可用 产品   初始 库存   创建 一个 库存 调整 ， 点击 盘点   销售 流程 集成 ， 选择 一个 客户 ， 创建 一个 报价单 ， 添加 产品 ， 确认 销售 ， 点击 交货   库存 产品 供应链 可用 ， 显示 调拨 单 ， 手工 检查 可用 ， 产品 ， 数量 ， 验证 交货   确认   采购 流程 集成 ， 采购 ， 创建 询价 ， 确认 订单 ， 询价单 采购 单 调拨 单 生成 ， 点击 发货 。 库存 ， 查找 入库 送货 ， 点击 产品 ， 扫描枪 扫描 odoo 确认 验证 收 货单 。   确立 订货 规则 ， 一个 好 仓管 系统 会 货物 存量 太低 太高 ， odoo 订货 规则 ， 。 库存 产品 中 输入 最小 数量   采购   WARNING   历史   商业 智能化   Odoo 框架 简介   python 版本   安装 配置     PostgreSQL 数据库   python 虚拟环境 配置   安装 odoo 依赖   centos   ubuntu   nodejs   安装 odoo   数据库 配置   pg _ hba . conf   初步 启动   windows 下 源码 安装   odoo . conf   数据库 相关   网络 相关   日志 相关   翻译 相关   邮箱 相关   初入 odoo   数据库 管理 界面   登录 界面   Administrator 首选项   导入 一个 翻译   新 Demo 用户   模块 管理   修改 公司 信息   进销存 财务 系统 抽象 讨论   采购 部门 为例   创建 addon   开发 前   快速 生成 模块 骨架   Odoo 模块 文件   安装 自定义 模块   第一个 模块   controllers   views   models   security   demo   美化 网页   url   route 参数   data 文件   快捷 标签   menuitem   template   report   定制 odoo   定制 菜单   菜单   动作   menuitem   act _ window   定制 视图   表单 视图   tree 视图   定义 模型   Recordset   @ api . multi   @ api .   domain 语法   search 方法   write 方法   . env   继承 修改 odoo   扩展 现有 模块   模块 增加 field   修改 已有 field   重载 原 模型 方法   视图 继承 修改   xpath + expr   field +     position   定制 odoo 实战   寻根问底 第一 谈   pruchase 模块 研究   删除 询价单 子 菜单   采购 订单 生成 采购 单   学习 odoo 内部 机制   controller   security   template   t -   t - call   循环 渲染   t - attf - *   库存 管理   采购   激活 产品 变体 特性   采购   会计   会计学 入门   财务报表   原始凭证   账户   资产 类 账户   负债 类 账户   所有者 权益 账户   分类帐   会计科目 表   报告 期间   用户 角色 权限   客户 流程   转账 付款   支票 付款   客户 催款   供应商 流程   登记 账单   账单 付款   核销 银行 账单   附录   模型 表格 清单   本页   base . language . install   res . company   purchase . order   res . users   参考资料   采购 一个 采购 单 （ Purchase   Order ） ， 询价单 采购 招标 自动 生成 。   销项 税   销售额 * 税率   进项 税   购买 货物 支付 税额   应 缴税   =   销项 税   -   进项 税   条形码   barcode   产品 模版   野马 牌 T恤衫 ，   S   蓝色   产品 变量   尺寸 颜色 属性 ， 一个 产品 变量 都 一个 barcode 条形码   一个 产品 变量 都 price   价格 ，   price   =   template   price   +   variant   price   存货 （ Inventory ）   Picture   （ 产品 变量 绑定 ）   Other   Field   大部分 field 产品 模版 关联 ， 改变 ， 相关 产品 变量 都 改变   激活 产品 变体 特性   销售 -   设置 -   产品 变体   添加 产品   -   采购   创建 询价单   -   保存   -   确认 询价单   -   创建 采购 订单   保存   接受 产品 点击   接受 产品   （ 确认 送货 ）   供应商 账单   （ 登记 付款 ）   会计   会计学 入门   会计 系统 企业 两个 :   欠 别人 。 资产 ( assert ) 企业 拥有 控制 企业 带来 未来 经济效益 资源 。 :   现金 ， 物料 ， 设备 土地 。 负债 ( liabilities ) 企业 欠非 所有者 （ 债权人 ） 债务 ， 未来 现金 、 产品 服务 偿还 。 权益 ( equity ) 指 企业 所有人 企业 资产 享有 求偿 权 。   :   资产   =   负债   +   所有者 权益   负债 放在 所有者 权益 ， 负债 先 。 一个 扩展 会计 公式 :   资产   =   负债   +   所有者 名下 资本   -   所有者 提取   +   收入   -   费用   收入 减去 费用 便是 净利润 ( net   income ) ， 费用 大于 收入 ， 会 净 损失 ( net   loss ) 。   常见 经济 业务 :   所有者 投资   成立 一家 公司 ， 以该 公司 名义 存 钱 ， 创始人 这笔 钱 所有者 投资 ， 所有者 权益 中 所有者 名下 资本 。   现金 采购 物料   公司 现金 资产 一种 资产 ( 物料 ) ， 这项 经济 业务 仅仅 改变 资产 形式 。   现金 购买 设备   类似 ， 仅仅 改变 资产 形式 ， 公司 资本 总 数量 没 变 。   赊购 物料   公司 资产 增加 ， 赊 钱 公司 负债 。   提供 服务 赚取 现金   资产 现金 增加 ， 右边 收入 增加 。   现金支付 费用   资产 现金 减少 ， 右边 费用 增加 ， 减去 。   赊销 方式 提供 服务 出租 设备   左边 资产 应收款 项 增加 ， 右边 收入 增加 。   应收 账款 变现   左边 资产 应收款 变为 现金 ， 右边 变化 。   支付 应付 款项   应付 款项 左边 现金 减少 ， 右边 负债 减少 。   所有者 提取 现金   左边 资产 现金 减少 ， 右边 所有者 权益 减少 。   财务报表   利润表   所有者 权益 表   资产 负债表   现金流量 表   原始凭证   原始凭证 纸质 电子版 ， :   销售 发票 ， 支票 ， 订货单 ， 供货商 签发 账单 ， 员工 收入 记录 ， 银行 账单 。   账户   资产 类 账户   =   负债 类 账户   +   所有者 权益 账户   资产 类 账户   资产 指 企业 拥有 控制 预计 未来 企业 带来 经济效益 资源 。 会计 系统 都 包含 账户 :   现金 账户 ( cash )   企业 现金 金额 ， 现金 增减 变动 情况 都 记录 现金 账户 中 。   应收款 项 ( account   receivable )   指 卖方 持有 买房 卖方 付款 承诺 。   应收 票据 ( note   receivable )   称为 期票 ， 一种 书面 承诺 ， 承诺 未来 特定 时间 还款 。   预付 款项 ( prepaid   accounts )   代表 提前 支付 未来 费用 。   物料 ( supplies )   完 资产 ， 完 成本 记入 费用 账户 。   设备 ( equipment )   一项 资产 ， 设备 耗费 ， 成本 一点点 列为 费用 ， 费用 折旧 。   建筑物 ( buildings )   土地 ( land )   负债 类 账户   常见 负债 类 账户 :   应付 款项 ( account   payable )   口头 暗含 付款 承诺 。   应付 票据 ( note   payable )   较为 正式 未来 付款 承诺 。   预收 账款 ( unearned   revenues )   未来 企业 提供 产品 劳务 才能 清偿 负债 。   应计 负债 ( accrued   liabilities )   企业 所欠 尚未 偿还 负债 。   所有者 权益 账户   提及 扩展 会计 公式 ， 所有者 权益 账户 分为 :   所有者 名下 资本 ， 所有者 提取 ， 收入 费用 。   分类帐   信息系统 中 账户 集合 分类帐 。   会计科目 表   企业 账户 名称 编号 列表 会计科目 表 。   编号 中 科目 号 国标 ， 子目 号 省市 ， 内定 。     \\ href { http : / / blog . sina . . cn / s / blog _ 60dc73f50100kq6l . html } { 网页 }   介绍 ， 资产 类 编号 首位 科目 号 1 ， 负债 2 ， 所有者 权益 3 。   报告 期间   年度 财务报表 ， 报告期 一年 会计报告 ， 一个月 ， 一季度 中期 财务报告 。   设置 公司 信息   设置 银行 账户   （ 科目 编号 翻译 应 改为 银行帐号 ）   银行 识别码 实际上 银行 swift   code   称之为   BIC   bank   identifier   code   科目表   安装 中国 科目表   税   创建 税项 ， 设置 销售 采购 默认 税项 ， 公司 开发票 ， 系统 会 自动 税项 。   币种 支持 ， 暂时 不用   一项 新 业务 ， 创建 客户 供应商   公司 运营 实物 服务 称之为 产品 ， 创建 公司 产品   用户 角色 权限   专员   访问 级别 ， 开单   经理   访问 ， 会计 权限 ，   主管   高级 访问 ， 记录 发票 ， 管理 银行费用 ， 核销 日记账 分录   客户 流程   转账 付款   创建 一个 客户 发票   登记 银行 账单   核销 银行 账单   支票 付款   创建 一个 客户 发票   发票 界面 登记 付款   创建 存款单   登记 银行 账单   已有 交易 核销   客户 催款   核销 银行 账单   查看 未 付款 发票   发 催款 信   供应商 流程   登记 账单   创建 账单   现金交易   审核 账单   账单 付款   标记 账单 付款   打印 支票 生成 付款单   核销 银行 账单   自动 核销 银行 账单   附录   模型 表格 清单   本页   子标题 模型   . env [ ]   调用 名字 ， 代码 演示 模型 代码 定义 模型 名 写 上 表格 名 。   base . language . install   class   BaseLanguageInstall ( models . TransientModel ) :   _   =   \" base . language . install \"   res . company   class   Company ( models . Model ) :   _   =   \" res . company \"   purchase . order   class   PurchaseOrder ( models . Model ) :   _   =   \" purchase . order \"   res . users   res .   网页 视图 下 菜单 :   设置 → 用户 。   表格 （ 说 模型 ） 存储 登录 用户 信息 ， 用户名 密码 。   参考资料   wiki 商业智能   wiki   ERP   ERP 不 花钱 ,   作者 :   老肖 （ OSCG ） ,   版本 :   1.0   Odoo   Development   Essentials   ,   author :   Daniel   Reis   ,   date :   April   2015   OdooV10   官方 文档   Odoo     API   guideline   Documentation   ,   author :   Nicolas   Bessi   ,   date :   April   13 ,   2015   .   会计学 原理   19 版   作者 :   John   J . Wild   ,   Ken   W .   Shaw   .   崔学 刚译 ,   中国人民大学出版社 .",
            "tags":"archived",
            "url":"articles/odoo-learning-notes.html"
        },
        {
            "title":"crontab",
            "text":"crontab 工具 用来 系统 执行 周期性 ， ubuntu 下 服务 名字 cron ； centos 下 服务 名字 crond 。   crontab 命令 查看 修改 配置 ：   crontab   - l   # 列出 配置文件 内容   crontab   - e   # 配置文件 编辑   编辑 vi 编辑器 。 crontab   - e 修改 配置 会 生效 ， 不 重启 crontab 后台 服务 。 重启 后台 服务 ， 都 会 计时 。 配置 写 每隔 一个 小时 执行 ， 等到 下 一个 小时 才 会 执行 。   推荐 写 上 一个 每分钟 echo 命令 crontab 运行 情况 。   *   *   *   *   *   echo   \" test \"   日志 默认   / var / log / cron   （ centos ） 。   配置 含义   ：   分   时   日   月   星期   命令   小时 24 时制 ， 星期 0 星期日 ， 1 星期一 。 命令 一行 简单 shell 命令 ， 多行 命令 建议 写成 bash 脚本 ， 脚本 执行 权限 ， 写 上 脚本 绝对路径 名 即可 。   NOTICE   ：   crontab 执行 命令 shell 环境 下 ， pyenv 环境 工作 ， 推荐 命令 文件 都 绝对路径 。   五分钟 ：   * / 5   *   *   *   *   三个 小时 ：   0   * / 3   *   *   *   分钟 写 上 0 ， 这是 新手 很 犯 一个 错误 。   早上 七点钟 ：   0   7   *   *   *   常见 crobtab 配置   小节 参考   篇文章   。   每月   0   0   1   *   *   每周   0   0   *   *   0     0   0   *   *   *   五个 小时   0   * / 5   *   *   *   三十分钟   * / 30   *   *   *   *   定时 备份 crontab 配置   远程 连接 服务器 ， crontab   - e 编辑 连接 意外 终止 ， crontab 配置 都 会 清空 ！ ！   请 加个 定时 备份 crontab 配置 命令 ：   *   * / 1   *   *   *   crontab   - l   >   / home / backup / crontab . back",
            "tags":"others",
            "url":"articles/crontab.html"
        },
        {
            "title":"游戏剧本怎样写阅读笔记",
            "text":"书籍 点评   本书 游戏 剧本创作 入门 学习 第一 本书 ， 更 推荐 阅读 电影 话剧 相关 。 批判性 看吧 ， 地方 通用 剧本 写作技巧 都 价值 ， 地方 太 过于 死板 作者 经验总结 看 图 一个 乐吧 ， 日本 游戏 行业 行有行规 ， 去 模仿 太蠢 。 开发 游戏 思考 想 参考价值 。   游戏 剧本 小说 吝于 笔墨   小说 服务 对象 最终用户 读者 ， 氛围 塑造 ， 背景 交代 都 不吝 笔墨 ， 游戏 剧本 服务 对象 制作 游戏 程序员 、 游戏 角色 形象 艺术 设计师 ， 阅读 游戏 剧本 希望 更快 指导 工作 接下来 做 。   游戏 剧本 小说 从零开始   小说 基本上 从零开始 ， 小说 作者 想 写 写 ， 游戏 剧本 从零开始 ， 最 游戏 开发阶段 一个 游戏 策划 阶段 。 游戏 剧本 编写 遵从 游戏 策划书 。   游戏 策划书 ：   游戏 开发 基础 文档 信息 ， 包括 游戏 标题 主旨 ， 游戏 目标 操作系统 ， 游戏 目标 用户 游戏 画面 整体 感觉 内容 。   游戏 策划书 原因 会 角色 剧情 走向 大体 结局 都 。   游戏 剧本 写作 风格 更 接近 传统 剧本 写作   游戏 剧本 写作 风格 更 接近 传统 剧本 写作 ， 传统 剧本 写作 更 剧本 演职人员 指导 类似 小说 最终 阅读 体验 展示 。 游戏 剧本 写作 更 后续 游戏 开发人员 工作 指导 。   作者 列出 一个 例子 ， 做 简化 ：   CG01   画面   鸿蒙 之初 ...   CG02   地点   画面 描述   对话 1   用户 按键   对话 2   用户 按键   BGM01   ...   作者 讨论 更 人 游戏 团队 开发 游戏 情况 ， 独立 游戏 开发者 来说 写得 详细 一点 。   游戏 剧本 写作 大体 接近 传统 剧本 写作 ， 会 更 关注 游戏 中 要素 ： 画面 ， 对话 ， 环境 渲染 风格 ， 音乐 。   游戏 剧本 创作 传统 文学艺术 形式 创作 很多 相同点   游戏 说到底 一种 艺术 形式 ， 很多 ， 美学 追求 上 故事 架构 技巧 上 ， 都 相互 参考 借鉴 。   这块 就行了 ， 千万别 条条框框 框住 文学创作 方法 ， 正 文无 成法 ， 文 无定形 ， 更 风格 想法 声音 。 打算 一套 公式 般的 东西 文学创作 ， 读者 估计 看 没 几分钟 厌倦 。   正 该书 作者 提到 脸谱化 观点 ， 观点 也许 日本 游戏 业界 惯例 常识 ， 女孩子 年龄 设定 14 岁 ， 都 略去   。 本书 提出 很多 游戏 剧本创作 中 涉及 ， 这才 本书 精华 所在 ， 接下来 讨论 我会 关注 作者 提了 做 思考 工作 ， 作者 答案 ， 创作 更 价值 启发性 。   游戏 剧本创作 会 反复 主题 、 故事 、 角色 、 世界 四个 要素   游戏 策划 阶段 目标 游戏 主题 会 基本上 ， 故事 走向 会 ， 角色 设定 会 ， 世界 设定 会 。   主题 创作 故事   思考 主题 包含 游戏 目的 ： 作者 说 主题 失恋 ， 游戏 目的 寻找 地底下 宝藏 ， 主题 游戏 目的 说 ， 主人公 失恋 对象 主人公 找到 某某 宝藏 才能 同意 复合 。   思考 主题 足以 创作 故事 ： 游戏 主题 还 不足以 创作 故事 ， 扩充 主题 创作 故事 。   游戏 传统 文学艺术 形式 相 一个 玩家 互动性 ， 游戏 中 选项 游戏 故事 表达 主题 融合 ， 故事 用心 ， 玩家 感觉 游戏 设计 上 美 诚意 。   参考 借鉴 创作 故事   游戏 剧本 创作 创造 活动 ， 离不开 游戏 ， 图书 ， 电影 参考 借鉴 。   角色 创作 故事   倒 游戏 剧本 特色 ， 实际上 传统 文学艺术 形式 ， 小说 电影 雕塑 都 一个 角色 设定 。 很多 因素 会 影响 角色 设定 创造 ， 角色 设定 ， 故事 走向 角色 设定 个性 推动 。 很 ， 玩家 沉浸 式 游玩 游戏 故事 ， 感情 代入 角色 中 ， 角色 不 符合 设定 ， 玩家 会 出戏 感觉 ， 文学 世界 里 ， 故事 角色 设定 合理性   1   牛顿 万有引力 还要 。   角色 设定 讨论   作者 角色 设定 上 讨论 略过 ， 实际上 游戏 说到底 小说 传统 文学艺术 形式 ， 文 无定法 ， 更 创作者 风格 想法 声音 。 商业 上 角色 设定 准则 ， 实际上 是从 商业 上 出发 ， 玩家 读者 讨厌 新意 灵魂 角色 设定 创造 。   作者 这块 讨论 ， 角色 设定 因素 值得 创作 故事 角色 设定 思考 ：   名字   年龄   职业   相貌   头发   体格   服装   性格   特技   弱点   口吻   口头禅 习惯 说话 方式   角色 过往 经历 设定   角色定位 讨论   这块 略过 ， 角色定位 讨论 创作 故事 类似 分析 反思 ：   主人公   攻克 对象 难关 角色   系统 角色   游戏 功能性 传统 NPC 角色   敌对 角色   大 反派   竞争者 角色   情侣 角色   伙伴 角色   家人 角色   契机 角色   救星 角色   叛徒 角色   贤者 角色   推动 剧情 发展 ， 故事 发生变化 ， 跳 角色 。   世界 设定 讨论   时代 ？ 时代 特征 ？   故事 地点 ？ 国家 ？ 地区 ？ 地方 特征 ？   世界 和平 动荡 ？   世界 国家 概念 ？ 国家 ， 分为 几个 国家 ？   世界 宗教 概念 ？ 宗教 ， 总共 宗教 ？ 宗教 特征 ？ 影响力 ？   世界 分为 民族 种族 ？   世界 政治体制 ？ 政治形势 ？ 经济体制 ？ 特别 经济 状况 ？ 世界 货币 ？ 货币 几种 ， 单位 ？ 经济 下 生活 水平 ， 人 富裕 贫穷 ， 过得 ， 吃 ， 住 。   世界 家族制度 ？ 婚姻制度 ？ 婚姻制度 婚姻制度 ？   世界 理想 男性 形象 女性 形象 ？ 人 职业 受 人 尊敬 地位 高 。 社会存在 禁忌 忌讳 不愿 谈及 。   世界 世界 相比 不同点 。   世界 语言 ， 哪几种 语言 ， 语言 发音 特征 。   交通 手段 ？ 交通 手段 。   通信 手段 ？ 通信 手段 。   特定 世界 设定 背景 下 ， 故事 大 方向 创作 方向 。   结构 讨论 很 值得 去 学习   结构 讨论 很 值得 去 学习 ， 提到 故事 角色 四 要素 说 不好 听点 不 抄 ， 最 只能 借鉴 参考 ， 剧本 结构 知识 ， 真的 抄 。   起承转合 结构   游戏 起承转合 结构 ， 会 发现 很多 游戏 都 采用 先 抛出 引子 事件 起因 ， 主角 追查 事件 线索 经历 事情 ， 线索 都 汇合 主 事件 一个 高潮 。 说 再 俗套 一点 ， 游戏 一个 boss 。 打破 结构 创新 剧作者 面临 失败 风险 ， 早 结构 当做 某种 约定俗成 东西 ， 好比 应用程序 GUI 界面 ， 都 习惯 ， 不 ， 会 不 。 特别 理由 ， 挑战 起承转合 结构 规则 ， 不信 去 看 莎士比亚 剧本创作 遵循 类似 起承转合 结构 。   起承转合 细分 ， 一个 大 故事 分为 三个 结构 ， 事件 开启 ， 事件 发展 事件 结尾 。 事件 开启 ， 合 事件 结尾 。 承 转 事件 发展 阶段 。 一个 大 故事 细分 几个 小 故事 ， 一个 游戏 分为 几个 章节 几幕 ， 故事 序章 故事 结尾 之外 ， 故事 几章 承转 ， 承 承接 上 一章 故事 发展 ， 放慢 叙事 节奏 ， 更 展现 上 事件 带来 后果 ； 转 推进 故事 ， 引入 事件 转折点 ， 加快 故事 发展 节奏 。   故事 开端   故事 开端 三个 要素 ：   传达 游戏 目的   （ 必 做 ， 生化 奇兵 主创者 说 ， 最 飞机 坠毁 那段 开场 CG ， 去 参加 游戏 演示 ， 差评 如潮 ， 花 几天 时间 赶出来 开场 CG ， 接下来 交口称赞 。 一个 游戏 内容 质量 再 好 ， 故事 开端 游戏 目的 传达 不好 ， 都 极 翻车 ， 游玩 动力 ， 内容 做 再 好 表现 不 。 ）   传达 游戏 玩法   （ 新手 教程 章 ）   传达 这是 一个 游戏   （ 游戏 世界观 介绍 ）   故事 通向 高潮 过程   通向 高潮 过程 讲故事 重点 关键所在 ， 讲 好 这部分 ， 实际上 特定 结构 套路 。 讲故事 特定 结构 套路 传统 平铺直叙 事件 还要 承担 听者 感情 上 代入 感 体验 。 讨论 说 听者 ， 实际上 日常 讲故事 小说 游戏 剧本 原理 都 相通 。   着重强调 故事 目的 剧透 游戏 最终   2   ， 承担 激起 听者 故事 过程 兴趣 。   讲故事 过程 听者 ， 故事 对话 形式 展开 ， 作者 书面 陈述 ， 作者 书面 陈述 形势 时 加上 预期 希望 听者 感受 ， 听者 代入 进来 。 讲故事 过程 结构 清晰 划分 ， 结构 划分 标准 是从 听者 角度 出发 。 听者 会 疑问 ， 听者 会 兴趣 ， 听者 会 角色 感情 代入 ， 听者 会 感到 吃惊 ， 听者 会 期待 。 简言之 ， 时时 听者 读者 听 故事 听到 看 小说 内心 想法 感受 ， 听者 读者 内心 互动 。   故事 高潮   游戏 高潮 简单 达成 最终 目的 简单 ， 游玩 花费 时间 、 精力 感情 释放 ， 愉悦感 。   故事 高潮 关键 不 高潮 本身 ， 通向 高潮 过程 中 。   游戏 特色 内容   分支 支线 故事   分支 支线 故事 好比 主菜 甜点 ， 游玩 多样 不 枯燥 游玩 体验 ， 游玩 喜好 选择 分支 ， 更能 游戏 故事 叙事 节奏 贴近 游玩 喜好 。   一般来说 分支 游戏 故事 背景 融为一体 ， 分支 质量上乘 ， 游玩 游戏 世界 游戏 好感度 会 直线 。   游戏 失败 设定   游戏 失败 设定 会 赋予 一个 故事 上 意义 。   游戏 结束 设定   游戏 结束 设定 ， 或者说 故事 结局 。   游戏 重玩 机制   游戏 重玩 机制 游戏 一大 特色 ， 游戏 故事 更好 融为一体 值得 游戏 设计者 探索 研究 课题 。   游戏 选项   游戏 选项 游戏 结局 ， 故事 主题 深化 才 引入 进来 。 游戏 结局 结局 愚蠢 。   极端 寻求 开放 世界 极端 寻求 结局 选项 游戏 都 持 保留意见 ， 极端 头 会 极大 损伤 游戏 故事性 。 游戏 游戏性 很大 一部分 建立 游戏 选项 上 ， 类型 游戏 游戏 选项 设计 实际上 很 技巧 ， 很多 都 故事 主题 相关 要素 扩展 要素 相关 。 少量 调剂 主题 无关 选项 ， 那句话 ， 游戏 选项 游戏 游戏性 一个 开发 点 ， 弄 出太多 杂七杂八 无关紧要 选项 只会 游玩 感到 厌倦 。   极端 开放 世界 极端 选项 游戏 一件 风险 事情 ， 两个 风格 游戏 都 跳出 传统意义 上 故事 游戏 范畴 ， 不 本文 讨论 之内 。 正 跳出 传统 故事 范畴 ， 玩家 极大 风险 感受 自由 开放 空洞 无所适从 ； 极端 选项 游戏 本来 设计 初衷 弱化 角色扮演 增强 玩家 互动 代入 感 ， 选项 这块 设计 不好 ， 也许 照顾 玩家 个性 喜好 ， 游戏 角色 代入 感 代入 感都 。   脚注   角色 设定 合理性 恒定性 ， 角色 个性 展现出 复杂性 变动性 。   ↩   情况 下 会 讲故事 人会 预先 剧透本 故事 结局 ， 会 听者 走向 结局 过程 好奇心 ， 讨论 讲 好 故事 目的 所求 听者 故事 过程 好奇心 。   ↩",
            "tags":"notes",
            "url":"articles/you-xi-ju-ben-zen-yang-xie-yue-du-bi-ji.html"
        },
        {
            "title":"docker学习笔记",
            "text":"前言   docker 请 参看   网页   ， 说 docker 改变 软件 生态 确实 不为过 。 老实 说 接触 docker 感觉 学到 很多 东西 ， linux 系统 相关 ， ansible 部署 工具 相关 ， virtualbox   vagrant 相关 ， 都 慢慢 过时 淘汰 。 工具 很 有用 ， 说 淘汰 ， 更 确切 来说 ， 玩家 来说 ， 节省 更 精力 时间 ， 不 折腾 工具 配置 学习 折腾 老半天 。   That ‘ s       love   docker .   实际上 docker 带来 变化 远远 不止 一个 节省 开发者 做 事情 时间 一个 不错 工具 简单 ， 伴随 SPPS ， 软件 服务 ， 更 确切 来说 互联网 大 背景 下 ， 应运而生 。 ， 开发者 顺应 时代 ， 编码 ， 软件应用 很多 ， 都 做出 改变 。 请 读者 进一步 阅读   https : / / 12factor . net / zh _ cn /   讨论 。   实际上 折腾 vagrant ， 很 认同 理念 ：   开发 ， 测试 ， 生产 环境 ， 彻底解决 ， 运行 ， 不行 。 vagrant 控制 virtualbox 创建 虚拟机 方式 ， 在我看来 显得 略微 笨拙 点 ， 配置 繁琐 ， 很 好地解决 ； docker 很 好地解决 之外 ， 虚拟化 方案 更 轻量级 ， 更 接近 原生 。   docker 包括 三个 核心 概念 ：   镜像 image ， 容器 container ， 仓库   image   镜像   用来 创建 docker 容器 模板   container   容器 ， 看做 镜像 生成 一个 实例   docker 仓库 用来 保存 镜像 ，   docker   hub   提供 很多 docker 仓库 。   安装   内容   过时   ， 请 参考 官方 文档 安装 。   windows 下 安装   windows 下 安装 操作系统 专业版 企业 版 ， 只能   docker   tool   box   安装 。 记得   window10   开发者 模式 打开 。   windows10 企业 版 专业版 ， 没试 ， 想 官网 ， 安装 成功 。   kitematic   docker   镜像 管理工具 ， 推荐 ， 很 。   centos 下 安装   更 详细 内容 见   官方 文档   。   yum   install   - y   yum - utils   yum   install   - y   device - mapper - persistent - data   yum   install   - y   lvm2   yum - config - manager   - - add - repo   https : / / download . docker . / linux / centos / docker - ce . repo   yum   install   docker - ce   ubuntu 下 安装   更 详细 内容 见   官方 文档   。   sudo   apt -   remove   docker   docker - engine   docker . io   containerd   runc   sudo   apt -   update   sudo   apt -   install   \\   apt - transport - https   \\   ca - certificates   \\   curl   \\   gnupg - agent   \\   software - properties - common   curl   - fsSL   https : / / download . docker . / linux / ubuntu / gpg   |   sudo   apt - key   add   -   sudo   add - apt - repository   \\   \" deb   [ arch = amd64 ]   https : / / download . docker . / linux / ubuntu   \\   $ (   lsb _ release   - cs   )   \\   stable \"   sudo   apt -   update   sudo   apt -   install   docker - ce   docker - ce - cli   containerd . io   linux 系统 下 安装   linux 系统 下 安装 docker 运行 ：   sudo   docker   run   - world   ， 运行 ：   docker   run   - world   不 ， 登录 用户 docker 群组 中 去 ：   sudo   usermod   - aG   docker   $ USER   【 NOTCIE   命令 生效 退出 登录 下 】   第一个 项目   内容 参考 视频 ：   项目 新建 一个 docker   镜像 或者说 image 。   新建 一个 文件夹 ， 编写 Dockerfile   FROM   php : 7.0 - apache   COPY   src /   / var / www / html   EXPOSE   80   FROM     镜像 基于 镜像 ， 镜像 名字 php ， 一个 官方 镜像 ， 分支 名字   7.0 - apache   。   执行 COPY 动作 ， 文件夹 src 文件夹 内容 ， 复制到 容器 【 镜像 生成 容器 ， 源 镜像 基于 linux 系统 】   / var / www / html   文件夹 下 。   暴露 80 端口   src 下 一个 简单 php 文件 ， 讨论 重点 。   生成 镜像   docker   build   - t   image _   . < _ foler >   列出 本地 镜像   docker   image   ls   网下 下载 镜像   docker   pull   - world   删除 镜像   docker   image   rm   < id >   制作 镜像 运行 命令 ，   a358003542   docker   hub   注册 用户名 ， 采用 写法 ：   docker   build   - t   a358003542 /   .   启动 镜像   docker   run   - p   8080 : 80   a358003542 /   docker   run   命令 自动 试着 docker   hub 下载 镜像 功能 ， 命令 run 单词 含义 一个 容器 内 执行 命令 ， 会 自动 一个 镜像 创建 一个 容器 。   端口 转发 ， docker 容器 内 80 ， 容器 对外 发布 8080 端口 。 命令 查看 下 创建 容器 ：   docker   container   ls   项目 提交 docker   hub   docker   login   docker   push   a358003542 /   docker   push   名字 格式   docker   hub 上 用户名 / 仓库 名字   。   删除 虚悬 镜像   docker   build   docker   pull   同名 镜像 ， 旧 镜像 仓库 名 tag 会 ， 类 镜像 虚悬 镜像 。 可用 命令 删除 组合 虚悬 镜像 ：   docker   image   prune   . dockerignore   . dockerignore   类似   . gitignore   文件 ， 用于 docker   build 镜像 忽略 掉 不 文件 文件夹 ， docker build 镜像 过程 时 ， 会 自动 指定 上下文 目录 打包 传递 docker 引擎 。   Dockerfile   FROM   指定 基础 镜像   COPY   文件 文件夹 复制到 容器 位置 ， COPY 本地 内容 路径 相对路径 。   ADD   ADD COPY 功能 基本一致 ， ADD 还 增加 额外 功能 ， 面向 网络 下载 。   RUN   相当于 容器 内 执行 shell 命令 ， RUN 之间 环境 不 共用 ， 一个 RUN 命令 容器 一层 ， 推荐 RUN 命令 都 合并 。   CMD   CMD 提供 运行 容器 默认 ，   ubuntu   镜像   CMD     / bin / bash   ， 输入 ：   docker   run   -   ubuntu   会 bash 。   Dockerfile 定义 ENV 环境变量 会先 CMD shell 层 。   ENV   设置 环境变量   Dockerfile ，   引用 设置 环境变量 ：   $ APP _ PATH   VOLUME   定义 匿名 卷   ：   VOLUME   / home / data   定义 容器 数据 存储 匿名 卷 ， Dockerfile 会 申明 匿名 卷 ， 就算 容器 运行 时 用户 忘记 指定 存储 卷 ， 容器 运行 时 容器 存储 卷 写入 数据 。   - v   mydata : / home / data   制定 存储 卷 ， 会 覆盖 Dockerfile 声明 默认 配置 。   EXPOSE   声明 容器 提供 服务 端口 ，   - p   9001 : 9001   映射 端口 。   WORKDIR   指定 docker 环境 下 当前工作 目录 （ 运行 docker   run docker 环境 下 ）   保存 镜像 文件   docker   save   < image >   启动 容器   启动 容器 bash 交互   docker   run   -   \" id     running   container \"   bash   容器 后台 运行 ， 希望 登入 容器 ， 推荐   exec   ：   docker   exec   -   < container >   bash   exec 登入 容器 ， 输入   exit   导致 容器 停止 。   容器 运行 时 设定 重启 策略   - - restart =   默认   容器 退出 不 做   - - restart = - failure   容器 非 0 状态 退出   docker 会 尝试 启动 容器   - - restart =   用于 docker 服务 重启 自动 启动 容器   查看 容器 输出 日志   台 形式 启动 容器 ， 查看 容器 日志 ：   docker   logs   < container >   docker   logs   - - tail = 100   < container >   - - tail   列出 条 日志 。   docker   compose   安装   更 详情 参考   官方 文档   ， 列出 linux 简单 下载安装 。   sudo   curl   - L   \" https : / / github . / docker / compose / releases / download / 1.24 . 0 / docker - compose - $ ( uname   - s ) - $ ( uname   - m ) \"   - o   / usr / local / bin / docker - compose   sudo   chmod   + x   / usr / local / bin / docker - compose   docker - compose 说 docker 容器 编排 工具 ， 实际上 单个 容器 启动 配置 定制 很 。   一个 简单 例子 所示 ：   version :   \" 3 \"   services :   web :   build :   .   env _ file :   -   . / pycode / python . env   volumes :   -   . / data : / home / data   -   . / pycode : / home / pycode   ports :   -   9001 : 9001   选项 很多   docker   run   命令 时 可选 参数 ， 功能 大体 都 类似 。   运行 docker - compose   启动 容器 组 ， 重启 查看 日志 。   docker - compose     阶段 构建   阶段 构建 最 常用 模式 容器 dev 环境 runtime 环境 分开 ， 实施 阶段 构建 ， 深刻理解 项目 包是 运行 时 环境 ， 包是 编译 环境 。   新开 一个 编译 环境 容器 ， 装 好 编译 项目 代码 依赖 ， 项目 代码 编译 好 。   新建 一个 运行 时 环境 容器 ， 最 核心 代码 ：   COPY   - - = builder   $ ROOT / build   $ ROOT / build   builder 容器 编译 好 build 内容 复制到 运行 时 容器   做 两个 好处 ：   编译 依赖 很多 ， 运行 时 容器 镜像 很 小巧   编译 容器 发生 变动 情况 下 ， build 镜像 ， 编译 时 容器 会 利用 cache ， 再 费时 编译 工作   Dokcerfile 最佳 实践     . dockerignore   命令 尽量 合并 ， dockerfile 一个 命令 新建 一个 docker 层 。 docker 早期 很 关键 ， docker 重点 关注 三个 命令 ， 尽量 合并 ：   RUN   COPY   ADD   阶段 构建 ， 大大降低 镜像 大小 ， 不用 再 苦苦 挣扎 去 想 减少 中间层 文件 。   安装 不 软件   apt 安装 软件 先 update 尽量 合并 一句 话 ， 一个 最佳 实践 ， 还 apt 安装 过程 缓存 删掉 。   RUN   apt -   update   &&   apt -   install   - y   \\   aufs - tools   \\   automake   \\   build - essential   \\   curl   \\   &&   rm   - rf   / var / lib / apt / lists / *   docker 权限 控制 最佳 实践   docker 项目 下 默认 root 会 更 ， docker 容器 就算 root ， 安装 性 容器 外 root 区别 ， 说 。 情况 一般来说 ， 推荐 非 root 账号 ， 实践 容器 外 运行 用户 容器 内 运行 用户 。 容器 会 ， 更 容器 运行 程序 输出 文件 ， 容器 外 用户 访问 ， 容器 外该 用户 文件夹 ， 挂载 容器 时 ， 容器 内 用户 运行 程序 访问 文件 ， 权限 。   这方面 docker 版本 【 18.06 】 还 支持 ， 只能 DIY 定制 方式 ， 好 特别 麻烦 。 docker Dockerfile 运行 容器 ， 加上 ：   - - user   1000 : 1000   运行 容器 用户 。   docker - compose 启动 容器 ， docker - compose . yml 上 配置 ：   web   :   build   :   context   :   .   args   :   -   UNAME = $ { UNAME }   -   UID = $ { UID }   -   GID = $ { GID }   ...   user   :   $ { UID } : $ { GID }   配置 环境变量 ， 再 运行   docker - compose   ， 写 一个 bash 脚本 ：   # ! / usr / bin / env   bash   export   UNAME   =   $ (   whoami   )   export   UID   =   $ (   id   - u   )   export   GID   =   $ (   id   - g   )   exec   docker - compose   \"   $ @   \"   运行 ：   bash   runinenv - docker - compose . sh     传递 环境参数 启动 docker - compose   命令 效果 。   还 容器 配置 ：   FROM   python : 3.6   ARG   UNAME   =   wanze   ARG   UID   =   1000   ARG   GID   =   1000   ENV   UHOME   =   / home /   $ UNAME   RUN   groupadd   - g   $ GID   - o   $ UNAME   RUN   useradd   - m   - u   $ UID   - g   $ GID   - o   - s   / bin / bash   - d   $ UHOME   $ UNAME   USER   $ UNAME   新 建立 容器 root 用户 ， 新建 一个 容器 外 用户 用户 群组 。 容器 默认 登录 用户 配置 好 。   挂载 VOLUMN 上 配置 ：   volumes :   -   . / data : / home / $ { UNAME } / data   -   . / pycode : / home / $ { UNAME } / pycode   目标 文件夹 容器 外 所有者 容器 运行 ， 容器 内 程序 都 访问 。   小节 参考   网页     网页   。   docker 镜像 存储 配置   小节 参考   网页   ， 值得一提的是 方法 服务器 重启 重新配置 ， 好处 配置 很 简单 ：   sudo   docker   rm   - f   $ ( docker   ps   - aq ) ;   docker   rmi   - f   $ ( docker   images   - q )   sudo   systemctl   stop   docker   sudo   rm   - rf   / var / lib / docker   sudo   mkdir   / var / lib / docker   sudo   mkdir   / mnt / docker   sudo   mount   - - rbind   / mnt / docker   / var / lib / docker   sudo   systemctl   start   docker   docker 对系统 hosts 配置   不 手工 修改   / / hosts   文件 ， docker 支持 写法 【 参考   网页   】 ：   extra _ hosts :   -   \" somehost : 162.242 . 195.82 \"   -   \" otherhost : 50.31 . 209.229 \"   设置 时 区   #   set   timezone     hongkong   RUN   unlink   / / localtime   &&   ln   - s   / usr / share / zoneinfo / Asia / Hong _ Kong   / / localtime   参考资料   http : / / www . ruanyifeng . / blog / 2018 / 02 / docker - tutorial . html   https : / / docker _ practice . gitee . io   https : / / docs . docker . /",
            "tags":"tools",
            "url":"articles/dockerxue-xi-bi-ji.html"
        },
        {
            "title":"html5学习教程一html篇",
            "text":"If       a   english   reader ,   I   recommend     article       html5   starting   point .   第一个 模板   < ! DOCTYPE   html >   <   html   lang   =   \" zh - cn \"   >   <   head   >   <   meta   charset   =   \" utf - 8 \"   >   <   title   >     awesome   title   < /   title   >   < /   head   >   <   body   >   < /   body   >   < /   html   >   doctype 声明   html5 doctype 声明 非常简单 ， 开头 简单 一行 即可 :   < ! DOCTYPE   html >     html   标签 ，   head   标签 ， head 标签 内容 显示 网页 上 ， 本网页 配置 信息 。   字符集 设置 utf - 8   html5 更 简洁 语法 :   < meta   charset = \" utf - 8 \" >     body   标签 存放 显示 网页内容 。   第二个 例子   < ! DOCTYPE   html >   <   html   lang   =   \" zh - cn \"   >   <   head   >   <   meta   charset   =   \" utf - 8 \"   >   <   title   >   basic   html   < /   title   >   < /   head   >   <   body   >   <   nav   >   <   ul   >   <   li   > <   a   href   =   \" # \"   >   Home   < /   a   > < /   li   >   <   li   > <   a   href   =   \" # \"   >   About   < /   a   > < /   li   >   <   li   > <   a   href   =   \" # \"   >   Products   < /   a   > < /   li   >   <   li   > <   a   href   =   \" # \"   >   Contact   Us   < /   a   > < /   li   >   < /   ul   >   < /   nav   >   <   header   >   <   h1   > <   a   href   =   \" # \"   >   Very   Basic   Document   < /   a   > < /   h1   >   <   h2   >   A   tag   line         < /   h2   >   < /   header   >   <   section   >   <   article   >   <   h3   > <   a   href   =   \" # \"   >   First   Article   Title   < /   a   > < /   h3   >   <   p   >   Lorem   ipsum   dolor   sit   amet ,   consectetur   adipiscing   elit .   Integer   nec   odio .   < /   p   >   < /   article   >   <   article   >   <   h3   > <   a   href   =   \" # \"   >   Second   Article   Title   < /   a   > < /   h3   >   <   p   >   Praesent   libero .   Sed   cursus   ante   dapibus   diam .   < /   p   >   < /   article   >   < /   section   >   <     >   <   h4   >   Connect   With   Us   < /   h4   >   <   ul   >   <   li   > <   a   href   =   \" # \"   >   Twitter   < /   a   > < /   li   >   <   li   > <   a   href   =   \" # \"   >   Facebook   < /   a   > < /   li   >   < /   ul   >   < /     >   <   footer   >   <   p   >   All   rights   reserved .   < /   p   >   < /   footer   >   < /   body   >   < /   html   >   html5 新 很多 文档 结构 标签 ， 标签 布局 含义 ， 相当于 一个 自带 名字 div ， 默认 标签 。 作用 html 内容 分组 ( group ) 。   常用 标签 含义 ， 中 ， 尽量 规范 标签 。   header :   一个 网页 总要 个头 ， 推荐 都 标签 。   nav :   目录 导航 菜单 。   section :   本网页 主体 信息 主 页面 — — 类似 GUI 显示 窗口 。   article :   section 独立 内容 。   :   网页 主体 信息 不太 相关 信息 。   footer :   作者 ， 版权 脚注 信息 。   都 div class id 写法 取代 ， 中 默认 标签 需求 ， html5 默认 标签 。   例子 标签 ， 很 常用 标签 ， 承接 补充 写 一个 常用 html 标签 清单 。   常用 html 标签 清单   ul :   不 编号 列表 ， 无序 列表 （ Unordered   list ） 。 item   li   标签 封装 。   ol :   编号 列表 ， 序列表 （ Ordered   list ） 。 item   li   标签 封装 。   h1 , h2 , h3   ...   标题 标签 ， 数字 标题 层级 。   p :   段落 标签 。   b :   文字 加粗   i :   文字 斜体   br   换行   hr   水平线   img   图片 ， 最 常用 属性   src   ， 指明 图片 引用 地址 。   建立 一个 链接   a :   引用 链接 标签 ， 常用 属性   href   ， 指明 引用 地址 ，   title   悬浮 提示 文字 。   < a   href = \" / \"   title = \"     \" > show < / a >   一个 链接 用来 下载 文件 ，   download   属性 指定 默认 保存 文件名 。   < a   href = \" https : / / download . mozilla . org / product = firefox - 39.0 - SSL & os = win & lang = en - US \"   download = \" firefox - 39 - installer . exe \" >   Download   Firefox   39     Windows   < / a >   连接   target = \" _ blank \"   属性 ， 目标 连接 将会 浏览器 新 标签 页 打开 。   创建 一个 电子邮箱 链接 ：   < a   href = \" mailto : @ mozilla . org \" > Send   email     < / a >   文字 html5 规范   html5 提出 规范 ， 不 推荐   < b >   标签 文字 用途 （ 文字 加粗 词 提醒 读者 词 特别 记忆 ） 。 推荐   < em >   标签 一级 ，   < strong >   标签 更进一步 。 默认 样式 中 ，   < em >   斜体 ，   < strong >   粗体 。 html5 表达 文字 样式 标签   < b > < i >   尽可能 不用 废弃 ， 文字 都 推荐   < em >     < strong >   标签 。 设计 思路 html 一个 描述 文档 内容 结构 标签 系统 ， 不 带有 内容 表现形式 东西 。 推荐 html5 规范 ， 少   < b >   标签   < i >   标签 。 请 参看   网页   讨论 。   注释   < ! - -   Make       a   comment .   - - >   序列表 带 无序 列表   无序 列表 嵌套 进去 即可 。   <   ol   >   <   li   >   ol   li1   < /   li   >   <   li   >   ol   li2   < /   li   >   <   ul   >   <   li   >   ul   li1   < /   li   >   <   li   >   ul   li2   < /   li   >   < /   ul   >   < /   ol   >   table   table 表格 用于 布局 ， 不 推荐 风格 ， html 标签 尽可能 文本 结构层 非 表现形式 层 。 一个 完整 table 模板 所示 :   <   table   >   <   caption   >   表格 标题 caption 标签   < /   caption   >   <   thead   >   <   tr   > <     >   标签   < /     > <     >   fullname   < /     > <     >     < /     > < /   tr   >   < /   thead   >   <   tbody   >   <   tr   > <   td   >   tr   < /   td   > <   td   >   table   row   < /   td   > <   td   >   表格 中 一行   < /   td   > < /   tr   >   <   tr   > <   td   >     < /   td   > <   td   >   table   head   < /   td   > <   td   >   表格 列名   < /   td   > < /   tr   >   <   tr   > <   td   >   td   < /   td   > <   td   >   table   data   < /   td   > <   td   >   表格 展示 数据   < /   td   > < /   tr   >   < /   tbody   >   < /   table   >   表格 标题 caption 标签   标签   fullname     tr   table   row   表格 中 一行     table   head   表格 列名   td   table   data   表格 展示 数据   大体 html 上 画表格 上 所示 ， 更 漂亮 表格 制作 都 css ， 先 略过 。   div span   div （ division ） html 标记 语言 中 区块 。 html 页面 显示 元素 好比 一个个 盒子 排布 ，   div   看作 一个 自定义 盒子 。 html 中有 两种 显示 风格 盒子 ， 一种 块状 区块 ， p 段落 标签 ； 一种 inline 盒子 ， 比如说 em 标签 ， 换行 。   div 标签 更 确切 表达 块状 区块 ， 看作 display 属性   block   （ 不 ， 推荐 接受 设定 ） ； inline 区块 ，   span   标签 元素 ， 理解 改 标签 元素 display 属性   inline   。   inline   css   最 css 属性 inline   css 模式 html 标签 中   style   属性 加上 。   font - size   字体大小   <   p   style   =   \" font - size : 12pt \"   >   paragraph   < /   p   >   color   字体 颜色 ，   这是 css 支持   color 关键词 清单   。   <   h2   style   =   \" color : green \"   >   paragraph   < /   h2   >   font - family   字族 ，   这是 css 支持   字族 信息   。   <   ol   >   <   li   style   =   \" font - family : Arial \"   >   Arial   < /   li   >   < /   ol   >   文字 标签 都 三个 属性 控制 其内 文字 大小 ， 颜色 字族 。 都 推荐 css 控制 ， 思路 顺序 优先 inline   css ， 太过 情况 下才 单独 css 控制 。   background - color   背景 颜色 。 读者 熟悉 LaTeX 排版系统 ， 都 LaTeX 排版 很 核心 一个 概念 盒子 。 html ， 一个个 标签 看作 一个个 排版 盒子 。 background - color 控制 一个 盒子 背景 颜色 。   <   body   style   =   \" background - color : yellow \"   >   < /   body   >   text - align   文字 标签 盒子 里 对齐 方式 。 选 参数 :   left ,   ,   center 。   <   h3   style   =   \" text - align : center \"   >   居中 对齐 标题   < /   h3   >   外部 css   一种 说法 ， 放在 html   标签 css 外部 css 文件 引用 区分 开来 ， 在我看来 区别 不大 。 网络 上 一种 说法 html   标签 多用 id css 定义 ， 外部 css 文件 只用 class 定义 好 普适性 ， 在我看来 削足适履 。 额 ， 国内 网络 环境 都 懂 ， 喜欢 少用 css 文件 引用 ， 尽量 css 定义 都 放在   标签 ， 加载 快 一点 ， ， 倒 没什么 特别 好 讲究 。 css 定义 前 class ， 元素 才 id 属性 控制 ， 想 。   放在   标签 css 大致 格式 引入 进来 :   <   style   >   格式 外部 css 文件格式 完全一致   < /   style   >   引入 外部 文件 css :   <   link   rel   =   \" stylesheet \"   href   =   \" main . css \"   >   外部 css 文件 还 进一步 引用 css 文件 :   @   import   url   (   \" http : / / getbootstrap . / dist / css / bootstrap . min . css \"   )   ;   引用 语句 分号 不 太 ， 不太 关心 ， 没事 加上 。 参考   网页   。   设置 背景图片   background - image : url ( \" https : / / theurl / tothe / image . jpg \" ) ;   设置 背景图片 位置   设置 背景图片 位置 ， 值 top ， center ， ， left ， top ， bottom ， 所示 :   top   left   top   center   top     center   left   center   center   center     bottom   left   bottom   center   bottom     只 给出 一个 值 ， 第二个 值 默认值 center 。   background - position :   center   center ;   设置 背景图片 重复   默认 repeat ， 设置   - repeat   ， 背景图片 重复 铺满 背景 。   background - repeat :   - repeat ;   设置 背景图片 不随 页面 滚动   background - attachment : fixed ;   设置 背景 图片尺寸   设置   cover   ， 背景图片 会 拉伸 足够 大 ， 覆盖 区域 ， 图片 部位 显示 背景 中 。   background - size :   cover ;   设置     ， 背景图片 会 拉伸 长度 宽度 不 超过 背景 为止 。   还 指定 宽高比 ， 宽 100px ， 高 150px :   background - size : 100px   150px ;   设置 背景 颜色   html 标签 盒子 背景 颜色 ， color 设置 字体 颜色 。   background - color : red ;   控制 文本 大小写   所示 ， 依次 :   大写 ， 首字母 大写 ， 小写 。   h1   { text - transform : uppercase }   h2   { text - transform : capitalize }   p   { text - transform : lowercase }   边框 画 一个 圆   边框 一个 圆 。   < div   style = \" border : 1pt   solid   blue ; border - radius : 50% ; width : 100px ; height : 100px ; margin : auto ; \" > < / div >   z - index 属性   css 中 标签 盒子 设置 z - index 属性 ， 影响 标签 盒子 堆叠 顺序 。 比如说 header 标签   z - index   属性 设置 1 ， 都 不 设置 ， 保证 header 网页 头 第一个 先 堆放 。 :   header {   z - index : 1 ;   }   表单   html 中 表单 情况 ， 详细 。 表单 指   form   标签 加上 其内 包含   input   元素 。 input 元素 熟知 文本 输入框 ， 下 拉 列表 ， 单选框 ， 复选框 。   < form >   < input >   < / input >   < / form >   表单 元素 类型 input 标签   type   元素 定义 ， 详细 :   单行 文本 输入   单行 文本 输入 input 标签 ， type 类型   text   ， 文字 推荐   label   标签 。   <   form   >   <   label   >   :   < /   label   >   <   input   type   =   \" text \"     =   \" yourname \"   > < /   input   >   < /   form   >   input     属性 很 ， 其值 文本 输入 值 变量名 （ python wsgi 机制 其刷成   form . yourname   引用 ） 。   :   多行 文本 输入   多行 文本 输入   textarea   标签 生成 ， 先 简单 下 即可 。   <   p   >   :   < /   p   >   <   textarea   rows   =   \" 5 \"   >     textarea         < /   textarea   >   <   p   >   :   < /   p   >   :     textarea         :   加上 action   表单 form 标签 上 加上 action 属性 ， 表单 内 定义 submit 按钮 input 元素 ， 点击 将会 数据 发送给 action 去 ， 具体方法 method 属性 定义 ， 默认 GET 。   < form   action = \" / \"   method = \" POST \" >   < input   type = \" text \" >   < button   type = \" submit \" > submit < / button >   < / form >   required   加上 requird 属性 ， 该字段 填上值 。   < input   type = \" text \"   required >   placeholder   预 显示 文字   < input   type = \" text \"   placeholder = \" input     \"   required >   按钮   html 好几种 方法 创建 一个 按钮 ， w3school 不 推荐 button 标签 ， 推荐 所示 input 标签 形式 :   <   form   action   =   \" https : / / www . google . \"   method   =   \" \"   >   <   input   type   =   \" submit \"     =   \" click     google \"   > < /   input   >   < /   form   >       属性 定义 按钮 上 显示 文字 。 跳转 form 标签   action   属性 定义 ， 还 定义   method   属性 定义 HTTP method ， 一个 表单 提交 例子 :   <   form   action   =   \" http : / / httpbin . org / post \"   method   =   \" post \"   >   <   label   >   :   < /   label   >   <   input   type   =   \" text \"     =   \" \"   / >   <   label   >   password :   < /   label   >   <   input   type   =   \" password \"     =   \" password \"   / >   <   input   type   =   \" submit \"     =   \" 提交 \"   / >   < /   form   >   :   password :   还 一个 新 type 类型   password   ， 类似 单行 文本 输入 ， 输入 密码 ， 屏幕 上 显示 。   重置 按钮   < input   type = \" reset \"   = \" 重置 \"   / >   按钮 将会 表单 内容 清空 。   单选 按钮   <   form   action   =   \" http : / / httpbin . org / \"   method   =   \" \"   >   <   label   >   Male   < /   label   >   <   input   type   =   \" radio \"     =   \" Sex \"     =   \" Male \"   checked   =   \" checked \"   / >   <   label   >   Female   < /   label   >   <   input   type   =   \" radio \"     =   \" Sex \"     =   \" Female \"   / >   <   input   type   =   \" submit \"     =   \" 提交 \"   >   < /   form   >   Male   Female   新   checked   ， 默认 单选 按钮 复选 按钮 选中 ， 设置   \" checked \"   默认 选中 。   复选 按钮   <   form   action   =   \" http : / / httpbin . org / \"   method   =   \" \"   >   <   p   >   喜欢 吃 水果 :   < /   p   >   <   label   >   apple   < /   label   > <   input   type   =   \" checkbox \"     =   \" fruits \"     =   \" apple \"   / >   <   label   >   banana   < /   label   > <   input   type   =   \" checkbox \"     =   \" fruits \"     =   \" banana \"   / >   <   label   >   pear   < /   label   > <   input   type   =   \" checkbox \"     =   \" fruits \"     =   \" pear \"   / >   <   input   type   =   \" submit \"     =   \" 提交 \"   / >   < /   form   >   喜欢 吃 水果 :   apple   banana   pear   label 标签   标签 用户 输入框 内容 ， 一个 用途 ， 改进 鼠标 用户 可用性 ， 用户 点击 标签 ， 将会 聚焦 目标 表单 对象 上 ， 只 设置 ：   < label   = \" 控件 id 名称 \" >   < input   id = \" 控件 id 名称 \"   响应 式 布局   提示 ： 推荐 bootstrap 响应 式 设计 ， 内容 有助于 理解 bootstrap 内部 响应 式 布局 。   请 读者 先 阅读   篇文章   。 这篇刚   Ethan   Marccote   给出 例子 有个 信息 ， 设备 像素 分级 :   大于 1300 像素   600 1300 像素   400 600 像素   小于 400 像素   像素 分级 设备 css 设置 提供 参考 。   网页 都 加上 一行 :   < meta   = \" viewport \"   content = \" width = device - width ,   initial - scale = 1 \"   / >   网页 默认 宽度 设备 宽度 ， 原始 缩放 比为 1 。   元素 宽度   width :   xxx   px   写 死 css 设置 ，   %     auto   。 字体 大小 都 推荐   em   大小 。   h1   默认 大小   1.5 em   。   h1   {   font - size :   1.5 em ;   }   small   默认   0.875 em   。   small   {   font - size :   0.875 em ;   }   流动 式 布局 ， 区块 位置 都 浮动 ， 情况 下会   position :   absolute   ， 这会 带来 很多 麻烦 ， 尽量少 。   屏幕 响应 式 多个 css 配置 :   【 css 很多 通用 配置 设备 皆 ， 屏幕 响应 css 放在 css 文件 面 。 】   参看   篇文章   ， 提到 流行   mobile -   设计 思路 ， 有限 照顾 手机 小 屏幕 设备 设计 流程 。 先写 好 通用 css 配置 ， css 文件 面 设置 屏幕 响应 css 设置 。 最小 屏幕 照顾 :   @   media   screen     (   min - width   :   400px   )   { }   @   media   screen     (   min - width   :   600px   )   { }   @   media   screen     (   min - width   :   1000px   )   { }   @   media   screen     (   min - width   :   1400px   )   { }     min - width   指 设备 宽度 至少 大于 值 ，   max - width   指 设置 宽度 小于 值 。 例子 ， 假设 设备 750px ， 第一个 第二个 配置 都 ， css 覆盖 配置 ， 定制 生效 ， 先 调 手机 端的 mobile - 思路 。   图片 ， 设置 宽度 。   img   {   max - width :   100% ; }   - js   class   < html   class = \" - js \"   lang = \" zh \" >   说 class 用来 设置 情况 下 javascript 禁用 css 。",
            "tags":"html5_tutorial",
            "url":"articles/html5-tutorial-html.html"
        },
        {
            "title":"index",
            "text":"  好 ， 再 ， 宇宙 大 爆炸 说起 。   滚蛋 ， 才 不 关心 几十亿年 前 宇宙 爆炸 ， 事情 讲起 。 别提 玄之又玄 哲学 讨论 ， 简直 浪费 时间 。 非得 说点 ， 请 简短 一点 ， 都 ， 道 可道 ， 道 。 好 哲学 道理 言简意赅 ， 最 关键 说 ， 听者 用心 体会 。   恩 ， 道理 。 尽可能 简短 一点 个头 。 这是 一个 无可争辩 事实 ，     。 做 事 ， 外部 言语 。   世间 言语 分为 三类 ：   天言 ， 己言 人言   。 言语 最 次级 ， 内心 智慧 言语 值得 用心 去 倾听 ， 上天 言语 值得 努力 追寻 探求 。   人言 做 参考 ， 世间 人 言 充斥 泛滥 ， 一种 克制 态度 。 才能 更好 聆听 内心 声音 ， 内心 智慧 。 要说 几年 ， 受益匪浅 是从 己言 驱散 内心 孤独 ， 智慧 快乐 。 聆听 好己 言 做 修行 工作 。 经验   冥想 散步 要常 做   。   探求 天言 ， 第一步 更好 做好 己言 聆听 修行 ， 内心 静谧 ， 才 下 一步 聆听 天言 。 王阳明 提出 心 私欲 阻隔 ， 心中 之理 天理 。 表述 不 完备 ， 否定 层面 来说 人 内心 私欲 或者说 动物性 移除 ， 人 内心 声音 己言 不可避免 很大 局限性 ； 肯定 层面 来说   人 身上 神性   。 人子 神性 出发 ， 是从 天人合一 精神 需求 出发 ， 去 如同 上天 （ 造物主 ） 去 创造 。 过程 中人子 聆听 天言 。   二   写作 钻研 一段时间   利用 latex 写作   ， latex 写作 会 强制 文档 结构 层次 更 清晰 。 慢慢 转移 利用   pelican 模块   博客 写作 。   markdown   写作 灵活 轻便 ， 作图 功能 欠佳 ， 都 还好 。 知识 体系 内心世界 体系 架构 都 一个 事 ， 写作 工具 关系 太 大 。 简单 文字 写出 最 优美 小说 世界 ， 关键 取决于 内心 。   三   很多 小说 写作 都 是因为 做 一个 梦 ， 挺 有意思 写 。 写 梦 过程 一个 再 创作 过程 ， 梦 说出 大概 是因为 ， 梦则 说不上来 做 梦 ， 梦 分析 一种 个人感觉 。   安德鲁   不 做 梦 ， 安德鲁 名字 梦 中 得知 。 说 写 ，     ， 阅读 梅勒妮 · 芬 内尔 《 克服 低 自尊 本书 ， 。   克里克   ， 阅读 朱迪亚 · 珀尔 《 一书 ， 只能 说 本书 启发 ， 本书 表述 东西 智能 思考 来说 不 新鲜 ， 三岁 小孩 拥有 智能 胜过 专家教授 表达 智能 ， 更 去 寻问 内心 智慧 。   四   一个 奇怪 情况 ， 排版 pdf 希望 显示 周易 六十四 卦 ䷀ 字符 ， 大概 找 好久 才 发现 DejaVu   Sans 字体 周易 六十四 卦 字符 ， 本来 打算 常规 调 字体 方式 显示 字符 ， 却 发现 效果 ， 估计 区块 字符 划分 CJK 字符 ， xeCJK 宏包 ， 更 详细 讨论 参见   xeCJK 宏包 中 特殊字符 显示   一文 。",
            "tags":"others",
            "url":"articles/index.html"
        },
        {
            "title":"天言，己言和人言",
            "text":"言语 分为 三种 ： 天言 ， 己言 ， 人 言 。   人 言 别人 说 ， 讨论 某种 现象 ， 参考 ， 放在 身上 出错 。 遗憾 日常 接触 最 人 言 ， 人言有 很 多种 表现形式 ， 书籍 音频 视频 图画 ， 别人 头脑 中 世界观 造物 都 称之为 人 言 。 正是 人 言 充斥 世间 ， 芸芸众生 中 愚蠢 乏思之辈 何其 多哉 。   己言 相比 人言 更 值得 重视 ， 是因为 涉及 上 更 情况 ， 还 求人 求己 ， 大 智慧 都 出自 内心 ， 言语 媒介 说 再 好 很 难起 作用 。 更 不用 讲 言语 谬误 频出 ， 出于 私心 私欲 言语 ， 更是 误导 害人不浅 。   再 提醒 一点 ， 世间 出名 看起来 很 厉害 科学家 教授 权威 之流 ， 人工智能 — — 一个 能力 超过 三岁 小孩 人工智能 ， 说不出 所以然 。 在座 年龄 超过 三岁 ， 内心 智慧 ， 远远 高过 科学家 教授 之流 言语 中 智慧 。   个体 人 知识 能力 局限性 ， 己言 带有 很大 局限性 ； 唯有 天言 ， 无所不知 上天 言语 ， 值得 去 努力 聆听 遵从 。",
            "tags":"thought",
            "url":"articles/tian-yan-ji-yan-he-ren-yan.html"
        },
        {
            "title":"周易预测学相关应该如何处理闰月",
            "text":"皇极 经世 紫微斗数 ， 周易 预测 相关 ， 月份 划分 都 规则 ：   一年 定义 农历 立春到 下 立春   一年 分为 十二个 月 ， 计算 只能 说 大部分 情况 下 农历 重合 ， 近似 看 农历 ， 意义 来说 ， 一年 分为 十二个 月 划分 。   也就是说 紫微斗数 农历 一种 近似 表达 ， 盲信 农历 月份 会 闰月 手足无措 ， 具体来说 闰月 年份 ， 讲 农历 立春到 立春 天数 除以 十二 ， 再 十二个 月 划分 刻度 。   举个 例子 2020 年 2 月 4 日 立春 ， 春节 1 月 25 日 ， 春节 不相干 。 2021 年 2 月 3 日 下 立春 。 距离 365 天 ， 一月 三十 十二分 五天 。   import   time     datetime   import   datetime     dateutil . relativedelta   import   relativedelta     dateutil . rrule   import   rrule   ,   MONTHLY   dt1   =   datetime   (   2020   ,   2   ,   4   )     i     range   (   12   ) :   dt1   + =   relativedelta   (   days   =   30.4167   )   print   (   dt1   )   2020 - 02 - 04   00 : 00 : 00   第一 月   2020 - 03 - 05   10 : 00 : 02.880000   第二 月   2020 - 04 - 04   20 : 00 : 05.760000   第三 月   2020 - 05 - 05   06 : 00 : 08.640000   第四 月   2020 - 06 - 04   16 : 00 : 11.520000   第五 月   2020 - 07 - 05   02 : 00 : 14.400000   第六 月   2020 - 08 - 04   12 : 00 : 17.280000   第七 月   2020 - 09 - 03   22 : 00 : 20.160000   第八 月   2020 - 10 - 04   08 : 00 : 23.040000   第九 月   2020 - 11 - 03   18 : 00 : 25.920000   十月   2020 - 12 - 04   04 : 00 : 28.800000   第十一 月   2021 - 01 - 03   14 : 00 : 31.680000   十二月   2021 - 02 - 03   00 : 00 : 34.560000   下 一年",
            "tags":"others",
            "url":"articles/zhou-yi-yu-ce-xue-xiang-guan-ying-gai-ru-he-chu-li-run-yue.html"
        },
        {
            "title":"皇极经世小程序",
            "text":"皇极 经世 小 程序   请 输入 想要 预测 年份 ：   year :   确认   信息   周易 相关 资料 整理 批判 思考 汇集 成一 本书 ， 查阅 参考 。   项目 Github     。",
            "tags":"tools",
            "url":"articles/huang-ji-jing-shi.html"
        },
        {
            "title":"javascript语言学习教程一基础篇",
            "text":"注释   多行 注释 推荐 写法 ：   / * *   *   make ( )   returns   a     element   *   based       passed -   tag     * /   单行 注释   / /   ， 注释 都 新起 一行 写 ， 代码 块 内 注释 ， 空 一行 ：   / /   This     a   comment       computer     ignore .   function   getType   ( )   {   console   .   log   (   ' fetching   type ... '   ) ;   / /   set     default   type     '   type '   const   type   =     .   type   | |   '   type '   ;   return   type   ;   }   注释 文字 具体内容 注释 符号 空一 空格 。   javascript 代码 放在   javascript 代码 推荐 放在 HTML 文档 面 ，   < / body >   标签 ， 浏览器 更快 加载 页面 。 倒 特别 ， 刚 简单 javascript 代码 写上去 :   <   script   >     awesome   javascript   code   < /   script   >   javascript 代码 量 一点 推荐 单独 放在 一个 js 文件 上 ， 引入 进来 :   <   script   src   =   \" \"   > < /   script   >   程序 中 操作 对象   简介   javascirpt 数据类型 分为 两类 ， 一类 原始 类型 ： 数值 、 字符串 布尔值 ； 另一类 对象 类型 。 javascript 两个 值 ：   null     undefined   。 javascript 数值 、 字符串 、 布尔值 、 null 、 undefined 之外 都 对象 。 提到 数组 ， 函数 都 对象 ， 只不过 其是 javascipt 内部 定义 对象 。   声明 常量 变量   javascript 利用 关键词   var   ，   const       声明 变量 ， const 声明 常量 ， var 声明 变量 ， var 声明 变量 javascript 中 常用 声明 变量 关键词 。 声明 变量 作用域 很 不同于 编程语言 ，   函数 作用域   。 函数 区块 内 声明 变量 函数 体都 ， 包括 花 括号 结构 任意 嵌套 函数 。 程序员 变量 作用域 习惯 块 作用域 ， airbnb 提出 不 推荐   var   ， 推荐     ，   const       都 块 作用域 （ block - scoped ） 。 我持 保留意见 ， javascript 本身 一个 很 宽松 语言 ， 遵从 程序员 习以为常 惯例 ， 当作 教条 大可不必 。   全局变量   网页 中有 全局 对象   window   ， 全局变量 挂   window   对象 。   数值 ( number )   javascript 不 区分 整数 值 浮点 数值   ， javascript 中 数字 都 浮点 数值 ， 这是 javascript 编程语言 很大 。 数值 型 运算 ， 加减乘除 不用 说 。   %   python 求余 操作 。 python3 中有   5 / / 2   求商 概念 ， javascript 概念 ， 类似 效果 。   console . log ( parseInt ( 5 / 2 ) )   parseInt ( )   字符串 转 成 整数型 ， 返回 NaN 。   parseInt   (   ' 123 '   ,   10   ) ;   / /   123   parseInt   (   ' 11 '   ,   2   ) ;   / /   3   parseFloat ( )   字符串 转 成 浮点 型 ， 返回 NaN 。   parseFloat   (   ' 3.14 '   )   3.14   NaN number 型 ， 判断 是否是 NaN ， airbnb 推荐 风格 ：   Number   .   isNaN   (   ' a '   )   false   Number   .   isNaN   (   1   )   false   Number   .   isNaN   (   NaN   )   true   字符串 ( string )   javascript python 单引号 双引号 都 ， airbnb 规范 推荐   单引号   。   const     =   ' Capt .   Janeway '   ;     +   简单 字符串 拼接 工作 ， aribnb 规范 提出 字符串 程序性 拼接 推荐 模块 语言 ，   $ { variable }   ， 很 好 （   `   符号 ） 。   ` How     ,   $ {     }   `   javascript 字符串 类型 python 类似 ，   string [ 0 ]   支持 。 不 string [ 0 : 2 ] ， 幸运 javascript 提供 类似 python 中 那种 切片 概念 ，   slice   方法   console . log ( \" \" . slice ( 0 , 2 ) )   console . log ( [ 1 , 3 , 4 , 5 ] . slice ( 0 , 2 ) )   javascript slice 方法 python 切片 操作 区别 ，   ( start , end )   两个 参数 ， 负数 末尾 算起 概念 ， 倒 ， 都 从左到右 那种 顺序 。 请 参看     。   字符串 方法   length :   字符串 长度   toUpperCase :   大写   toLowerCase :   小写   indexOf :   返回 子 字符串 索引 位置 ， index 索引 编号 规则 python 。   substring :   返回 子 字符串 ， 熟悉 python 那种 切片 规则 ， 推荐   slice   方法 。   replace :   替换 操作   split :   分割 操作   toString 方法   javascript 数值 、 布尔值 、 对象 字符串 都 一个   toString   方法 ， 大体 类似 python   str   函数 。 定义 对象 加上   toString   方法 ：   class   Jedi   {   constructor   (   options   =   { } )   {     .     =   options   .     | |   '   '   ;   }   getName   ( )   {   return     .     ;   }   toString   ( )   {   return   ` Jedi   -   $ {     .   getName   ( )   }   `   ;   }   }   布尔值 ( boolean )   javascript 布尔值   true     false   。 判断 操作 时 ， 希望 值 ， 类似 python 判断   = =   符号 ， javascript 中   = = =   。 三个 号 ， 别出心裁 ， 好处 ， javascript 历史 遗留问题 。   = = =   Equal     ! = =   Not   equal     boolean 值 判断 遵循 规则 ：   false   0   空 字符串   \" \"   NaN   null   undefined   都 视作 false   都 视作 true   Boolean   ( { } )   true   null   javascript   null   。 其是 一个 值 。 类似 python   None   ， 一个   undefined   。 函数 return 值 会 默认 返回   undefined   ， 感兴趣 查 两个 区别 ， 看 ， 挺 无聊 。 谈到   = =     = = =   区别 ，   = = =   ，   undefined   不 等于   null   ，   = =   ， javascript 会 额外 做 类型转换 工作 ， 两个 会 看作 。   ECMA - 262   ：   null   = =   undefined ;   - >   return   true   airbnb 推荐 风格 ， 操作 一律 推荐   = = =     ! = =   ，   = =     ! =   。   typeof 操作符   查看 对象 对象 类型 ， typeof 操作符 只 返回 六种 ， 比如说 提到 数组 object ； null object 。   number   string   object   function   array   date   regexp   boolean   null   undefined   symbol   (     es6 )   typeof   x   \" undefined \"   typeof   1   \" number \"   数组   javascript 数组 （ array ） 数据结构 概念 上 大体 类似 python 列表 。   构建 一个 数组   var   array1   =   [ ] ;   var   array2   =     Array   ( ) ;   const   items   =   [   1   ,   2   ,   3.14   ,   ' Hello '   ,   null   ,   true   ] ;   索引 index 编号 法则 python 。   数组 方法   length :   数组 长度   indexOf :   返回 数组 子 元素 索引 位置   slice :   切片 操作 ， 类似 python   lst [ 0 : 2 ]   那种 表达方法 。 slice 方法 不 接受 参数 默认 返回 列表 引用 ， 所说   浅 拷贝   。 浅 拷贝 简单 来说 复制 一个 字典 数组 （ 对象 ） ， 第一层 key 赋值 第一层 ， 第一层 key 一个 对象 引用 ， 拷贝 前 对象 拷贝 后 对象 都 会 指向 统一 对象 ， 深 拷贝 进一步 递归 拷贝 。   push :   末尾 添加 一个 元素   pop :   一个 元素 删除   unshift :   数组 头部 添加 一个 多个 元素 ， 返回 新 数组 长度   shift :   数组 头部 删除 一个 元素   sort :   排序 ， 破坏型 。 值得一提的是 数字 排序 从大到 小 顺序 ， 不太 :   >   var   lst   =   [ 1 , 5 , 2 , 3 , 51 , 4 , 45 , 545 , 541 , 48 , 77 ]   >   undefined   >   lst . sort ( )   >   [   1 ,   >   2 ,   >   3 ,   >   4 ,   >   45 ,   >   48 ,   >   5 ,   >   51 ,   >   541 ,   >   545 ,   >   77   ]   python 中 最 说 字符串 ， number 类型 。 排序 ， 操作 （ 参看   网页   ） :   var   lst   =   [   1   ,   5   ,   2   ,   3   ,   51   ,   4   ,   45   ,   545   ,   541   ,   48   ,   77   ]   function   sortNumber   (   a   ,   b   ) {   return   a   -   b   }   lst   .   sort   (   sortNumber   )   alert   (   lst   )   sort 方法 接受 一个 函数参数 ， 函数 接受 两个 参量 ， 用来 判断 a b 值 大小 ， 返回值 小于 0 ， a 放在 。 返回值 大于 0 ， a 放在 。 排序 方法 支持 数字 字符串 情况 。 javascript   字符串   -   字符串   情况 会 尝试 做 转换成 number 类型 才 做 。   reverse :   反转 ， 破坏型 。   splice :   指定 索引 删除 元素 ， 此处 添加 元素 ， 相当于 update 更新 。   >   var   arr   =   [   ' Microsoft '   ,   ' Apple '   ,   ' Yahoo '   ,   ' AOL '   ,   ' Excite '   ,   ' Oracle '   ] ;   >   undefined   >   arr   .   splice   (   2   ,   3   ,   ' Google '   ,   ' Facebook '   ) ;   >   [   \" Yahoo \"   ,   \" AOL \"   ,   \" Excite \"   ]   >   arr   >   [   \" Microsoft \"   ,   \" Apple \"   ,   \" Google \"   ,   \" Facebook \"   ,   \" Oracle \"   ]   参数 是从 索引 2 删除 3 元素 ， 添加 元素 。 例子 splice 方法 破坏型 方法 ， 返回 删除 元素 。   splice 方法 用于 只 删除 不 添加 纯 删除 操作 ， 只 添加 不 删除 纯 添加 操作 。   / /   只 删除 , 不 添加 :   arr . splice ( 2 ,   2 ) ;   / /   只 添加 , 不 删除 :   arr . splice ( 2 ,   0 ,   ' Google ' ,   ' Facebook ' ) ;   concat :   连接 两个 数组 ， 非 破坏型 。   >   var   lst1   =   [ 1 , 2 , 3 ]   >   undefined   >   var   lst2   =   [ ' a ' , ' b ' , ' c ' ]   >   undefined   >   lst1 . concat ( lst2 )   >   [ 1 ,   2 ,   3 ,   \" a \" ,   \" b \" ,   \" c \" ]   join :   类似 python 字符串 join 方法 ， 所示 :   var   arr   =   [ ' A ' ,   ' B ' ,   ' C ' ,   1 ,   2 ,   3 ] ;   arr . join ( ' - ' ) ;   / /   ' A - B - C - 1 - 2 - 3 '   fill :   数组 值来 填充   两个 数组   参考   网页   。   function   arraysEqual   (   a   ,   b   )   {     (   a   = = =   b   )   return   true   ;     (   a   = =   null   | |   b   = =   null   )   return   false   ;     (   a   .   length   ! =   b   .   length   )   return   false   ;   / /   If     don ' t   care       order       elements   inside   / /     array ,       sort     arrays   .     (   var   i   =   0   ;   i   <   a   .   length   ;   ++   i   )   {     (   a   [   i   ]   ! = =   b   [   i   ] )   return   false   ;   }   return   true   ;   }   遍历 数组     (         array   )   {   / /           }   遍历 数组 还 ：   >   a   =   [   ' a '   ,   ' b '   ,   ' c '   ]   <   a   .   forEach   (   function   (     ,   index   ) {   console   .   log   (     ,   index   ) ;   } ) ;   >   a   0   >   b   1   >   c   2   大体 类似 python   enumerate   写法 。   判断 元素 数组 中   [ ' a ' , ' b ' ] . indexOf ( ' a ' )   返回   - 1   元素 不 数组 中 ， 数组 中 。   function   _ _ array   (   array   ,   element   ) {     (   array   .   indexOf   (   element   )   = = =   -   1   ) {   return   false   }     {   return   true   }   }   object   javascript object 大体 看作 python 中 字典 类型 。   创建 空 object 推荐 写法 ：   const   item   =   { } ;   ：   const   person   =   {     :   ' Bob '   ,   age   :   20   ,   tags   :   [   ' js '   ,   ' web '   ,   ' mobile '   ] ,   city   :   ' Beijing '   ,   zipcode   :   null   } ;   aribnb 提出 属性 名 写 上 ， 包括 函数 ：   const   lukeSkywalker   =   ' Luke   Skywalker '   ;   const   obj   =   {   lukeSkywalker   ,   } ;   函数 先 function 声明 ， 写进去 ：   const   atom   =   {     :   1   ,   addValue   (     )   {   return   atom   .     +     ;   } ,   } ;   属性 名 javascript 非法 ， 只好 单引号 包围起来 。   动态 生成 对象 属性 名   const   obj   =   {   id   :   5   ,     :   ' San   Francisco '   ,   [   getKey   (   ' enabled '   ) ]   :   true   ,   } ;   语句   ' '     xiaoming   ;   >   var   d   =   { }   undefined   >   d   [   ' a '   ]   =   1   1   >   d   Object   {   a   :   1   }   >   ' a '     d   true   >   1     [   1   ,   2   ,   3   ]   true   delete 语句   python del 语句 。 javascript   delete   语句 删除 不 键 报错 。   >   d   Object   {   a   :   1   }   >   delete   (   d   .   b   )   true   >   d   Object   {   a   :   1   }   >   delete   (   d   .   a   )   true   >   d   Object   { }   hasOwnProperty 方法   python2 _ key 方法 ， python2 移 ， 推荐 语句 。   d   =   {   ' a '   :   1   }   d   .   hasOwnProperty   (   ' a '   )   true   aribnb 提出 相关 建议 ， 我持 保留意见 ， python 出身 ， 更 喜欢 语句 。   / /   good   console   .   log   (   Object   .   prototype   .   hasOwnProperty   .   call   (   object   ,   key   ) ) ;   shallow   copy   const   original   =   {   a   :   1   ,   b   :   2   } ;   const   copy   =   {   ...   original   ,   c   :   3   } ;   / /   copy   = >   {   a :   1 ,   b :   2 ,   c :   3   }   函数   一个 简单 函数 定义 所示 （ 写法 airbnb 规范 推荐 风格 ） :     greeting   =   function   (     ) {   console   .   log   (     ) ;   }   greeting   (   ' '   )   javascript 函数 名 一个 变量 ， 这是 唯一 值得注意 ， 采用 写法 ， 熟悉 :   function   abs   (   x   ) {     (   x   > =   0   )   {   return   x   ;   }     {   return   -   x   ;   }   }   两种 定义 风格 等价 。 值得一提的是 函数 return 值 ， 返回   undefined   。   arguments 用法   javascript 函数 内部   arguments   变量 ， 一个 Array ， :   arguments [ 0 ]   arguments . length   其会 接受 传入 函数 参量 。   rest 用法   类似 lisp 语言 rest 参量 控制 概念 ，   function   func   (   a   ,   b   , ...   rest   ) {   console   .   log   (   rest   ) ;   }   rest a b 之外 参量 。 三个 点 号 :   ... rest   。   箭头 函数   简单 来说 箭头 函数   lambda   表达式 更 简洁 写法 ， 说 javascript 语境 区别 function ：   绑定   。   (   param1   ,   param2   ,   …   ,   paramN   )   = >   {   statements   }   逻辑   条件 判断 结构   条件 判断 结构 ， python 大同小异 ， 圆括号 （ 记住 圆括号 加上 ） 花 括号 。   var   feedback   =   10     (   feedback   >   8   )   {   console   .   log   (   \" Thank   !   We     race         concert ! \"   )   }     {   console   .   log   (   \" I ' ll     practicing   coding     racing . \"   )   }   javascript 不像 python 强制 缩进 风格 ， 推荐 用缩 进来 增强 代码 可读性 逻辑 清晰性 ， :   age   =   20     (   age   <   6   )   {   console   .   log   (   ' kid '   )   }       (   age   > =   18   )   {   console   .   log   (   ' adult '   )   }     {   console   .   log   (   ' teenager '   )   }   javascript switch 语句 ， pythoner 懂 ， 多个   语句 。   循环   javascript python 都 语句 ， 语句 少 ， 更 语句 。   var   count   =   10   ;     (   var   i   =   0   ;   i   <   count   ;   i   ++   ) {   console   .   log   (   i   ) ;   }   遍历 数组     (         array   )   {   / /           }   遍历 数组 还 ：   >   a   =   [   ' a '   ,   ' b '   ,   ' c '   ]   <   a   .   forEach   (   function   (     ,   index   ) {   console   .   log   (     ,   index   ) ;   } ) ;   >   a   0   >   b   1   >   c   2   大体 类似 python   enumerate   写法 。   遍历 对象   递归 遍历 对象 key :     (   var   i     {   ' a '   :   1   ,   ' b '   :   2   } )   {   console   .   log   (   i   )   }   循环   语句 循环 ：   var   count   =   10   ;   var   i   =   0   ;     ( ;   i   <   count   ;   ) {   console   .   log   (   i   ) ;   i   ++   ;   }   无限 循环   语句 无限 循环 ：     ( ; ; ) {   dosomething ;   }   语句   语句 简单 下 。   var   x   =   0   ;   var   n   =   99   ;     (   n   >   0   )   {   x   =   x   +   n   ;   n   =   n   -   2   ;   }       语句   var   n   =   0   ;     {   n   =   n   +   1   ;   }     (   n   <   100   ) ;   异常   类似 python   ... ...   ， javascript ：     {   throw   （   Error ( \" Invalid   Parameters \" ) ) ;   } catch   ( e )   {   console . log ( e ) ;   } finally   {   / /     .   }   关键词   类似 python 中 ， javascript ， object 定义 方法 ，     指向 对象 实例 。   面向对象 传统 写法   function   Point   (   x   ,   y   )   {     .   x   =   x   ;     .   y   =   y   ;   }   Point   .   prototype   .   toString   =   function   ( )   {   return   ' ( '   +     .   x   +   ' ,   '   +     .   y   +   ' ) '   ;   } ;   var   p   =     Point   (   1   ,   2   ) ;   新式 写法   / / 定义 类   class   Point   {   constructor   (   x   ,   y   )   {     .   x   =   x   ;     .   y   =   y   ;   }   toString   ( )   {   return   ' ( '   +     .   x   +   ' ,   '   +     .   y   +   ' ) '   ;   }   }       函数 ， ：   function   ( ) {   . x   =   1 ;   }   指定 函数 运行 ， 调用 函数 对象 。   比如说 函数 调用 ：   jquery 对象 .   函数 指定 jquery 实例 ， 网页 标签 元素 。   集合   javascript 中 集合 Set 大体 python 中 集合 概念 相近 。   var   s1   =     Set ( ) ;   / /   空 Set   var   s2   =     Set ( [ 1 ,   2 ,   3 ] ) ;   / /   含 1 ,   2 ,   3     add   方法 用于 添加 一个 元素 。   delete   方法 删除 元素 。   三元 运算符   test     expression1   :   expression2",
            "tags":"javascript",
            "url":"articles/javascriptyu-yan-xue-xi-jiao-cheng-yi-ji-chu-pian.html"
        },
        {
            "title":"python语言学习教程一基础篇",
            "text":"初识 python   Python 成功 脚本语言 。 最初 Guido   van   Rossum 开发 ， 1991 年 第一次 发布 。 Python ABC Haskell 语言所 启发 。 Python 一个 高级 、 通用 、 跨平台 、 解释 型 语言 。 人 更 倾向 称之为 动态 语言 。 很 易学 ， Python 一种 简约 语言 。 最 一个 特征 ， 不 分号 括号 ， Python 缩进 。 ， Python 来自 世界各地 庞大 志愿者 维护 。   python 两个 版本 区别 ， python2 python3 。 新 学者 推荐 python3 编程 ， 文档 基于 python3 。   安装 配置   python 安装 配置 linux 没什么 好 说 ， windows 下 安装 编辑 好 系统 环境变量   PATH   值 ， 好 读者 cmd powershell 下 调用 python 命令 。   初次 安装 程序 选项 。   python REPL 环境   终端 中 输入 python python 语言 REPL 环境 ， 很多 linux 系统 默认 python2 。 运行 ：   python   - - version   查看 默认 python 版本号 。   python3 终端 中 输入 python3 即可 。   python 命令行 用法   命令行 格式 ：   python3   [ 可选项 ]   test . py   [ 选 参数 1   选 参数 2 ]   类似 运行   python3   - -   查看 python3 命令 可选项 。   - i   选项 ， python 执行 完 脚本 会 REPL 环境 等待 下 一个 命令 ， 一闪而过 有用 。   python 执行 脚本 参数 传递   命令行 接受 多个 参数 都 ， 报错 ， py 文件 用到 。 py 文件 中要 ， 导入 sys 模块 ， sys . argv [ 0 ] py 文件 系统 中 文件名 ， 接下来 sys . argv [ 1 ] 命令行 接受 第一个 参数 ， 依次 类推 。   代码 注释   python 语言 注释 符号 bash 语言 （ linux 终端 编程语言 ） # 符号 注释 代码 。 py 文件 开头 代码 所示 ：   1   2   # ! / usr / bin / env   python3   # - * - coding : utf - 8 - * -   代码 第一行 下 py 文件 执行 模式 执行 python3 编译   1   ， 第二行 py 文件 编码 utf - 8 编码 ， python3 支持 utf - 8 符号 ， 很 强大 一个 更新 。   多行 注释 利用 编辑器 快速 每行 加上 # 符号 。   Unicode 码 支持   谈及 python3 支持 Unicode 码 ， 执行 模式 加载 ， 第二行 写 上 ：   # - * - coding : utf - 8 - * -   一句 。   读者 请 实验 小 例子 ， 打印 一个 笑脸 符号 ：   1   2   3   4   5   6   # ! / usr / bin / env   python3   # - * - coding : utf - 8 - * -   print   (   '   \\ u263a   '   )   ☺   > > >   数字 笑脸 符号 Unicode 码 （ 十六进制 ） 。   代码 多行 一行   技巧 代码 越界 会 用到 。 反 斜线   \\   即可 。 更 常用 表达式 圆括号   ( )   括 ， 内部 换行 。 python 中 表达式 都 包围 圆括号 中 。   一行 多行   python 中 不用 分 号 ， 分号 意义 大致 bash c 语言 中 意义 类似 ， 一行 结束 。 c 语言 分号 。   输入 输出   最 input print 命令   input 函数 请求 用户 输入 ， 值 赋值 变量 。 赋值 类型 字符串 ， 强制 类型转换 — — int 函数 （ 整数 ） ， float 函数 （ 实数 ） ， str 函数 （ 字符串 ） — — 。 print 函数 输出 函数 。   读者 请 运行 例子 ：   x = input ( ' 请 输入 一个 实数 ： ' )   string = ' 输入 实数 乘以 2 等于 ： ' +   str ( float ( x ) * 2 )   print ( string )   __ main __ __ __     网站   讲解 ， py 文件 执行 ，   __ __   py 文件 中 值   __ main __   ， py 文件 模块 引入 ，   __ __   py 文件 中 值 py 文件 模块 模块 名 。   比如说 随便 新建 一个 test . py 文件 ， py 文件 简单 打印   __ __   值 ， 再 打开 终端 ， 运行 ：   python3   test . py   打印 ：   __ main __   。 python REPL 环境 ， 再 输入 ：   import   test   会 发现   __ __   值 字符   \" test \" 。   mymodule 模块 里 mymod . py 文件 （ 新建 一个 mymodule 文件夹 ， 再 新建 一个 mymod . py 文件 。 ） ， mymod . py 文件   __ __   值   \" mymodule . mymod \" 。   安装 python 高级 知识   源码 安装 python   源码 安装 python ， 依赖 预先 安装 。   zlib     zlib - devel   opensll     openssl - devel   ，   ssl . h   文件 找 不到 缺少 。   sqlite - devel     import   sqlite3   ， 将会 提示 找 不到   _ sqlite3   ， 编译 python 。   windows 下 pip   windows 下 pip 安装 ， wheel 包 ， 装上 ， 简单 安装 源码 即可 ， 调用 cython 编译 过程 确保 python 装上   V C++     python   ， 官网 下载 地址     。   额外 提 一点   Visual   C++   Compiler     Python   2.7     math   rint   方法 ， linux 下 稍微 差异 。   程序 中 操作 对象   python c 语言 ， c     int   x   =   3   ， 变量 整数 ， 字符 都 指定 ， python 不 做 ， 只 声明   x   ＝   3   即可 。 程序语言 一个 变量 （ 包括 结构 对象 ） 内存 分配 ， python 语言 帮 工作 做 ， 就让 省下 这份 心 。   ' ' '   这是 一个 多行 注释   写 上 很多 废话   ' ' '   x   =   10   print ( x , type ( x ) )   python 程序 模块 （ modules ） ， 模块 文件 。 模块 声明 （ statements ） ， 声明 表达式 （ expressions ） ， 表达式 负责 创造 操作 对象 （ objects ） 。 python 中 皆 对象 。 python 语言 内置 对象 （ 数值 、 字符串 、 列表 、 数组 、 字典 、 文件 、 集合 、 内置 对象 。 ） 会 详细 。   赋值   python 中 赋值 语法 简单 ， x = 1 ， 一个 赋值 语句 。 c 语言 ， c 先 声明 int   x ， 开辟 一个 内存空间 ， 才能 x 赋值 。 python x = 1 语句 实际上 至少 三个 工作 ： ， 判断 1 类型 （ 动态 类型 语言 这步 ） ； 二 ， 类型 对象 存储 内存 ； 三 ， 创建 x 名字 名字 指向 内存 ， x 称之为 c 语言 指针 对象 。   序列 赋值   x , y = 1 , ' a '   [ z , w ] = [ ' b ' , 10 ]   print ( x , y , z , w )   1   a   b   10   > > >   记得 python 中 表达式 加上 圆括号 ，   x , y   一个 数组   ( x , y )   ， 数组 平行 赋值 ， 第二行 列表 平行 赋值 。 这是 一个 很 有用 技巧 。   语言 会 介绍 swap 函数 ， 接受 两个 参数 两个 参数 值 交换 ， 交换 过程 用到 临时 变量 。 python 中 不 再 创建 一个 临时 变量 ， 序列 赋值 会 自动 生成 一个 临时 右边 序列 （ 变量 都 原始 值 ） ， 再 赋值 （ 一一对应 指 两边 序列 长度 。 ）   交换 两个 元素   python 中 交换 两个 元素 序列 赋值 形式 很 便捷 ：   > > >   x   =   1   > > >   y   =   2   > > >   x , y   =   y , x   > > >   print ( x , y )   2   1   过程 先 执行 x = y 执行 y = x ， ， 程序 右边 创建 一个 临时 序列 ， 变量 都 值 ，   x , y = ( 2 , 1 )   ， 再 序列 赋值 。   赋 值   x = y = ' a '   z = w = 2   print ( x , y , z , w )   a   a   2   2   > > >   语句 形式 c 语言 ， 内部 机制 不 。 python 声明 x = y ， x y 指针 值 ， 指针 值 都 指向 ' a ' 字符串 对象 ， 说 x y 一个 东西 ， 取 名字 。   语句   2   测试 ， 显示 x y 一个 东西 。   > > >   x = y = ' a '   > > >   x     y   True   > > >   x   = =   y   True   写成 形式 ：   > > >   x   =   ' a '   > > >   y   =   ' a '   > > >   x     y   True   x y 指向 同一个 对象 ， python 内部 还 不 太 （ 神奇 ） 。 语句 功能 再 举个 例子 ：   > > >   x   =   [ 1 , 2 , 3 ]   > > >   y   =   [ 1 , 2 , 3 ]   > > >   x   = =   y   True   > > >   x     y   False   两个 列表 对象 。   增强 赋值 语句   x = x + y 写作 x   + =   y 。 类似 ：   + =   & =   > > =   - =   | =   < < =   * =   &# 94 ; =   * * =   / =   % =   / / =   迭代 对象 迭代 赋值   python 语言 ， 发现 python 中 迭代 思想 深入骨髓 。 接触 序列 赋值 模式 ， 发现 赋值 临时 创建 右边 序列 之外 ， 还 迭代 操作 ， 推测 python 平行 赋值 模式 扩展 迭代 对象 ， 发现 确实 ！   > > >   x , y , z =   map ( lambda   x   :   x + 2 , [ - 1 , 0 , 1 ] )   > > >   print ( x , y , z )   1   2   3   一点 确保 左边 变量 数目 迭代 对象 输出 元素 数目 ， 进一步 扩展 序列 解包 赋值 支持 ：   > > >   x , y , * z =   map ( lambda   x   :   x + 2 , [ - 1 , 0 , 1 , 2 ] )   > > >   print ( x , y , z )   1   2   [ 3 ,   4 ]   通配 赋值 ， 喜欢 称呼 ， 通配 收集 元素 列表 ； 函数参数 通配 传递 ， 收集 元素 元组 。   ， 迭代 对象 赋值 迭代 操作 加上 元素 一对一 赋值 操作 。   数值   python 数值 内置 类型 ： int ， float ， complex   3   。 python 算术 运算 操作 加减乘除 （ +   -   *   / ） 。   =   赋值 ， 类似 数学 书上 中缀 表达式 优先级 括号 法则 ， 都 编程语言 说 烂 东西 。   print ( ( 1 + 2 ) * ( 10 - 5 ) / 2 )   print ( 2 * * 100 )   二进制 八进制 十六进制   二进制 数字 0b （ 零比 ） 开头 ， 八进制 数字 0o （ 零 ） 开头 ， 十六进制 数字 0x （ 零 艾克斯 ） 开头 。   0b101010 ,   0o177 ,   0x9ff   二进制 格式 查看 数字 bin 命令 ， 十六进制 查看 数字 hex 命令 。   > > >   bin ( 42 )   ' 0b101010 '   > > >   hex ( 42 )   ' 0x2a '   进制 转换 小 程序   number = input ( \" 请 输入 一个 数字 ： \" )   number =   eval ( number )   #   radix =   input ( ' ' ' 请 输入 想 转换 进制 系统   2     二进制   8     八进制   16     十六进制   ' ' ' )   radix   = eval ( radix )     True :     radix   = =   2 :   print ( bin ( number ) )   break   elif   radix   = =   8 :   print ( oct ( number ) )   break   elif   radix   = =   16 :   print ( hex ( number ) )   break   :   print ( \"     input     wrong   radix \" )   程序运行 情况 所示 ：   请 输入 一个 数字 ： 20   请 输入 想 转换 进制 系统   2     二进制   8     八进制   16     十六进制   8   0o24   基于 字符串 进制 转换 字符串 format 方法 。   数学 幂方 运算   \\ ( x &# 94 ; y \\ )   ， x y 次方 第二行 所述   x * * y   形式 即可 。 pow 函数 作用 ，   pow ( x , y )   。   数值   数值 提及   > ， < ， = = 之外 ， > = ， < = ， ! = （ 大于 等于 ， 小于 等于 ， 不 等于 ） 。 python 还 支持 连续 ， 数学 格式   \\ ( a < x < b \\ )   ， x 区间   \\ ( ( a , b ) \\ )   判断 。 python 中 写成 形式 ：   a < x < b   。 过程 两个 操作 进一步 操作 。   相除 取商 余   正整数 相除   x / / y   值 意义 很   商   。 带上 负号 感觉 怪 ， 先 略过 。 相关   取余   数 ，   x% y   ， x 除以 y 余数 ， 带上 负号 情况有变 ， 先 略过 。   复数   python 支持 复数 ， 复数 写法 类似   1 + 2j   形式 ， z 赋值 一个 复数 ， 一个 复数 类型 ， 类 两个 属性 量 ，   real     imag   。   z . real   给出 复数 实数 部 。 imag imaginary   number 缩写 ， 虚数 ， 想像出来 数 。   abs 函数   都 abs 函数 绝对值 函数 ， python 自带 ， 不 加载 模块 。 作用 复数 ：   z = 3 + 4j   print ( z . real , z . imag )   print ( abs ( z ) )   数学 中 复数 绝对值 定义 完全一致 ， 复数的模 ：   \\ ( \\ left |   z   \\ |   = \\ sqrt   {   a &# 94 ; {   2   } + b &# 94 ; {   2   }   } \\ )   round 函数   简单 理解 函数 数值 功能 。   > > >   round ( 3.1415926 )   3   > > >   round ( 3.1415926 , 0 )   3.0   > > >   round ( 3.1415926 , 1 )   3.1   > > >   round ( 3.1415926 , 2 )   3.14   > > >   round ( 3.1415926 , 4 )   3.1416   第二个 参数 接受 0 负数 没 意义 ， 取 1 大于 1 数 ， 保留 几位 小数 。   min ， max sum 函数   min ， max 函数 用法 sum 用法 稍微 差异 ， 简单 见 min ， max ， sum 都 接受 一个 元组 列表 （ ？ ） ， 返回 元组 列表 最小值 ， 最大值 相加 总和 。 min max 还 支持 min ( 1 , 2 , 3 ) 形式 ， sum 不 支持 。   > > >   min ( ( 1 , 6 , 8 , 3 , 4 ) )   1   > > >   max ( [ 1 , 6 , 8 , 3 , 4 ] )   8   > > >   sum ( [ 1 , 6 , 8 , 3 , 4 ] )   22   > > >   min ( 1 , 6 , 8 , 3 , 4 )   1   位操作   python 支持 位操作 ， 简单 说 ： 位 左移 操作 \\ < \\ < ， 位 操作 & ， 位 操作 | ， 位 异或 操作 \\ &# 94 ; 。   > > >   x = 0b0001   > > >   bin ( x   < <   2 )   ' 0b100 '   > > >   bin ( x   |   0b010 )   ' 0b11 '   > > >   bin ( x   &   0b1 )   ' 0b1 '   > > >   bin ( x   &# 94 ;   0b101 )   ' 0b100 '   math 模块       math   import   *   ， 符号 pi e 引用 圆周率 自然 常数 。 math 模块 还 提供 很多 数学 函数 ， ：   sqrt   开 平方根 函数 ， sqrt ( x ) 。   sin   正弦 函数 ， 类似 cos ， tan ， sin ( x ) 。   degrees   弧度 转化 角度 ， 三角函数 默认 输入 弧度 值 。   radians   角度 转化 位 弧度 ， radians ( 30 ) 。   log   开 对数 ， log ( x , y ) ，   \\ ( \\ log _ y   x \\ )   ， y 默认 e 。   exp   指数函数 ， exp ( x ) 。   pow   扩展 内置 方法 ， 支持 float 。 pow ( x , y )   简单 写个 例子 ：   > > >     math   import   *   > > >   print ( pi )   3.141592653589793   > > >   print ( sqrt ( 85 ) )   9.219544457292887   > > >   print ( round ( sin ( radians ( 30 ) ) , 1 ) ) # sin ( 30 ° )   0.5   更 内容 请 参见   官方 文档   。   random 模块   random 模块 提供 函数 解决 随机数 。   random   random 函数 0 1 之间 随机 实数 （ 包括 0 ） 。   ​   random ( ) - > [ 0.0 ,   1.0 ) 。   uniform   uniform 函数 a b 之间 随机 实数 （ a ， b 值 指定 ， 包括 a 。 ） 。   ​   uniform ( a , b ) - > [ a.0 ,   b.0 ) 。   randint   randint 函数 a b 之间 随机 整数 ， 包含 a b 。   ​   randint ( a , b ) - > [ a , b ]   choice   choice 随机 一个 列表 字符串 中 取出 一个 元素 。   randrange   randrange 函数 a b 之间 随机 整数 ， 步长 c （ a ， b ， c 值 指定 ， 相当于 choice ( range ( a , b , c ) ) 。 整数 之间 randint 函数 ， 函数 针对 range 函数 步长 生成 整数 序列 情况 。   sample ( p , k )   sample 函数 p 中 随机 选取 唯一 元素 （ p range ( n ) 集合 ， 唯一 不放回 抽样 ， p 样品 重复 元素 ， 生成 列表 会 重复 元素 。 ） k 长度 列表 返回 。   一个 简单 例子 ：   > > >     random   import   *   > > >   print ( random ( ) )   0.36882919781549717   > > >   print ( uniform ( 1 , 10 ) )   2.771065174892699   > > >   print ( randrange ( 1 , 6 ) )   1   > > >   print ( randint ( 1 , 10 ) )   3   > > >   print ( choice ( ' abcdefghij ' ) )   j   > > >   print ( choice ( [ ' 1 ' , ' 2 ' , ' 3 ' ] ) )   2   随机 实数 ， 包含 临界值 数学 意义 大于 价值 ， 写 一个 类似 小 脚本 看 ， 随机 实数 很 难 随机 数 。     random   import   *   i   =   0     True :   x   =   uniform ( 0 , 2 )     x   = =   0 :   print ( i )   break   :   print ( x )   i   + =   1   上 一个 例子 ， 不 随机 实数 概率 永远 ， 肯定 很小 很小 。 解决 ， 概率 随机 整数 好 。   更 内容 请 参见   官方 文档   。   statistics 模块   模块 python3.4 才 进来 。   例子 稍作 修改 ， 使 一个 骰子 模拟器 。   i _ list   列表 收集 实验 中掷 次 骰子 才 6 次数 。     random   import   *   i _ list   =   [ ]     len ( i _ list )   <   100 :   i   =   1     True : # 实验   x   =   randint ( 1 , 6 )     x   = =   6 :   print ( ' times : '   ,   i )   break   :   print ( x )   i   + =   1   i _ list . append ( i )   print ( i _ list )     statistics   import   *   print ( ( i _ list ) ) # 平均值   print ( median ( i _ list ) ) # 中位数 ， 去掉 最低 ...   statistics 模块 中     函数 接受 一组 数值 列表 ， 返回 这组 数值 平均值 。   median   函数 返回 统计学 上 中位数 ， 简单 看作 一组 数字 去掉 一个 最低 ， 剩下 一个 两个 （ 两个 要取 平均值 ） 数值 值 。   更 内容 请 参见   官方 文档   。   序列   字符串 ， 列表 ， 元组 （ tuple ， 翻译成 元组 ， 内容 不 数值 。 ） 都 序列 （ sequence ） 子类 ， 序列 性质 都 ， 讲 理解 记忆 。   len 函数   len 函数 返回 序列 含 元素 个数 ：   string001 = ' string '   list001 = [ ' a ' , ' b ' , ' c ' ]   tuple001 = ( 1 , 2 , 3 , 4 )     x     [ string001 , list001 , tuple001 ] :   print ( len ( x ) )   6   3   4   > > >   调出 值   序列 来说 跟个 方括号 ， 加上 序号 （ 程序 界 老规矩 ， 0 计数 。 ） ， 调出 位置 值 。 还 例子 。   string001 = ' string '   list001 = [ ' a ' , ' b ' , ' c ' ]   tuple001 = ( 1 , 2 , 3 , 4 )     x     [ string001 , list001 , tuple001 ] :   print ( x [ 2 ] )   r   c   3   > > >   倒   倒 计数 - 1 倒数 第一个 ， - 2 倒数 第二个 。 依次 类推 。   string001 = ' string '   list001 = [ ' a ' , ' b ' , ' c ' ]   tuple001 = ( 1 , 2 , 3 , 4 )     x     [ string001 , list001 , tuple001 ] :   print ( x [ - 1 ] , x [ - 2 ] )   g   n   c   b   4   3   调出 多个 值   不写 从头开始 ， 不写 到达 尾部 。 加个 冒号 形式 。     元素 进来 ， python 区间 默认 含义 都 包头 不 包尾 。 想要 一个 元素 进去 ， 默认 不 写 形式 。   string001 = ' string '   list001 = [ ' a ' , ' b ' , ' c ' ]   tuple001 = ( 1 , 2 , 3 , 4 )     x     [ string001 , list001 , tuple001 ] :   print ( x [ 1 : 3 ] , x [ - 2 : - 1 ] , x [ : - 1 ] , x [ 1 : ] , x [ 1 : - 1 ] )   tr   n   strin   tring   trin   [ ' b ' ,   ' c ' ]   [ ' b ' ]   [ ' a ' ,   ' b ' ]   [ ' b ' ,   ' c ' ]   [ ' b ' ]   ( 2 ,   3 )   ( 3 , )   ( 1 ,   2 ,   3 )   ( 2 ,   3 ,   4 )   ( 2 ,   3 )   数学 半开 半闭 区间 定义 理解 包含 关系 很 便捷 。   数学 半开 半闭 区间 ， 左 元素 右 元素 都 叙述 定位点 。 左 元素 包含 右 元素 不 包含 。   方向 从左到右 ， 定义 区间 从右到左 ， 空值 。   区间 超过 ， 从左到右 包含 元素 ， 。   元素 定位点 ， 空值 ， ：   string001 [ 2 : - 4 ]   ， 2 - 4 实际上 定位 同一个 元素 之上 。 额外 值得一提 列表 插入 操作 ， 请 参看 列表 插入 操作 这一 小节 。   序列 反转   这是 python 最 令人 叹为观止 地方 ， 语言 列表 反转 编写 一个 函数 ， python 一种 令人感动 方法 。   string001 = ' string '   list001 = [ ' a ' , ' b ' , ' c ' ]   tuple001 = ( 1 , 2 , 3 , 4 )     x     [ string001 , list001 , tuple001 ] :   print ( x [ : : - 1 ] )   gnirts   [ ' c ' ,   ' b ' ,   ' a ' ]   ( 4 ,   3 ,   2 ,   1 )   range 函数 介绍 时 提及 序列 索引 range 函数 参数设置 很 类似 ， 这是 参考 理解 ， 序列 （ 列表 ， 字符串 ） 索引 参数   [ start : end : step ]   range 函数 参数设置 ， 第一个 参数 起步 值 ， 第二个 参数 结束 值 ， 第三个 参数 步长 。 end 不 填 都 好 理解 ， 迭代 完 即可 ， step 负数 ， 起点 不填 默认 - 1 。   range 函数 生成 迭代 器 对象 接受 索引 参数 语法 ， 看上去 怪异 ：   > > >   range ( 1 , 10 , 2 )   range ( 1 ,   10 ,   2 )   > > >   range ( 1 , 10 , 2 ) [ : : - 2 ]   range ( 9 ,   - 1 ,   - 4 )   > > >   list ( range ( 1 , 10 , 2 ) )   [ 1 ,   3 ,   5 ,   7 ,   9 ]   > > >   list ( range ( 1 , 10 , 2 ) [ : : - 2 ] )   [ 9 ,   5 ,   1 ]   range 函数 切片 操作 返回 一个 range 对象 ， 修正 。 切片 操作 类 方法 ， python slice 对象 。   序列 可更改 性   字符串 不 更改 ， 组合 新 字符串 ； 列表 更改 ； 元组 不 更改 。   序列 加法 减法   两个 字符串 相加 字符串 拼接 。 乘法 加法 重复 ， 一个 字符串 乘以 一个 数字 拼接 几次 。 列表 元组 字符串 大致 情况 类似 。   print ( ' abc ' + ' def ' )   print ( ' abc ' * 3 )   print ( [ 1 , 2 , 3 ] + [ 4 , 5 , 6 ] )   print ( ( 0 , ' a ' ) * 2 )   abcdef   abcabcabc   [ 1 ,   2 ,   3 ,   4 ,   5 ,   6 ]   ( 0 ,   ' a ' ,   0 ,   ' a ' )   字符串   python 语言 不像 c 语言 ， 字符 字符串 不分 ， 单引号 双引号 包 一个 字符串 。 单引号 双引号 特别 区别 ， 字符串 单引号 ， 双引号 ， 单引号 字符 不 转义 - - - - - - 转义 很多 编程语言 \\ 符号 。 显示   '   输入   \\ '   。   三 单引号 三 双引号   单引号 双引号 情况 下 ，   \\ n   换行 ， \\ n 换行 。 还 三 单引号 \" ' 三 双引号 \\ \" \\ \" \\ \" 包围 横跨 多行 字符串 ， 换行 意义 换行 ， 不 似 。   print ( ' ' ' \\   这是 一段 测试 文字       a   test   line   空白   换行 都 所见 所得 式 保留 。 ' ' ' )   startswith 方法   > > >   x   =   ' helloABC '   > > >   x   ' helloABC '   > > >   x . startswith ( ' ' )   True   > > >   x . endswith ( ' ABC ' )   True   startswith   测试 字符串 子 字符串   endswith   测试 字符串 子 字符串 结束   find 方法   字符串 find 方法 可用 查找 子 字符串 ， 找到 返回 - 1 ， 找到 返回 字符串 偏移量 。 用法 ：   s . find ( ' d ' )   。   replace 方法   字符串 replace 方法 替换 操作 ， 接受 两个 参数 ： 第一个 参数 匹配 子 字符串 ， 第二个 参数 替换 样子 。   > > >   print ( ' a   b   11   de ' . replace ( ' de ' , ' ding ' ) )   a   b   11   ding   > > >   print ( ' 1 , 1 , 5 , 4 , 1 , 6 ' . replace ( ' 1 ' , ' replaced ' ) )   replaced , replaced , 5 , 4 , replaced , 6   upper 方法   字符串 转换成 大写 形式 。   > > >   str = ' str '   > > >   str . upper ( )   ' STR '   类似 ：   lower   都 小写   capitalize   首字母 大写 ， 都 小写 。   isdigit 方法   isdigit   测试 数字   isalpha   测试 字母   isalnum   测试 数字 字母   split 方法   字符串 split 方法 字符串 空格 逗号 分隔符 分割 而成 ， 分割 成子 字符串 列表 。 默认 空格 分隔符 。   > > >   string = ' a = 1 , b = 2 , c = 3 '   > > >   string . split ( ' , ' )   [ ' a = 1 ' ,   ' b = 2 ' ,   ' c = 3 ' ]   splitline 方法   一个 字符串 行 分开 。 split 方法 接受   \\ n   参数 ， splitline 方法 不 接受 参数 ：   > > >   string   '     line   \\ nthis     line   \\ nthis     line   '   > > >   string . splitlines ( )   [ '     line   ' ,   '     line   ' ,   '     line   ' ]   > > >   string . split ( ' \\ n ' )   [ '     line   ' ,   '     line   ' ,   '     line   ' ]   join 方法   字符串 join 方法 有用 ， 严格来说 接受 一个 迭代 器 参数 ， 最 常见 列表 。 列表 中 多个 字符串 连接起来 ， 采用 一种 优雅 方式 ， 两个 字符串 之间 才 插入 字符 ， 正是 。 例子 所示 ：   > > >   list001 = [ ' a ' , ' b ' , ' c ' ]   > > >   \" \" . join ( list001 )   ' abc '   > > >   ' , ' . join ( list001 )   ' a , b , c '   strip 方法   rstrip 方法   字符串 右边 空格 都 删除 。 换行符 会 删除 掉 。   lstrip 方法   类似 rstrip 方法 ， 字符串 左边 空格 都 删除 。 换行符 会 删除 掉 。   format 方法   字符串 format 方法 字符串 内 变量 替换 操作 ， 花 括号 不带 数字 format 方法 替换 量 ， 带 数字 0 第一个 替换 量 ， 类推 。 还 名字 引用 。   > > >   print ( ' 1 + 1 = { 0 } ， 2 + 2 = { 1 } ' . format ( 1 + 1 , 2 + 2 ) )   1 + 1 = 2 ， 2 + 2 = 4   > > >   print ( '       { } ' . format ( = ' Jim   T   Kirk ' ) )         Jim   T   Kirk   转义 不 转义   \\ n   \\ t   这是 常用 转义字符 ， 换行 制表 。   \\ \\   输出 \\ 符号 。   输出 字符串 不想 转义 格式 ：   > > >   print ( r ' \\ t   \\ n   \\ test ' )   \\ t   \\ n   \\ test   count 方法   统计 字符串 中 字符 连续 子 字符串 次数 。   > > >   string   =   '     a   test   line . '   > > >   string . count ( ' ' )   1   > > >   string . count ( ' t ' )   3   r 方法   rfind   rindex   rjust   rsplit   ， 方法 会 很 有用 ， 含义 理解 ：   find   index   ljust   split 。   想 看 ， 区别 是从 右往 左 。   列表   方括号 包含 几个 元素 列表 。   列表 插入 操作   字符串 数组 都 不 更改 不 ， 列表 。 列表 还 一种 定位 元素 区间 方法 插入 操作 ， 理解 区间 违和 ， 定位 元素 区间 本来 概念 模糊 ， 看作 特例 ， 视作 插入 。   list001 = [ ' ' , ' ' , ' ' ]   list001 [ 1 : - 2 ] = [ ' ' , ' ' ]   print ( list001 )   [ ' ' ,   ' ' ,   ' ' ,   ' ' ,   ' ' ]   extend 方法 列表 之间 加法 重合 ， list . extend ( [ 4 , 5 , 6 ] ) list = list + [ 4 , 5 , 6 ] ， 加法 还 自由选择 覆盖 原 定义 ， 实际上 自由 。   insert 方法 列表 插入 操作 ：   > > >   list   =   [ 1 , 2 , 3 , 4 ]   > > >   list . insert ( 0 , 5 )   > > >   list   [ 5 ,   1 ,   2 ,   3 ,   4 ]   > > >   list . insert ( 2 , ' a ' )   > > >   list   [ 5 ,   1 ,   ' a ' ,   2 ,   3 ,   4 ]   append 方法   python append 方法 面加   一个 元素   ， append 一个 列表 一个 列表 整体 一个 元素 。 append 方法 会 永久 改变 列表 对象 值 。   记住 ， append 原处 修改 列表 方法 都 返回值 。   > > >   list   =   [ 1 , 2 , 3 , 4 ]   > > >   list . append ( 5 )   > > >   list   [ 1 ,   2 ,   3 ,   4 ,   5 ]   希望 不 改动 原 列表 附加 ， 请 加法 操作 列表 。   reverse 方法   reverse 方法 不 接受 参数 ， 一个 列表 翻转 。 希望 不 改变 原 列表 翻转 ， 返回值 ， 请 方法 ：   > > >   list   [ 1 ,   2 ,   3 ,   4 ,   5 ]   > > >   listNew   =   list [ : : - 1 ]   > > >   list   [ 1 ,   2 ,   3 ,   4 ,   5 ]   > > >   listNew   [ 5 ,   4 ,   3 ,   2 ,   1 ]   copy 方法   copy 方法 复制 返回 列表 。   sort 方法   排序 ， 改变 列表 。 默认 递增 排序 ，   reverse = True   调成 递减 排序 。   默认 递增 排序 顺序 数字 数字 越来越 大 ， 字符 （ ） ACSII 码 编号 递增 排序 。 列表 数字 字符 会 报错 。   > > >   list   =   [ ' a ' , ' ab ' , ' A ' , ' 123 ' , ' 124 ' , ' 5 ' ]   > > >   list . sort ( )   > > >   list   [ ' 123 ' ,   ' 124 ' ,   ' 5 ' ,   ' A ' ,   ' a ' ,   ' ab ' ]   sort 方法 很 一个 选 参数   key = function   ， function 函数 定义 函数 （ lambda 语句 。 ） ， 函数 只 接受 一个 参数 ， 排序 方法 （ 迭代 列表 时 ） 接受 元素 。 给出 一段 代码 ， tostr 函数 接受 对象 返回 字符 ， 出错 。   def   tostr ( item ) :   return   str ( item )   list001   =   [ ' a ' , ' ab ' , ' A ' , 123 , 124 , 5 ]   list001 . sort ( key = tostr )   print ( list001 )   [ 123 ,   124 ,   5 ,   ' A ' ,   ' a ' ,   ' ab ' ]   sorted 函数   sorted 函数 列表 sort 方法 区别 返回 原处 修改 。 sorted 函数 第一个 参数 严格来说 迭代 对象 ， 也就是说 还 接受 列表 之外 迭代 对象 。 用法 两个 差别 不 大 。   > > >   sorted ( ( 1 , 156 , 7 , 5 ) )   [ 1 ,   5 ,   7 ,   156 ]   > > >   sorted ( { ' andy ' : 5 , ' Andy ' : 1 , ' black ' : 9 , ' Black ' : 55 } , key = str . lower )   [ ' Andy ' ,   ' andy ' ,   ' black ' ,   ' Black ' ]   第二个 例子 调用   str . lower   函数 ， 接受 item ， 比如说 ' Andy ' ， 转化 andy ， 参与 排序 。 成 英文字母 大小写 不 敏感 排序 方式 。   字典 按值 排序   类似 字典 按值 排序 方法   4   ：   > > >   sorted ( { ' andy ' : 5 , ' Andy ' : 1 , ' black ' : 9 , ' Black ' : 55 } . items ( ) , key = lambda   i :   i [ 1 ] )   [ ( ' Andy ' ,   1 ) ,   ( ' andy ' ,   5 ) ,   ( ' black ' ,   9 ) ,   ( ' Black ' ,   55 ) ]   例子 先 字典 items 方法 返回 ( key , ) 迭代 对象 ， lambda 方法 返回 接受 item 值 ， 值来 排序 。   中文 排序   例子 演示 中文 名字 排序 。 函数 思路   pypinyin   （ 一个 第三方 模块 ） ， 中文 姓名 拼音 ， 一个 列表 ， 拼音 组合 列表 排序 ， 生成 目标 列表 。   list001 = [ ' 张三 ' , ' 李四 ' , ' 王二 ' , ' 麻子 ' , ' 李二 ' , ' 李一 ' ]   def   zhsort ( lst ) :     pypinyin   import   lazy _ pinyin   pinyin = [ lazy _ pinyin ( lst [ i ] )     i     range ( len ( lst ) ) ]   lst0 = [ ( a , b )     ( a , b )     zip ( lst , pinyin ) ]   lst1 =   sorted ( lst0 ,   key = lambda   d : d [ 1 ] )   return   [ x [ 0 ]     x     lst1 ]   print ( zhsort ( list001 ) )   [ ' 李二 ' ,   ' 李四 ' ,   ' 李一 ' ,   ' 麻子 ' ,   ' 王二 ' ,   ' 张三 ' ]   reversed 函数   提到 序列 反转 做 :   lst [ : : - 1 ]   推荐 做法 reversed 函数 做 ， reversed 函数 返回 迭代 对象 。   string001 = ' string '   list001 = [ ' a ' , ' b ' , ' c ' ]   tuple001 = ( 1 , 2 , 3 , 4 )     x     [ string001 , list001 , tuple001 ] :   print ( list ( reversed ( x ) ) )   [ ' g ' ,   ' n ' ,   ' i ' ,   ' r ' ,   ' t ' ,   ' s ' ]   [ ' c ' ,   ' b ' ,   ' a ' ]   [ 4 ,   3 ,   2 ,   1 ]   马上 想到 ， 列表   reverse   方法 ， 其是 破坏型 方法 ， 类似   sort   方法 ， 破坏型 ， 非 破坏型 方法   sorted   。 特别 需求 时 都 非 破坏型 方法 ， reversed ， sorted 。   删除 元素   赋空 列表 值 ， 相当于 元素 都 删除 。   pop 方法 ： 接受 一个 参数 ， 列表 元素 定位 值 ， 元素 删除 ， 方法 返回 元素 值 。 不 接受 参数 默认 删除 一个 元素 。   remove 方法 ： 移除 第一个 元素 ， 返回 元素 ， 返回 错误 。   del 函数 ： 删除 列表 中 元素 。   > > >   list001 = [ ' a ' , ' b ' , ' c ' , ' d ' , ' e ' ]   > > >   list001 . pop ( 2 )   ' c '   > > >   list001   [ ' a ' ,   ' b ' ,   ' d ' ,   ' e ' ]   > > >   list001 . pop ( )   ' e '   > > >   list001   [ ' a ' ,   ' b ' ,   ' d ' ]   > > >   list001 . remove ( ' a ' )   > > >   list001   [ ' b ' ,   ' d ' ]   > > >   del   list001 [ 1 ]   > > >   list001   [ ' b ' ]   count 方法   统计 元素 次数 。   > > >   list001 = [ 1 , ' a ' , 100 , 1 , 1 , 1 ]   > > >   list001 . count ( 1 )   4   index 方法   index 方法 返回 元素 偏移 值 。   > > >   list001 = [ 1 , ' a ' , 100 ]   > > >   list001 . index ( ' a ' )   1   列表 解析   来看 例子 ：   def   square ( n ) :   return   n * n   print ( list ( map ( square , [ 1 , 2 , 3 , 4 , 5 ] ) ) )   print ( [ square ( x )     x     [ 1 , 2 , 3 , 4 , 5 ] ] )   [ 1 ,   4 ,   9 ,   16 ,   25 ]   [ 1 ,   4 ,   9 ,   16 ,   25 ]   map 函数 函数 列表 元素 中 生成 一个 map 对象 （ 迭代 对象 ） ， 外面 加上 list 函数 才能 生成 列表 形式 。 第二种 方式 更 python 风格 ， 推荐 列表 解析 方法 。   python 中 推荐 迭代 操作 上 列表 解析 风格 ， python 中 迭代 操作 c 语言 。   列表 解析 加上 过滤 条件   语句 一个 子句 过滤 条件 ， 看 例子 理解 ：   > > >   [ s * 2     s     [ ' ' , ' abc ' , ' final ' , ' ' ]     s [ 0 ]   = =   ' h ' ]   [ ' hellohello ' ,   ' helphelp ' ]   例子 列表 解析 ， 找到 元素 乘以 2 操作 ， 过滤 条件 字符 h 字母 开头 ， 表达式 不 真的 元素 都 过滤 掉 。   完整 列表 解析 结构   给出 一个 完整 列表 解析 结构 ， 最 常见 情况 一两个 语句 ， 外加 括号 可选项 。   [   expression     var1     iterable1   [   condition1   ]     var2     iterable2   [   condition2   ]   ........   ]   逻辑 从左到右 第一个 语句 最先 执行 语句 ， 第二个 语句 跟着 执行 。   iterable1 指 迭代 对象 ， 也就是说 返回 迭代 对象 函数 map ， filter ， zip ， range 函数 都 放进去 。 克制 写出 太 过于 晦涩 程序 。 循环 语句 嵌套 太多 ， 极容易 出错 。   程序 ：   > > >   [ x + str ( y )     x     [ ' a ' , ' b ' , ' c ' ]     y     [ 1 , 2 , 3 , 4 , 5 , 6 ]     y   &   1 ]   [ ' a1 ' ,   ' a3 ' ,   ' a5 ' ,   ' b1 ' ,   ' b3 ' ,   ' b5 ' ,   ' c1 ' ,   ' c3 ' ,   ' c5 ' ]   > > >   [ x + str ( y )     x     [ ' a ' , ' b ' , ' c ' ]     y     [ 1 , 2 , 3 , 4 , 5 , 6 ]       y   &   1 ]   [ ' a2 ' ,   ' a4 ' ,   ' a6 ' ,   ' b2 ' ,   ' b4 ' ,   ' b6 ' ,   ' c2 ' ,   ' c4 ' ,   ' c6 ' ]   Notice :   推荐 写带 两个 语句 列表 解析 ， 参看 [ 高质量 python 代码 ]   。   列表 解析 好处   熟悉 列表 解析 语句 结构 ， 一两个 语句 不太 情况 下 ， 很 简单明了 。 语法 精炼 ， 运行 速度 循环 至少 快 上 一倍 。 python 迭代 思想 深入骨髓 ， python 优化 工作 很多 都 围绕 迭代 展开 ， 多用 列表 解析 会 代码 运行 更 快 。   好处 ， 加上 cool pythonic 风格 ， 推荐 多用 列表 解析 风格 解决问题 。   元组 生成   加个 括号 这是 一个 元组 对象 。   > > >   [ ( x , x * * 2 )     x     range ( 5 ) ]   [ ( 0 ,   0 ) ,   ( 1 ,   1 ) ,   ( 2 ,   4 ) ,   ( 3 ,   9 ) ,   ( 4 ,   16 ) ]   语句 中 列表 可变 影响   情况 迭代 迭代 对象 迭代 对象 返回 一个 值 利用 值 赋值 操作 ， 列表 却是 一个 可变 东西 ， 列表 操作 中 修改 ， 情况 会 ？   lst   =   [ 1 , 2 , 3 , 4 , 5 ]   index   =   0     x     lst :   lst . pop ( index )   print ( x )   1   3   5   过程 细节 不 ， 语句 记忆 原 列表 ， 记忆 返回 次数 偏移 值 。   列表 元素 替换   推荐 列表 解析 方法 列表 元素 替换 功能 。   def   replace ( x , a , b ) :     x   = =   a :   return   b   :   return   x   lst = [ 1 , 5 , 4 , 1 , 6 ]   > > >   [ replace ( i , 1 , ' replaced ' )     i     lst ]   [ ' replaced ' ,   5 ,   4 ,   ' replaced ' ,   6 ]   列表 元素 去 重   列表 元素 去 重 推荐 set 集合 对象 ， 其会 自动 去除 重复 元素 。   > > >   lst   =   [ 1 , 2 , 3 , 4 , 5 , 1 , 2 , 3 , 4 , 5 ]   > > >   [ i     i     set ( lst ) ]   [ 1 ,   2 ,   3 ,   4 ,   5 ]   元组   圆括号 包含 几个 元素 元组 ( tuple ) 。 元组 列表 在于 元组 改变 。 元组 是从 序列 对象 ， 元组 很多 方法 都 讲 。 元组 上 列表 极其 接近 ， 很多 内容 略过 。   值得一提的是 输入 写   x , y   形式 ， 实际上 表达式 加上 括号 ， 一个 元组   ( x , y )   。   生成器 表达式   类似 列表 解析 ， 元组 解析 返回 元组 ？ ， 谈到 python 中 表达式 圆括号 忽略 ， 元组 解析 式 更 名字 生成器 表达式 ， 返回 生成器 对象 ， 生成器 函数 调用 返回 对象 。 生成器 对象   __ __   方法 ， 调用 函数 。   > > >   x   =   [ i     i     [ 1 , 2 , 3 ] ]   > > >   x   [ 1 ,   2 ,   3 ]   > > >   y   =   ( i     i     [ 1 , 2 , 3 ] )   > > >   y   < generator   object   < genexpr >     0xb70dbe8c >   字典   列表 字典 可变 ， 列表 引用 原处 修改 ， del 语句 。   并非 对象 都 做 字典 key ， python 中 内置 变 对象 都 散列 ， 可变 对象 都 散列 。 可散列 才 做 字典 key 。 可散列 对象 ：     __ hash __   方法 ， 大小     __ eq __   方法 ， 判断 。   值得一提 元组 做 字典 key 。 顺便 提 元组 大小 ， python 中 元组 大小 ：   元组 列表 大小   元组 列表 判断 很 好 理解 ， 东西 :   > > >   ( 1 , - 1 )   <   ( 2 , - 2 )   确实 古怪 。 请 读者 参考   网页   ) ， 官方 文档 ：   Tuples     lists     compared   lexicographically     comparison       elements .   This   means       compare   equal ,     element     compare   equal         sequences             type           length .   官方 文档 大于 小于 情况 说 很 ， 字里行间 大体 领会 精神 :   迭代 对象 大小 ， 逐个 。   迭代 对象 测试 返回 True False 。   逐个 ， 跳 元素 ， 两个 不 元素 ， 返回 两个 元素 。   快 完 （ 最小 迭代 对象 长度 为准 ） ， 判断 操作 ， 长度 ； 大小 判断 操作 ， 长度 更长 对象 更大 。   例子 :   > > >   ( 1 , - 1 )   <   ( 2 , - 2 )   True   > > >   ( 1 , - 1 )   <   ( - 1 , - 2 )   False   > > >   ( 1 , - 1 , - 3 )   <   ( 1 , - 1 )   False   > > >   ( 1 , - 1 , )   <   ( 1 , - 1 , 0 )   True   创建 字典   字典 一种 映射 ， 从左到右 顺序 ， 简单 地将键 映射 到值 。 字典 声明 格式 ：   dict001 = { ' ' : ' tom ' , ' height ' : ' 180 ' , ' color ' : ' red ' }   dict001 [ ' ' ]   创建 一个 空 字典 ， 赋值 创建 键 ：   dict002 = { }   dict002 [ ' ' ] = ' bob '   dict002 [ ' height ' ] = 195   列表 创建 字典   [ [ ' a ' , 1 ] , [ ' b ' , 2 ] , [ ' c ' , 3 ] ] 形式 ， dict 函数 字典 ， [ ' a ' , ' b ' , ' c ' ] [ 1 , 2 , 3 ] 形式 zip 函数 ， dict 函数 字典 ：   > > >   lst   [ [ ' a ' ,   1 ] ,   [ ' b ' ,   2 ] ,   [ ' c ' ,   3 ] ]   > > >   dict001 = dict ( lst )   > > >   dict001   { ' a ' :   1 ,   ' b ' :   2 ,   ' c ' :   3 }   字典 字典   列表 在于 字典 索引 方式 \" 键 \" 。   dict003 = { ' ' : { ' ' : ' bob ' , ' ' : ' smith ' } }   dict003 [ ' ' ] [ ' ' ]   字典 遍历 操作   字典 特定 顺序 遍历 操作 通用 做法 字典 keys 方法 收集 键 列表 ， 列表 sort 方法 语句 遍历 ， 所示 ：   dict = { ' a ' : 1 , ' c ' : 2 , ' b ' : 3 }   dictkeys = list ( dict . keys ( ) )   dictkeys . sort ( )     key     dictkeys :   print ( key , ' - > ' , dict [ key ] )   警告   ： 例子 python 早期 版本 不 ， 保险 见 ， 推荐 sorted 函数 ， sorted 函数 默认 字典 键 排序 返回 键 值 列表 。   dict = { ' a ' : 1 , ' c ' : 3 , ' b ' : 2 }   > > >     key     sorted ( dict ) :   ...   print ( key , ' - > ' , dict [ key ] )   ...   a   - >   1   b   - >   2   c   - >   3   字典 遍历 顺序 ， 简单 ：   > > >     key     dict :   ...   print ( key , ' - > ' , dict [ key ] )   ...   c   - >   2   a   - >   1   b   - >   3   keys 方法   收集 键值 ， 返回 。   values 方法   keys 方法 类似 ， 收集 值 ， 返回 。   > > >   dict001 . values ( )   dict _ values ( [ 3 ,   1 ,   2 ] )   > > >   list ( dict001 . values ( ) )   [ 3 ,   1 ,   2 ]   items 方法   keys values 方法 类似 ， 返回 ( key , ) 。   > > >   dict001 . items ( )   dict _ items ( [ ( ' c ' ,   3 ) ,   ( ' a ' ,   1 ) ,   ( ' b ' ,   2 ) ] )   > > >   list ( dict001 . items ( ) )   [ ( ' c ' ,   3 ) ,   ( ' a ' ,   1 ) ,   ( ' b ' ,   2 ) ]   ， python2 三个 方法 返回 列表 ， python3 返回 迭代 对象 更 节省 计算资源 些 。   字典 语句   语句 只 针对 字典 键 ， 不 针对 字典 值 。   > > >   dict001 = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 }   > > >   2     dict001   False   > > >   ' b '     dict001   True   字典 对象 方法   方法 去 找 键 值 ， 不 引用 ， 方法 好处 键 不 出错 。   > > >   dict001 = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 }   > > >   dict001 . ( ' b ' )   2   > > >   dict001 . ( ' e ' )   update 方法   感觉 字典 一个 小型 数据库 ， update 方法 一个 字典 键 值 覆盖 进 字典 中 去 ， 称之为 更新 ， 加上 ， 覆盖 。   > > >   dict001 = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 }   > > >   dict002 = { ' e ' : 4 , ' a ' : 5 }   > > >   dict001 . update ( dict002 )   > > >   dict001   { ' c ' :   3 ,   ' a ' :   5 ,   ' e ' :   4 ,   ' b ' :   2 }   pop 方法   pop 方法 类似 列表 pop 方法 ， 引用 键 ， 偏移 地址 ， 不 说 。   字典 解析   字典 解析 方式 很 好 理解 。   > > >   dict001 = { x : x * * 2     x     [ 1 , 2 , 3 , 4 ] }   > > >   dict001   { 1 :   1 ,   2 :   4 ,   3 :   9 ,   4 :   16 }   zip 函数 创建 字典   利用 zip 函数 两个 迭代 对象 平行 合成 一个 配对 元素 迭代 对象 ， dict 函数 字典 对象 。   > > >   dict001 = zip ( [ ' a ' , ' b ' , ' c ' ] , [ 1 , 2 , 3 ] )   > > >   dict001   < zip   object     0xb7055eac >   > > >   dict001 = dict ( dict001 )   > > >   dict001   { ' c ' :   3 ,   ' b ' :   2 ,   ' a ' :   1 }   集合   python 数学 上 无序 不 重复 元素 集合 概念 ， 讨论 列表 去 重元素 提到 正好 利用 集合 特性 。   > > >   list001 = [ 1 , 2 , 3 , 1 , 2 , 4 , 4 , 5 , 5 , 5 , 7 ]   > > >   { x     x     list001 }   { 1 ,   2 ,   3 ,   4 ,   5 ,   7 }   > > >   set ( list001 )   { 1 ,   2 ,   3 ,   4 ,   5 ,   7 }   集合 解析 形式 set 命令 迭代 对象 都 集合 类型 。 希望 列表 list 命令 强制 类型转换 列表 类型 即可 ， 中 确实 元素 不 重复 这一 特性 ， 集 合作 数据 操作 类型 。   集合 迭代 对象 。 迭代 对象 列表 解析 操作 不 啰嗦 。 介绍 集合 操作 。   集合 添加 元素   值得一提的是 想 创建 一个 空 集合 ,   set 命令 ， 用花 括号 系统 会 创建 空 字典 。 集合   add   方法 添加 ， 重复 元素 添加 不 进来 。   警告   ： 值得一提的是 集合 只能 包括 变 类型 ， 列表 字典 集合 内部 元素 。 元组 变 ， 加进去 。   > > >   set001 = set ( )   > > >   set001 . add ( 1 )   > > >   set001   { 1 }   > > >   set001 . add ( 2 )   > > >   set001   { 1 ,   2 }   > > >   set001 . add ( 1 )   > > >   set001   { 1 ,   2 }   update 方法 更新 多个 元素 ：   > > >   set001 = set ( ' a ' )   > > >   set001 . update ( ' a ' , ' b ' , ' c ' )   > > >   set001   { ' b ' ,   ' a ' ,   ' c ' }   集合 去掉 元素   两个 集合 对象 方法 用于 去掉 集合 中 元素 ， discard 方法 remove 方法 ， discard 方法 删除 集合 中 元素 都 发生 ， remove 方法 删除 不 元素 会 KeyError 。   > > >   set001 = set ( ' ' )   > > >   set001 . discard ( ' h ' )   > > >   set001   { ' e ' ,   ' o ' ,   ' l ' }   > > >   set001 . discard ( ' l ' )   > > >   set001   { ' e ' ,   ' o ' }   remove 方法 类似 不 做 演示 。   两个 集合 之间 关系   子集 判断   集合 对象 一个 issubset 方法 用于 判断 集合 集合 子集 。   > > >   set001 = set ( [ ' a ' , ' b ' ] )   > > >   set002 = set ( [ ' a ' , ' b ' , ' c ' ] )   > > >   set001 . issubset ( set002 )   True   简便 方式 两个 集合 之间 关系 ， > ， < ， > = ， < = ， = = 判断 都 。 set001 set002 子集 ， 元素 set002 都 包含 ，   set001 < = set002   ， 真 子集 概念   set001 < set002   不 等于 即可 。   两个 集合 之间 操作   例子 演示 两个 集合 之间 交集 ：   &   ， 并集 ：   |   ， 差集 ：   -   。   > > >   set001 = set ( ' ' )   > > >   set002 = set ( ' hao ' )   > > >   set001   &   set002   # 交集   { ' o ' ,   ' h ' }   > > >   set001   |   set002   # 并集   { ' h ' ,   ' l ' ,   ' a ' ,   ' e ' ,   ' o ' }   > > >   set001   -   set002   # 差集   { ' e ' ,   ' l ' }   类似 集合 对象 intersection 方法 ， union 方法 ， difference 方法 ：   > > >   set001 = set ( ' ' )   > > >   set002 = set ( ' hao ' )   > > >   set001 . intersection ( set002 )   # 交集   { ' h ' ,   ' o ' }   > > >   set001 . union ( set002 )   # 并集   { ' e ' ,   ' a ' ,   ' h ' ,   ' o ' ,   ' l ' }   > > >   set001 . difference ( set002 )   # 差集   { ' e ' ,   ' l ' }   clear 方法   一个 集合 清空 。   copy 方法   类似 列表 copy 方法 ， 制作 一个 集合 copy 备份 赋值 变量 。   pop 方法   无序 弹 出 集合 中 一个 元素 ， 返回 KeyError 错误 。   bytes 类型   编码 知识   存储 计算机 都 二进制 流 ， 正确 解析 字符 ， 建立 编码 规则 。 熟悉 ASC Ⅱ 编码 规则 。 ACS Ⅱ 编码 Latin - 1 utf - 8 编码 子集 ， 一连串 基于 ACS Ⅱ 编码 字符串 utf - 8 编码 正确 解析 。   python2 中 支持   bytes   类型   。 python2 一个   unicode   类型 。   bytes 简单 理解 字符 含义 二进制 字节 流 。   b ' test '   ， 加 个字符 b B ， 解析 bytes 类型 。   > > >   x   =   b ' test '   > > >   x   b ' test '   > > >   type ( x )   < class   ' bytes ' >   > > >   x [ 0 ]   116   > > >   x [ 1 ]   101   > > >   list ( x )   [ 116 ,   101 ,   115 ,   116 ]   > > >   python 打印 时会 尽可能 打印 字符 ， x 打印 显示 出 test 字符 ， x 一连串 数字 序列 不 字符串 含义 ， 调用 bytes 类型   decode   方法 ， bytes 类型 解码 str 类型 。   > > >   y   =   x . decode ( ' utf - 8 ' )   > > >   y   ' test '   > > >   type ( y )   < class   ' str ' >   编码方式 正确 ， 正确 解析 原 bytes 字节 流 回事 。 还 big5 GB 编码 。   字符串 str 类型 有个   encode   方法 编码 操作 输出 编码 bytes 字节 流 。   方法   看 str 类型 bytes 类型 方法 差异 :   > > >   set ( dir ( ' abc ' ) )   -   set ( dir ( b ' abc ' ) )   { ' isdecimal ' ,   ' casefold ' ,   ' __ rmod __ ' ,   ' format _ map ' ,   ' format ' ,   ' encode ' ,   ' __ mod __ ' ,   ' isnumeric ' ,   ' isprintable ' ,   ' isidentifier ' }   > > >   set ( dir ( b ' abc ' ) )   -   set ( dir ( ' abc ' ) )   { ' decode ' ,   ' fromhex ' }   bytes str 拥有 功能 ， 大部分 学到 用于 str 字符串 类型 方法 用于 bytes 类型 中 。 方法 泛滥 ， bytes 字节 流 类型 ， 内在 字符 含义 ， 方法 不 推荐 。   upper 方法 replace 方法 :   > > >   b ' t ' . upper ( )   b ' T '   > > >   b ' testst ' . replace ( b ' st ' , b ' oo ' )   b ' teoooo '   字节 流 连接 很 加法 join 方法 ， 所示 :   > > >   b ' t '   +   b ' e '   b ' te '   > > >   b ' ' . join ( [ b ' a ' , b ' c ' ] )   b ' ac '       ， python2 加法 join 方法 都 丢掉 b 修饰符 :   > > >   b ' ' . join ( [ b ' a ' , b ' c ' ] )   ' ac '   > > >   b ' a '   +   b ' b '   ' ab '   无关紧要 ， python2 理解 str python3 bytes 类型 ， unicode python3 str 类型 。   bytearray 类型   bytearray bytes 类型 类似 ， 内部 支持 方法 操作 bytes 类型 类似 ， 更 像是 一个 列表 ， 原处 修改 字符串 bytes 变 。 python2 bytearray 类型 ， 内在 文本 二进制 不分 。   文件   文件 对象 迭代 对象 。   写 文件   文件 操作   open   函数 创建 一个 文件 对象 ， 简单 理解 接口 搭接 好 。 文件 对象   write   方法 文件 写 操作 ， 调用   close   方法 写 内容 才 真的 写进去 。   file001   =   open ( ' test . txt ' , ' w ' )   file001 . write ( '   world1 \\ n ' )   file001 . write ( '   world2 \\ n ' )   file001 . close ( )   C语言 文件 操作 ， 会为 python 语言 简单 便捷 赞叹不已 。 三句话 ： 创建 一个 文件 对象 ， 调用 文件 对象 wirte 方法 写入 内容 ， close 方法 关闭 文件 即可 。   读 文件   用法   open   函数 创建 一个 文件 对象 ，   read   方法 调用 文件 内容 。 记得   close   关闭 文件 。   file001   =   open ( ' test . txt ' )   filetext = file001 . read ( )   print ( filetext )   file001 . close ( )     readline   方法 一行 一行 读取 文件 内容 。   open 函数 模式   open 函数 模式 ：   ' r '   默认值 ， read ， 读 文件 。   ' w '   wirte ， 写 文件 ， 文件 不 会 创建 文件 ， 文件 已 ， 文件 原 内容 会 清空 。   ' a '   append ， 附加 内容 ， write 方法 内容 会 附加 原文件 。   ' b '   模式 设置 选项 ， ' b ' 单独 ， 三个 基本模式 组合 ， ' rb ' ， 二进制 数据格式 读 。   ' + '   模式 设置 选项 ， ' + ' 单独 ， 三个 基本模式 组合 ， ' r + ' ， + updating 更新 ， 读 写 ， ' r + ' ， ' w + ' ， ' a + ' 区别 ？ 区别 ' r + ' 不 文件创建 功能 ， 文件 不 会 报错 ， ' r + ' 清空 文件 ， ' r + ' 不 清空 文件 write 方法 情况 会 ； ' w + ' 文件创建 功能 ， ' w + ' write 方法 内容 都 ； ' a + ' write 方法 内容 附加 原文件 上 ， ' a + ' 文件创建 功能 。   语句 打开 文件   类似 例子 语句 打开 文件 ， 不用 close 方法 关闭 文件 。 语句 提供 类似 语句 功能 自动 应对 打开 文件 时 异常情况 。     open ( ' test . txt ' , ' w ' )     file01 :   file01 . write ( '   world1 \\ n ' )   file01 . write ( '   world2 \\ n ' )     open ( ' test . txt ' , ' r ' )     file01 :   filetext = file01 . read ( )   print ( filetext )   函数   函数 一个 对象 ， 函数 对象 。 函数 名 变量名 都 引用 ， 函数 名 带个 括号 才 执行 。 不带 括号 返回 函数 对象 引用 地址 。   > > >   print   < built -   function   print >   理解 函数 一个 对象 ， 例子 中 ， fun 刚 一个 函数 列表 ， 迭代 语句 里 ， multiply 函数 对象 ， 接下来 函数 对象 。 过程 x * a 再 加上 b 。   \\ ( a * x   + b \\ )   x   =   3   def   multiply ( x , a ) :   return   x * a   def   ( x , b ) :   return   x + b   fun   =   [ multiply   ,   ]   para   =   [ 3 , 2 ]     fun , para     zip ( fun , para ) :   x   =   fun ( x , para )   print ( x )   自定义 函数   定义 函数 def 命令 ， 语句 结构 ：   def   yourfunctionname ( para001 , para002 ... ) :     something001     something002   参数传递   函数 参数 值 赋值 形式 传递 ， 有助于 理解 不定 变量 函数 。 函数 参数 名是 意义 ， lambda 函式 理解 ， def 定义 有名 函数 ， 引用 地址 ， 内部 作用 原理 lambda 无名 函式 ， 形式参数 名是 x y 都 无所谓 。 ， 给出 一个 古怪 例子 ：   y = 1   def   test ( x , y = y ) :   return   x + y   print ( test ( 4 ) )   输出 5 。 函数 形式参数 y 外面 y 一个 东西 ， 参数 传递 赋值 形式 ， ？ 解释 函数 形式参数 y 函数 内部   本地 变量   y ， 外面 y 不 ， 理解 请 看 下 一节 （ 变量 作用域 ） 。   ：   > > >   x = [ 1 , 2 , 3 ]   > > >     x     x :   ...   print ( x )   ...   1   2   3   语句 迭代 赋值 操作 ， 语句 刚 定义 x 外面 x 一个 东西 ， 刚 定义 x 语句 内部   本地 变量   。   想到 想起 编写 removeduplicate 函数 一个 ， 语句 针对 列表 可变 迭代 对象 工作 原理 ？ 请 看 例子 ：   > > >   lst = [ 1 , 2 , 3 , 4 ]   > > >     x     lst :   ...   print ( x , lst )   ...   del   lst [ - 1 ]   ...   1   [ 1 ,   2 ,   3 ,   4 ]   2   [ 1 ,   2 ,   3 ]   迭代 对象 惰性 求值 内部 机制 在我看来 很 神奇 ， 还 不 太 ， 例子 列表 惰性 求值 记忆 内部 数值 ， 记忆 （ 合情合理 ） ， 迭代 StopIteration 异常 终止 。   变量 作用域   python 变量 作用域 大部分 语言 c 语言 lisp 语言 概念 都 类似 ， 函数 局部变量 ， 一层 套 一层 ， 引用 外面 ， 外面 不 引用 。   机制 函数 都 命名 空间 ， （ 模块 类似 ） 好像 一个 盒子 封装 内部 变量 。 本地 变量 函数 ， 类似 语句 ； 全局变量 模块 ， 更 确切 表述 文件 ， 比如说 文件 里 ， 导入 模块 变量名 ， 实际上 模块 导入 变量名 都 引入 文件 。   类 继承 类似 一种 搜索 机制 ， 先 搜索 本地 作用域 ， 上 一层 ( def ， lambda ， ) 本地 作用域 ， 全局 作用域 ， 内置 作用域 。 直观 图 所示 ：   简单 来说 python 变量 作用域 ： 盒子 套 盒子 ， 搜索 是从 盒子 最 往外面 寻找 ， 外面 变量 ， 外面 不 。   内置 作用域   内置 作用域 一个   __ builtin __   模块 ， python 作用 机制 会 自动 搜索 内置 模块 变量 。 内置 模块 学习 函数 名 ， print ， range ， 内置 异常 名 。   想到 python 内置 函数 覆盖 定义 ， 事实 确实 ：   > > >   abs ( - 3 )   3   > > >   def   abs ( x ) :   ...   print ( x )   ...   > > >   abs ( 3 )   3   > > >   abs ( - 3 )   - 3   学习 单元测试 会 接触 mock 概念 ， 作用 机制 大体 类似 覆盖 掉 定义 对象 。   global 命令   希望 函数 定义 变量 全局变量 ， 变量 声明 加上   global   命令 即可 。   不 建议 做 ， 做 ， 写 两行 代码 才能 ， 不 推荐 做 。   def   test ( ) :   global   var   var =   ' '   test ( )   print ( var )     就算 做 ， 变量 只能 py 文件 中 引用 ， 文件 不了 。 推荐 做法 写 一个 用于 配置 参数 config . py 文件 ， 全局变量 都 放在 ， 文件 ， import 进来 。 config . py 文件 修改 会 影响 py 文件 配置 ， 全局变量 可管 可控 通用 ， 才 正确 编程 方式 。   nonlocal 命令   nonlocal 命令 python3 才 ， 概念 类似 lisp 语言 闭包 ( closure 技术 ) ， ， 函数 记忆 一点 状态 ， 不想 状态 信息 全局变量 ， 不 希望 用类 方式 ， nonlocal 命令 简单 。   global 意味着 命名 只 一个 嵌套 模块 中 ， nonlocal 查找 只 限于 嵌套 def 中 。 理解 nonlocal 理解 函数 嵌套 函数 情况 - - - - - - 工厂 函数 ， 一个 函数 返回 一个 函数 对象 。 比如说   def   add ( x ) :   x = x   def   action ( y ) :   return   x + y   return   action   > > >   add1 = add ( 1 )   > > >   add1 ( 5 )   6   > > >   add2 = add ( 2 )   > > >   add2 ( 5 )   7   return   action 返回 一个 函数 对象 ， add1 接口   def   action   。 熟悉 lisp 语言 明白 ， action 外面 函数 变量 自由 变量 ， 嵌套 函数 引用 自由 变量 。 声明   nonlocal   x   ， 修改 嵌套 函数 外面 声明 变量 。   def   add ( x ) :   x = x   def   action ( y ) :   nonlocal   x   x = x + 1   return   x + y   return   action   > > >   add2 = add ( 2 )   > > >   add2 ( 5 )   8   > > >   add2 ( 5 )   9   > > >   add2 ( 5 )   10   生产 函数 运行 上 状态 性 ， 实际上 类 构建 出 类似 效果 ， 闭包 方式 显得 更 适合 。   给出 一个 稍微 点 例子 ：   def   myrange ( n ) :   i = n   def   action ( ) :   nonlocal   i     i > 0 :   i = i - 1   return   i   return   action   > > >   myrange5 = myrange ( 5 )   > > >   myrange5 ( )   4   > > >   myrange5 ( )   3   > > >   myrange5 ( )   2   > > >   myrange5 ( )   1   > > >   myrange5 ( )   0   > > >   myrange5 ( )   > > >   给出 类似 类 方法 ：   class   myrange :   def   __ init __ ( , n ) :   . i = n   def   action ( ) :     . i   >   0 :   . i   - =   1   return   . i   > > >   myrange5 = myrange ( 5 )   > > >   > > >   myrange5 . action ( )   4   > > >   myrange5 . action ( )   3   > > >   myrange5 . action ( )   2   > > >   myrange5 . action ( )   1   > > >   myrange5 . action ( )   0   > > >   myrange5 . action ( )   > > >   编码 思路 上 基本上 没什么 差异 ， 说 稍作 修改 换成 类 版本 。 推荐 类 方法 。 用类 不伦不类 大材小用 。 不 做 进一步 讨论 ， 闭包 思想 函数 编程 中 很 一个 思想 ， 学习 。   参数 默认 参数   定义 函数 圆括号 接受 参数 ， 参数 跟个 号 ， 来个 赋值 语句 ， 赋 值 参数 默认值 。 随便 写个 演示 程序 ：   def   test ( x = ' ' ) :   print ( x )   test ( )   test ( ' world ' )     world   不定 参量 函数   谈到 sum 函数 只 接受 一个 列表 ， 不 支持 形式 ： sum ( 1 , 2 , 3 , 4 , 5 ) 。 设计 一个 接受 不定 任意 数目 参量 函数 。 一种 奇怪 赋值 方式 。   序列 解包 赋值   NOTICE :   python2 不 支持 小节 讨论 序列 解包 赋值 。 python2 函数 定义 中是 支持   * args   写法 。   > > >   a , b , * c = 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9   > > >   print ( a , b , c , sep = '   |   ' )   1   |   2   |   [ 3 ,   4 ,   5 ,   6 ,   7 ,   8 ,   9 ]   > > >   a , * b , c = 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9   > > >   print ( a , b , c , sep = '   |   ' )   1   |   [ 2 ,   3 ,   4 ,   5 ,   6 ,   7 ,   8 ]   |   9   > > >   * a , b , c = 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9   > > >   print ( a , b , c , sep = '   |   ' )   [ 1 ,   2 ,   3 ,   4 ,   5 ,   6 ,   7 ]   |   8   |   9   带上 一个 星号 * 变量 变得 类似 通配符 味道 ， 针对 序列 （ 数组 ， 列表 ， 字符串 ） ， 都 会 元素 收集 一个 列表 ， 说 。   语句 支持 序列 解包 赋值 ， 通配 元素 收集 一个 列表 ， ：     ( a , * b , c )     [ ( 1 , 2 , 3 , 4 , 5 , 6 ) , ( 1 , 2 , 3 , 4 , 5 ) , ( 1 , 2 , 3 , 4 ) ] :   print ( b )   [ 2 ,   3 ,   4 ,   5 ]   [ 2 ,   3 ,   4 ]   [ 2 ,   3 ]   函数 中 通配符   > > >   def   test ( * args ) :   ...   print ( args )   ...   > > >   test ( 1 , 2 , 3 , ' a ' )   ( 1 ,   2 ,   3 ,   ' a ' )   类似 序列 解包 赋值 中 带 星号 表通配 概念 ， 定义 函数 写 上 一个 带 星号 参量 （ 想象 函数 传递 参数 一个 类似 序列 解包 赋值 过程 ） ， 函数 定义 ， args 接受 参量   元组   。   mysum 函数   def   mysum ( * args ) :   return   sum ( args [ : ] )   print ( mysum ( 1 , 2 , 3 , 4 , 5 , 6 ) )   21   定义 接受 任意 参数 mysum 函数 ， 上 所示 。 过程 接受 args （ 已成 一个 元组 ） ， sum 函数 即可 。   任意 数目 可选 参数   函数 定义 写 上 带上 两个 星号 变量 * * args ， args 函数 接受 可选 参数 一个 字典 值 。   > > >   def   test ( * * args ) :   ...   return   args   ...   > > >   test ( a = 1 , b = 2 )   { ' b ' :   2 ,   ' a ' :   1 }   利用 构建 出 一个 简单 词典 对象 生成器 。   解包 迭代 对象 传递 参数   * args 函数 定义 中 ， 通配 参数 放入 元组 中 。 函数调用 中 ， 针对 迭代 对象 ， 一个 * 星号 包含 元素 迭代 ， 参数 一一对应 赋值 。   > > >   map   =   map ( lambda   x : x + 2 , [ 1 , 2 , 3 ] )   > > >   print ( * map )   3   4   5   > > >   print ( * [ 1 , 2 , 3 ] )   1   2   3   最 简单 打印文件 命令   说 文件 一个 迭代 对象 ， 解包 文件 对象 一个 最 简单 打印文件 命令 ， 简单 惊天地泣鬼神 ...   print ( * open ( ' test . py ' ) )   解包 字典 关键字 参数   类似 ， * * args 语法 字典 对象 解包 函数 关键字 参数 。 函数 f 例子 ：   > > >   def   f ( a , b , c = 3 ) :   ...   print ( a , b , c )   > > >   f ( * * { ' c ' : 6 , ' b ' : 4 , ' a ' : 2 } )   2   4   6   > > >   f ( 1 , 2 , 5 )   1   2   5   例子 告诉 选 参数 a b 字典 形式 复制 。   参数 顺序   老实 说 参数 ， 选 参数 （ 关键字 参数 ） ， 任意 （ 通配 ） 参数 ， 任意 （ 通配 ） 关键字 参数 概念 混在 人 困惑 。 顺序 ：   参数 ，   ， 位置 一一对应 分配 参数 。   关键字 参数 ， 匹配 关键字 参数 。   通配 参数 ， 额外 非 关键字 参数 分配 * args 元组 。   通配 关键字 参数 ， 额外 关键字 参数 分配 * * kwargs 字典 ，   。   所示 ：   def   test ( x ,   y ,   c = 1 ,   d = 1 ,   * args ,   * * kwargs ) :   print ( x ,   y ,   c ,   d ,   args ,   kwargs )   写法 python2 python3 兼容 。 python3 新 一个 keyword - 参数 （ 读者 记住 关键字 参数 就行了 ） ， 所示 ：   def   test ( x ,   y ,   c = 1 ,   d = 1 ,   * args ,   z = None   , * * kwargs ) :   print ( x ,   y ,   c ,   d , args ,   kwargs , z )   一点 ， python2 东西 ， python2 python3 兼容性 不用 太 关注 东西 。 看 例子 ， keyword - 参数 极容易 keyword 参数 常说 关键字 参数 混淆 东西 ， keyword - 参数 确实 类似 关键字 参数 ， 常规 关键字 参数 位置 赋值 ， 指定 名字 赋值 。   keyword - 参数 标志 星号 。 所示 ， z 参数 ， 一个 还 赋予 默认值 keyword - 参数 。   def   test ( x ,   y ,   c = 1 ,   d = 1 ,   * args ,   z   , * * kwargs ) :   print ( x ,   y ,   c ,   d , args ,   kwargs , z )   人 只 想 keyword - 参数 ， 通配 参数 不感兴趣 ， 会 写 ：   def   test ( x ,   y ,   c = 1 ,   d = 1 ,   * ,   z   , * * kwargs ) :   print ( x ,   y ,   c ,   d , args ,   kwargs , z )   写 通配 参数 ， 函数 最 只能 接受 4 不 指定 名字 参数 ， x ， y 两个 ， c d 两个 关键字 参数 匹配 两个 。   keyword - 参数 用处   keyword - 参数 用处 其是 一个 不 指定 名字 赋值 关键字 参数 ， 或者说 关键字 参数 中 给出 名字 ， keyword - 参数 。   一点 ， python2 不 支持 东西 ， python2 类似 效果   * * kwargs   写 上 很多 行 代码 才行 ， 所示 ：   def   test ( x ,   y ,   * * kwargs ) :   a   =   kwargs . pop ( ' a ' )   b   =   kwargs . pop ( ' b ' ,   False )   #   第二个 参数 默认 参数 效果     kwargs :   raise   TypeError ( Unexpected   kwargs :   { 0 } ' . format ( kwargs ) )   异常 信息 随便 写 ， 重点 。   生成器 函数   函数 定义 return 语句 ， yield 语句 ， 构建 出 一个 生成器 函数 ，   > > >   def   test ( x ) :   ...     i     range ( x ) :   ...   yield   2 * i +   1   ...   > > >   test ( 3 )   < generator   object   test     0xb704348c >   > > >   [ x     x     test ( 3 ) ]   [ 1 ,   3 ,   5 ]   > > >   [ x     x     test ( 5 ) ]   [ 1 ,   3 ,   5 ,   7 ,   9 ]   生成器 函数 返回 生成器 对象 （ generator   object ） ， yield 形式 定义 生成器 函数 返回 一个 生成器 对象 range 对象 类似 ， 都 描述性 迭代 对象 ， 元素 不 展开 ， 请求 运算 ， 编程 风格 内存 压力 很小 ， 适合 迭代 元素 特别 情况 。   test 函数 简单 理解   2x + 1   ，   0 < = x < n   （ 赋 值 ） 。   给出 一个 ： 描述 素数 生成器 函数 。   这是 网上 流行 素数 检验函数 ， 效率 高 。   def   isprime ( n ) :     n   = = 2 :   return   True   # 按位 1 ， 都 0 个位数 1   # 奇数 返回 1 真则 假 ， 偶数 返回   # 0 假则 真   elif   n < 2       n   &   1 :   return   False   # 埃拉托 斯特尼 筛法 ...   # 查 一个 正整数 N 素数 ， 最 简单 方法 试 除法 ，   # 该数 N 小于 等于 N * * 0.5 素数 去 试除 ，   # 若均 整除 ， N 素数     x     range ( 3 , int ( n * * 0.5 ) + 1 , 2 ) :     n   %   x   = =   0 :   return   False   return   True   给出 两种 形式 素数 生成器 函数 ， prime2 （ ） 。 prime ( n ) 第几个 素数 。 生成器 函数 一种 惰性 求值 运算 ， yield 迭代 一次函数 运算 （ yield ） ， 机制 好 神奇 。   def   prime2 ( n ) :     x     range ( n ) :     isprime ( x ) :   yield   x   def   prime ( n ) :   i = 0   x = 1     i < n :     isprime ( x ) :   i   + = 1   yield   x   x   + = 1   加载 函数 做 检验 ：   > > >   isprime ( 479 )   True   > > >   [ x     x     prime2 ( 100 ) ]   [ 2 ,   3 ,   5 ,   7 ,   11 ,   13 ,   17 ,   19 ,   23 ,   29 ,   31 ,   37 ,   41 ,   43 ,   47 ,   53 ,   ........ ]   > > >   [ x     x     prime2 ( 1000 )     100 <   x   <   200 ]   [ 101 ,   103 ,   107 ,   109 ,   113 ,   127 ,   131 ,   137 ,   139 ,   149 ,   ....... ]   > > >   len ( [ x     x     prime2 ( 10000 )     - 1   <   x   <   3572 ] )   500   > > >   [ x     x     prime ( 1 ) ]   [ 2 ]   > > >   [ x     x     prime ( 2 ) ]   [ 2 ,   3 ]   递归 函式   递归 函式 某种程度 上 取代 循环 迭代 程序结构 ， 不 推荐 做 。 谈及 递归 函式 归结为 数学 函数 ， 递归 算法 直观 （ 不 高效 ） 。 菲波 奇函数 ：   def   fib ( n ) :     n = = 0 :   return   1     n = = 1 :   return   1   :   return   fib ( n - 1 ) + fib ( n - 2 )     x     range ( 5 ) :   print ( fib ( x ) )   1   1   2   3   5   ， 数学 来说 ， 递归 算法 表述 简洁 易懂 。 内部 细节 ， 定义 fib 称之为 函式 ， 函式 一种 操作 模式 ， 具体操作 复制出 函式 （ 函数 操作 都 数据 ） ， 函式 扩展 生成 函数 操作 。   看 递归 函式 写 阶乘 函数 ， 简洁 ， 最美 方法 。   def   fact ( n ) :     n   = =   0 :   return   1   :   return   n * fact ( n - 1 )   print ( fact ( 0 ) , fact ( 10 ) )   1   3628800   递归 ？   最 推荐 递归 情况 情况 ， 一份 工作 （ 函数 ） 执行 一遍 感觉 工作 做 完 ， 做 一小部分 ， 进展 ， 好比 蚂蚁 吞 大象 ， 递归 思想 。 一种 情况 表面 上 看 进展 ， 事情 发展 ， 感受 一个 条件 最终 将会 终止 程序 一个 输出 ， 递归 。   递归 思想 最 核心 两个 概念 一做 一小部分 工作 ， 感觉 做 做 事情 会 做 完 ； 二有 一个 终止 判断 最终 将会 作用 。   递归 函式 类似 迭代 结构 ， 递归 函式 不 滥用 。 递归 函式 生成 一种 执行 操作 n 次 结构 ：   def   dosomething ( n ) :     n = = 0 :   pass   elif   n = = 1 :   print ( ' ! ' )   :   print ( ' ! ' )   return   dosomething ( n - 1 )   print ( dosomething ( 5 ) )   !   !   !   !   !   None   ， print 语句 换成 操作 ， 机器人 向前走 一步 ， dosomething 换个 名字 向前走 ( 5 ) 成 向前走 5 步 。   lisp car - cdr 递归 技术   lisp 语言 中 ，   car - cdr 递归 技术 很 一门 技术 ， 特长 遍历 随意 嵌套 列表 结构 列表 中 一个 元素 执行 某种 操作 。   来看 例子 ， 一个 任意 嵌套 列表 元素 放入 一个 列表 中 函数 ：   lst   =   [ [ 1 , 2 , [ 3 ] ] , [ 4 , [ 5 , [ [ [ [ 10 ] , 11 ] ] ] ] , ( 1 , 2 , 3 ) ] , [ { ' a ' , ' b ' , ' c ' } , 8 , 9 ] ]   def   _ list ( thing ) :   return   isinstance ( thing ,   list )   def   flatten ( iter ) :   templst   =   [ ]     x     iter :       _ list ( x ) :   templst . append ( x )   :   templst   + =   flatten ( x )   return   templst   print ( flatten ( lst ) )   [ 1 ,   2 ,   3 ,   4 ,   5 ,   10 ,   11 ,   ( 1 ,   2 ,   3 ) ,   { ' c ' ,   ' b ' ,   ' a ' } ,   8 ,   9 ]   函数 逻辑 最小 元素 对象 列表 ， 收集 进 列表 ； ， 展开 ， 调用 原函数 展开 函式 。   例子 意义 上 来讲 还 不算 lisp 经典 car - cdr 递归 技术 ， 给出 一个 典型 例子 ， 复制 任意 嵌套 结构 列表 。 列表 copy 方法 做 工作 ， 例子 进一步 car - cdr 技术 。   def   _ list ( thing ) :   return   isinstance ( thing ,   list )   def   copy _ list ( lst ) :       _ list ( lst ) :   return   lst   elif   lst   = =   [ ] :   return   [ ]   :   return   [ copy _ list ( lst [ 0 ] ) ]   +   copy _ list ( lst [ 1 : ] )   print ( copy _ list ( [ 1 , [ 2 , 6 ] , 3 ] ) )   嵌套 列表 复制 修改 操作 ， 最合适 lisp car - cdr 技术 ， 不得不 承认 ， 递归 写法 递归 函式 最 难懂 。   不管怎么 ， 基础 之上 ， 第一个   语句 中 传递 lst 实际上 是非 列表 元素 ， 修改 操作 ， 原 列表 嵌套 基础 上 ， 等于 遍历 列表 中 元素 某种 操作 。   元素 都 平方 ：   def   square ( x ) :   return   x * * 2   def   square _ list ( lst ) :       _ list ( lst ) :   return   square ( lst )   elif   lst   = =   [ ] :   return   [ ]   :   return   [ square _ list ( lst [ 0 ] ) ]   +   square _ list ( lst [ 1 : ] )   print ( square _ list ( [ 1 , [ 2 , 6 ] , 3 ] ) )   想像 功能 函数 作用 列表 中 元素 不 原 列表 嵌套 结构 ， lisp car - cdr 技术 ， 嵌套 结构 ？ 也许 。 。   lambda 函式   python 中 函数 一个 对象   def   语句 定义 ， 定义 函数 对象 函数 名 变量 绑定 。 实际上 python 中 函数 一个 对象 名字 ：   def   add ( x , y ) :   ...   return   x + y   ...   add   < function   add     0x000001B952B770D0 >   add2   =   add   del   add   add2 ( 1 , 2 )   3   add   Traceback   (   recent   call   ) :   File   \" < input > \" ,   line   1 ,     < module >   NameError :     ' add '       defined   add2 .__ __   ' add '   lambda   λ 表达式 简单 理解 名字 函数 对象 ：   add   =   lambda   x , y :   x + y   add   < function   < lambda >     0x000001B952B77378 >   add .__ __   ' < lambda > '   add ( 1 , 2 )   3   type ( add )   < class   ' function ' >   type ( add2 )   < class   ' function ' >   上 所示 ， def 定义 函数 lambda 函式 python 都 函数 对象 ， 或者说 都 function   class 。 调用 很 类似 ， lambda 函数 定义 函数 对象   __ __   默认   < lambda >   。   lambda 函数 地方 会 用到 ， 函数 参数传递 情况 下 ， 简短 函数 动作 没 再想个 函数 名字 场景 。   print 函数   print 函数 接受 任意 参量 ， 逐个 打印 。 关键字 参数 ：   sep   ： 默认值   '   '   ， 一个 空格 ， 修改 为空 字符串 ， 逐个 打印 字符 之间 间隔 。   end   ： 默认值   ' \\ n '   ， print 函数 执行 完 打印 字符 ， 默认 打印 一个 换行符 。   file   默认值   sys . stdout   ， 终端 显示 ， 修改 文件 变量 ， 文件 输出 内容 。   逻辑   布尔值   boolean 类型 ， 语言 ， 两个 值 ：   True   ，   False   。 强制 类型转换 函数   bool   。   逻辑 小 知识   python 中 ， 逻辑 真假 上 小 知识 ， 简单 下 。   数 0 、 空 对象 对象 None 值 都 假   非零 数字 或非 空 对象 都 真   两条 bool 函数 强制 类型转换   测试 会 递归 作用 数据结构 中   测试 会 返回 True False   两条 说 东西 ， 读者 请 看 这一 小节 。   元组 列表 大小   元组 列表 判断 很 好 理解 ， 东西 :   > > >   ( 1 , - 1 )   <   ( 2 , - 2 )   确实 古怪 。 请 读者 参考   网页   ) ， 官方 文档 ：   Tuples     lists     compared   lexicographically     comparison       elements .   This   means       compare   equal ,     element     compare   equal         sequences             type           length .   官方 文档 大于 小于 情况 说 很 ， 字里行间 大体 领会 精神 :   迭代 对象 大小 ， 逐个 。   迭代 对象 测试 返回 True False 。   逐个 ， 跳 元素 ， 两个 不 元素 ， 返回 两个 元素 。   快 完 （ 最小 迭代 对象 长度 为准 ） ， 判断 操作 ， 长度 ； 大小 判断 操作 ， 长度 更长 对象 更大 。   例子 :   > > >   ( 1 , - 1 )   <   ( 2 , - 2 )   True   > > >   ( 1 , - 1 )   <   ( - 1 , - 2 )   False   > > >   ( 1 , - 1 , - 3 )   <   ( 1 , - 1 )   False   > > >   ( 1 , - 1 , )   <   ( 1 , - 1 , 0 )   True   None   函数 return 值 会 返回 None 值 ， None 值 NoneType 对象 中 一个 值 ， 列表 空值 ， 值 都 不 。 . search 找到 匹配 会 返回 None 值 。 None 值 逻辑 上 逻辑 假 ，   None 逻辑 真 。   > > >   def   f ( ) :   ...   pass   ...   > > >   y   =   f ( )   > > >   y   > > >   type ( y )   < class   ' NoneType ' >   条件 判断   python 中 条件 语句 格式 ：     test :   条件 判断 执行 区块   命令 跟个 条件 判断 语句 ， 记住 加个 冒号 ， 缩进 区块 都 条件 判断 真的 执行 语句 。     test :     something001     :     something002   逻辑 条件 判断 ， 真 ，   something001 ； 假 ，   something002 。     test001 :     something001   elif   test002 :     something002   看 明白 ， elif 。   逻辑 或否   逻辑 ， 逻辑 ， 逻辑 否 。   编写 一个 逻辑 ， 判断 一个 字符串 ， 字符串 开头 a b ， 结尾 s ， 倒数 第二个 字符 单引号 ' 。 演示 逻辑 。 。   x = ' agais '     ( ( x [ 0 ]   = =   ' a '     x [ 0 ]   = =   ' b ' )     x [ - 1 ]   = = ' s '     (   x [ - 2 ]   = = \" ' \" ) ) :   print ( '     .. ' )       ..   稍 条件 判断   ， elif 语句 ， 还 逻辑 或非 组合 判断 。 编程 中 条件逻辑 ？   逻辑 语句 \" 或非 \" 组合 组合 ， 过分 嵌套 。 代码 所示 ， 一个 情况 分成 两 ， ... ... 语句 ，   x = - 2     x > 0 :   print ( ' x 大于 0 ' )   :   print ( ' x 小于 0 ' )   一个 情况 分成 三 ， ... elif ... 语句 。 深度 平行 语句 \" \" 逻辑 ， 或者说 类似 编程语言 switch 语句 。   x = 2     x > 0 :   print ( ' x 大于 0 ' )   elif   x < 0 :   print ( ' x 小于 0 ' )   :   print ( ' x 等于 0 ' )   再 看一看 代码 ， 代码   错误   ， 两个 语句 不 逻辑 分析 关系 。   x = 2     x > 0 :   print ( ' x 大于 0 ' )     x < 0 :   print ( ' x 小于 0 ' )   :   print ( ' x 等于 0 ' )   代码 ， 例子 演示 加深 一个 深度 条件 判断 语句 处于 逻辑 判断 情况 ， 语句 条件 判断 逻辑 语句 判断 逻辑 再 左边 （ ） 判断 逻辑 \" \" 逻辑 ， 或者说 成是 \" 交集 \" 。 比如说   print ( ' 0 < x < 2 ' )   语句 语句 判断 逻辑   x < 2   上 一层 判断 逻辑   x > 0   \" 交集 \" ，   0 < x < 2   。   x = - 2     x > 0 :   print ( ' x 大于 0 ' )     x > 2 :   print ( ' x > 2 ' )   elif   x < 2 :   print ( ' 0 < x < 2 ' )   :   print ( ' x = 2 ' )   elif   x < 0 :   print ( ' x 小于 0 ' )   :   print ( ' x 等于 0 ' )   过程 情况 图 所示 ：   编程 处于 何种 判断 逻辑 之下 一个 清晰 ， 强烈建议 读者 好好 思考 。 毕竟 磨刀 不 误 砍柴 功 。   语句 捕捉 错误   语句 编程 中 用来 错误 不 打算 应付 错误 最 通用 方式 。 一个 变量 预先 想 接受 一个 数值 ， 用户 却 输入 一个 字符 ， 这段 语句 包围 ； 编程 发现 情况 ， 懒得 理会 ， 简单 这块 出错 语句 包围 ， 跟个 语句 ， 打印 出 一个 信息 \" 出错 \" ， 即可 。 用法 所示 ：     True :   x = input ( ' 请 输入 一个 数 ， 返回 除以 2 数值 \\ n 输入 \" quit \" 退出 \\ n ' )     x = = ' quit ' :   break     :   num = float ( x )   print ( num / 2 )   :   print ( ' 出错 ' )   异常 完整 语句   :   yourCode     yourError :         yourError2 :     something2   ......   :     somethingN   finally :       funallystuff   语句 逻辑 试着 执行 区块 下 语句 ， 出现异常 ， 看 异常 yourError ， 执行   ， yourError2 ， 执行   something2   ...... ， 异常 ， 执行 字句 :     somethingN ， 异常 ， 异常 将会 返回 （ 更 控制程序 ） 。   finally 语句 作用 ， finally 语句 实际上 语句 中 异常 判断 情况 关系 ， 有没有 异常 发生 ， 都 执行 。 简单 不 缩进 写 语句 ， finally 语句 就算 程序 发生 异常 ， 会 先 执行 ， 异常 上 传给 控制程序 。   语句 finally 语句 可选 ， 具体情况 来看 。   放 语句 情况   语句 放上 语句 还 细讲 。   语句 相关 逻辑 说 ， 语句 继续执行 。 第一个 情况 ， 字句 return ， 函数 会 跳出 语句 ， 执行 成功 会 跳出 。 错误 捕捉 ， 错误 捕捉 再 放入 一个 raise 语句 ， 再 抛出 一个 错误 ， 语句 会 中止 。 抛出 异常 。 字句 ， 逻辑 错误 ， 将会 执行 字句 ， ， 语句 break 命令 ， 会 跳出 语句 。   情况 稍微 ， 接触 两种 :   这是 一个 mongodb 调用 函数 装饰器 。 试图 调用 mongodb ， 发生 AutoReconnect 异常 ， 将会 sleep 一秒 再 去   调用函数 。 成功 ， return ， 自然 跳出 语句 。   def   safe _ mongocall ( call ) :   ' ' ' mongodb   replica   set   assistant ' ' '   def   _ safe _ mongocall ( * args ,   * * kwargs ) :     i     xrange ( 100 ) : #   :   return   call ( * args ,   * * kwargs )     pymongo . AutoReconnect :   import   time   time . sleep ( 1 )   print ( \"     connect   mongodb   ... \" )   return   _ safe _ mongocall   第二个 例子 较为 常用 ， 重复 做 某件事 会 发生 错误 ， 捕捉 错误 ， 继续执行 。 捕捉 计了 数 。   def   test ( ) :   failcount   =   0     i     range ( src _ count ) :   :         Exception     :   failcount   + =   1   sucess _ count   =   src _ count   -   failcount   return   sucess _ count   还 想到 一种 程序结构 ， 语句 逻辑 分支 。 试 做 某件事 ， ， 执行 字句 break ， 发生 异常 执行 异常 中 字句 ， 内容 不 执行 。 反常规 ， 联系实际 生活 ， 确实 逻辑 ， 假想 ， 发生 错误 不行 执行 字句 ， 假想 内容 不 执行 。   语句   语句 迭代 对象 都 做出 元素 包含 对象 之中 判断 。   > > >   ' a '     [ ' a ' , 1 , 2 ]   True   > > >   dict   { ' a ' :   1 ,   ' c ' :   2 ,   ' b ' :   3 ,   ' d ' :   4 }   > > >   ' e '     dict   False   > > >   ' 2 '     dict   False   例子 ， 列表 判断 元素 预料 ， 字典 说 语句 ， 不 判断 值 。   迭代 语句   内部 重复 操作 程序 先 迭代 结构 ， 实在 不行 才 循环 结构 ， 毕竟 简单 更美 更 。   python 迭代 语句 类似 lisp 语言 dolist dotimes 函数 ， 例子 ：     x     ' abc ' :   print ( x )   a   b   c     序列   类型 ， 字符串 ， 列表 ， 数组 都 。 语句 看作 先 执行 x = ' a ' 类似 匹配 赋值 操作 ， 执行 缩进 区块 ， 依次 类推 。   分句     x     ' abc ' :     x   = =   ' b ' :   print ( x )   break   :   print ( ' test ' )   语句 加上 分句 形式 ， 迭代 完 会 执行 分句 。 语句 还 迭代 过程 中 ， break return ， 分句 执行 。   range 函数   range 函数 常 迭代 语句 ， 返回 一个 迭代 对象 。   range ( 1 , 10 , 2 )   range 函数 用法 上 ， 1 10 ， 步长 2 ， list 函数 包裹 ， 将会 输出 [ 1 , 3 , 5 , 7 , 9 ] 。 不 步长 。 range ( 10 ) 看作 [ 0 , 10 ) ， range ( 1 , 10 ) 看作 [ 1 , 10 ) 。 再 加上 步长 概念 区间 概念 有所不同 。     x     range ( - 10 , - 20 , - 3 ) :   print ( x )   - 10   - 13   - 16   - 19   例子 还 演示 range 负数 概念 ， 区间 概念 考察 ， 理解 ， 行得通 ， 是因为 步长 负数 ， 负数 ， 情况 会 讨论 类似 ， 一个 空值 。   迭代 加上 操作   迭代 信息流 操作 生成 目标 序列 。   > > >   squares = [ x * * 2     x     [ 1 , 2 , 3 , 4 , 5 ] ]   > > >   squares   [ 1 ,   4 ,   9 ,   16 ,   25 ]   enumerate 函数   enumerate 函数 返回 一个 enumerate 对象 ， 对象 偏移 值 元素 组合 ， 一个 迭代 对象 。   > > >   enu   =   enumerate ( ' abcd ' )   > > >   [ i     i     enu ]   [ ( 0 ,   ' a ' ) ,   ( 1 ,   ' b ' ) ,   ( 2 ,   ' c ' ) ,   ( 3 ,   ' d ' ) ]   循环   语句 用法 编程语言 类似 ， 条件 控制 ， 循环 结构 。     test :         :       值得一提的是 语句 语句 一个 整体 ， 情况 下 执行 完 执行 语句 不 加上 控制 。 语句 一个 功用 循环 break 语句 执行 跳过去 ， 见 。   break 命令   break 跳出 循环 结构 。 谈到 语句 一个 整体 ， break 跳过 语句 。   continue 命令   continue 命令 接下来 循环 结构 执行 区块 不 执行 ， 跳 条件 判断 循环 。 ， 循环 。 语句 中 continue 命令 。   pass 命令   pass 命令 都 不 做 。 pass 命令 即可 用于 循环 语句 用于 条件 语句 。   pass 命令 都 不 做 意义 ， 一个 空 占位 符 很 有用 。 编写 一个 大型 GUI 程序 ， 信号 － 槽 机制 都 构思 好 ， 函数 暂时 还 没 写 好 ， 函数 ， 空 函数 名 加上 pass 语句 写 上 ， 程序 编写 调试 。   脚注   chmod 加上 执行 权限 执行 。 第一行 完整 解释   env   程序 搜索 python 路径 ， 代码 更具 可移植性 。 还 说 一点 ， 会谈 virtualenv 模块 ， 类似 引用 python 写法 确保 调用 python 虚拟环境 下 python 解释器 。   ↩   语句 用来 测试 对象 同一性 ， 内存 里 同一个 东西 ， 不仅仅 值 。 = = 确保 值 。   ↩   int 、 float 命令 都 强制 类型转换 命令   ↩   参考 网站   ↩     ( ! document . getElementById ( ' mathjaxscript _ pelican _#% @ # $ @ # ' ) )   {   var   align   =   \" center \" ,   indent   =   \" 0em \" ,   linebreak   =   \" false \" ;     ( false )   {   align   =   ( screen . width   <   768 )     \" left \"   :   align ;   indent   =   ( screen . width   <   768 )     \" 0em \"   :   indent ;   linebreak   =   ( screen . width   <   768 )     ' true '   :   linebreak ;   }   var   mathjaxscript   =   document . createElement ( ' script ' ) ;   mathjaxscript . id   =   ' mathjaxscript _ pelican _#% @ # $ @ # ' ;   mathjaxscript . type   =   ' text / javascript ' ;   mathjaxscript . src   =   ' / theme / js / mathjax / MathJax . js ' ;   mathjaxscript [ ( window . opera     \" innerHTML \"   :   \" text \" ) ]   =   \" MathJax . Hub . Config ( { \"   +   \"   config :   [ ' MMLorHTML . js ' ] , \"   +   \"   TeX :   {   extensions :   [ ' AMSmath . js ' , ' AMSsymbols . js ' , ' noErrors . js ' , ' noUndefined . js ' , ' mhchem . js ' ] ,   equationNumbers :   {   autoNumber :   ' AMS '   }   } , \"   +   \"   jax :   [ ' input / TeX ' , ' input / MathML ' , ' output / HTML - CSS ' ] , \"   +   \"   extensions :   [ ' tex2jax . js ' , ' mml2jax . js ' , ' MathMenu . js ' , ' MathZoom . js ' ] , \"   +   \"   displayAlign :   ' \" +   align   + \" ' , \"   +   \"   displayIndent :   ' \" +   indent   + \" ' , \"   +   \"   showMathMenu :   true , \"   +   \"   messageStyle :   ' normal ' , \"   +   \"   tex2jax :   {   \"   +   \"   inlineMath :   [   [ ' \\ \\ \\ \\ ( ' , ' \\ \\ \\ \\ ) ' ]   ] ,   \"   +   \"   displayMath :   [   [ ' $ $ ' , ' $ $ ' ]   ] , \"   +   \"   processEscapes :   true , \"   +   \"   preview :   ' TeX ' , \"   +   \"   } ,   \"   +   \"   ' HTML - CSS ' :   {   \"   +   \"   styles :   {   ' . MathJax _ Display ,   . MathJax   . mo ,   . MathJax   . mi ,   . MathJax   . mn ' :   { color :   ' inherit   !   important ' }   } , \"   +   \"   linebreaks :   {   automatic :   \" +   linebreak   + \" ,   width :   ' 90%   container '   } , \"   +   \"   } ,   \"   +   \" } ) ;   \"   +   \"   ( ' default '   ! = =   ' default ' )   { \"   +   \" MathJax . Hub . Register . StartupHook ( ' HTML - CSS   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax [ ' HTML - CSS ' ] . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" MathJax . Hub . Register . StartupHook ( ' SVG   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax . SVG . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" } \" ;   ( document . body   | |   document . getElementsByTagName ( ' head ' ) [ 0 ] ) . appendChild ( mathjaxscript ) ;   }",
            "tags":"python_language",
            "url":"articles/python-basic.html"
        },
        {
            "title":"人工智能的未来阅读笔记",
            "text":"前言   意义 上 来说 ， 计算机科学 领域 神经网络 发展 大脑 研究 科学 关系 太 大 ， 说 最 早期 哲学 上 启发 ， 计算机科学 领域 神经网络 学科 更 是从 数学 研究 出发 慢慢 发展 。 本书 — — 杰夫 · 霍金斯 2004 年 出版 《 人工智能 未来   — — 来说 ， 目的 计算机科学 领域 加上 一点 数学 花边 ， 更 是从 哲学 思考 层面 启迪   人工智能   研究 。 人工智能 一个 很 宽广 研究 领域 ， 如果说 神经网络 解决 ， 人工智能 研究 领域 来说 ， 沧海一粟 形容 。 读者 阅读 本书 ， 没 去 联想 神经网络 学科 ， 更 是从 人工智能 关注 出发 。   笔者 来说 类人 智能 ， 或者说 类似 人 机器人 不 ， 一个 很 关键 分界点 ， 机器人 创造 ， 创造 局限 形式 内容 创造 ， 意义 创造 。 图灵 仅仅 模仿 层面 来说 机器 智能 ， 由人 给定 机器 意义 目的 效用 ， 机器 设计 选择 多种不同 目的 解决方案 ， 机器 智能 一千年 之内 。   参考 人脑 构造 结构 工作 原理 持 保留意见 ， 机器 智能 基于 特性 发展 进化 ， 人 创造 ， 上天 人 创造 中 给与 人 启迪 ， 人 自我 设限 创造 遵照 上天 原先 那种 创造 道理 ， 中国 人 古话 来说 盲从 古师 不 懂 举一反三 。 本书 人脑 构造 工作 原理 讨论 权做 参考 ， 给与 读者 一点 灵感 火花 ， 茶余饭后 有趣 ， 足矣 。   历史   弗朗西斯 · 克里克 科学 美国 人中 发表 一篇 文章 《 大脑 思考 ， 此君 DNA 结构 发现 人 ， 天才 思考 投入 大脑 研究 之中 。   克里克 积累 大脑 详尽 知识 ， 大脑 工作 原理 来说 仍 一个 难解 迷 。   说 ： 最 概念 上 缺乏 一个 总 框架 。   这一 振聋发聩 声音 唤醒 《 人工智能 未来 一书 作者 — — 杰夫 · 霍金斯 心中 长久以来 愿望 ， 去 研究 大脑 ， 制造 一个 智能 机器 。   人工智能 关键人物 阿兰 · 图灵 ， 提出 \" 通用 计算 \" 概念 ， 证明 建构 细节 上 有所不同 ， 从根本上 讲 计算机 都 等效 。   图灵 建造 智能 机器 ， 感到 电脑 智能化 。 提出 一个 著名 图灵 检验 。 一台 电脑 诱使 一个 询问者 一个 人 ， 说 这台 机器 智能 。   杰夫 · 霍金斯 提出 见解 ， 图灵 犯 二十世纪 上半叶 占 主导地位 心理学 思潮 — — 行为主义 — — 错误 ， 都 试图用 定义 智能 ， 确实 智能 一种 表现 ， 绝不 智能 本质 智能 首要 解释 。   1   早期 人工智能 热潮 充斥 过度 自信 ， 解 数学 证明题 ， 虚构 一个 积木 世界 ， 下象棋 ， 专家系统 解答 。 创造者 人 思考 。   1986 年 ， 杰夫 · 霍金斯 学习 智能 大脑 功能 理论 研究成果 。 ， 人工智能 第二个 研究 小 高峰 ， 代表 神经网络 。 神经网络 建造 一个 系统 ， 编程 计算机 ， 模拟 神经元 连接 。 一条 正确 道路 上 ， 显示 进展 令人 失望 ， 弄 出 仿真 预测 模型 证明 不用 神经网络 传统 编程 方法 。 是因为 急功近利 思想 ， 神经网络 都 建立 极为 简单 模型 上 ， 相互 少量 连接 神经元 排成 三列 。   反馈     时间   概念 。 更 新 大脑皮层 一个 统一 重复 层级 结构 ， 神经网络 都 结构 缺乏 。   人脑 开发 智能 机器 必由之路 — — 杰夫 · 霍金斯   新 大脑皮层   大脑 ， 一层 薄薄的 皮包 覆 ， 层皮 新 大脑皮层 。 杰夫 · 霍金斯 智能 藏 新 大脑皮层 之中 。 杰夫 · 霍金斯 智能 都 新 大脑皮层 ， 丘脑 海马 作用 。   古脑 人 欲望 情感 ， 杰夫 · 霍金斯 早期 智能 机器 类似 人 欲望 情感 。   正常人 小脑 损害 生活 太 大 ， 小脑 原始 时间 观念 ， 新 大脑皮层 会 事件 流 出新 时间 观念 。 大脑 一部分 器官 原始 控制 很大 一部分 功能 都 新 大脑皮层 取代 。   人类 大脑皮层 展开 相当于 4 张 A4 打印纸 大小 。 面积 大小 ， 大脑皮层 纵向 还 分为 六层 。 有人 估计 300 亿个 神经元 。 弗朗西斯 · 克里克 《 惊人 假设 一书中 说道 ： \" 思想 大 脑细胞 产物 ， 魔力 ， 浆汁 。 思想 神经元 闪动 信息流 。 \"   2   。   蒙 卡斯尔 假说   1978 年 ， 弗龙 · 蒙 卡斯尔 发表 一篇 论文 《 大脑 功能 组织 原则 ， 文章 指出 大脑皮层 外表 上 结构 上 都 惊人 ， 不论是 主管 视觉 输入 主管 触觉 大脑皮层 区域 、 控制 肌肉 区域 、 布洛卡 语言 区 区域 。 实际上 。 暗示 说 ， 区域 发挥 作用 千差万别 ， 功能 方法 完全相同 。   蒙 卡斯尔 ， 解剖学家 大脑皮层 惊人 相似性 ， 深究 含义 。 蒙 卡斯尔 却 相似性 意味着 更 东西 。   大脑皮层 视觉 区域 ， 运动 区域 肌肉 运动 ， 区域 中央 神经系统 连接 。   大脑皮层 之间 细小 差异 正是 连接 差异   大脑皮层 功能 区域 都 遵循 一个 算法 ， 视觉 、 听觉 、 运动 输出 之间 差异 。   威斯康辛 州 大学 生物医药 工程学 教授 保尔 · 巴奇 · 瑞塔 发明 一种 人 舌头 上 显示 视觉 模式 方法 ， 戴上 装置 ， 盲人 舌头 来看 东西 。 原理 前额 戴上 一个 小型 摄像头 ， 影像 信息 一个 像素 一个 像素 传输 舌头 上 压力 点上 ， 视觉 影像 转化 无数 压力 点 模式 。 大脑 却 很快 学会 正确 辨别 模式 。   2003 年 ， 韦恩 舌头 装置 ， 一个 球向 滚 ， 伸手 抓起 桌上 一杯 饮料 。 走 ， 门 ， 门框 。 舌头 东西 ！   实例 告诉 大脑皮层 灵活 ， 死死地 说 区域 主管 视觉 区域 语言 。 分工 人脑 基因 ， 大脑皮层 能力 远不止 。 大脑 模式 ， 模式 来自 不 ， 时间 上以 固定 方式 ， 大脑 感觉   3   。   大脑 记忆 解决问题   杰夫 · 霍金斯 大脑皮层 记忆 电脑 芯片 记忆 区别 ：   大脑皮层 存储 模式 序列   大脑皮层 以自 - 联想 方式 回忆 模式   大脑皮层 恒定 形式 存储 模式   大脑皮层 层级 结构 存储 模式   三个 杰夫 · 霍金斯 短 篇幅 下 ， \" 模式 \" 读者 理解 大脑 中 构建 理念 世界 模型 ， 前 三个 区别 大意 ， 大脑皮层 存储 记忆 模型 顺序 ， 大脑皮层 存储 记忆 模型 联想 功能 ， 大脑皮层 存储 记忆 模型 类似 柏拉图 讨论 理念 世界 模型 抽象 恒定 ， 实际上 同语 反复 ， 新造 一个 词语 恒定 表征 。   该书 第四章 太多 价值 东西 ， 恒定 表征 造 一个 新词 对人 头脑 中 理念 世界 泛泛 哲学 讨论 ， 前人 做 很多 很 ， 顺序 联想 不 计算机 记忆 模拟 。 机器 智能 人 智能 界限 不 在于 计算   1 + 1   ， 在于 理解   1   ， 很多 预先 假定 计算机   1   模型 推出 创造 能力 ， 殊不知   1   模型 本身 创造 能力 之上 。   大脑 做 事情 时时刻刻 都 预测   杰夫 · 霍金斯 该书 第五章 大谈 大脑 预测 能力 ， 说 房间 ， 实际上 都 一系列 默认 空间 扫描 序列 ， 时时 序列 中 下 一个 信息 作出 预测   4   。   走路 ， 会 预测 脚 ； 听歌 ， 会 预测 下 一个 音符 ； 听 别人 说话 ， 会 预测 会 听到   5   。   常驻程序 基于 现有 模型 序列 预测 功能 不 机器 智能 模拟 上 困难 。 大脑 预测 能力 活动 功能 一部分 ， 思考 智能 关键 。   新 大脑皮层 分层 结构   该书 第六章 杰夫 · 霍金斯 大篇幅 讨论 新 大脑皮层 分层 结构 ， 看得出来 作者 做 相关 资料 查阅 研究 工作 ， 生理 解剖学 上 东西 讨论 重点 ， 杰夫 · 霍金斯 新 大脑皮层 分层 结构 讨论 做出 更 简要 汇总 整理 ：   新 大脑皮层 纵向 分为 六层 ， 六层 细胞 垂直 柱 皮层 最 计算 单元 ：   六层 细胞 形态各异 ， 刺激 信号 兴奋 。 最小 计算 单元 计算 单元 发生 ：   新 大脑皮层 记忆 知识 建立 一种 庞大 网络 。   人 智能 暂且 不 讨论 ， 杰夫 · 霍金斯 人 大脑 工作 思考 很 价值 。 一句 简单 来说 ：   知行合一   。 换成 该书 话语 简要 描述 人 皮层 脑 大体 上 分层 结构 ， 信息 向上 流向 向下 流向 。 向上 流向 感知 ， 向下 流向 预测 。 杰夫 · 霍金斯 人 皮层 脑 信息 基本上 融为一体 ， 上 顶层 底层 单元 都 类似 结构 ：   单元 内部 都 恒定 表征 — — 常用 术语 来说 模型 。   模式 推导 出 因果 讨论 人 大脑 工作 这一 来说 不 大 ， 章节 内容 启发性 。   谈及 最小 计算 单元 该书 谈到 生物学 细节 ， 海马 组织 快速 模式识别 命名 细胞 负责 命名 价值 太 大 ， 功能性 类 细节 不 生物学 上 类比 。   人 大脑 统一 ， 一体 ， 知行合一 某种 宇宙 上天 融为一体 境界 ， 这说 很 直白 ， 看不到 现有 计算机 架构 可能性 。 上天 造 东西 很 很 简单 ， 显得 内部 东西 都 很 融洽 ， 很 美 ， 事实 确实 。 说道 玄学 上 细胞 底层 信息 DNA 信息 都 融为一体 ， 也就是说 说 ， 上 来说 计算机 两层 之间 信息 无缝 融合 都 。   很 作者 大谈 人 智能 创造力 提及 大脑 最小 神经 单元 ， 最小 概念模型 创造 概念 之上 。 谈及 人 智能 奥妙 不 在于   1 + 1   ， 在于   1   。 作者 谈及 大脑 分层 结构 ， 结构 下 放到 最小 那种 神经网络 反馈 结构 中 ， 恒定 表征 ， 或者说   1   。   1   模型 确实 具备 抽象 泛化 性质 ， 等同于 人脑   1   人脑 模型 ， 持 怀疑 态度 。   基于 进化史 四脑 分类   本文 结尾 笔者 还 想 加点 料 ， 大脑 一个 简单 进化史 描述 。   人类 宇宙 信息 都 历史 或者说 进化史 ， 大体 分为 三个 阶段 ：   神经系统 包含 信息 超过 基因 信息 — — 代表 个体 生存 很   皮层 脑 信息 超过 本能 脑 信息 — — 代表 程序 式   语言文字 信息 超过 大脑 信息 — — 代表 社会 文化 发展 个体 生存 还 。   大脑 中 神经细胞 某种 内在 统一性 ， 进化 阶段 专门化 四个 ：   一是 本能 脑 ， 死板 程序 式 ；   二是 皮层 脑 ， 近似于 自动 吸收 存储 信息 前期 程序 式 信息处理 ；   三是 额脑 ， 人 目的 ， 人 目的 制定 出 计划 ；   四是 情绪 脑 ， 目的 效益性 判断 。   本能 脑 负责 外部 接受 信息 ， 皮层 脑 负责 接受 信息 转化 为额脑 读懂 信息 ， 额脑 欲念 世界 。 还 一个 情绪 脑 ， 情绪 脑 作用 更 快速 执行 。 某种 情绪 激活 ， 一类 信息 会 特别 活跃 ， 做出 指定 对策 ， 执行 。 如果说 三个 调配 信息 ， 情绪 脑 调配 能量 。 总 能量 情况 下 ， 能量 利用 。   谈论 人 进化 会 特别强调 额脑 概念 。 直立人 发展 皮层 脑 ， 而智人 发展 额脑 。 正是 额脑 智人 直立人 区别 开来 。 额脑 语言 宗教 信仰 意志力 人 社会性 都 关系 。   额脑 皮层 脑有 区别 ？ 额脑 皮层 脑 靠近 额部 一块 进化 。 皮层 脑 ， 只活 。 接受 信息 ， 存储 ， 还 做 早期 简单 信息处理 工作 。 人 生活 ， 沉浸 世界 里 。 仅此而已 ， 脑中 唯一 非 现实 世界 创造 做梦 — — 皮层 脑神经 连接 随机 漫游 。   随机 漫游 证明 有用 ， 物种 带来 利益 ， 大脑 极度 兴奋 。 偶尔 意义 漫游 。 （ 直立人 发现 火 用处 ， 都 靠近 。 ）   而额脑 作用 控制 主动 创造 随机 漫游 。 思维 底向上 ， 从上向下 两种 思考 风格 ， 实际上 都 主动 随机 漫游 。   智 人 日益 进化 额脑 ， 积极主动 随机 漫游 ， 探求 ， 积极行动 。 活在 皮层 脑中 — — ， 活在 额脑 中 — — 未来 — — 或者说 一个 创造 主观 世界 之中 。   脚注   独自一人 思考 ， 外 ， 否认 智能 。   ↩   杰夫 · 霍金斯 赞同 这一 观点 ， 这是 一种 牛顿 物理学 兴起 机械 还原 主义 错误 。   ↩   意义 上 来讲 ， 蒙 卡斯尔 假说 后续 实验 都 支持 大脑 输入 信息 上 灵活性 ， 都 基于 面对 实验 智能 体 内部 先验 智能 ， 韦恩 是因为 大脑 内部 智能 存储 看 听 很多 智能 经验 ， 针对 特定 输入 模式 微小 调整 ， 韦恩 看 经验 听 经验 ， 不 舌头 去 看 舌头 去 听 。   ↩   关注点 扫描 序列 很多 因素 相关 ， 文化 相关 。 常说 中国 人 习惯 看 总体性 东西 。 总体 根于 局部 ， 中国 人 扫描 序列 。 想 中国 字 西方 识别 字母 关系 。 西方 几个 字母 辨认 才 单词 ， 中国 字 识别 一种 笔画 式 框架 式 。   ↩   会 预测 错误 ， 好奇心 挑逗 。   ↩",
            "tags":"notes",
            "url":"articles/ren-gong-zhi-neng-de-wei-lai-yue-du-bi-ji.html"
        },
        {
            "title":"人身上具有神性",
            "text":"人 身上 某种 神性 ， 神性 来自 宇宙 本身 ， 人 归根结底 宇宙 一部分 ， 神性 人 宇宙 某种 律动 需求 。 中国 人 更 熟悉 词汇 天人合一 精神 需求 。   机器学习 算法 都 给定 一个 标签 ， 就算 将来 高级 机器人 智能算法 ， 给定 机器人 一个 目的 。 机器人 动物 某种 目的 效益 解释 ， 设计 多种 机器 智能 类似 动物 。 人 机器 智能 区别 在于 人能 创造 — — 创造 局限 数据 层面 层面 创造 ， 将来 几千年 后 机器 智能算法 模拟 。 人 机器 智能 最 核心 区别 人 创造 意义 ， 未来 几万年 更 远 未来 ， 机器 智能 创造 意义 ， 请 人类 公民 身份 ， 人 智能 无 区别 ， ， 神性 ， 宇宙 上 天大 计划 一部分 。   正是 人 智能 创造 意义 ， 更 具体来说 ， 目的 追寻 ， 目的 本身 意味着 意义 ， 基于 天人合一 内在 精神 需求 ， 宇宙 发展 角度 出发 ， 某种 美学 角度 出发 ， 更 底层 不 谈及 不 自觉 大脑 活动 ， 创造 活动 ， 最小 理念 模版 ， 起源 原型 ， 变种 原型 再 加工 再 创造 ， 内在 精神 需求 — — 看起来 最 乏善可陈 人 身上 不 例外 — — 都 人 谈及 神性 。   人 创造 活动 要素 都 先起 始于 一个 现实 中 原型 ， 再 修改 加工 ， 解构 重组 。 后续 工作 ， 最 起源 原型 变种 类似 进化树 ， 变异 创造 活动 作者 世界观 架构 中 都 变种 作者 创造 世界 中 融洽 。   谈及 现实 原型 更 确切 表述 起源 原型 ， 最 原型 人 创造 。 并不比 变种 创造 多出 某种 现实性 。 现实 评判 约束 人 创造 活动 不 理解 人 创造 活动 ， 现实 转眼 即逝 特性 显得 很 之外 ， 理解 现实 本身 人 创造 能力 上 。   起源 原型 很多 便利 ： 更 易于 别人 接受 ， 创造 消耗 精力 少 基本上 从外 世界 现有 原型 中 抽取 而成 ， 外 世界 本身 一个 融洽 体系 ， 起源 原型 内部 组件 融洽 。   起源 原型 再 创造 变种 原型 一个 很 消耗 精力 活动 ， 内部 组件 要素 很难 融洽 协调 。 创造 一个 成功 变种 原型 会 一件 很 事 ， 不 避讳 词 ， 创造 正是 人之为 人 处 。",
            "tags":"thought",
            "url":"articles/ren-shen-shang-ju-you-shen-xing.html"
        },
        {
            "title":"xeCJK宏包中的某些特殊字符显示",
            "text":"排版 pdf 希望 显示 周易 六十四 卦 ䷀ 字符 ， 大概 找 好久 才 发现 DejaVu   Sans 字体 周易 六十四 卦 字符 ， 本来 打算 常规 调 字体 方式 显示 字符 ， 却 发现 效果 ， 估计 区块 字符 划分 CJK 字符 ， xeCJK 宏包   xeCJK 提供   \\ CJKfontspec   命令 确实 起到 效果 ， 六十四个 卦 六十四 字符 ， 单独 写 命令 newunicodechar 封装 都 很 好 解决方案 ， newunicodechar xeCJK 宏包 之间 协调 。   仔细阅读 xeCJK 宏包 文档 确认 解决方案 ：   xeCJK 宏包 提供   xeCJKDeclareSubCJKBlock   定义 一个 字符 区块 ：   \\ xeCJKDeclareSubCJKBlock   {   LIUSHISIGUA   } {   \" 4DC0   - >   \" 4DFF   }   设置 CJK 字体 单独 指定 一个 字符 区块 字符 字体 ：   \\ setCJKmainfont   [ LIUSHISIGUA = DejaVu   Sans ]   {   Source   Han   Serif   CN   }   tex 文档 复制粘贴 ䷀ 字符 显示 。",
            "tags":"others",
            "url":"articles/xecjkhong-bao-zhong-de-mou-xie-te-shu-zi-fu-xian-shi.html"
        },
        {
            "title":"周易摇卦小程序",
            "text":"摇卦   摇卦 先 静心 ， 问 所求 疑问 事 。   测一卦   原文   解卦   变卦 原文   变卦 解卦   测一卦 ...   测一卦 ...   ​   测一卦 ...   测一卦 ...   信息   周易 相关 资料 整理 批判 思考 汇集 成一 本书 ， 查阅 参考 。   项目 Github     。",
            "tags":"tools",
            "url":"articles/zhou-yi-yao-gua.html"
        },
        {
            "title":"texmaker",
            "text":"texmaker 很 喜爱 编写 tex 文档 时 编辑器 ， 配置 都 直观 易用 ， 本文 列出 读者 不 小 技巧 。   善用 向导 菜单   向导 名字 误导 ， 人 向导 功能 。 向导 菜单 功能 都 很 有用 ， 提供 对话框 选项 功能 快速 生成 tex 代码 片段 ， 表格 向导 一个 快速 生成 表格 tex 代码 工具 ， 很 好 。   自定义 快速 输入 片段   自定义 菜单 自定义 标签 ， 选择 编辑 自定义 标签 ， LaTex 内容 输入 tex 代码 片段 ， 一个 表达 ：   % Verbatim   将会 展开 ：   \\ begin   {   Verbatim   }   •   \\ end   {   Verbatim   }     •   符号 ， 占位 符 ， 代码 片段 输出 文档 中 光标 将会 。 不用   % Verbatim   表达 写 上 tex 代码 片段 效果 都 。   •   符号 写作   @   。   自定义 标签 快捷键   Shift + F1   。   左边 面板 一栏 自定义 ， 定义 任意 数量 代码 片段 ， 写法 讨论 类似 ， 快捷键 ， 支持 一种 风格 快捷 输入 ， 写 上 ：   \\ begin   {   framed   }   @   \\ end   {   framed   }   按键 写 上   framed   ， 文档 中 输入   : framed   ， 按下 方向键   - >   ， 代码 片段 会 自动 展开 ， 很 。",
            "tags":"editor",
            "url":"articles/texmaker.html"
        },
        {
            "title":"我在游戏分类上的讨论",
            "text":"游戏 分类 一个 统一 标准 ， 游戏 分类 很 模棱两可 ， 就算 分类 上 模棱两可 游戏 ， 合适 标注 ， 选择 游戏 很大 参考 意义 。   游玩 角度 出发 ， 分类 ， 公认 ， 游玩 角度 出发 分类 。   Action 动作类   游戏 分类 一个 分类 ， 谈论 FPS 游戏 大部分 动作游戏 都 分类 ， 游玩 类 游戏 一个 共同点 游玩 实时 游戏 情景 变化 实时 做出 一系列 动作 ， 类型 动作 游玩 过程 中 占据 很大 比重 。   刺客 信条 系列 ， 生化危机 系列 ， 无主之地 系列 ， 质量 效应 系列 ， 古墓 丽影 系列 ， 巫师 系列 ， 羞辱 系列 都 归于 动作类 。 不 一一列举 。   Card 卡牌 类   类 游戏 一个 很 套牌 游玩 ， 类 游戏 很 好 分类 。   炉石 传说   昆特 牌   Drama 戏剧 类   类 游戏 本来 归于 Other 类 不便 归类 ， 游戏性 角度 出发 类 游戏 解密 动作 都 会 带 一点 都 该游戏 最 ， 该游戏 最 更 去 讲述 一个 故事 。   奇异 人生   瘟疫 传说   Hellblade :   Senua ' s   Sacrifice   Indie 独立 游戏   加上 独立 游戏 分类 会 发现 很 难 分类 小游戏 都 归于 此类 ， 实在 省 分类 一点 心 。 类 评分 太高 ， 归于 独立 游戏类 游玩 评分 还 提高 一点 。 独立 游戏 定义 稍微 模糊 ， 游戏 大厂 小 团队 会 开发 小游戏 ， 独立 游戏 分类 立在 ， 游玩 体验 上 独立 游戏 某种 共性 。   去 月球   杀戮 尖塔   塔 罗斯 法则   a   story       uncle   baba       奥日 系列   坎 巴拉 太空 计划   Rimworld   星露 谷物 语   FTL   晶体管       breach   darkest   gungeon   Moba 类   Dota   英雄 联盟   风暴 英雄   SMITE   Other 类   游戏 实在 不好 分类 只好 归于 Other 类 ， 辐射 4 ， 骑马 砍杀 ， 上古 卷轴 5 。 类 游戏 不 归于 动作类 是因为 类 游戏 最 核心 游戏 中 情景 动作 ， 更 带有 某种 模拟 氛围 性质 ， 简单 归于 模拟游戏 类 ， 相 某种 单纯 针对 主题 模拟游戏 一点 RPG 要素 ， 说 这类 游戏 归于 沙盒 类 ， 暂时 列为 Other 类 。   Puzzle 解密 类   游戏 解密 类 游戏 ， 游戏 一点 动作 成分 成分 不大 归于 解密 类 ：   portal2   RTS 即时战略 类   类 游戏 一个 2.5 d 视角 下 操作 单个 多个 角色 建筑 即时 建造 活动 。   星际争霸 系列   魔兽争霸 系列   帝国时代 系列   Simulator 模拟器 类   游戏 一眼 看 归于 模拟器 类 ， 游戏 带有 一点 动作 要素 ， 游戏 主题 来说 ： 去 模拟 某种 情景 。     hunter :   call       wild   Farm   Simulator   Strategy 策略 类   策略 类 战术 类 一并 讲 ， 策略 类 游戏 一个 玩家 某种 长时间 策略 规划 类 游戏 。 战术 类 游戏 针对 一场 几场 玩家 头脑 风暴 。   群星   冰汽 时代   文明 系列   Tactical 战术 类   神界 原罪 系列   Beat ' emup 都 打倒 类   都 打倒 类 游戏 清场 游戏 ， 类 游戏 一个 主题 游玩 一个 地图 一个 地图 怪物 清场 活动 。 不 喜欢 暗黑 破坏神 类 游戏 标注 动作 角色扮演 游戏 ， 类型 游戏 最 核心 。   暗黑 破坏神 系列   恐怖 黎明   合金弹头 系列   火炬 之光   泰坦   darksides 系列",
            "tags":"game",
            "url":"articles/wo-zai-you-xi-fen-lei-shang-de-tao-lun.html"
        },
        {
            "title":"克里克",
            "text":"克里克 独自 面对 眼前 堆积如山 文献 遐想 ， 还 研究生 论文 素材 。 想 老爹 没想到 克里克 考上 研究生 ， 克里克 研究生 快要 读完 ， 克里克 几年 研究 中 确实 学到 不少 东西 ， 原本 那种 内向 气质 上 加上 少许 木讷 ， 看上去 更 学者 味道 。 再 克里克 陷入 沉思 。   就读 观察 晶石 观察 文献 专业 ， 观察 晶石 几千年 前 人类 最 发现 ， 发现 散落 宇宙 中 晶石 ， 晶莹剔透 ， 时不时 会 透出 景象 。 时间 空间 地点 未知 ， 观察 景象 呈现出 一种 迷雾 般的 神秘 。 不为 人 关注 ， 早期 一代 一代 学者 做 针对 观察 晶石 中 景象 观察 记录 工作 ， 一千年 前 ， 距离 观察 晶石 发现 两三千年 ， 学者 艾伯特 浩瀚 史料 中 ， 时代 ， 观察 晶石 相关 文献 成 史料 记载 。 发现 观察 晶石 景象 无 意义 幻象 ， 呈现 大 宇宙 中 无数个 小 宇宙 中 某处 发生 景象 ， 提出 一种 假说 ， 光 景象 信息 大 宇宙 中 会 传递 ， 传递 遵从 某种 宇宙 时空 规律 ， 观察 晶石 无意 中 捕捉到 光 景象 。   发现 学者 艾伯特 假说 反证 ， 观察 景象 一个 都 科技 上 超过 时代 ， 时代 地方 发生 事情 。 学术界 对待 观察 晶石 景象 ， 各种各样 研究 专业 ， 观察 文献 专业 算是 一个 热门 专业 。 针对 景象 中 历史文献 标的物 ， 汇总 整理 信息 试图 完整 复现 历史文献 。 观察 晶石 研究 专业 说来 一门 历史 学科 ， 学者 艾伯特 做 突破性 贡献 在于 ， 历史 史料 中 出 大 宇宙 运行 规律 。 大 宇宙 运行 规律 ， 再 定向 观察 历史 景象 时代 即将 发生 事情 做出 更好 预测 判断 。 讨论 涉及 数学公式 克里克 一知半解 ， 大概 宇宙观 学者 艾伯特 发生 改变 ， 宇宙 中 一个 信息 景象 都 相互 关联 ， 观察 晶石 中 不起眼 事件 会 一个 观察 晶石 一个 重大事件 。   克里克 想 研究课题 ， 研究课题 中古时代 学者 写 著作 ， 著作 讨论 皇帝 皇后 妻妾 数量 之间 关系 学问 。 老实 说 克里克 不 著作 重要性 可言 ， 导师 课题 ， 不管怎么 说 复现 这本 文献 就算 研究课题 ， 更 深刻 含义 加 分项 。   克里克 研究课题 相 算 简单 ， 来看 观察 晶石 呈现 学者 写得 这篇 文献 前 几页 来看 ， 语言 宇宙 中古 英语 变种 034 号 。 克里克 运气 好 ， 人 很 面对 一个 未知 变种 型号 ， a 符号 成 奇怪 符号 ， 更 糟糕 差异性 更大 ， 偏离 宇宙 中古 英语语法 都 ， 成 未知 语言 ， 还 找 观察 晶石 语种 研究 人员 去 帮忙 。   研究生 毕业 课题 简单 一点 ， 克里克 心想 。 不 意味着 克里克 高枕无忧 睡大觉 ， 完整 复现 观察 晶石 中 一本 文献 一项 繁重 工作 ， 研究 人员 翻阅 观察 晶石 研究 同仁 著作 论文 。 会 意外 发现 观察 晶石 历史 资料 中 ， 恰恰 学者 书写 这篇 著作 几页 景象 ， ， 观察 晶石 学 标准 论证 方法 去 证明 两段 观察 晶石 景象 相关性 。   观察 晶石 景象 宇宙 次元 标的 ， 时空 标的 ， 一个 新 观察 晶石 做 第一个 工作 加上 宇宙 次元 标的 时空 标的 。 说 标的 描述 景象 真实 宇宙 次元 时空 所在 ， 大致 参考 。 具体来说 针对 观察 晶石 中 景象 一个 细节 扫描 ， 涉及 专业 资料 分析 索引 ， 好 基本上 标准化 程序化 ， 新 观察 晶石 景象 ， 克里克 只 国际 通用 程序 扫描 即可 。 一个 新 观察 晶石 景象 都 会 自动 上 传到 国际 晶石 学术研究 资料库 ， 保证 程序 扫描 分析 宇宙 次元 时空 标的 完全正确 ， 研究 人员 资料 分析 纠错 工作 ， 克里克 来说 资料库 说 宇宙 次元 时空 标的 ， 。   克里克 第一步 整理 工作 ， 中古时代 学者 生平 景象 汇总 ， 克里克 做 完 。 克里克 查看 毕业论文 第一章 工作 。   学者 写 第二部 著作 ， 克里克 研究课题 《 皇帝 妻妾 数量 还 发表 一部 著作 ， 上古时代 奴隶 角斗场 ， 大概 讨论 上古时代 奴隶 角斗场 上 表现 地位 分层 ， 克里克 半点 兴趣 ， 实际上 研究课题 这本 著作 没什么 兴趣 。 第一章 工作 整理 汇总 ， 大概 简单 这部 著作 说 ， 大概 皇帝 谨慎 选择 妻妾 数量 ， 太 少 ， 太 。 太 少 不足以 彰显 皇家 威严 ， 太 会 早期 皇帝 精力 ， 床上 生活 上 过于 内耗 ， 无暇 好 政事 ， 危及 国家 安危 。   克里克 翻阅 写 好 论文 ， 第二章 后世 学者 针对 学者 著作 讨论 ， 补全 著作 。 这部分 克里克 基本上 写 完 。   克里克 往下 翻 ， 停止 鼠标 滚动 ， 第三章 算是 困难 ， 提到 观察 晶石 景象 宇宙 次元 时空 标的 ， 定位 准确 。 比如说 克里克 两个 学者 写作 第一章 序言 景象 ， 两个 景象 第一章 序言 文字 不尽相同 ， 研究者 做出 解释 。 克里克 写道 ：   \" 两个 景象 文字 对比 来看 ， 行文 含义 ， 辞藻 表述 上 差异 ， 认定 两个 版本 两个 宇宙 两个 变种 版本 宇宙 中 作者 做出 表述 都 。 \"   克里克 站 起身 活动 身子 ， 就要 面对 一个 难点 。 学者 第二章 里 一段 文字 中 差异 ， 第一个 景象 写道   图库 纳斯 国王 皇帝 妻妾 数量 过少 大臣 宰相 娶 妻妾 ， 皇帝 心怀不满 ， 参考资料 46 5 章 论述 佐证   ， 第二个 景象 写道   图库 纳斯 国王 皇帝 妻妾 数量 过多 疏于 政务 大臣 宰相 心怀不满 ， 参考资料 46 5 章 论述 佐证   。 这是 来自 两个 宇宙 次元 作者 写作 景象 ， 表述 差异 很大 ， 不 影响 两个 宇宙 次元 作者 写作 这本 著作 大 思想 表述 ， 参考资料 46 图库 纳斯 国王 讨论 截然不同 论证 。   克里克 写道 ： \" 图库 纳斯 国王 参考资料 23 论述 一个 勤于 政务 皇帝 ， 后 一个 景象 某种 宇宙 变种 ， 参考资料 23 3 章中 论述 ， 宇宙 次元 景象 标志性 差异 现象 观察 晶石 景象 XB120221 中 描绘 贪狼星 亮度 徒增 现象 ， 宇宙 次元 主流 宇宙 次元 差异 ， 图库 纳斯 国王 性情大变 ， 变得 纵欲 荒废 政务 。 \"   克里克 写道 ： \" 观察 晶石 景象 CZ501051 中 作者 基尔 纳斯 写作 针对 参考资料 46 引用 上 差异 显示 观察 晶石 景象 处于 观察 晶石 景象 XB120221 一个 宇宙 次元 轻微 变种 中 。 \"   克里克 伸 伸懒腰 ， 满意 地扫 一遍 刚才 写 东西 ， 写 差不多 ， ， 娱乐 一把 打会 游戏 。",
            "tags":"novel",
            "url":"articles/ke-li-ke.html"
        },
        {
            "title":"古墓丽影崛起女巫洞窟攻略",
            "text":"本文 古墓 丽影 崛起 ， 女巫 洞窟 ， 芭芭雅 ： 女巫 神庙 攻略 ， 讨论 两个 难点 。   利用 绳索 洞窟 内部   先射 对面 滚轮 ， 固定 滚轮 ， 再射 对面 滚轮 固定 旁边 固定 柱上 ， 调整 好 两个 平台 高度 ， 好 爬 右边 高 地上 。   爬 右边 高地 射 滚轮 ， 固定 高 地上 滚轮 ， 人 滑下去 。   再射 对面 滚轮 ， 固定 滚轮 ， 再射 对面 滚轮 固定 旁边 固定 柱上 ， 这次 调整 两个 平台 高度 右边 高 地上 左边 高 地上 。   对面 小 平台 ， 跳 绳索 上 ， 等到 右边 高地   转 右边 高地 滚轮 ， C 脱离 ， 过程 快 跑 ， 跳 平台 ， 跑 左边 高地 ， 跳 平台 ， 跳 爬上去 。   BOSS   最 核心 打法 站 滚轮 旁 ， 射 BOSS 飞船 ， 滚轮 自动 BOSS 拉过来 【 一层 不用 射箭 ， 二层 三层 BOSS 射一箭 ， 不 射准 ， BOSS AI ， 一射 ， 躲起来 ， BOSS 烧 绳子 】   拉过来 ， 打开 锅炉 盖 ， 烧 BOSS 。 最 关键 点 ， 清 小兵 不用说 。   一层 两个 烧 完 ， 上 二层 ， 二层 两个 烧 完 ， 做 平台 转 。   三层 一个 ， 坐 最高层 转 平台 ， 平台 一个 小 隔间 E 就行了 。",
            "tags":"game",
            "url":"articles/gu-mu-li-ying-jue-qi-nu-wu-dong-ku-gong-lue.html"
        },
        {
            "title":"巫师1讲了一个什么故事",
            "text":"巫师 1 一个 游戏 快 过时 ， 巫师 1 剧情 回想起来 真的 很少 游戏 比肩 ， 剧情 做 巫师 3 都 还好 。 巫师 1 究竟 讲 一个 故事 ， 越玩到 越 引人入 深 不能自拔 。   故事 开篇 ， 承继 巫师 小说 系列 ， 白狼 稻草 叉 捅 半死不活 失忆 维瑟 米尔 艾 斯卡尔 救 走 拖 回到 凯尔 莫罕 。   经典 失忆 桥段 算不上 一个 亮点 ， 很多 游戏 二代 三代 都 会 主角 失忆 ， 主角 重做 设定 ， 这是 游戏 主角 一个 从零开始 慢慢 变强 过程 ， 巫师 1 一个 游戏 一代 做 承继 小说 剧情 。   正 游戏 要素 ， 主角 技能 操作 炼金术 实际上 剧情 关系不大 ， 游戏 游戏性 设计 ， 简单 略过 不谈 。   巫师 1 剧情 是从 一群 人 围攻 凯尔 莫罕 ， 凯尔 莫罕 实际上 围攻 ， 凯尔 莫罕 建筑设计 上 很多 地方 都 保留 一种 残破 迹象 。 这群人 围攻 ， 这群人 ？ 围攻 凯尔 莫罕 ， 目的 ？   特莉丝 对话 为首 一个 很 强大 术士 名叫 萨 弗拉 ， 会 这群人 火 蜥蜴 帮 。 萨 弗拉 召唤 一个 很大 巨魔 螳螂 ， 很快 突破 凯尔 莫罕 大门 。 特莉丝 很 困惑 ， 凯尔 莫罕 价值 东西 ， 猎魔 特莉丝 隐瞒 ， 进攻者 目的地 凯尔 莫罕 地下 实验室 。 实验室 秘密 物品 ， 秘密 物品 猎魔 人 变异 ， 会 火 蜥蜴 帮 利用 制造 一种 新 变种 人 。   序章 基本上 一个 引子 ， 剧情 上 留下 更 疑问 ， 剧情 发展 最终 指向 基本上 围绕 引子 展开 ， 这是 疑问 。   猎魔 人 大本营 人 攻打 ， 还 忍 ， 接下来 去 追查 ， 丢失 东西 找 回来 。   故事 第一章 维吉玛 郊外 开篇 一个男孩 夏妮 一群 魔兽 追杀 ， 三个 角色 剧情 上 都 ， 男孩 叫亚汶 ， 基本上 贯穿 剧情 最 核心人物 ， 种种 迹象 来看 ， 亚汶 大 反派 。 游戏 剧情 来看 ， 杰洛特 亚汶 对话 影响 杰洛特 大 反派 — — 蔷薇 玫瑰 骑士团 大师 — — 对话 。 游戏 说 ， 基本上 假定 ， ， 玄之又玄 时空 穿越 都 解释 。 大 反派 大师 早就 ， 才 杰洛特 亚汶 ， 亚汶 大师 ， 亚汶 大师 ， 大师 亚汶 ， 都 不可思议 能力 ， 作者 解释 ， 读者 阅读 中 感受 ， 却 无法解释 。 这是 作者 剧情 设计 上 很 超 一点 ， 好 一点 ， 一个 主观 世界 架构 ， 感知 外围 验证 理解 很 。 剧情 发展 走向 蒙 上 一种 神秘感 吸引 人 感觉 。   第二个 角色 夏妮 都 懂得 ， 杰洛特 老朋友 ， 剧情 发展 中 扮演着 角色 。 第三个 角色 魔兽 ， 魔兽 词条 实际上 说 很 ， 魔兽 人心 腐化堕落 之地 ， 小 村落 会 一点点 揭开 表面 宁静 村落 内在 人心 腐化堕落 。 游戏 杰洛特 这章 再 回到 村落 。 游戏 设计 上 简化 ， 几章 来看 ， 一章 内 几个 地图 切换 不成问题 ， 更 解释 ： 杰洛特 再也 不想 回到 恶心 人 地方 。   该作 剧情 设计 多么 好 ， 游戏 正式 第一章 第一个 画面 透露 出 信息 。 第一章 意义 上 来讲 过多 推进 主线 ， 追查 火 蜥蜴 帮 。 本章 找到 火 蜥蜴 帮 村落 一个 小 巢穴 ， 信息 很多 。 是因为 玩家 还 一个 慢慢 熟悉 游戏 操作 过程 ， 并不需要 马上 推动 主线 带来 玩家 情绪 上 紧张感 ； 第二 叙述 上 起承转合 ， 正 处在 一个 承接 引子 阶段 ， 不 太 突发事件 ； 是因为 调查 角度 入手 太多 进展 。   第一章 过多 推进 主线 ， 第一章 很多 环境 渲染 上 玩家 世界 感知 。 引入 一个 猎魔 人贝连 加尔 ， 贝连加尔 变种 猎魔 人 厌恶 反思 提高 游戏 剧情 深度 ； 引入 人类 非人类 种族 冲突 ； 引入 亚汶 神奇 男孩 ； 引入 永恒 之火 ， 蔷薇 玫瑰 骑士团 。   亚汶 值得 ， 游戏 选择 上 杰洛特 选择 亚汶 交给 永恒 之火 教士 ， 蔷薇 玫瑰 骑士团 ， 永恒 之火 武装 组织 ， 武装 组织 提及 大师 创建 ， 假定 ， 剧情 作者 假设 选项 ， 亚汶 永恒 之火 慢慢 抚养 下 成长 永恒 之火 蔷薇 玫瑰 骑士团 大师 。 称之为 bug ， 作者 明说 大师 亚汶 ， 背后 之间 千丝万缕 ， 大师 亚汶 佩戴 护身符 ， 亚汶 希里 上古 之血 能力 ， 穿越时空 能力 。 亚汶 希里 都 末世 预言 ， 大师 实际上 做 事情 度过 末世 ， 最终 希里 消灭 末世 冰霜 。 巫师 3 希里 穿越时空 能力 局限 空间 穿梭 ， 时间 穿越 概念 。 欣赏 。 强行 要说 亚汶 大师 ， 那亚汶 时间 穿越 最 bug 那种 时间 穿越 ， 时间 穿越 过程 中 长大 ， 一个 时 空中 多种 时间 线 形态 。 好 作者 说亚汶 大师 ， 归于 神秘色彩 。   第一章 女巫 角色 很 ， 正 雪崩 之下 ， 雪花 无辜 。 细心 去 看 ， 女巫 雅比 盖尔 角色 实际上 很多 地方 事情 做 不 地道 ， 明明 人买 药水 干什么 ， ， 只 负责 卖 药水 ； 很多 地方 引诱 利用 杰洛特 。 最终 选择 保护 女巫 ， 魔兽 杀 ， 全村 人 屠 。 做 ， 想起 贯穿 巫师 小说 最 经典 对白 ：   Evil     Evil .   Lesser ,   greater ,   middling …   Makes     difference .   The   degree     arbitary .   The   definition ' s   blurred .   If   I ' m     choose       evil     …   I ' d       choose     . \"   最终 杰洛特 玩家 选择 ， 没 办法 置身 之外 ， 再 做 一个 巴尔 维坎 屠夫 。   第一章 主线 实际上 杀 魔兽 ， 围绕 杀 魔兽 揭开 村子 不为人知 黑暗面 。 最终 杰洛特 带 内心 厌恶 一丝 线索 维吉玛城 。   第二章 设计 很 有意思 ， 单独 来看 都 一个 不错 侦探 故事 ， 杰洛特 主线 去 追查 火 蜥蜴 帮 头目 ， 找到 侦探 雷蒙德 帮忙 ， 雷蒙德 列出 一大 串 嫌疑犯 清单 ， 置身 维吉玛城 势力 ， 游走 奔波 ， 最终 发现 竟然 远在天边 近在眼前 雷蒙德 找 火 蜥蜴 帮 头目 阿扎 。 游戏 年头 ， 前前后后 跑 路 人 厌倦 ， 剧情 来说 ， 不看 攻略 ， 不 看 对白 ， 玩家 怀疑 错人 付出代价 ， 设定 很 有意思 。   第二章 第三章 再合 讨论 ， 本来 一个 大 地图 上 ， 再 单独 去 分析 子 ， 会 发现 人物 设计 性格 鲜明 ， 最 印象 深刻 文森特 · 梅斯 卡门 故事 ， 本来 文森特 · 梅斯 城镇 守卫 一种 严肃 死板 感觉 ， 刚 接触 卡门 一个 简单 保护 妓女 免遭 骚扰 故事 ， 游戏 设计 一两个 完 。 没想到 文森特 卡门 一段 地下 情 ， 一个 城镇 守卫 一个 高等 妓女 ， 。 没想到 文森特 竟然 一个 狼人 ， 剧情 发展 ， 杰洛特 面临 一个 两难 境地 ， 猎魔 人 天职 杀掉 怪物 狼人 ， 卡门 竟然 不 嫌弃 文森特 狼 人 ， 希望 解除 狼 人 诅咒 。 杰洛特 帮 卡门 忙 【 奖励 繁琐 程度 真的 投入 回报 不成比例 ， 想 玩家 推进 内心 正义感 善心 ， 游戏 乐趣 】 来回 奔波 ， 终于 文森特 卡门 放下 成见 接受 。 故事 单独 一个 短篇小说 都 不错 有趣 ， 留下 很 深 印象 。   第二章 第三章 主线 推进 很多 ， 最终 第三章 结尾 会 杀掉 二号 反派 【 序章 得来 感觉 】 教授 。 还 会 获知 公主 雅坦 参与 。 松鼠 党 骑士团 之间 矛盾 跃然纸上 ， 分支 很 有趣 不 一一 谈论 。   剧情 第四章 会 发现 主线 推进 变慢 ， 故事 设计 起承转合 原则 ， 先 推进 主线 ， 氛围 热烈 ， 又会到 一个 平缓 期 。 第四章 平缓 期里 ， 几个 关键 东西 ： 一是 亚汶 ， 第四章 亚汶 对话 影响 剧情 ， 简单 来说 亚汶 大师 ， 亚汶 对话会 影响 大师 对话 。 二是 松鼠 党 绑架 亚汶 ， 接受 骑士团 仇恨 松鼠 党 ， 松鼠 党 游戏 剧情 事件 角色 变得 越来越 ， 第五章 游戏 剧情 大 背景 — — 松鼠 党 作乱 。 杰洛特 面对 面对 松鼠 党 ， 再 ， 选择 玩家 手中 ， 松鼠 党 松鼠 党 对立面 都 说 谁错 ， 观点 ， 松鼠 党 太 过于 激进 ， 一刻 某种 感情 上 不得不 同情 人 ， 第四章 山洞 里 见到 松鼠 党 悲惨生活 现状 。   第五章 剧情 解决 头号 大 反派 阿扎 解决 公主 雅坦 麻烦 。 阿扎 没什么 好 说 ， 剧情 最 都 头号 大 反派 ， 第五章 最终 才 最终 大 BOSS 骑士团 大师 。 公主 雅坦 ， 人物 个性 上 来说 ， 公主 雅坦 在政治上 喜欢 胡作非为 很 ， 作者 剧情 上 引入 公主 雅坦 更 一种 回温 ， 那篇 短篇小说 《 逐恶 回温 。   最终 章 直面 最终 大 BOSS 大师 ， 这本 意外 ， 大部分 游戏 最高潮 都 会 面临 一个 大 反派 ， 巫师 1 最终 章有 两个 点 设计 好 ： 一是 亚汶 世界 上 很多 事情 讨论 最终 影响 大 反派 世界观 ， 游戏 整体性 提升 一个 档次 ， 玩家 游戏 游玩 过程 思索 重温 。 二是 杰洛特 登上 山顶 面对 大 BOSS ， 会 一路 人来 ， 让玩家 内心 温暖 ， 玩家 游戏 游玩 过程 重温 。   说 一个 游戏 剧情 起承转合 最终 会 迎来 一个 高潮 ， 高潮 过后 ， 玩家 久久 释怀 ， 游戏 玩完 好像 内心 留下来 点 。 巫师 1 无疑 上 做 好 。 游戏 高潮 ， 登山 顶 老朋友 都 最终 大 BOSS 这段 。 实际上 巫师 3 打狂 猎 还会 ， 设计 真的 好 ， 游戏 整体性 更强 ， 游戏 剧情 游玩 体验 都 融为一体 。   巫师 1 剧情 设计 上 优秀 出色 ， 有人 说 CDPROJECT 出道 巅峰 认同 。 本文 浅尝辄止 讨论 ， 笔者 游玩 过程 回味 。",
            "tags":"game",
            "url":"articles/wu-shi-1jiang-liao-yi-ge-shi-yao-gu-shi.html"
        },
        {
            "title":"多个行星中某些会采用不同的历法",
            "text":"小时 定义 物理 范畴 ， 行星 都 通用 ， 改变 。   基于 时间 建立 历史 事件 刻度 统一 。 说 时间 点 地方 发生 事件 ， 时间 点 在历史上 不 似 物理学 上 严苛 ， 歧义 。   讨论 超过 太阳系 ， 年 定义 争议 ， 年 总 定义 地球 绕 太阳 一周 时间 。 说 公元 3066 年 某某某 出生 ， 大体 都 这是 地球 上 居民 公认 那种 历法 时间 计算 。   讨论 超过 太阳系 ， 人 会 说 星系 都 会 年 概念 ， 不大可能 ， 年 概念 历史 表述 太 过于 ， 星系 行星 很 接近 太阳系 ， 类地行星 居民 人数 超过 地球 ， 行星 都 采用 地球 计年法 。 将来 地球 不 ， 地球 计年法 会 某种 文化遗产 天文学 定义 固定 而全 星系 通用 。 想象 文化圈 人 ， 基于 语言 最简 表述 原则 ， 表达 某某 科学家 出 生于 公元 3066 年 ， 啰啰嗦嗦 说 一大堆 东西 。   再 讨论 天 定义 ， 就要 提及 一点 因素 ， 地球 白天黑夜 概念 近似于 一种 文化 术语 ， 一个 人 说 起床 工作 总 假定 时间 早晨 ， 说 中午 吃 中饭 假定 白天 工作 时间 正 中午 。 对此 举证 宇航员 作息时间 工作 8 小时 ， 起床 早餐 工作 中餐 工作 休息 生活习惯 都 改变 。   星系 类地行星 ， 类地行星 居住 居民 ， 上 讨论 生活 时间 概念 会 变得 很 ， 说 早上 太阳 当地 早上 ， 说 晚上 太阳 落下来 当地 晚上 ， 推之 ， 当地 概念 当地 类地行星 自转 定义 。 星系 类地 星系 或者说 天 那种 文化 含义 意义 ， 会 地球 类地行星 公用 天 定义 。   下 ：   年 定义 地球 计年法 【 文明 不 地球 文明 不 讨论 ， 采用 核心 行星 计年法 】   天 定义 类地行星 本地 天 定义 ， 地球 差异 ， 天 白天黑夜 概念 很 模糊 ， 采用 类似 文化圈 核心 类地行星 天 定义 。   年 定义 唯一 ， 当地 天 定义 多样 ， 阿西莫夫 一个 银河 标准 时间 ， 同意 ， 诸多 行星 会 自转 速率 日夜 颠倒 不便 ， 不 同意 。 实际上 想 地球 上 时区 概念 ， 当地 时区 概念 照顾 当地 居民 白天 文化 概念 。   推断 行星 间会 多种 历法 。 历法 建立 中心 类地行星 名字 命名 ， 川陀 ， 会 一个 当地 川 陀 历法 。 历法 一年 天数 等于 川陀星 地球 年内 自转 圈数 ， 历法 几月 几号 概念 ， 还 不大 确切 新 历法 会 确立 。",
            "tags":"thought",
            "url":"articles/duo-ge-xing-xing-zhong-mou-xie-hui-cai-yong-bu-tong-de-li-fa.html"
        },
        {
            "title":"我是存在的",
            "text":"  思考 起点 承认 认知 边界 ， 有限 生命 ， 目光 人类 认知 领域 内 ， 一个 圆圈 ， 圆圈 外 都 不 可知 领域 。 不 可知 领域 并不一定 感知 ， 感知 验证 短期内 不 可知 领域 。   不 可知 领域 内部 ， 很大 一部分 区域 模糊 半 可知 区域 。 人类 知识 可知 领域 中心 小 一部分 ， 个体 人 身上 ， 基本上 中心 一个点 。   点 最 核心 一点 确定无疑 ： ， 如是 。   言语 沟通交流 工具 ， 围绕 描述 ， 才 沟通交流 。 设想 两个 世界 体系 ， 世界 体系 内部 都 内部 运作 规律 表达方式 ， 两个 世界 沟通交流 ， 两个 世界 体系 之间 言语 沟通 ， 理解 ； 误解 ， 不应 归结 一方 理解 过程 上出 。 言语 描述 工具 ， 下 一步 才 言语 发送 方 围绕 正确 描述 言语 接收 方 围绕 去 正确理解 。   言语 描述 某种 独立 沟通 外 ， 外 真实性 确定无疑 ， 言语 交流 都 徒劳 。 评判 外部 言语 ， 言语 构筑 一个 模型 ， 极大 贴近 外部 ， 请 贴近 词 ， ， 言语 只 去 尽可能 模拟 ， 不 取代 。   还 数学 上 度量衡 描述 过程 ， 言语 外部 描述 ， 好像 描述 一个 无理数 ， 无理数 ， 要用 ， 理解 去 描述 无理数 ， 只 一个 无限 逼近 过程 。   类似 言语 还 用于 描述 沟通 一方 内部 世界 ， 评判 描述 作者 内心世界 言语 ， 一个 描述 如实 内心 构建 世界 ， 故意 捏造 、 装腔作势 、 欺骗 愚昧 不 知己 心 言语 ， 毫无价值 。 描述 内在 世界 言语 ， 真诚 第一 要义 。   人类 作品 本质 上 都 作者 言语 ， 其要 某种 外部 描述 ， 分类 非 虚构 类 ； 作者 内在 世界 描述 ， 分类 虚构 类 ， 虚构 类 指非 ， ， 某种程度 上 ， 劣质 非 虚构 类 作品 相比 ， 很多 虚构 类 作品 更 高 真实 性 ， 如实 作者 内心 构建 世界 。",
            "tags":"thought",
            "url":"articles/wo-shi-cun-zai-de.html"
        },
        {
            "title":"安德鲁",
            "text":"机场 候车室 ， 正 接听 一个 电话 ， 一个男孩 我放 行李 座椅 上 ， 漫无 尽心 地升 一个 懒腰 ， 大衣 顺势 张开 。 我太多 ， 男孩 走 一会 ， 发现 座椅 上 毛衣 不见 。   赶忙 去 追 男孩 ， 好 男孩 还 没 跑 远 ， 拐角处 。 大声 叫喊 抓小偷 ， 追 好久 ， 大概 叫喊 周边 巡警 ， 一个 游乐场 店铺 ， 一个 警察 抓 一个 正 。   警察 问 怎么回事 ， 说 男孩 偷 毛衣 ， 一看 男孩 大衣 还 鼓鼓的 ， 伸手 打开 男孩 毛衣 ， 掏出 东西 ， 却 发现 一个 白色 未曾 见 围巾 。 再 仔细 打量 男孩 时 ， 断然 找 不到 第二个 藏 毛衣 地方 。   警察 摆 出 一脸 疑惑 神情 四处张望 ， 游乐场 警察 ， 开着 碰碰车 ， 碰碰车 有个 无比 轮胎 ， 占 车子 一半 大小 ， 问 警察 干什么 。   警察 说 ， ， 平时 执勤 挺 辛苦 ， 会 玩玩 推推 球 游戏 。   警察 说 ， 算了 ， 没事 ， 刚才 看错 。   警察 走 ， 去 洗手间 ， 男孩 跟着 。 完 问 男孩 ， 。   男孩 说 来自 一个 地方 ， 地方 有个 狮子 雕像 ， 住 地方 有个 花园 ， 花园 有个 喷泉 ， 整天 都 喷水 。   说 ， ， 新加坡 。   问 男孩 ， 名字 。   说 安德鲁 ， 很小 离开 家乡 ， 闯荡 世界 ， 立志 偷遍 全世界 。   说 那句 偷遍 全世界 坚定 目光 竟然 感动 。 男孩 不 毛衣 掏 出 ， 接过 毛衣 ， 一笑 道 ： 地方 人 从小 教育 循规蹈矩 ， 厌倦 ， ， 请 偷遍 全世界 。",
            "tags":"novel",
            "url":"articles/an-de-lu.html"
        },
        {
            "title":"关于中国人无信仰的观点是站不住脚的",
            "text":"时代 未知 中 寻求 确知 信仰 ， 一部分 信仰 人 称为 宗教 ， 一部分 信仰 人 称为 迷信 ， 信仰 深藏 人 内心 ， 不可触摸 人 潜意识 谈及 ， 更 不为 人 所识 。   确知 确知 科学 。 我称 当今 时代 后 牛顿 时代 ， 后 牛顿 时代 科学 相比 前 牛顿 时代 很大 发展 ， ， 未知 已知 比例 基本上 太 大 改变 。 说 ， ， 人所能 感知 未知 比重 更大 。 科学 讨论 领域 确切 感知 很小 一部分 ， 很多 讨论 局限性 。   哲学 ， 理解 明智 之学 去 勇敢 拥抱 已知 勇敢 承认 未知 未知 。 理性 讨论 ， 人有 很大 不 理性 成分 ， 内心 最 本质 ， 未知 ， 抱 一种 情绪 。 上帝 赐予 情绪 ， 情绪 如同 未知 ， 值得 正视 。 面对 股 情绪 ， 哲学 局限性 ， 安抚 股 情绪 ， 宗教 ， 迷信 ， 文学 潜意识 很 好 疗效 。   中国 时期 内 实际上 诞生 不少 宗教 ， 时期 内 如同 古希腊 百家争鸣 哲学 大 繁荣 时期 ， 中国 时期 内 外来 宗教 佛教 大 扩散 占 主导地位 时期 ， 讨论 中国 人 宗教信仰 ， 中国 一个 连续 文明 有别于 在历史上 一个 文明 。 正 历史 复杂性 ， 造就 文明 很 难用 一种 单一 宗教 哲学 或者说 解释 。   分析 中国 人 信仰 ， 发现 谈论 中国 人 无 信仰 观点 站不住脚 ， 信仰 某种 未知 当做 已知 ， 中国 人 纯粹 哲学 ， 实际上 中国 人有 很多 迷信 ， 中国 人 很多 不 科学 偏见 执念 。   发现 中国 人 ， 周易 历朝历代 哲学家 文学家 ， 基本上 都 一种 \" 天人感应 \" 学说 。 天人感应 ， 周易 预测学 都 立脚 石 ， 天人感应 ， 中国 人 很多 哲学家 观念 谈论 都 变得 理解 ， 孔子 老子 ， 很大 都 谈论 天道 人 顺从 天道 。 包括 皇帝 ， 说 命令 顺承 上天 旨意 。 天人感应 学说 简单 白话 说 ：   人生 一场 修行 ， 修行 目的 更好 理解 天意 ， 天意 行事 。 修行 足够 好 【 周易 一种 理解 天意 术 ， 修行 不好 ， 上天 不 天意 昭示 ， 周易 学得 再 好 没用 ， 周易 义理 派 关注 周易 哲学 道理 修行 。 佛教 思想 进来 实际上 观念 上 加上 修行 为善 指导 ， 术 ， 佛教 术 ， 中国 人 更好 修行 为善 ， 更好 上天 垂见 ， 实际上 老子 天道无亲 常 善人 思想 说 】 ， 上天 会 天意 昭示 ， 天意 行事 ， 人生 天命 【 请 中国 人 顺天 行事 ， 顺天 行事 好运 ， 并不认为 顺天 行事 尘世 荣华富贵 】 。   天人感应 学说 再 详细 谈论 ， 想 再 谈论 一个 很 有趣 现象 ： 中国 人 生死 不感兴趣 态度 。 孔子 说 ： 不知 生 焉知 死 ， 这是 孔子 表达 ， 中国 人 思想观念 ， 对比 古埃及 生存 意识形态 ， 显明 。 死后 情况 这是 一个 很大 未知 ， 宗教 很 核心 一个 解决 死 。 儒教 道教 都 不 承认 宗教 很大 一个 原因 ， 不 试图 解决 。 佛教 进来 ， 中国 人 如同 看 小说 很 兴趣 听 轮回 ， 死后 地狱 观点 ， 笑了笑 ， 回过 头 好像 忘 ， 变得 不感兴趣 。 兴致 ， 故事 添油加醋 加上 很多 东西 ， 好 葬礼 变得 有趣 ， 改动 估计 佛教 都 不 佛教 ， 说 道教 东西 ， 老实 说 老子 庄子 承认 。 仪式 ， 会 外国人 中国 人 还 保有 原有 祖先崇拜 信仰 ， 一种 误解 。 如同 孔子 说 ， 操办 仪式 隆重 庄严 ， 失 礼节 ， 真的 中国 人 真的 仪式 上 投入 感情 ， 错 。 中国 人 骨子里 死 后 情况 不感兴趣 。   不感兴趣 态度 在我看来 很 难解 谜题 ， 有人 说 中国 人 一群 极致 世俗 主义者 ， 想 大体 正确 ， 说 中国 人 唯利是图 ， 至少 比不上 犹太人 ， 人人 都 趋利避害 ， 这是 本性 ， 人 本性 东西 不到 国民 性格 程度 上 。 历史 上 证据 证明 中国 人 尘世 活得 很 艰难 活得 很 优越 关注 尘世 ， 中国 人 简单 骨子里 死 后 情况 不感兴趣 。 不 涉及 哲学 宗教 ， 未知 ， 潜意识 讨论 ， 不感兴趣 。   非得 提出 一个 观点 ， 大概 中国 人 语言 缘故 更 偏向 视觉 实在 ， 西方 民族 语言 基于 发音 缘故 更 偏向 听觉 实在 。 中国 人 死后 情况 讨论 ， 都 一种 淡淡的 态度 ， ， ， ， 。 过后 忘 。 解释 不怎么 站得住脚 ， 古埃及 苏美尔 象形文字 ， 一个 解释 是因为 实际上 都 演变成 表音文字 ， 本质 区别 。 发现 文化 情况 更 确切 来说 统治阶级 文化 情况 ， 统治 阶层 很多 都 外来 入侵者 。",
            "tags":"thought",
            "url":"articles/guan-yu-zhong-guo-ren-wu-xin-yang-de-guan-dian-shi-zhan-bu-zhu-jiao-de.html"
        },
        {
            "title":"伟大的我",
            "text":"来到 一个 小 村落 ， 小 村落 旁 绿水 环绕 ， 远处 一座 小 山丘 ， 风景 甚 不错 。 迎面 跑 一个 小女孩 ， 嘴里 时不时 喊 ： \" 赫米特 王是 希望 ， 赫米特 王是 力量 \" 。 一巴掌 小女孩 扇 翻 ， 可贱 小女孩 ， 灵魂 早已 恶势力 污染 ， 容忍 。 ， 村子 中央 有个 扩音 喇叭 ， 还 宣讲 ， 开头 两句 。 发射 一个 寒冰箭 ， 小 技能 ， 随便 扩音 喇叭 摧毁 。   村民 渐渐 聚拢 ， 都 高声 欢呼 ： \" ， ， ， 这下 有救 \" ， \" ， 请 宣示 ， 宣示 那贵 黄金 真理 \" 。   示意 安静 ， 说道 ：   \" 人人 皆 可为 ， 感受 不到 内心 ， 是因为 出生 之日起 ， 不 ！ 娘胎 里 ， 周遭 恶势力 污染 ， 到来 帮 铲除 恶势力 。 恶势力 铲除 日 ， 亦 ， 充满 力量 ， 使 不 完 技能 ， 世界 历史 因果 皆 头脑 一念之间 ， ， 都 。 \"   村民 再 发出 欢呼 ： \" ， 得救 \" ， \" 不亏 ， 那至善 真理 \" ...... 人群 中 有人 眼中 饱含 热泪 。   ， 不远处 一个 村干部 带 三四个 当地 恶霸 棍棒 ， 为首 高喊 ： \" 抓住 ， 抓住 反叛 分子 ， 重重 有赏 \" 。 人群 四散 逃开 ， 我定 定 准星 ， 一个 寒冰箭 ， 倒 一个 。 一个 寒冰箭 ， 再 倒 一个 。 村干部 跑 身旁 ， 挥棒 ， 一个 招架 ， 再发 一个 寒冰箭 ， 一个 喽啰 倒 。 顺势 劈 砍 干部 ， 干部 一个 踉跄 ， 一个 寒冰箭 ， 倒 。 剩下 喽啰 发觉 形势 不妙 ， 但太迟 ， 一个 寒冰箭 ， 倒地不起 。   村民 再 慢慢 聚拢 ， 有个 年纪 稍大 说道 ： \" 感谢您 ， ， 消灭 村里 恶霸 ， 仗势欺人 ， 无恶不作 ， 总算 报应 。 \"   说道 ： \" 还 报应 ， 报应 下 十八层 地狱 。 \"   村民 回 道 ： \" ， 一事 相求 ， 村子 东边 不远处 ， 一个 山洞 ， 住 一个 怪物 ， 滋扰 村民 ， 抢夺 村民 庄稼 收成 ， 还 抢夺 村民 蓄养 家畜 ， 害 村民 夜不能寐 ， 希望 帮忙 消灭 怪物 。 \"   回道 ： \" \" ， 接 上路 。   去 东边 路上 小怪 ， 不值一提 ， 提到 小 山丘 ， 确实 有个 山洞 。 山洞 人造 一个 隧道 ， 早 年 失修 ， 大革命 时期 战争 时期 留下来 。 再 进去 一团漆黑 ， 点燃 火把 ， 山洞 滴滴 滴水 ， 甚 潮湿 ， 再 往里面 进去 一点 ， 周遭 墙壁 痕迹 来看 ， 动物 爪子 常年累月 刨出来 。   一个 稍微 宽敞 点 洞穴 ， 正 四处 打量 时 ， 只 听见 震耳 怪物 说话声 ： \" ？ \"   ， \" ？ \" 。 一个 寒冰箭射 ， 正中 怪物 大肚皮 ， 怪物 恼怒 ， 挥舞 一个 无比 皮鞭 ， 喊 讲 ： \" 不听话 ， 不听话 ...... \" 。 不 ， 皮鞭 抽中 ， 很 疼 。 再 细看 ， 那怪 样貌 甚 丑陋 ， 似人 非人 样子 ， 皮鞭 抽 。 山洞 本来 地方 不大 ， 皮鞭 呼 盖住 洞穴 四分之一 样子 ， 甚 棘手 。 再发 一个 寒冰箭 ， 打中 怪物 大肚皮 ， 怪物 肚皮 之大 。 怪物 恼怒 叫喊 一声 ， 震耳 叫喊 脑袋 晕晕 ， 仿佛 有人 脑子 低语 ： \" 真 没用 ， 没用 东西 \" 。 才 雕虫小技 干扰 心智 ， 我施 一个 定神 法 ， 目标 ， 再发 一个 寒冰箭 ， 打动 头部 ， 正中要害 ， 怪物 轰 倒下 ， 化作 一堆 灰尘 ， 只 留下 一地 怪物 不 收集 金币 装备 ， 竟然 一个 金黄色 装备 ， 不错 不错 。   回到 村子 ， 黄昏时分 ， 年长 村民 回交 ， 说 感谢 ， 邀请 家里 上 一夜 ， 答应 。   黑夜 时分 ， 炉前 对话 ， 年长 村民 提到 担忧 ， 担忧 赫米特 王会 派兵 报复 村子 。 安慰 道 ： \" 一路 北上 ， 直捣 赫米特 王 老巢 ， 赫米特 王将 没工夫 来管 远处 小村子 事情 \" 。   第二天 村民 再次 聚集 ， 手里 捧 土特产 ， 年长 村民 说道 ： \" ， 感谢您 做 ， 这是 村民 一点 心意 ， 请 收下 。 祝您 北上 征途 中 胜利 走向 胜利 。 \"   接受 村民 好意 ， 说道 ： \" 村民 ， 谢谢你们 。 平时 厉兵秣马 ， 随时 备战 才行 。 这大 变革 时代 就要 到来 ， 人人 皆 机会 ， 成就 自我 ， 风险 。 今日 ， 做 自我 ， 做 事情 。 \"",
            "tags":"novel",
            "url":"articles/wei-da-de-wo.html"
        },
        {
            "title":"git版本控制",
            "text":"前言   有趣 git 归于 编程 类 ， 放在 通用 工具 类 ， git 强大 工具 刚 用于 代码 版本控制 ， 想到 一个 简单 线 上 Git 服务商 起步 Github 发展 地步 ， Github 成就 很大 一部分 是因为 Git 强大 工具 能力 局限 代码 版本控制 ， 文档 任意 文本 版本控制 都 胜任 。   git 基础   git 命令 流程 ：   远程 仓库 文件 本地   网上 创建 项目 ， 网上 存档 下载 本地 ， 希望 下载 地点 ， 打开 终端 ：   git   clone   https : / / github . / a358003542 / xelatex - guide - book . git   初始化 本地 仓库   git   init   命令 用于 初始化 本地 仓库 ，   git   clone   仓库 文件 初始化 ，   origin   远程 服务器 名字 加上 去 。   本地 仓库 索引   先   git   status   命令 查看 仓库 改动 情况 ， 文件 不想 改动 ，   git   checkout     放弃 更改 ， 某项 改动 想 提交 ，   git   add     目标 文件 索引 。 add 命令 跟上 文件夹 名 ， 文件夹 下 文件 都 跟踪 。 本地 删除 文件 ， 希望 仓库 删除 文件 ， 加上   - -   选项 ：   git   add   - -   _ folder   索引 改动 提交 本地 仓库   git   commit   - m   ' 2013 - 08 - 25 : 19 : 00 '   文字 信息 这次 更改 注释 ， 不 加上   - m   选项 ， 编辑器 写 上 信息 。   本地 仓库 改动 提交 远程 仓库   第一次 提交 远程 服务器 取个 简单 点 名字 ：   git   remote   add   origin   https : / / github . / a358003542 / xelatex - guide - book . git     origin   远程 服务器 简称 ， 按理 来说 名字 随便 取 ， 都 origin ， github 上 clone 仓库 默认 远程 服务器 名字 大多   origin 。   都 简单 命令 更新 ：   git   push   origin   master   最新 git 版本 简单 写作   git   push   。   远程 仓库 改动 更新 本地   命令 git 文件 操作 合并式 ， 替换 最新 改动 文件 。 希望 远程 仓库 改动 包括 删除 更新 本地 ， 可选项   - -     （ - - 删除 动作 选项 ， 想要 删除 文件 git   rm   命令 git 仓库 才 会 记录 这次 删除 动作 ， 本地 远程 仓库 都 跟踪 这次 删除 动作 ）   。   git   pull   origin   master   最新 版本 git   简单 写 上   git   pull   ， 内部 智能 判断 分支 参数 。   情况 下   add   commit   push   三步 。 这是 日常 维护 提交 流程 。 网站 上 远程 仓库 做 修改 ， 记得 先用 pull 命令 远程 仓库 改动 更新 本地 。   第一次 配置   设置 名字 email ：   git   config   - - global   user .   \" Your   Name \"   git   config   - - global   user . email   \" _ email @ . \"   git 全局 设置 ， 项目 无关 。 打开 家 目录 下   . gitconfig   文件 看 。   . gitignore 文件   github 创建 项目 选择 好 项目 语言 ， 会 自动 创建 一个   . gitignore   文件 ， 文件 语法 很 简单 ，   * .   项目 内 后缀 文件 都 索引 。   推荐   gitignore 项目   看 。   初始化 仓库   git   init   git   init   当前工作 目录 下 初始化 git 管理 仓库 ， 打开 查看 隐藏 文件 ， 会 一个   . git   文件夹 ， git 用于 管理 项目 文件 存放 ， 会 用到   config   文件 。   github 上 创建 项目 ， 项目 克隆 （ 创建 一个 文件 ） ， 不 再 执行 init 命令 ， 远程 仓库 执行 。 打开 config 文件 会 remote   origin   定义 好 。   clone http 连接 ， 想 ssh 连接 ， config 文件 下 修改 即可 。   删除 文件 动作 跟踪   本地 删除 文件 ， 希望 远程 仓库 删除 文件 ， 先看   git   status   文件 改动 。     git   rm   目标 文件   跟踪目标 文件 删除 动作 。     git   add   文件夹 ， 加上   - -   选项 ， 文件夹 内 文件 删除 动作 会 自动 跟踪 。   查看 git 仓库 文件 改动 情况   git   status   查看 git 仓库 更改 记录   git   log   git   log   命令 查看 本地 仓库 更改 记录 。 git   log 很多 设置 ， 有个 最 简单 例子 （ 参考 githowtu 网页 ） ：   git   log   - - pretty   =   format :   ' % h   % ad   |   % s% d   [ % ] '   - - graph   - - date   =   short   创建 一个 别名 ， 家 目录   . gitconfig   文件 写 上 ：   [   alias   ]   hist   =   log   - - pretty   =   format :   ' % h   % ad   |   % s% d   [ % ] '   - - graph   - - date   =   short   git 命令 别名 功能   提到 修改 家 目录   . gitconfig   文件 输入   git   hist   很 git 仓库 更改 记录 好看 打印信息 。     git   config   - - global   alias . hist   \" log   - - pretty = format : ' % h   % ad   |   % s% d   [ % ] '   - - graph   - - date = short \"   命令 实际上 修改 主 文件夹 . gitconfig 文件 ， 打开 看 。   切换 版本   切 回到 一个 版本 中 去 ：   git   checkout   3fbdf2c   commit hash 值 可用 git   log 查看 ， 命令 将会 本地 文件夹 返回 特定 版本 状态 。   取消 文件 修改   git   checkout   file _ _ folder   修改 文件 ， 还 add commit ， 修改 不 满意 ， 想 舍弃 。 上 checkout 文件 文件夹 取消 修改 ， 文件 回滚 commit 时 未修改 样子 。   commit 更改   提交 一个 commit ， 发现 地方 修改 ， commit 附加 信息 不 满意 ， :   git   commit   - - amend   覆 写 上 commit 记录 ， amend 改进 修正 。 只能 amend 那次 commit ， 运行 命令 ， 等于 上 commit 都 取消 掉 ， 做 修改 ， 再 一个 commit 。   取消 add 文件   不 小心   add   .   文件 ， 文件 不想 add ， 取消 add 操作 。   git   reset   HEAD   file _ _ folder   分支 功能   git 分支 功能 特别 强大 ， 推荐 灵活 开发 。 git 保存 文件 差异 变化 量 一系列 文件 快照 。 git commit ， 相关 提交 信息 之外 ， 一个 指向 这棵树 指针 。 git 中 分支 本质 上 仅仅 指向 commit 对象 可变 指针 。   git   branch   testing   新建 一个 分支 ， commit 对象 上 新建 一个 分支 指针 。 git 还 保存 一个 名叫   HEAD   特别 指针 ， 指向 工作 本地 分支 。 运行 git   branch 仅仅 新建 一个 分支 ， 系统 自动 切换 分支 ， 切换 分支   git   checkout   testing   命令 。 master 分支 testing 分支 向前 commit 推 ， 一个 分支 样貌 图 所示 :   上图 HEAD 工作 分支 点 ， master 默认 主 分支 ， 上 图 一个 testing 分支 。 上图 f30ab 开 一个 testing 分支 ， testing 分支 commit ， master 分支 推 ， 本地 文件夹 当前工作 分支 master 。     pro   git   一书 说法 ， Git 中 分支 实际上 仅 一个 包含 所指 对象 校验 （ 40   个字符 长度   SHA - 1   字串 ） 文件 ， 创建 销毁 一个 分支 廉价 ， 切换 快 。 Git 鼓励 开发者 频繁 分支 。   新建 分支   新建 一个 git 分支 ：   git   branch   _ branch _   ​   额外 提醒 新建 一个 git 分支 ， 还 checkout 命令 切换 分支 ， 停留 分支 上 。   查看 分支   git   branch   用于 查看 分支 状态 。 加上 选项   - a   还会 显示 远程 分支 状态 。   ​   切换 分支   git   checkout   _ branch _   ​   克隆 分支   git   clone 项目 只 想 克隆 分支 ， 加上   - b   选项 只 clone 远程 仓库 分支 ：   git   clone   - b   _ branch _   _ project _ url   ​   合并 分支   比如说 testing 分支 master 分支 想 合并 。 切换 master 分支 ， git   merge 合并 分支 ， 所示 :   git   checkout   master   git   merge   _ branck _   合并 策略 新建 ， 迭加 合并 ， 文件 冲突 手工 。   删除 本地 分支   小节 参考   网页   。   git   branch   - D   branch _   删除 远程 分支   git   push   origin   : branch _   分支 分支 推送   git   push   origin   dev : dev   本地 一个 dev 分支 ， 推送 远程 dev 分支 。 删除 远程 分支 语法 类似 ， 冒号 指定 本地 分支 。   一种 很 不 规范 做法 :   git   push   origin   dev : master   本地 dev 分支 推送 远程 master 分支 ， 不 推荐 做 ， 尽量 本地 分支 远程 分支 名字 ， 免得 弄混 。   tag 功能   github 上 release 栏 基于 git tag 功能   ， 命令 推送 一个 release 或者说 提交 一个 tag 。 修改 额外 信息 额外 附加 bin exe 文件 ， github 上 网页 操作 。   查看 tag   git   tag   添加 tag   git   tag   tag _   tag 推送 远程   git   push   - - tag   commit 几次 后悔   commit 几次 ， 几次 commit 都 不 太 满意 ， 想 回滚 commit 下 。 ：   git   reset   - - hard   commit _ id   ##   修改   ##   新 commit   git   push   - - force   喜欢   - - hard   选项 回滚 commit 下 （   - - soft     - - mixed   选项 。 ） ， 远程 仓库 都 记录 ， 再 对照 选择 。 记得 push 操作 加上   - - force   选项 。   子 模块 功能   git 项目 添加 子 模块   一个 git 仓库 文件夹 一个 git 仓库 ， 称该 git 仓库 为子 模块 ， 内容 添加 子 模块 管理 ：   git   submodule   add   submodule _ url   将会 多出 一个   . gitmodules   文件 ， 存放 项目 子 模块 信息 。   子 模块 还 内容 ， 还 运行 ：   git   submodule   update   获取 子 模块 内容 。   clone 包括 子 git 模块   项目 有子 git 模块 ， 简单 git   clone 命令 内容 下载 。 参考   网页   。   加上   - - recursive   选项 会 下载 项目 子 git 模块 。   git   clone   - - recursive   . git   clone 带有 子 模块 项目 将子 模块 clone ， 想 clone ， 命令 ：   git   submodule   update   - - init   - - recursive   日常 子 模块 操作   子 模块 一个 git 项目 ， 子 模块 文件夹 ， 常规 git 操作 。 主 项目 指向 版本号 子 模块 ， 操作 主 模块 上 生效 。   要主 项目 指向 子 模块 最新 版本 操作 ：   git   add   - -   submodule _ folder   git   commit   - m   \" update   submodule \"   中文 乱码   参考   网页   。   用户 家 目录 下   . gitconfig   文件 设置 ， 读者 参考 下 ：   [ core ]   quotepath   =   false   autocrlf   =   false   safecrlf   =   true   [ gui ]   encoding   =   utf - 8   [ i18n   \" commit \" ]   encoding   =   utf - 8   [ i18n ]   logoutputencoding   =   utf - 8     autocrlf   =   false   git     windows 一个 设置 ， Linux 换行符 windows 换行符 关闭 ；   safecrlf = true   设置 ， git     windows 不 做 更改 。   quotepath   git 路径 默认 转义 关闭 。   设置 utf8 编码 。   ​   参考资料   git 简明 指南   git   howto   图解 git   git   community   book 中文版   pro   git 第二 版",
            "tags":"tools",
            "url":"articles/git.html"
        },
        {
            "title":"计算机网络基础知识",
            "text":"先 找到 目标 计算机   简单 回顾 学习 Linux 系统 时 接触 网络 知识 ， Internet 源起 美国 ARPAnet 项目 ， 其有 知识点   两个 位于 网域 计算机 才 文件 交互   。 读者 会 问 网域 ， 网域 说白了 一个 大 互联网 分割 分割 再 分割 一个 产物 。 分割 手段   子网掩码   ， 判断 两个 计算机 网域 ？ 计算机 IP地址 子网掩码 相加 ， 说 位于 网域 。   说 一台 计算机 一台 计算机 发送 一个 信息 包 ， 计算机 会 分析 路由表 ， 发现 目标 机器 网域 ， 发送信息 。 不 网域 ， 计算机 就要 路由表 信息 包 发送给 默认 路由器 （ gateway ） 。 路由器 交换机 网络 世界 里 扮演着 一个 角色 ， 不 数据 ， 只 负责 数据 分发 。 过程 实际上 描述 过程 迭代 重复 ， 路由器 一个 路由表 ， 目标 机器 网域 ， 不则 信息 包 发送给 一个 默认 路由器 交换机 ， 最终目标 机器 位于 网域 ， 信息 包 发送给 目标 机器 。   通信协议   计算机 找到 目标 计算机 开口 说话 ， 随便 说话 发送 一堆 乱码 ， 目标 机器 看不懂 。 制定 计算机 之间 通信协议 。 计算机 之间 通信协议 ？ 简单 来说 好比 两个 人 之间 对话 某种 规范 ， 两个 国家 外交 协商 某种 特定 交互 流程 。 一个 人 一个 人 说 \" 你好 \" ， 一个 人 收到 回应 \" 你好 \" ， 收到 ， 第一个 收到 回应 ， 协议 牵手 成功 ， 会话 ， \" 星期 \" ， 发送 ， 一个 人 收到 回应 \" 星期一 \" … … 类似 交互方式 。 连接 双向 ， 连接 持续 ， 发送 goodbye 关闭 协议 ， 协议 单向 ， 无 状态 协议 ， HTTP 协议 ， 信息 发送 完 连接 就算 自动 关闭 。   描述 还 遗漏 一点 交互 流程 上 规范 ， 发送 信息 包 格式 规范 ， 或者说 格式 。   应用程序 体系结构   网络 世界 里 两种 应用程序 体系结构 ： 一种 client / server 体系结构 ； 一种 peer     peer ， P2P 体系结构 。   选择 客户机 / 服务器 体系结构 ， 应用程序 会 两个 命令 两种 工作 模式 ， 一个 启动 本地 客户机 进程 ， 一个 启动 服务器 进程 ， 很多 应用程序 都 。 P2P BitTorrent 下载 软件 熟知 。   讨论 最 client / server 体系结构 。   套 接字   程序 之间 进程 进程 之间 通信 ， 一个 客户机 进程 ， 一个 服务器 进程 ， 两个 进程 之间 通信 。 谈到 P2P 体系结构 ， 理解 ， 一个 进程 客户机 服务器 。 定义 :   给定 一对 进程 之间 通信 ， 称 发起 通信 进程 客户机 进程 ， 会 话 中 等待 进程 服务器 进程 。 （ 理解 被动 等待 通信 信号 ）   两个 进程 之间   \\ textbf { 套 接字 }   ( socket ) 发送 接受 报文 。 套 接字 一个 主机 内 应用层 传输层 之间 接口 ， 应用程序 开发者 控制 套 接字 层面 上 东西 ， 套 接字 传输层 控制 东西 有限 ， 仅限于 :   选择 传输层 协议 设定 几个 传输层 参数 （ 缓存 报文 长度 ） 。   TCP / IP 网络 上 两个 传输 协议 :   UDP 协议 TCP 协议 。 软件 开发者 创建 新 应用程序 时 ， 传输层 TCP 协议 UDP 协议 。   TCP 协议   TCP 协议 面向 连接 可靠 数据传输 。 面向 连接 指 客户机 服务器之间 握手 过程 好 建立 TCP 连接 ， 结束 拆除 连接 。 可靠 数据传输 指 TCP 协议 保证数据 无差错 顺序 交付 发送 。 TCP 协议 还 拥塞 控制 机制 。 SMTP （ 电子邮件 ） 协议 ， Telnet 协议 ， HTTP 协议 ， FTP 协议 多用 TCP 协议 。   UDP 协议   UDP 一种 不 提供 不必要 服务 轻量级 传输层 协议 ， 仅 提供 最小 服务 。 UDP 无 连接 ， 两个 进程 之间 握手 过程 。 UDP 协议 不 保证 报文 接受 进程 收到 ， 不 保证数据 顺序 到达 。 UDP 拥塞 控制 机制 。 因特网 电话 流媒体 多用 UDP 协议 。   HTTP 协议   HTTP （ HyperText   Transfer   Protocol ） 超文本 传输 协议 网络 世界 一个 熟知 协议 ， 应用层 ， 应用层 协议 。 HTTP 定义 两个 端系统 ， 一个 客户机 ， 一个 服务器 ， 两个 之间 报文交换 报文 格式 。 Web 浏览器 HTTP 协议 客户机 端 ， Web 服务器 HTTP 协议 服务器端 。   HTTP 协议 TCP 协议 传输层 协议 ， 用户 请求 一个 Web 页面 时 ， 浏览器 HTTP 客户机 服务器 建立 一个 TCP 连接 ， 连接 建立 ， 浏览器 服务器 套 接字 交流 。 客户机 经由 其套 接字 服务器发送 一个 HTTP 请求 报文 ， 随后 服务器 接受 HTTP 请求 报文 ， 内部 ， 找到 html 文件 资源 文件 数据 运算 ， 经由 套 接字 回应 一个 HTTP 响应 报文 客户机 。 HTTP 服务器 进程 通知 TCP 断开 TCP 连接 ， TCP 大概 等到 客户机 完整 接受 HTTP 响应 报文 ， TCP 连接 断开 。 HTTP 客户机 接受 HTTP 响应 报文 ， TCP 连接 断开 ， HTTP 请求 算是 完 。   Web 页面 还 包含 图片 引用 javascript 引用 ， 一个 引用 浏览器 客户机 都 一个 HTTP 请求 ， 类似 。 基于 HTTP 协议 TCP 协议 只 一个 请求 报文 一个 响应 报文 传输 ， 一个 Web 页面 ， 发送 十几个 HTTP 请求 ， 就要 建立 十几个 TCP 连接 。 （ 过程 大抵 ， 客户机 都 会 打开 5 - 10 并行 TCP 连接 。 ）   描述 HTTP 协议 初始 版本 情况 ， HTTP /   1.1 HTTP 协议 持久 连接 特性 ， 默认 采用 持久 连接 方式 。 持久 连接 减少 新开 TCP 连接 消耗 ， HTTP 每送 一个 报文 请求 断开 TCP 连接 ， 连接 长时间 未 ， HTTP 服务器 才 关闭 连接 。   说 HTTP 协议 本身 无 状态 ， HTTP 服务器 记忆 客户机 信息 ， cookie session ， cookie 客户机 保存 状态 信息 ， session 服务器 保存 状态 信息 ， 。   HTTP 报文格式   HTTP 报文 分为 两种 ， 一种 请求 报文 ， 一种 响应 报文 。   一个 HTTP 请求   GET   /   HTTP / 1.1   Host :   www . google .   User - Agent :   Mozilla / 5.0   ( X11 ;   Ubuntu ;   Linux   x86 _ 64 ;   rv : 40.0 )   Gecko / 20100101   Firefox / 40.0   Accept :   text / html , application / xhtml + xml , application / xml ; q = 0.9 , * / * ; q = 0.8   Accept - Language :   zh - CN , zh ; q = 0.8 , en - US ; q = 0.5 , en ; q = 0.3   Accept - Encoding :   gzip ,   deflate   Connection :   - alive   第一个 方法 字 段 ， HTTP GET 、 POST 、 PUT 、 DELETE 方法 ， HOST 请求 主机 名字 ， User - Agent 用户 浏览器 ， Connection 设置 - alive 正是 说 建立 持久 连接 。   响应 :   HTTP / 1.1   200   OK   Cache - Control :   private   Content - Length :   231   Content - Type :   text / html ;   charset = UTF - 8   Date :   Wed ,   02   Sep   2015   08 : 47 : 52   GMT   Location :   https : / / www . google . / gws _ = ssl   .........   响应 200 熟知 HTTP 响应 状态 码 。 HTTP 协议 更 内容 html5 学习 中 讨论 。   cookie 技术   cookie 作用 原理 ， 用户 登录 一个 网站 ， 网站 服务器返回 一个 HTTP 响应 ， 一行   Set - cookie :   whatwhatwhat   HTTP 响应 用户 浏览器 接受 ， 特定 cookie 文件 中 添加 一行 ， 服务器 名字 （ HOST ） Set - cookie 标识码 信息 。 浏览器 再 访问 网站 ， 自动 HTTP 请求 上 加上 一行 :   Cookie :   whatwhatwhat   网站 服务器 HTTP 请求 一行 ， 说 ， ， 张三 回来 。 用户 网站 上 操作 记录 都 网站 数据库 统一 管理 ， 张三 点击 页面 ， 张三买 东西 。   web 缓存 器   web 缓存 器 代理服务器 ， 代表 初始 服务器 满足用户 HTTP 请求 。 过程 :   用户 浏览器 缓存 器 建立 TCP 连接 ， 发送 一个 HTTP 请求 。   web 缓存 器会 检查 本地 缓存 目标 对象 备份 ， ， web 缓存 器用 HTTP 响应 回应 用户 浏览器 。   web 缓存 器 目标 对象 缓存 ， 会 初始 服务器 打开 一个 TCP 连接 ， 发送 一个 HTTP 请求 ， 目标 对象 ， 对象 缓存 本地 ， 用户 浏览器 回应 一个 HTTP 响应 好 新 对象 发给 用户 浏览器 。   web 缓存 器 本地 目标 对象 缓存 ， 缓存 过于 陈旧 。 缓存 器 证实 本地 缓存 内容 最新 ， 利用 HTTP 协议   \\ verb + If - modified - +   一行 。 web 缓存 器 发送 一个 短小 HTTP 请求 ， 包含 一行 :   If - modified - sine :   Wed ,   4   Jul   2007   09 : 23 : 24   日期 web 缓存 器 存储 上 缓存 对象 HTTP 响应 头上   Last - Modified   一行 。   Web 服务器 会 回应 一个 很 短小 HTTP 响应 ， 最 简短 HTTP 状态 码 几个 信息 ， 304 , Not   Modified 。   DNS 协议   DNS 协议 计算机网络 最底层 找到 目标 计算机操作 相关 ， 应用层 。   输入 域名   www . .   ， 计算机 不 ， 计算机 转化 IP地址 才行 ， 计算机 转化 ， 互联网 世界 ， 很多 DNS 服务器 ， 计算机 查询 DNS 服务器 ， 获取 域名 IP地址 。",
            "tags":"programming",
            "url":"articles/network-basic.html"
        },
        {
            "title":"vi编辑器",
            "text":"推荐 先 安装 完整版 vim ， 按键 乱码 会 自动 解决 。 中文 输入法 状态 下 会 切换 vi 模式 困扰 。   vi 编辑器 第一条 ， 记住   i   编辑 模式 ， 按键 都   Esc   退出 编辑 模式 才 。   常用 快捷键   按键 针对 常见 键盘 ， MAC 下 按键 会 有所不同 。   Ctrl   +   f   屏幕 向下 一页   G   一行   gg   第一行   推荐   1G   行 跳转 操作 ，   100G   跳 转到第 100 行 。   dd   删除 行   yy   复制 行   p   粘贴   u   撤销   r   redo   块 选择   按键   v   块 选择 ， 光标 块 选择 。   y   复制 块   d   删除 块   查找   匹配 单词   / Lao   Zi   搜索 精确 匹配 含有 \" Lao   Zi \" 字符串 ，   n   查找 \" Lao   Zi \" ， 查找 下 一个   查找 历史   输入   /   方向键 ， 如同 终端 上 方向键 调用 上 一个 命令 ， 调用 上 查找 命令 。 很 有用 。   反向 查找   问号     反向 查找 。   n   ， 下 一个 反向 ， 理解 n 上 查找 命令 重做 。   锚定 行   正则表达式 知识 ：   &# 94 ;   符号 一行 。 执行 查找 命令 ：   / &# 94 ; Th   算是 一个 小型 正则表达式 匹配 模式 ， 自然语言 描述 ： 匹配 T 行首 ， 还 一个 字母 h 文本 。 The This 开头 行 都 匹配 进去 ， 请 读者 试试   / &# 94 ; This   精确 匹配 T 行首 ， 跟着 字母 文本 。   锚定 行 结尾   $   符号 一行 结尾 。   空行   / &# 94 ; $   。 将会 匹配 一条 字符 空行 。   替换   全局 替换   % s / 源 字符串 / 目的 字符串 / g     %   文档 ，   快速   shift + g   快速 文档 尾部   gg   快速 文档 头部   vimrc 配置   用户 主 文件夹 下   . vimrc   文件 vi 编辑器 定制 配置 。   vi 编辑器 下 输入   :   ， 写下 配置 ， 会 编辑器 上 生效 。   解决 Backspace 键 乱码 方向键 乱码   set   nocompatible   set   backspace = 2   自动 缩进   set   autoindent   显示 行号   set   nu   开启 语法 高亮   syntax     ​",
            "tags":"editor",
            "url":"articles/vibian-ji-qi.html"
        },
        {
            "title":"visual_studio",
            "text":"前言   本文 列出 visual _ studio 过程 中 值得一提 小 技巧 。   文档 格式化   visual   studio   文档 格式化 功能 ， 藏得 深 。 选择   工具 - > 选项 - > 环境 - > 键盘   ， 搜索 关键词   格式   ， 相关 ：   编辑 . 设置 文档 格式   ， 默认 快捷键   Ctrl + k   Ctrl + d   ， 文档 自动 格式化 。   编辑 . 设置 选定 内容 格式 ， 默认 快捷键   Ctrl + k   Ctrl + f   ， 选中 内容 自动 格式化 。   解决方案 多个 项目   一个 解决方案 下 一个 项目 内 C语言 编码 只 一个   main   函数 ， 多个   main   函数 ， 解决方案 下 再 新建 一个 项目 。   多个 项目 之间 启动 调试 切换 选择 项目 ， 右键 选择   设 启动 项目   。",
            "tags":"editor",
            "url":"articles/visual_studio.html"
        },
        {
            "title":"pycharm",
            "text":"前言   本文 列出 pycharm 过程 中 值得一提 小 技巧 。   上传 文件 服务器   原理 利用 sftp 上传 ， pycharm 大 环境 下 ， 确实 很 。 功能 只 pycharm 专业版 下 才 。   Tools   - >   Deployment   - >   configuration   服务器 上 频繁 测试 工作 ， 不 git 频繁 commit 情况 ， 先 测试 好 ， git 推送 。   设置 环境 远程 python 解释器   ：   Settings   - >   Project   - >   Project   Interpreter   ， 利用 pycharm 新建 一个 本地 虚拟环境 ， pipenv 建立 环境 ， pycharm 会 自动 找到 ， 利用 python 虚拟环境 ， 讲 ， 还 设置 解释器 环境 远程 服务器 python 环境 ， 开发 调试 接近 程序 运行 时 环境 。   ：   Tools   - >   Start   SSH   session ...   terminal 打开 一个 连接 远程 服务器 ssh 终端 ， 加上 设置 好 文件 upload 功能 ， 基本上 不 一个 额外 ssh 终端 连接 程序 。   讨论 都 基于 ssh 连接 ， ：   Tools   - >   Deployment   - >   Configuration   设置 好 ssh   server   连接 方式 。   正则表达式 替换   按下 路径 替换 ， 点 做 正则表达式 替换 ， 正则表达式 都 很 熟悉 ， 不 说 ， group 替换 ， 。   原 表达式   ( )   包围 想要 设定 group ， 表达式 引用 group （ 1 数 ） ，   \\ 1   \\ 2   ...   替换 表达式 引用 group 依次   $ 1   $ 2   ...   更 内容 请 参看 官方 文档     。",
            "tags":"editor",
            "url":"articles/pycharm.html"
        },
        {
            "title":"理解web服务器",
            "text":"前言   本文   500lines   项目 篇文章 学习 讨论 ， 篇文章 写 极好 ， 编码 很 好 借鉴 参考价值 ， 还 读者 http   web   server   做 事情 一个 。 篇文章 弄清楚 ， django flask 做 事 ， 很 胸有成竹 ， 包括 nginx 服务器 做 事 一个 大致 。   计算机网络 HTTP 相关 不 本文 讨论 ， 笔者 自觉 一块 时间 还 再 补一补 。   web 服务器 做 工作 ：   占 端口 HTTP   请求 包 发过来   HTTP 请求 包有 格式 ， 信息 parse 操作   请求 做点 （ 分发 GET   POST ）   程序 做点   返回 数据格式 ， html 。   返回 数据 传 回去   步骤 前 两步 一步 python   HTTPServer   帮 自动 做 ， 更 不用说 django flask 框架 ， 早就 帮 做好 。 只 关注 ， 请求 GET POST ， 程序 总要 干点 事 ， 送 回去 数据 整理 好 ， 再 并发 即可 。   更 高级 web   server   flask ， 会 提供 很多 额外 支持 ， 请求 参数 ， 请求 头等 信息 整理 ， 希望 restful 风格 api ， 只 返回 一个 字典 值 ， 响应 头 封装 帮 做好 ， 返回 数据 上 ， html 会 引入 jinja2 模块 引擎 ， 都 很 好 理解 。 web   server 干 事 。   第一个 例子   针对 python3 版本 代码 稍作 修改 。     http . server   import   HTTPServer   ,   BaseHTTPRequestHandler   class   RequestHandler   (   BaseHTTPRequestHandler   ) :   ' ' ' Handle   HTTP   requests     returning   a   fixed   ' page ' . ' ' '   #   Page     send   back .   Page   =   ' ' '   \\   < html >   < body >   < p > Hello ,   web ! < / p >   < / body >   < / html >   ' ' '   #   Handle   a   GET   request .   def   _ GET   (     ) :     .   send _ response   (   200   )     .   send _ header   (   \" Content - Type \"   ,   \" text / html \"   )     .   send _ header   (   \" Content - Length \"   ,   str   (   len   (     .   Page   ) ) )     .   end _ headers   ( )     .   wfile   .   write   (     .   Page   .   encode   ( ) )   # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     __ __   = =   ' __ main __ '   :   serverAddress   =   (   ' '   ,   8080   )   server   =   HTTPServer   (   serverAddress   ,   RequestHandler   )   server   .   serve _ forever   ( )     _ GET   方法 内部 作用 原理 ：   mname   =   ' _ '   +   . command       hasattr ( ,   mname ) :   . send _ error (   HTTPStatus . NOT _ IMPLEMENTED ,   \" Unsupported   method   ( % r ) \"   %   . command )   return   method   =   getattr ( ,   mname )   method ( )     . command   http 协议 请求 头 传过来 GET POST ，   handler 类会 去 找 方法 ， 找到 再 操作 。   函数 名来 分发 编程 模式 ， 很 值得 ， web   server 都 需求 。 url   server _   虚拟 server 分发 ， path   method   函数 分发 ， 再 高级 参数 验证 valide _   类似 分发 需求 。   简单 模板 输出 方案   不码 代码 ， 简单 python 字符串 format 方法 ， 更 jinja2 模板 系统 生成 html 内容 ， 后 话 。   挂载 静态 文件   静态 文件 找到 文件 ， 返回 。   index . html   文件 特别 。   500lines 该文 提到 一种 有趣 编码 写法 ：   class   case _ _ file ( object ) :   ' ' ' File     directory       exist . ' ' '   def   test ( ,   handler ) :   return     os . path . exists ( handler . full _ path )   def   act ( ,   handler ) :   raise   ServerException ( \" ' { 0 } '     found \" . format ( handler . path ) )   def   _ GET ( ) :   :   #   Figure             requested .   . full _ path   =   os . getcwd ( )   +   . path   #   Figure         handle   .     case     . Cases :   cond =   case ( )     cond . test ( ) :   cond . act ( )   break   #   Handle   errors .     Exception     msg :   . handle _ error ( msg )   class   RequestHandler ( BaseHTTPServer . BaseHTTPRequestHandler ) :   Cases   =   [ case _ _ file ,   case _ existing _ file ,   case _ _ fail ]   针对 多种 情况 ， 分发 ， 有点像 switch 语句 更 python 风格 更 优美 写法 。   简单 cgi 接口   接下来 cgi 接口 代码 很 简单 ：   class   case _ cgi _ file   (   object   ) :   ' ' ' Something   runnable . ' ' '   def   test   (     ,   handler   ) :   return   os   .   path   .   isfile   (   handler   .   full _ path   )     \\   handler   .   full _ path   .   endswith   (   ' . py '   )   def   act   (     ,   handler   ) :   handler   .   run _ cgi   (   handler   .   full _ path   )   def   run _ cgi   (     ,   full _ path   ) :   cmd   =   \" python   \"   +   full _ path   child _ stdin   ,   child _ stdout   =   os   .   popen2   (   cmd   )   child _ stdin   .   close   ( )   data   =   child _ stdout   .   read   ( )   child _ stdout   .   close   ( )     .   send _ content   (   data   )   核心 针对 python 脚本 文件 ， 启动 cgi 协议 接口 ， 简单 来说 启动 一个 python 解释器 运行 目标 脚本 文件 ， 获取 返回 内容 ， web   server 返回 内容 返回 即可 。   下 cgi 协议 ， CGI 协议 ， 全称 （ Common   Gateway   Interface ） 通用 网关 接口 ， 说 再 确切 一点 ， cgi 程序 web   server 之间 接口标准 ， 说 再 简单 粗糙 点 ， 一个 web   server ， apache     nginx   会 讨论 返回 静态 文件 做好 ， 请 读者 进一步 参看   篇文章   。   请求 ， 请求 讨论 CGI 协议 ， nginx web   server ， 例子 中 大部分 代码 扮演 角色 ， cgi 程序 ， 实际上 python 脚本 ， python 框架 ， 会 讨论 。   路径 上 挂载 参数 环境变量 传递 进来 ， 工作 ， CGI 协议 定义 内容 。 讲到 cgi 协议 ， python ， 不 不 提到 pep3333 wsgi 标准 。   WSGI   PEP3333   定义   Python   Web   Server   Gateway   Interface   ， python   web   server   网关 协议 ， 简称 WSGI 协议 。 名字 ， python 世界 里 ， 推荐 WSGI 协议 。 猜到 WSGI 好 ， 路径 path 挂载 参数 ， 送入 环境变量 。 还 服务器 信息 ， 客户端 信息 ， 本次 请求 信息 都 存入 environ 变量 中 ， WSGI   application （ python 程序 框架 提供 ） ， 调用 ， 规范 。   WSGI   middleware   层 ， django flask （ Werkzeug   ） ， 都 接触   Middleware   类 概念 。   nginx   扮演 web   server 服务 静态 文件 角色 ， wsgi 请求 发给 gunicorn ： gunicorn 官方 介绍 ：   Gunicorn   ' Green   Unicorn '     a   Python   WSGI   HTTP   Server     UNIX .   简单 来说 WSGI 协议 扮演 web   server 角色 ， gunicorn 挂载 另一边 ， django flask 框架 提供 wsgi 脚本 app ， 或者说 application 对象 所在 。   编码 框架 人 来说 ， 不用 太 在意 ， 记得 调用 path ， path 挂载 参数 ， 写 ， 返回 内容 。 框架 编写 人员 ， 就要 详细 研究 WSGI 协议 。",
            "tags":"web_server",
            "url":"articles/understanding-web-server.html"
        },
        {
            "title":"flask上下文释疑",
            "text":"  gunicorn 进程 模式 flask 作用   参考     解答 ：   import   socket   import   os   def   main   ( ) :   serversocket   =   socket   .   socket   (   socket   .   AF _ INET   ,   socket   .   SOCK _ STREAM   )   serversocket   .   bind   ( (   \" 127.0 . 0.1 \"   ,   8888   ) )   serversocket   .   listen   (   0   )   #   Child   Process     os   .   fork   ( )   = =   0   :   accept _ conn   (   \" child \"   ,   serversocket   )   accept _ conn   (   \" parent \"   ,   serversocket   )   def   accept _ conn   (   message   ,   s   ) :     True   :   c   ,   addr   =   s   .   accept   ( )   print   ' Got   connection       % s   '   %   message   c   .   send   (   ' Thank         connecting     % s   \\ n   '   %   message   )   c   .   close   ( )     __ __   = =   \" __ main __ \"   :   main   ( )   gunicorn   采用   pre - fork   work   模式 ， 大概 作业 模式 上 代码 所示 ， 不同点   gunicorn   主 进程 不 负责 消息 ， 只 负责 端口 监听 消息 分 发给 子 进程 。   进程 情况 大体 熟悉 ， 基本上 都 独立 运行 内部 变量 类 之间 不 程序 。 flask   wsgi 源码 中有 代码 ：   def   wsgi _ app   (     ,   environ   ,   start _ response   ) :   ctx   =     .   request _ context   (   environ   )   error   =   None     :     :   ctx   .   push   ( )   response   =     .   full _ dispatch _ request   ( )     Exception     e   :   error   =   e   response   =     .   handle _ exception   (   e   )     :   #   noqa :   B001   error   =   sys   .   exc _ info   ( ) [   1   ]   raise   return   response   (   environ   ,   start _ response   )   finally   :       .   _ ignore _ error   (   error   ) :   error   =   None   ctx   .   auto _ pop   (   error   )   environ 环境 中 大概 有本 进程   app 类 ， ctx 请求 环境 ， 简单 下 讨论 。   二   flask 应对 多线程   就要   flask   源码   globals   两行 代码 说起 ：   _ request _ ctx _ stack   =   LocalStack   ( )   _ app _ ctx _ stack   =   LocalStack   ( )   代码   请求 环境 栈 应用环境 栈 都 定义 ， LocalStack   参考   这片 文章   讨论 ， 借鉴 python   threading   模块   local ， 其是 一个 线程 本地 变量 ， 简单 来说 其是 一个 字典 线程 id 索引 ， id 取 值 ， 互不 干扰 。   flask 多线程 下 ， 请求 环境 栈 应用环境 栈 看做 堆栈 ， 互补 干扰 。   三   flask 应对 多协程   原则上 flask python threading local ， 协程 很 好 应对 ， python3.7 新增 一个   contextvars   模块 解决 。 ， gunicorn   多个 进程 worker ， 多个 进程 worker 之下 还 开启 多个 线程 ， 默认 线程 之外 ， gunicorn 还 开启 gevent 异步 线程 。 gevent 开启 多协程 ， flask 应对 情况 ？   flask   werkzeug 定义 Local 类 ， 源码 中 ：     :     greenlet   import   getcurrent     _ ident     ImportError   :     :     thread   import   _ ident     ImportError   :     _ thread   import   _ ident   werkzeug 会试 先 加载 greenlet _ ident   函数 ， 想 函数 支持 greenlet 协程 ， gevent 底层 开启 greenlet 协程 。   ， 也就是说 flask 请求 环境 栈 应用环境 栈 线程 独立 ， 额外 greenlet 支持 。   提出 一个 ， 估计 flask python 内部 asyncio 协程 模式 支持 。   四   请求 环境 栈 到底 做 工作   请求 到来 ， 请求 环境 栈 应用环境 栈 都 空 。 app 类 代码 引用 办法 。   一个 请求 ， 请求 环境 栈会 执行 push 动作 ， 收集 好 环境 很多 变量 ，   request   session   ， 变量 ， 请求 环境 上下文 压入 堆栈 ， 检查 应用环境 堆栈 ， 为空 ， 会 自动 创建 ； 默认 top ， 会 自动 创建 压入 。   讨论 flask 应对 多线程 多协程 默认 下 ， 【 讨论 ， 只 说 线程 】 ， 最小 线程 单元 中 ， 请求 环境 栈 应用环境 栈 都 ， 都 会 默默 记录 下 请求 环境 应用环境 ， 都 一个 请求 一个 请求 顺序 。 一个 请求 ， push ， 完 ， pop 。 很 简单 模式 。   应用环境 存储 做 优化 ， top 存储 None ， 到时候 需要的话 ， 调用   current _ app   来取 。   取 采用 代码 一种 惰性 动态 代理 机制 ：   def   _ lookup _ req _ object   (     ) :   top   =   _ request _ ctx _ stack   .   top     top     None   :   raise   RuntimeError   (   _ request _ ctx _ err _ msg   )   return   getattr   (   top   ,     )   request   =   LocalProxy   (   partial   (   _ lookup _ req _ object   ,   \" request \"   ) )   session   =   LocalProxy   (   partial   (   _ lookup _ req _ object   ,   \" session \"   ) )   g   =   LocalProxy   (   partial   (   _ lookup _ app _ object   ,   \" g \"   ) )   request   session 生存期 请求 期 ， 这是 。 g 变量 还 讨论 下 。 第一个 g 最小 粒度 在线 程 ， 线程 之间 g 不相干 。 在线 程 内部 接受 请求 ， 都 引用 默认 上下文 环境 ， g 多个 请求 公用 。 讨论 ， 线程 之间 g 不 通用 ， 就算 线程 内部 ， 应付 多个 请求 ， 多个 情况 来说 g 上下文 绑定 ， 请求 不 公用 g 。   flask 推荐 请求 之间 记住 值 ， 推荐 数据库 session 变量 ， session 挂 请求 上下文 中 ， 请求 上下文 创建 其是 接受 session 参数 ：   def   __ init __ ( ,   app ,   environ ,   request = None ,   session = None ) :   session 传递 还 ， werkzeug 。   flask 推荐 g 一种 方式 ， 管理 数据库 连接 ， g 会为 空 ， ， 确保 引用 ， 检查一下 即可 ：     flask   import   g   def   _ db   ( ) :     ' db '       g   :   g   .   db   =   connect _ _ database   ( )   return   g   .   db   @ app   .   teardown _ appcontext   def   teardown _ db   ( ) :   db   =   g   .   pop   (   ' db '   ,   None   )     db       None   :   db   .   close   ( )   五   情况 怎么回事   参考   篇文章   讨论   ， flask 支持 编码 风格 ：     werkzeug . wsgi   import   DispatcherMiddleware     frontend _ app   import   application     frontend     backend _ app   import   application     backend   application   =   DispatcherMiddleware   (   frontend   ,   {   ' / backend '   :   backend   } )   单一 线程 接受 请求 ， 请求 app 负责 ， 请求 app 负责 ， 上下文 环境 栈是 支持 情况 。   教程 都 会 提到 上下文 环境 用于 单元测试 ：     app . app _ context ( ) :   pass       import   app     flask   import   current _ app   app _ ctx   =   app . app _ context ( )   app _ ctx . push ( )   print ( current _ app . )   六   session 到底 东西   提到 flask 创建 请求 上下文 session 参数 不 传 进来 ， flask session 到底 东西 ？   说 下 背景 知识 ： 服务器 响应 内容 设置 响应 头 ：   Set - Cookie   ， flask ：   r   =   Response ( ' test ' )   r . set _ cookie ( ' a ' , ' 1 ' )   客服 端 client 或者说 浏览器 接收 响应 ， 下次 目标 服务器 请求 会 请求 头上 加上 Cookie 。   图 所示 ：   ：   第二次 刷新 ， 浏览器 无痕 模式 测试 ， 第一次 request 请求 头 Cookie 。   上 图 Cookie 中   session   字 段 ， 内容 含义 不明 。 flask session ：     flask   import   session   flask 加密 。",
            "tags":"web_server",
            "url":"articles/flask-context-faq.html"
        },
        {
            "title":"flask模块",
            "text":"前言   django 一种 构建 大型 商务 网站 解决方案 ， 贵 公司 技术 栈是 架构 django 之上 ， 性质 小 项目 ， 刚刚开始 新 项目 ， 推荐 flask 多于 django 。 flask tornado 之间 选择 上 ， 更 python 异步 一块 理解 上 ， 懂 python 异步 ， 做 api 并发 速度 都 很 高 ， 选择 tornado ， 选择 flask 。   个人爱好 去 搭建 小 网站 api 服务 ， 选择 flask 很 适合 。 本文 作者 鼓捣 小 网站 慢慢 积累 东西 。   推荐 启动 方式   flask 推荐 启动 方式 ：   flask   run     python   - m   flask   run   启动 flask 。 【 方式 很 适合 开发 测试 ， 部署 WSGI   server 】   执行 命令 ， 设置 好 环境变量 ， 最   FLASK _ APP   变量 ：   windows   set   FLASK _ APP = . py   flask   run   linux   export   FLASK _ APP = . py   flask   run   推荐 当前工作 目录 下 加上   . env   文件 ， 定义 ：   FLASK _ APP = myapp . py   FLASK _ ENV = development   FLASK _ DEBUG = 1   环境变量 ， 运行   flask   命令 会 自动 加载 环境变量 。 【 加载 针对 flask 命令 ， load _ dotenv   模块 做 做 ， 不 受 影响 。 】   FLASK _ DEBUG   设置 1 开启 flask 调试模式 ：   重载 器   源码 文件 变动 自动 重启 服务器   调试器   出现异常 浏览器 中 显示 异常 信息   生产 环境 调试模式 关闭 ！   pycharm 启动   pycharm flask 启动 支持 ， 采用 上 描述 启动 方式 ， 会 接近 服务器 部署 环境 。   选择 启动 python 脚本 ， 选择   Module     ，   python   - m   flask   命令 效果 ， 加上 参数   run   ， 环境变量 上 所示 ， 不用 再 特别 调配 ， 工作 目录 设置 下 即可 。   类似 还 再 加上 一个   python   - m   flask   shell   命令 。   flask 请求 分发   查看 flask app url 分发 情况   app . url _ map   默认 flask 有个 额外 路由   / static / < filename >   flask 请求 对象   request 请求 对象 ：   form   dict   存储 请求 表 单字 段   args   dict   存储 URL 上 传递 参数   values   form args 合集   cookies   dict   存储 请求 cookies   headers   dict   存储 http headers   files   dict   存储 请求 上传 文件   _ data   返回 请求 主体 缓冲 数据   _ json   return   dict   包含 解析 请求 主题 后 json   blueprint   请求 Flask 蓝本   endpoint   请求 Flask 端点 名称   method   HTTP 请求 方法   scheme   http https   _ secure   HTTPS 发送 请求 返回 True   host   请求 主机名   path   请求 URL 路径   query _ string   URL 查询 字符串   full _ path   URL   路径 查询 字符串   url   完整 URL   base _ url   url 查询 字符串   remote _ addr   远程 IP地址   environ   dict   请求 原始 WSGI 环境   flask 请求 钩子   请求 钩子 装饰器 ， flask 四种 钩子 ：   _ request   请求 执行   _ _ request   只 第一次 请求 前 执行   _ request   每次 请求 后 执行   程序 抛出 异常   teardown _ request   每次 请求 执行 ， 抛出 异常   请求 钩子 视图函数 之间 变量 互通 上下文 全局变量   g   ，   _ request   设置   g . user   登录 用户 ， 视图函数 调用   g . user   得知 登录 用户 。   flask 响应 对象   response   =   make _ response ( content ,   status _ code )   response . set _ cookie ( ' a ' , 1 )   响应 对象 属性 方法 ：   status _ code   headers   set _ cookies   设置 cookies   delete _ cookies   删除 一个 cookies   content _ length   内容 长度   content _ type   响应 主体 媒体 类型   set _ data   _ data   响应 ：   重定向 响应   状态 码   302   Location 写 上 目标 URL   flask 提供   redirect 函数 快速 生成 重定向 响应 对象 。   abort 函数   返回 状态 码 404   其是 抛出 异常   错误 页面   @ app . errorhandler ( 404 )   def   page _ _ found ( e ) :   return   render _ template ( ' 404 . html ' ) , 404   蓝图 ， 全局 效果 ，   app _ errorhandler   ：   @ main   .   app _ errorhandler   (   404   )   def   page _ _ found   (   e   ) :   return   render _ template   (   ' 404 . html '   ) ,   404   url _   url _ ( ' index ' ,   _ external = True )   名字 ，   送入 参数 进去   _ external   绝对路径   ， 相对路径 即可 ， 浏览器 之外 链接 绝对路径   蓝图 视图函数 ， 加上 蓝图 名 ：   url _ ( ' main . index ' )   静态 文件   url ( ' static ' ,   filename = ' favicon . ico ' )   flash 消息   flash 消息 用户 信息 。 flash 函数 。 模板 文件 上 加上 ：   { %     message     _ flashed _ messages ( )   % }   < div   class = \" alert   alert - warning \" >   < button   type = \" button \"   class = \" close \"   data - dismiss = \" alert \" > & times ; < / button >   { {   message   } }   < / div >   { %   endfor   % }   大型 结构   请 参看 参考资料 1 ， 有名 flasky 项目 结构 。 简单 说 ：   配置 开发 测试 生产 分离   工厂 函数   create _ app   延迟 创建 。   蓝图 （ Blueprint ）   蓝图 模块 写法 ：   ` ` ` python     flask   import   Blueprint   main   =   Blueprint ( ' main ' ,     )     .   import   views ,   errors   ` ` `   views   errors 模块 还 蓝图 对象 main ， 放在 引入 进来 。   蓝图 中 注册 写法 ：   python     . main   import   main     main _ blueprint   app . register _ blueprint ( main _ blueprint )   蓝图 错误 页面   app _ errorhandler   注册 全局 错误处理 ，   errorhandler   只 负责 蓝图 内 错误 。   python   @ main . app _ errorhandler ( 404 )   def   page _ _ found ( e ) :   return   render _ template ( ' 404 . html ' ) ,   404   蓝图 内 注册 视图函数 ，   url _   获取   main . index   形式 ， 蓝图 名 加上 视图函数 名 。   数据库 相关   __ tablename __   定义 表名 ， 默认 表名 遵循 复数 命名 约定     users   。   一块 东西 会 补充 ， 更 sqlalchemy sql 知识 。   flask   shell 命令 定制   @ app   .   shell _ context _ processor   def   make _ shell _ context   ( ) :   return   dict   (   db   =   db   ,   User   =   User   ,   Role   =   Role   )   运行 ：   flask   shell   db 变量 。   cmd 配置 好 环境变量   export   FLASK _ APP = . py   flask - migrate   flask - migrate   基于 sqlalchemy     alembic   ， 做 额外 工作 。   提供 便捷 命令行 接口 ， 熟悉 sqlalchemy alembic 。   一个 简要 例子 ：     flask   import   Flask     flask _ sqlalchemy   import   SQLAlchemy     flask _ migrate   import   Migrate   app   =   Flask   (   __ __   )   app   .   config   [   ' SQLALCHEMY _ DATABASE _ URI '   ]   =   ' sqlite : / / / app . db '   db   =   SQLAlchemy   ( )   db   .   init _ app   (   app   )   migrate   =   Migrate   (   app   ,   db   )   class   User   (   db   .   Model   ) :   id   =   db   .   Column   (   db   .   Integer   ,   primary _ key   =   True   )     =   db   .   Column   (   db   .   String   (   128   ) )   新 项目 运行 ：   flask   db   init   alembic   alembic   init   命令 ， 创建   migrations   文件夹 ， 文件 alembic ， migrations 文件夹 推荐 源代码 版本控制 。   简单 alembic ， 新建   env . py   优化 ， flask 配置 环境 里 配置   SQLALCHEMY _ DATABASE _ URI   变量 ， alembic 正确 找到 数据库 。   ：   flask   db   revision   #     alembic   revison   flask   db   migrate   #     alembic   revision   - - autogenerate   flask   db   upgrade   #     alembic   upgrade   flask   db   downgrade   #     alembic   downgrade   工作 流程 ：   修改 数据库 模型 或者说 数据库 模型 发生 变动   flask   db   migrate   创建 迁移 脚本   检查 自动 生成 脚本 ， 改正 不 正确 地方   flask   db   upgrade   改动 数据库   删除 无用 迁移 脚本   alembic 自动 生成 脚本 万能 ， 人工 审核 。 就算 没 迁移 脚本 ， 毫无意义 ， 版本 迁移 脚本 删除 。   从零开始 迁移 脚本   alembic 官方 文档 ， 很 有用 。   flask 下 加上 两个 命令 ， 负责 最 创建 数据库 代码生成 表格 工作 。   表格 生成 成功 都 flask - migrate   或者说   alembic 管理 ， 测试 models . py   新加 一列 ， 利用   flask   db   migrate   自动检测 新 一列 ， 自动 生成 代码 会 精准 。     sqlalchemy _ utils   import   database _ exists   ,   create _ database   ,   drop _ database   @ app   .   cli   .   command   ( )   def   initdb   ( ) :   user _ input   =   input   (   ' 命令 只 用于 数据库 初始化 ， 后续 更改 请 alembic 管理 ， 请 输入   [ Y ] '   )     user _ input   .   lower   ( )   = =   ' y '   :   engine   =   db   .   engine       database _ exists   (   engine   .   url   ) :   create _ database   (   engine   .   url   )     :   print   (   ' db   exists ... '   )   import   sys   sys   .   exit   (   -   1   )   assert   database _ exists   (   engine   .   url   )   db   .   create _   ( )     alembic . config   import   Config     alembic   import   command   alembic _ cfg   =   Config   (   ' migrations / alembic . ini '   )   command   .   stamp   (   alembic _ cfg   ,   \" head \"   )   @ app   .   cli   .   command   ( )   def   dropdb   ( ) :   \" \" \"   TODO   生产 环境 不 调用 命令   : return :   \" \" \"   user _ input   =   input   (   ' 警告 ! ! !   操作 删除 数据库 ， 数据 丢失 ， 请 输入 ：   [ YYY ] '   )     user _ input   = =   ' YYY '   :   engine   =   db   .   engine   db   .   drop _   ( )     database _ exists   (   engine   .   url   ) :   drop _ database   (   engine   .   url   )     :   print   (   ' db     exists ... '   )   assert     database _ exists   (   engine   .   url   )   flask - moment   Moment   JS   送入 UTC 时间 会 自动 转换 本地 时间 ， 服务器 时间 戳 记录 UTC 时间 。 用户 本地 时间 。   { %   block   scripts   % }   { {   super ( )   } }   { {   moment . include _ moment ( )   } }   { {   moment . lang ( \" zh - cn \" )   } }   { %   endblock   % }   模板 上 ：   < p > 时间 ：   { {   moment ( current _ time ) . format ( ' LLLL ' )   } } . < / p >   < p > { {   moment ( current _ time ) . fromNow ( refresh = True )   } } 刷新 . < / p >   格式 请 参看   MomentJs   官网   。   flask - wtf   这块 初 接触 理解 上 困难 ， flask - wtf 提供 WTForms 模块 集成 支持 ， 功能   wtf . quick _ form ( form )     flask - bootstrap     WTForms 额外 支持 。 理解 上 关键在于 理解   WTForms   模块 到底 干什么 事情 。   WTForms 模块   简单 来说 WTForms 模块 做 工作 模板 引擎 上 jinja2 模块 引擎 上 快速 创建 输入 表单 相关 验证 事宜 。   定义 一个 Form 类 ：     wtforms   import   Form   ,   BooleanField   ,   StringField   ,   validators   class   RegistrationForm   (   Form   ) :   username   =   StringField   (   ' Username '   ,   [   validators   .   Length   (   min   =   4   ,   max   =   25   ) ] )   email   =   StringField   (   ' Email   Address '   ,   [   validators   .   Length   (   min   =   6   ,   max   =   35   ) ] )   accept _ rules   =   BooleanField   (   ' I   accept     site   rules '   ,   [   validators   .   InputRequired   ( ) ] )   Form 类 Field 类 ， Field 类 一个 列表 定义 一系列 Validators   验证 器 。 Field 都 一个 Widget   ， Widget 负责 HTML 渲染 工作 。   form 类 值得 ：   form 对象 ，   form . username . data   获取 表单 中 值 。   定义 form 对象 定义   validate _ < field _ >   函数 ， 函数 会 针对 特定 field _ 调用 。 验证 失败 ， 抛出   ValidationError   异常 ， 异常 信息 错误信息 。   Form 类 python 中 代码 ：   @ app   .   route   (   ' / submit '   ,   methods   =   (   ' GET '   ,   ' POST '   ) )   def   submit   ( ) :   form   =   MyForm   (   request   .   form   )     request   .   method   = =   ' POST '     form   .   validate   ( ) :   return   redirect   (   ' / success '   )   return   render _ template   (   ' submit . html '   ,   form   =   form   )     flask - wtf   下 代码 ：   @ app   .   route   (   ' / submit '   ,   methods   =   (   ' GET '   ,   ' POST '   ) )   def   submit   ( ) :   form   =   MyForm   ( )     form   .   validate _ _ submit   ( ) :   return   redirect   (   ' / success '   )   return   render _ template   (   ' submit . html '   ,   form   =   form   )   flask - wtf   定义 Form 类 上 提供 便利 ：   会 自动   request . form     request . files   塞进去 。     validate _ _ submit   方法 即可 ， 集成   request . method   判断 — —   POST   PUT   PATCH   DELETE   都 。   WTForms   初始化 接收 值 ， 第一个 值   request . form   ， 还 支持 对接 model   对象 ， 还 跟上 关键词 参数 ：   form   =   MyForm ( request . form ,   user ,   username = ' zhangsan ' )   WTForms 提供 很多 内置 验证 器 支持 ， 还 定义 验证 器 。 验证 器   validate   方法 中 ， 。   WTForms 渲染   提到 form 类 实例 中 Field 调用 str ( )   一段 HTML 代码 ：   < input   id = \" content \"   = \" content \"   type = \" text \"   = \" foobar \"   / >   模板 引擎 渲染 时 ， jinja2 ， 会 接受 form 实例 。 一个 表单 渲染 ：   class   LoginForm   (   Form   ) :   username   =   StringField   (   ' Username '   )   password   =   PasswordField   (   ' Password '   )   form   =   LoginForm   ( )   < form   method = \" POST \"   action = \" / login \" >   < div > { {   form . username . label   } } :   { {   form . username ( class = \" css _ class \" )   } } < / div >   < div > { {   form . password . label   } } :   { {   form . password ( )   } } < / div >   < / form >   python 代码 ， form Field 接受 额外 关键词 参数 ， 属性 传入 input 标签 属性 。   csrf _ token 相关   WTForms     csrf _ token   支持 功能 ：   { {   form . csrf _ token   } }   这块 细节 请 参看 WTForms csrf _ token 相关 章节 ， 不 深究 ， 一个 csrf _ token 校验 。     flask - wtf   推荐 写法 ：   < form   method = \" POST \"   action = \" / \" >   { {   form . hidden _ tag ( )   } }   { {   form . . label   } }   { {   form . ( size = 20 )   } }   < / form >   hidden _ tag   方法 flask - wtf 提供 ， 隐藏 html   field   渲染 ，   flask - wtf   默认 会 加上   csrf _ token   支持 ， 语句 ：   { {   form . csrf _ token   } }   这是 一个 hidden 标签 ， 会 渲染 。   flask - bootstrap 提供 额外 支持   flask - bootstrap 提供 额外 支持 ， 简单 来说 编写 jinja2 宏 。   quick _ form   宏 ：   { {   wtf . quick _ form ( form )   } }   大体 输出 语句 ：   { %   import   \" bootstrap / wtf . html \"     wtf   % }   < form   class = \" form   form - horizontal \"   method = \" post \"   role = \" form \" >   { {   form . hidden _ tag ( )   } }   { {   wtf . form _ errors ( form ,   hiddens = \" \" )   } }   { {   wtf . form _ field ( form . field1 )   } }   { {   wtf . form _ field ( form . field2 )   } }   < / form >   说 大体 ， quick _ form   宏 参数 调配 。 默认 参数 输出 情况 。     form _ errors   宏     form _ field   宏 都   flask - bootstrap   宏 文件 定义 。 刚 表单 显示 特别 ，   quick _ form   宏 很 好 。   特别 ， 深究 flask - bootstrap   宏 定义 情况 ， 退化 写法 ， 再 稍作 定制 。   flask - wtf   最 原始 写法 ， 再 调配 下 即可 。   < form   method = \" POST \"   action = \" / \" >   { {   form . hidden _ tag ( )   } }   { {   form . . label   } }   { {   form . ( size = 20 )   } }   < / form >   WTForms 支持 Field   BooleanField   复选框   DateField   文本 字 段     datetime . date   DateTimeField   文本 字 段     datetime . datetime   DecimalField   文本 字 段     decimal . Decimal   FileField   文件 上传 字 段   HiddenField   隐藏 文本 字 段   FieldList   一组 指定 类型 字 段   FloatField   文本 字 段     float   FormField   一个 表单 字 段 嵌入 一个 表单   IntegerField   文本 字 段     integer   PasswordField   密码 文本 字 段   RadioField   单选 按钮   SelectField   下 拉 列表   SelectmultipleField   下拉多选 列表   SubmitField   表单 提交 按钮   StringField   文本 字 段   TextAreaField   多行 文本 字 段   WTForms 提供 Validator   DataRequired   确保 类型转换 后字 段 数据   Email   验证 电子邮箱   EqualTo   两个 字段 值   常用 两次 密码 输入   InputRequired   确保 类型转换 前字 段 数据   IPAddress   验证 IPv4 地址   Length   长度 验证   MacAddress   验证 MAC 地址   NumberRange   数字 校验   Optional   字 段 输入 ， 跳 校验 函数   Regexp   正则表达式 校验   URL   URL 校验   UUID   UUID 校验   AnyOf   输入 值 任一 值中   NoneOf   输入 值 不 一组 值中   flask - login   flask - login 引入 进来   jinja2 模块 都 支持   current _ user   变量 。   提供   login _ required   url 权限 控制 。   flask - login 请 参看 官方 文档 ， 重点 讲 flask - login 都 做 事情 ， 参考资料 1 说 很 好 。   login _ user   函数 用于 登录 用户 ， 核心 用户 id 写入 flask session 。 类似   logout _ user   id session 中 删除 。   渲染 jinja2 模板 ， 会   flask - login     current _ user   变量 请求 。 调用 flask - login     _ _ user   函数 。   _ _ user   检查 session 中 有没有 用户 id ， 返回   AnonymousUser   ， 调用   user _ loader   装饰器 注册 函数 。 【 值得 额外 一提 ， python 代码 引用   current _ user   返回 数据库 User 对象 ， 数据库 对象   current _ user ._ _ current _ object ( )   】   login _ required     current _ user     _ authenticated   方法 调用 ， True   ， False 拒绝 。   参考资料   Flask   Web   开发 第二 版   米格尔 · 格林 贝格 著   安道 译",
            "tags":"web_server",
            "url":"articles/flask-module.html"
        },
        {
            "title":"django学习笔记",
            "text":"Beginning   先 介绍 下 Djanog 项目 文件夹 结构 ， 命令 操作 常识性 东西 。   新建 一个 项目 ：   新建 项目   django - admin   startproject   project -   命令 创建 一个 文件夹 ， 文件夹 名字 设置 project - ， 文件夹 一个 manage . py 文件 ， 文件 作用 挂载 django 配置 （ settings . py 文件 ， 修改 dev _ settings . py 文件 ） 。   一个 文件夹 ， settings . py   、   urls . py     wsgi . py   文件 。   settings . py   控制 django 配置管理 ；   urls . py   控制 django 路径 分发 主 入口 ， 配置 中 修改 。   wsgi . py   apache uwsgi 挂载 控制 入口 。   最 简单 初始 项目 运行 ：   开启 服务器   python   manage . py   runserver   localhost : 8080   控制 服务器 监听 localhost 外网 0.0 . 0.0 ， 端口号 。   新建 一个 app   python   manage . py   startapp   app _   顺便 说 ， 项目 找 不到   manager . py   文件 ， 文件 一个 便捷 入口 ， 命令 都   django - admin   命令 运行 。   数据库 操作   定义 模型 ， 运行 :   python   manage . py   makemigrations   app _   过程 创建 app 下 migrations 文件夹 迁移 python 脚本 文件 ， 情况 手工 修改 迁移 文件 。   python   manage . py   migrate   命令 执行 迁移 python 脚本 。   交互式 环境   python 交互 环境 ， 纯 python 交互 环境 区别 django 东西 ， 定义 模型 对象 。 开发 测试 工作 有用 ！   python   manage . py   shell   sql 交互 环境 :   python   manage . py   dbshell   创建 超级 用户   最 创建 项目 admin   url 挂上去 ， 去   \\ verb + / admin +   url 下 看 ， 登录 做 数据库 表格 创建 工作 外 ， 还 创建 一个 超级 用户 用于 登录 。   python   manage . py   createsuperuser   apps . py   快捷 命令 创建 app 模块 文件 ， 例子 其有 文件 ， 文件 含义 ： 这是 django 项目 用来 存放 app   相关 配置 信息 地方 。   一个 例子 ：     django . apps   import   AppConfig   class   RockNRollConfig   (   AppConfig   ) :     =   ' rock _ n _ roll '   verbose _   =   \" Rock   ' n '   roll \"   定义 app 名字 完整 名字 ， app   __ init __. py   文件 下 ：   default _ app _ config   =   ' rock _ n _ roll . apps . RockNRollConfig '   引入 配置文件 。   ？ ， 最 简单 用处 app   INSTALLED _ APPS   默认 文件夹 名字 ， 定义 名字 。   一个 高级 用法 定制   ready   方法 ， 初始化 app 信号 设置 。   url 分发   web 框架 一个 核心 功能 url 分发 工作 ， 先 来看 下 django 这块 内容 。   过程   project     urls . py   定义 好 项目 url 分发 规则 。 默认 内容 :     django . urls   import   path     django . contrib   import   admin   urlpatterns   =   [   path   (   ' admin / '   ,   admin   .   site   .   urls   ) ,   ]   读者 兴趣 先看 下 admin 页 ，   / admin   。 请 确认 执行 数据库 操作   makemigrations     migrate   ， 创建 超级 用户   createsuperuser   。 django 默认 自动 创建 admin 支持 页面 。   接下来 类似 插入   app     urls 定义 。 简单 写 上 即可 :     django . urls   import   include   ,   path   ....   path   (   ' app _ / '   ,   include   (   ' app _ . urls '   ) ) ,   ....   url 分发 需求 情况 下 ， 都 推荐 上 django 官方 教程 推荐 url 分发 写法 。   app 下   urls . py   进一步 定义 url 分发 规则 :     django . urls   import   path     .   import   views   urlpatterns   =   [   path   (   ' '   ,   views   .   index   ,     =   ' index '   ) ,   ]   讨论 django 官方 教程 ， 推荐 写法 风格 。   url 上带 参数     django . urls   import   _ path     .   import   views   urlpatterns   =   [   _ path   (   r   ' &# 94 ; add / ( [ \\ d ] + ) / ( [ \\ d ] + ) $ '   ,   views   .   add   ,     =   ' add '   ) ,   ]   参数 逐个 传递 视图函数 ， 唯一 值得一提的是 django 视图函数 默认 第一个 函数 传递 进去   request   参量 。   views . py   内容 :     django . http   import   HttpResponse   def   add   (   request   ,   a   ,   b   ) :   res   =   int   (   a   )   +   int   (   b   )   return   HttpResponse   (   str   (   res   ) )   正则表达式 写法 老式 django url 写法 ， 特别 需求 ， django 官方 教程 ， 采用 推荐 写法 ：     django . urls   import   path     .   import   views   urlpatterns   =   [   path   (   ' add / < int : a > / < int : b > '   ,   views   .   add   ,     =   ' add '   ) ,   ]   url 定义     参量 大体 类似 flask   endpoint   概念 ， django   reverse   函数 ， 大体 类似 flask   url _   概念 。   视图函数   add   url :     django . core . urlresolvers   import   reverse   reverse ( ' add ' , args = ( 1 , 2 ) )   模板 中有 :   < a   href = \" { %   url   ' add '   1   2   % } \" > link < / a >   获取 full - url   提到 reverse 函数 返回 url 字符串 还 完整 url ， url 。 获取 全站 完整 url   request . build _ absolute _ uri ( location )   ， 不 指定 location 默认 url 。   请求 响应   request   ， APIView 含义 方法 ， 都 会 接收 一个   request 对象 ， 对象 ：   query _ params   GET 传过来 参数   data   POST   PUT   PATCH   传过来 参数 ， 还 没完 ， 传过来 文件 ， 表单 都 支持 。   user   请求 认证 会 返回 用户 记录 ， 编写 auth 类 会 ， 认证 ， 返回   AnonymousUser   Response   含义 方法 返回 对象 ， 第一个 参数 data ， 字典 值 ， 会 自动 封装 json 友好 格式 。 实际上 套路 ：   return   Response ( serializer . data )     serializer   有个   _ valid   方法 ， 用来 序列化 类 输出 前 预热 。 这两点 序列化 讨论 中 会 涉及 。 看 ：   Response ( data ,   status = None ,   template _ = None ,   headers = None ,   content _ type = None )   headers   http 协议 响应 头 ， status   http 状态 码 。   过程 套路 ， 很多 高级 视图 套路 都 类似 例子 ， 看 几遍 。   class   SnippetDetail   (   APIView   ) :   \" \" \"   Retrieve ,   update     delete   a   snippet   instance .   \" \" \"   def   _ object   (     ,   pk   ) :     :   return   Snippet   .   objects   .     (   pk   =   pk   )     Snippet   .   DoesNotExist   :   raise   Http404   def     (     ,   request   ,   pk   ,   format   =   None   ) :   snippet   =     .   _ object   (   pk   )   serializer   =   SnippetSerializer   (   snippet   )   return   Response   (   serializer   .   data   )   def   put   (     ,   request   ,   pk   ,   format   =   None   ) :   snippet   =     .   _ object   (   pk   )   serializer   =   SnippetSerializer   (   snippet   ,   data   =   request   .   data   )     serializer   .   _ valid   ( ) :   serializer   .   save   ( )   return   Response   (   serializer   .   data   )   return   Response   (   serializer   .   errors   ,   status   =   status   .   HTTP _ 400 _ BAD _ REQUEST   )   def   delete   (     ,   request   ,   pk   ,   format   =   None   ) :   snippet   =     .   _ object   (   pk   )   snippet   .   delete   ( )   return   Response   (   status   =   status   .   HTTP _ 204 _ NO _ CONTENT   )   urls . py 加上 :   url ( r ' &# 94 ; snippets / ( P < pk > [ 0 - 9 ] + ) / $ ' ,   views . SnippetDetail . _ view ( ) ) ,   正则表达式   ( P < pk > [ 0 - 9 ] + )   收集 一串 数字 ， 一串 数字 命名   pk   。   模型 定义   django 模板 sqlalchemy 很多 地方 类似 。   settings 配置   INSTALLED _ APPS :   加上 新   app   名字 ， 不 加   makemigrations   管理 数据库 。   DATABASES :   默认 会 创建 一个 sqlite3 数据库 ， 需求 ， 想要 mysql 数据库 ， 参考 样例 修改 配置 。 连接 mysql 样例 :   DATABASES   =   {   ' default ' :   {   ' ENGINE ' :   ' django . db . backends . mysql ' ,   ' NAME ' :   \" database _ \" ,   ' USER ' :   \" root \" ,   ' PASSWORD ' :   \" \" ,   ' HOST ' :   \" localhost \" ,   ' PORT ' :   \" 3306 \" ,   ' OPTIONS ' :   {   ' charset ' :   ' utf8 '   }   }   }   会 加上   charset     utf8 选项 ， mysql 设置 好 字符 编码 。 设置 init _ command   设置 字符 编码 更好 字符 编码 兼容性 。   ' OPTIONS ' :   {   ' init _ command ' :   ' SET   character _ set _ database = utf8   , \\   character _ set _ server = utf8 , \\   character _ set _ connection = utf8 , \\   collation _ connection = utf8 _ unicode _ ci ' ,   ' charset ' :   ' utf8 ' }   多个 数据库   多个 数据库 ， 最 常见 情况 单独 app 一个 数据库 。   再 加上 一个 数据库 定义 ：   DATABASES   =   {   ' default ' :   {   ' ENGINE ' :   ' django . db . backends . mysql ' ,   ' NAME ' :   \" database _ \" ,   ' USER ' :   \" root \" ,   ' PASSWORD ' :   \" \" ,   ' HOST ' :   \" localhost \" ,   ' PORT ' :   \" 3306 \" ,   ' OPTIONS ' :   {   ' charset ' :   ' utf8 '   }   } ,   ' youapp ' :   {   ' ENGINE ' :   ' django . db . backends . mysql ' ,   ' NAME ' :   ' youapp ' ,   ' USER ' :   ' root ' ,   ' PASSWORD ' :   ' ' ,   ' HOST ' :   ' ' ,   ' PORT ' :   ' ' ,   ' OPTIONS ' :   { ' charset ' :   ' utf8 ' }   } ,   }   app 新建 一个 dbrouter 文件 ， 定义 一个 YourRouter 类 。   DATABASE _ ROUTERS   =   [ ' youapp . dbrouter . YourRouter ' ]   类 定义 数据库 选择 ：   NOTICE :   app 中 定义 模型 记得 都 加上 app _ label meta 属性 。   class   YourRouter ( object ) :   def   db _ _ read ( ,   model ,   * * hints ) :     model ._ meta . app _ label   = =   ' youapp ' :   return   ' youapp '   return   None   def   db _ _ write ( ,   model ,   * * hints ) :     model ._ meta . app _ label   = =   ' youapp ' :   return   ' youapp '   return   None   def   _ relation ( ,   obj1 ,   obj2 ,   * * hints ) :     obj1 ._ meta . app _ label   = =   ' youapp '     \\   obj2 ._ meta . app _ label   = =   ' youapp ' :   return   True   return   None   def   _ migrate ( ,   db ,   app _ label ,   model _ = None ,   * * hints ) :     app _ label   = =   ' youapp ' :   return   db   = =   ' youapp '   return   None   定义 模型   好 ， 定义 模型 。 语法 :     django . db   import   models   class   Question   (   models   .   Model   ) :   question _ text   =   models   .   CharField   (   max _ length   =   200   )   pub _ date   =   models   .   DateTimeField   (   ' date   published '   )   熟悉 sqlalchemy 这段 代码 很 陌生 ， 进一步 细节 。   字 段 类型   IntegerField :   整型   BigIntegerField :   大 整数   BinaryField :   raw   data   BooleanField :   bool   值   CharField :   定义 字符串 类型 ， 设置 长度   max _ length   属性 。   TextField :   大段 文字 。   DateField :   python 中   datetime . date   对象 。   DateTimeField :   python 中   datetime . datetime   对象 。   一个 有用 基类 :   class   BaseModel   (   models   .   Model   ) :   class   Meta   :   abstract   =   True   updated _   =   models   .   DateTimeField   (   auto _   =   True   )   created _   =   models   .   DateTimeField   (   auto _ _ add   =   True   )   模型 都 继承 自该 基类 ， 基类 创建表格 ， Meta 设置   abstract = True   。 DateTimeField 加上   auto _ = True   ， 模型 每次   save   操作 都 会 自动更新 最新 日期 。     auto _ _ add = True   即该 记录 第一次 创建 时 设置 最新 日期 。 DateTimeField   auto _     auto _ _ add   两个 选项 default 选项 ， 自动 插入 默认 时间   django . utils . timezone . ( )   。   想 六个 小时 记录 查询 ：   checktime   =   timezone . ( )   -   timedelta ( hours = 6 )   result   =   result . exclude ( created _ __ gt =   checktime )   通用 选项   字 段 声明 控制 中有 通用 可选项 :   default :   设置 该字 段 默认值 ， default 还 接受 一个 函数 对象 。   null :   设置 True ， 自动 会 自动 填充 sql 中 NULL 值 ， 字符串 类型 字 段 默认 空字符 。   blank :   设置 True ， 空值 ， null 区别 null 说 数据库 ， blank 说 显示 。   db _ column :   设置 该字段 数据库 中 表格 名字 。   db _ index :   设置   True   该字段 开启 索引 。   primary _ key :   主键   。   unique :   唯一   unique _ _ date :   title 字段 设置 :   unique _ _ date = \" pub _ date \"     title 字段   pub _ date   字段 都 。 日期 内 title 只能 唯一 值 。 看作 一种   unique _   。   数据库 中 关系   ForeignKey :   外键 引用 ， 该字 段 名字 user ， 存储 表格 中 名字 user _ id ，   db _ column   控制 表格 名字 。 -   说 onetomany 关系 定义 ForeignKey 。 ：   class   City ( models . Model ) :     =   models . CharField ( max _ length = 60 )   state   =   models . CharField ( max _ length = 40 )   zipcode   =   models . IntegerField ( )   class   Address ( models . Model ) :   number   =   models . IntegerField ( )   street   =   models . CharField ( max _ length = 100 )   city   =   models . ForeignKey ( City )   一个 city 多个 address ， 一个 address 只能 一个 city ， 一个 外键 映射 city 。 ForeignKey 更 确切 manytoone 关系 ， 模型 一个 外键 属性 ， 多个 记录 指向 同一个 它物   参阅 篇文章   。   OneToOneField   OneToOneField   比较简单 ， 一个 记录 一个 属性 ， 用户 管理 会 用到 。   ManyToManyField   ManyToManyField   读者 请参阅 写   sqlalchemy 模块   一文 ，   写得 详细 。   模型 定义 字 段 ， 更 内容 请 参看 官方 文档 。   多字段 组合 唯一   参考   网页   ，   Meta   定义   unique _   属性 。   ...   title   =   models . CharField ( max _ length = 255 )   gzh _ id   =   models . CharField ( max _ length = 255 ,   null = True ,   blank = True )   ...   class   Meta :   db _ table   =   ' article '   unique _   =   ( \" title \" , \" gzh _ id \" )   定义 模型 中 元类 数据   ...   class   Meta :   db _ table   =   ' table _ '   db _ table   指定 创建 table 表格 名字 。   abstract   创建表格 ， 模型 抽象 模型 。   模型   模型 最 核心 查询 操作 ， 修改 记录 ， 查询 目标 记录 ， 修改 属性 save 即可 。   新建 记录     people . models   import   Person   Person . objects . create ( = \" WeizhongTu \" ,   age = 24 )   插入 一条 记录 主键 重复 ， 程序 会 返回 异常 。 推荐   _ _ create   方法 ：   obj ,   created   =   Person . objects . _ _ create ( _ = ' John ' ,   _ = ' Lennon ' ,   defaults = { ' birthday ' :   date ( 1940 ,   10 ,   9 ) } )   语句 查询 效果 新建 记录 效果 。 写 属性 操作 ， 大体 加强版 ：   :   obj   =   Person . objects . ( _ = ' John ' ,   _ = ' Lennon ' )     Person . DoesNotExist :   obj   =   Person ( _ = ' John ' ,   _ = ' Lennon ' ,   birthday = date ( 1940 ,   10 ,   9 ) )   obj . save ( )   单纯 方法 ， 记录 不 会 抛出   DoesNotExist   异常 ； 找到 多个 记录 ， 会 抛出   MultipleObjectsReturned   异常 。   _ _ created   方法 找到 多个 记录 会 抛出   MultipleObjectsReturned   异常 。     _ _ created   方法 确保 插入 一条 记录 记录 。 created = True target 新建 记录 。   理解   defaults   选项 ， defaults 定义 属性 参与 查询 过程 ， 参与 找到 记录 情况 下 ， 设置 值 。   查询 记录   说 获取 记录 ：   result   =   Person . objects . ( )   返回   QuerySet   对象 ， QuerySet 对象 下 一步 查询 操作 。 ：   result   =   result . filter ( = \" abc \" )   例子 来说 filter 方法 即可 ：   result   =   Person . objects . filter ( = \" abc \" )   排序   QuerySet 对象 进一步 排序 ：   result   =   result . order _ ( ' ' )   reverse   result   =   result . reverse ( )   exclude   排除 记录 ， 排除 created _ 字 段值 大于 时间 值 ：   result   =   result . exclude ( created _ __ gt =   checktime )   offset     limit   result   =   result [ offset :   offset + limit ]   删除 记录   找到 目标 记录 instance ， 调用   delete   方法 即可 。   记录   谈到 查询 操作 ， 读者 单纯 想 记录 ，   exists   方法 最快 最 简便 。 参考   网页   。     Article . objects . filter ( unique _ id =   unique _ id ) . exists ( ) :   ...   关系   OnetoOne 关系 非常简单 ，   a . b     b . a   都 。   ManytoOne 关系   ForeignKey   定义 关系 ， 引用 外键 对象 ，   a . b   即可 ， 反向 onetomany 那种 ， 定义 定义 好   related _   ， （ 参考     ） 引用 ：   b . related _   细节 请 查看 文档     。   序列化   理解 序列化 过程   django   restframework 序列化 类 类似 django 表单 类 ， django 表单 类 用于 沟通 django Model 网页 form 之间 桥梁 ； 序列化 类 用于 沟通 django Model 类 JSON 数据格式 之间 桥梁 。   注 :   Model   - >   Serializer   （ data 挂载 python dict 字典 值 ）   serializer   =   SnippetSerializer ( snippet )   serializer . data   #   { ' pk ' :   2 ,   ' title ' :   u ' ' ,   ' code ' :   u ' print   \" ,   world \" \\ n ' ,   ' linenos ' :   False ,   ' language ' :   u ' python ' ,   ' style ' :   u ' friendly ' }   过程 视图 类 方法 下 ， 数据库 操作 获取 数据库 目标 Model 记录 ， 送入 序列化 类 ， 目标 类   . data   属性 字典 值 ， 送入 Response HTTP 响应 值 。   用法 ， 字典 data 送入 序列化 类 data 属性 中 ，   serializer   =   SnippetSerializer ( data = data )   调用 序列化 类 save 方法 进一步 数据库 操作 。   serializer . save ( )   save 方法 依赖于 进一步 定义 序列化 类   create     update   方法 。 所示 ：   def   create ( ,   validated _ data ) :   return   Comment . objects . create ( * * validated _ data )   def   update ( ,   instance ,   validated _ data ) :   instance . email   =   validated _ data . ( ' email ' ,   instance . email )   instance . content   =   validated _ data . ( ' content ' ,   instance . content )   instance . created   =   validated _ data . ( ' created ' ,   instance . created )   instance . save ( )   return   instance   情况 下 想 定义 save 方法 。   ModelSerializer   类似 django 表单 类 ， 利用   ModelSerializer   类来 更 快 创建 序列化 类 。     rest _ framework   import   serializers   class   SnippetSerializer   (   serializers   .   ModelSerializer   ) :   class   Meta   :   model   =   Snippet   fields   =   (   ' id '   ,   ' title '   ,   ' code '   ,   ' linenos '   ,   ' language '   ,   ' style '   )   证明 简便 写法 （ 包括 create update 方法 都 会 自动 ） 应付 。 shell 里 代码 再 撸 一遍 。   > > >     snippets . models   import   Snippet   > > >   snippet   =   Snippet ( code = ' print   \" ,   world2 \" \\ n ' )   > > >     snippets . serializers   import   SnippetSerializer   > > >   snippet . save ( )   > > >   serializer   =   SnippetSerializer ( snippet )   > > >   serializer . data   { ' language ' :   ' python ' ,   ' linenos ' :   False ,   ' id ' :   3 ,   ' title ' :   ' ' ,   ' code ' :   ' print   \" ,   world2 \" \\ n ' ,   ' style ' :   ' friendly ' }   _ valid   方法   serializer . _ valid ( raise _ exception = True )   定义   validate   方法 目标 对象 验证 ， 定义   validate _ < fieldname >   定义 字 段 级别 验证 。   def   validate   (     ,   data   ) :   \" \" \"   Check       start         stop .   \" \" \"     data   [   ' start '   ]   >   data   [   ' finish '   ] :   raise   serializers   .   ValidationError   (   \" finish     occur     start \"   )   return   data   序列化 类 引用 request . user   参考     ， 序列化 类   . context [ ' request ' ]   获取   request   对象 ， 获取   user 对象 。   user   =   . context [ ' request ' ] . user   模板 基本概念   模板 样子 ， 模板 继承 ， block   ， 循环 ， 过滤 ， 。 熟悉 jinja2 模板 同学 稍微 看 下 大致 。   { %   extends   \" base _ generic . html \"   % }   { %   block   title   % } { {   section . title   } } { %   endblock   % }   { %   block   content   % }   < h1 >   { {   section . title   } }   < / h1 >   { %     story     story _ list   % }   < h2 >   < a   href = \"   { {   story . _ absolute _ url   } }   \" >   { {   story . headline   |   upper   } }   < / a >   < / h2 >   < p >   { {   story . tease   |   truncatewords   : \" 100 \"   } }   < / p >   { %   endfor   % }   { %   endblock   % }   django 查找 模板   django settings . py ：   PROJECT _ DIR   =   os . path . dirname ( os . path . dirname ( os . path . abspath ( __ file __ ) ) )   TEMPLATES = [   {   ' BACKEND ' : ' django . template . backends . django . DjangoTemplates ' ,   ' DIRS ' : [   os . path . join ( PROJECT _ DIR , ' templates ' ) ,   ] ,   默认 app 下 templates 文件 里 都 会 递归 遍历 查找 ， DIRS 加上 一个 文件夹 ， settings . py 所在 文件夹 下 templates 文件夹 会 去 遍历 。   模板 文件 都 会 合并 ， 模板 覆盖 机制 ， 无谓 覆盖 ， 模板 原则上 推荐 结构 templates ， app ， 都 再 新建 一个 目标 app 名字 ， 再 新建 模板 文件 。 稍 小 项目 扔 templates 不 大 。   想 覆盖 django 自带 admin 界面 ， 就要 templates 新建 一个 admin 文件夹 ， 模板 文件 ， 研究 下 django 源码 。   django 变量 传给 javascript   NOTICE :   不 推荐 写法 ， 推荐 走 ajax 通道 传 数据 。   django 视图函数 render context 字典 值 ， 字段 值 传给 django 模板 里 变量 ， ， django 变量 传递 javascript 。 小节 参考   网页   。   传递 字 段 建议 json 封装 下 ：     django . core . serializers . json   import   DjangoJSONEncoder   {     :   json . dumps ( data [ ' content _ images ' ] ,   cls = DjangoJSONEncoder )   }   javascript ：   var     =   JSON . parse ( \" { {     |   safe   |   escapejs   } } \" )     safe     escapejs   过滤器 。   扩展 用户 模型   小节 参考 这篇   不错 文章   。 扩展 django 自带 用户 模型 ， 最 常见 两种 情况 ， 实际上 两种 情况 都 会 。 第一种   User   模型     Profile   模型 分开 ， User 用来 存放 登录 相关 信息 ， Profile 用来 存放 更 用户 资料 信息 ， User     Profile     onetoone   关系 ， 会 建立 一个 signals 文件 保证 没 创建 一个 User 会 跟着 创建 一个 Profile ：     django . db . models . signals   import   post _ save     django . dispatch   import   receiver     profiles . models   import   Profile     . models   import   User   @ receiver   (   post _ save   ,   sender   =   User   )   def   create _ user _ profile   (   sender   ,   instance   ,   created   ,   * *   kwargs   ) :     created   :   Profile   .   objects   .   create   (   user   =   instance   )   @ receiver   (   post _ save   ,   sender   =   User   )   def   save _ user _ profile   (   sender   ,   instance   ,   * *   kwargs   ) :   instance   .   profile   .   save   ( )   django 默认 auth 机制 ， session   cookies 不 太 满意 ， 推荐 建立   User   模型 ，   继承   AbstractBaseUser   ， 大概 看   AbstractBaseUser   源码 ， 做 工作 都 围绕   password 字段 ， settings 定义 好 :   AUTH _ USER _ MODEL   =   ...   都 工作 。 继承 定义 字 段 不 多用 说 ， 推荐 进一步 继承   PermissionsMixin   类 。   class   User ( AbstractBaseUser ,   PermissionsMixin ) :   email   =   models . EmailField ( _ ( ' email   address ' ) ,   unique = True )   PermissionsMixin   类 定义 群组 信息 。   三个 字 段 属性 含义 ， 都 设置 ：   USERNAME _ FIELD   =   ' username '   EMAIL _ FIELD   =   ' email '   REQUIRED _ FIELDS   =   [ ' email ' ]   写 好   objects     UserManager   ， 继承   BaseUserManager   ， 做 定制 ， 东西 ？   Model . objects .   用法 。 情况 定义 好 ：   create _ user   create _ superuser   两个 方法 即可 。 两个 方法 控制 用户 创建 。   create _ superuser   负责   _ superuser   _ staff   设为 True 。   基于 类 视图   django 初步 下 基于 类 视图 概念 ， 代码 ：     django . http   import   HttpResponse   def   _ view   (   request   ) :     request   .   method   = =   ' GET '   :   #   < view   logic >   return   HttpResponse   (   ' result '   )   变为 更 简洁 ：     django . http   import   HttpResponse     django . views   import   View   class   MyView   (   View   ) :   def     (     ,   request   ) :   #   < view   logic >   return   HttpResponse   (   ' result '   )   依赖 类 继承 ， 引入 Minxin 类 ， http 很多 restful 风格 请求 上 ， 套路 ， 代码 复用 。 基本知识 python 类 继承 ， django   restframework   模块 用手 见识 DRY 理念 。   APIView   django   restframework   APIView   继承   django     View ， 针对 restful   api   很多 优化 ， 情况 下 编写 视图 ， 继承 APIView 合适 ， 介绍 通用 视图 高级 视图 ， 都 情况 下 特别 合适 少 写 代码 ， 好用 ， 仅此而已 。 不 合适 ， 定义     post   put   方法 很 。   视图 再 升级   情况 下   APIView   类   Mixin   最合适 ， 谈谈 django   restframework   提供 高级 通用 视图 类 。 类 都 继承   GenericAPIView   ， 都 一个 ， 类似   Serializer   - >   ModelSerializer   升级 过程 ， 视图 类 方法 操作 对象 基于 数据库 Model 操作 ， 推荐 视图 类 继承   GenericAPIView   。   GenericAPIView   GenericAPIView   继承   django   restframework     APIView   类 ， 提供 一个 很 特性   queryset   ， 设定   queryset 属性   _ queryset   方法 ， 视图 类 很多 方法 都 围绕   queryset   展开 。     CRUD   数据 操作   Minxin 类 ， GenericAPIView   组合 出 很多 高级 视图 类 。   一个 好 建议 这块 ， 看 源码 ， 源码 都 很 简单 ， 看 懂 ， 发现 符合 ， 少写 点 代码 。 额外 定制 需求 ， 重写 方法 。   权限 管理   认证   视图 类里 定义   authentication _ classes   目标 视图 类 认证 ， 默认 认证 管理 类 。   自定义 身份 认证   写 身份 认证 类 ， 继承   BaseAuthentication   ， 重写   authenticate ( ,   request )   方法 ， 认证 成功 返回   ( user ,   auth )   ， 返回 None 。 request . user   登录 用户 实例 ，   request . auth   登录 auth 信息 。   情况 下 身份 认证 失败 想要 抛出   AuthenticationFailed   异常 。   权限   视图 类里 定义   permission _ classes   目标 视图 类 权限 管理 ， 采用 默认 权限 管理 类 。   认证 完 会 进去 权限 管理 ， 权限 检查   request . user   request . auth   调用 。   最 简单 权限 管理 类   IsAuthenticated   ， 身份验证 用户 访问 ， 拒绝 没 用户 访问 。   IsAuthenticatedOrReadOnly   类 身份 认证 用户 访问 ， 身份验证 用户 只能 只读 访问 。   自定义 权限 管理 类   自定义 权限 管理 类 ， 继承   BasePermission   ， 一个 两个 方法 ：   _ permission ( ,   request ,   view )   _ object _ permission ( ,   request ,   view ,   obj )   请求 授予 权限 ， 返回 True ， 权限 返回 False 。   自定义 权限 管理 类 还 加上   message   属性 ， 用户 权限 没 抛出   PermissionDenied   异常 额外 显示信息 。   日志 管理   django python logging 模块 日志 系统 ， django 项目 日志 管理 学习 离不开 logging 模块 学习 。   logging 模块 中级 教程   logging 模块 中级 几个 词汇 ： loggers ,   handlers ,   filters ,     formatters 。   loggers   记录器   运行 logging . info ， 调用 默认 记录器 ， 会 针对 python 模块 文件创建 一个 记录器 。   logger   =   logging . getLogger ( __ __ )     __ __   一种 简便 命名 方法 ， 勤快 某种 情况 下 需要的话 手工 记录器 取个 名字 。     getLogger   函数 指定 名字 定义 （ 指 第三方 模块 下定义 ） ，   getLogger   指定 目标 名字 会 记录器 。 DIY 第三方 模块 日志 记录器 有用 。   记录器 挂载 卸载 处理器 对象 过滤器 对象 ：   logger . addHandler ( )   logger . removeHandler ( )   logger . addFilter ( )   logger . removeFilter ( )   记录器   setLevel ( )   方法 设置 最小 记录 级别 ， Handler 级别 协作关系 。   handlers   处理器 负责 分发 日志 信息 目标 地去 。 介绍 几个 Handler 类 ：   StreamHandler   信息 以流 形式 输出 ， 指 输出 终端   FileHandler   信息 写入 文件 中 去   RotatingFileHandler   信息 写入 文件 ， 文件大小 超过 值 ， 新建 一个 文件 写 。   TimeRotatingFileHandler   信息 写入 文件 ， 每隔 一段时间 ， 比如说 ， 会 自动 再 新建 一个 文件 再 往里面 写 。   处理器 对象   setLevel   方法 ， 提及 ， 记录器   setLevel   协作关系 ， 更 详细 描述 ， 信息 先 记录器 并分 发给 处理器 对象 ， 再 处理器 再 分发 目的地 。   处理器 挂载   格式 器   对象   过滤器   对象 。   handler . setFormatter ( )   handler . addFilter ( )   handler . removeFilter ( )   filters   过滤器   formatters   格式 器 ， 信息 格式 定义 。   字典 统一 配置   django setting . py 会 配置 ， 含义 很 ， 定义 处理器 ， 格式 器 ， 记录器 。   LOGGING   =   {   ' version ' :   1 ,   ' disable _ existing _ loggers ' :   False ,   ' formatters ' :   {   ' simple ' :   {   ' format ' :   \" % ( asctime ) s   % ( ) s   [ % ( levelname ) s ]   % ( thread ) d   % ( module ) s   % ( funcName ) s   % ( lineno ) s :   % ( message ) s \"   }   } ,   ' handlers ' :   {   ' log _ file ' :   {   ' class ' :   ' sdsom . common . log . DedupeRotatingAndTimedRotatingFileHandler ' ,   ' filename ' :   config . ( ' web ' ,   ' log _ path ' ) ,   ' ' :   ' midnight ' ,   ' maxBytes ' : int ( config . ( ' web ' , ' log _ max _ bytes ' ) ) ,   ' interval ' :   1 ,   ' backupDay ' :   int ( config . ( ' web ' ,   ' log _ backup _ days ' ) ) ,   ' dedupetime ' :   int ( config . ( ' web ' ,   ' log _ dedupe _ time ' ) ) ,   ' formatter ' :   ' simple '   } ,   } ,   ' loggers ' :   {   ' django . request ' :   {   ' handlers ' :   [ ' log _ file ' ] ,   ' level ' :   config . ( ' web ' ,   ' log _ level ' ) ,   ' propagate ' :   True ,   } ,   }   }   自定义 命令   目标 app 新建 一个   management   文件夹 ， 新建 一个   commands   文件夹 ， 两个 文件夹 都 带上   __ init __. py   文件 。   commands 文件夹 定义 python 脚本 ， 脚本 命令 调用 ：   python   manage . py   command _   ：   python   manage . py     查看 命令 列表 。   一个 命令 模块 所示 ：     django . core . management . base   import   BaseCommand   ,   CommandError     polls . models   import   Question     Poll   class   Command   (   BaseCommand   ) :     =   ' Closes       poll     voting '   def   add _ arguments   (     ,   parser   ) :   parser   .   add _ argument   (   ' poll _ id '   ,   nargs   =   ' + '   ,   type   =   int   )   def   handle   (     ,   *   args   ,   * *   options   ) :     poll _ id     options   [   ' poll _ id '   ] :     :   poll   =   Poll   .   objects   .     (   pk   =   poll _ id   )     Poll   .   DoesNotExist   :   raise   CommandError   (   ' Poll   \"   % s   \"       exist '   %   poll _ id   )   poll   .   opened   =   False   poll   .   save   ( )     .   stdout   .   write   (     .   style   .   SUCCESS   (   ' Successfully   closed   poll   \"   % s   \" '   %   poll _ id   ) )   django celery   django - crontab 模块 我试 ， 很 便捷 ， 基于 系统 crontab ， django celery 组合 ， celery 灵活 消息 分发 机制 ， 无疑 未来 开发 带来 更 可能性 。 celery 官方 文档     ， 本文 讲 celery 基本概念 django 集成 ， 更 celery 知识 请参阅 官方 文档 。   celery 核心 概念   broker   队列 服务提供者 ， celery 推荐 redis rabbitmq broker 。   task   执行 ， 定义 函数 。   backend   用来 存储 输出   worker   celery 启动 开启 一个 worker 。   django 内 文件 安排   小节 参考   篇文章     篇文章   。 提醒 读者 ， django celery 集成 并不需要 额外 安装 插件 ， 讲 配置 实际上 一个 单独 celery   app 大部分 都 类似 ， 细节 上 优化 。   celeryconfig . py   推荐 django   app   settings . py   旁 新建   celeryconfig . py   文件 ， 教程 设置 配置文件 名字   celery . py   ， 很 不好 ， 文件名 模块 名字 重复 会出 。 内容 ：   import   os     celery   import   Celery   os   .   environ   .   setdefault   (   ' DJANGO _ SETTINGS _ MODULE '   ,   ' project _ . settings '   )   app   =   Celery   (   ' project _ '   )   app   .   config _ _ object   (   ' django . conf : settings '   ,   namespace   =   ' CELERY '   )   app   .   autodiscover _ tasks   ( )   @ app   .   task   (   bind   =   True   )   def   debug _ task   (     ) :   print   (   ' Request :   { 0 ! r }   '   .   format   (     .   request   ) )   新建 测试 ， 几行 配置 基本上 死 。 最 值得 讲 两行 ：   app . config _ _ object ( ' django . conf : settings ' ,   namespace = ' CELERY ' )   app . autodiscover _ tasks ( )   第一行 是从 django 配置 对象 中 读取 配置 ， 特别   namespace = ' CELERY '   ，   CELERY _   开头 配置 才 会 读取 ， 原 celery 配置 关系 ：   CELERY _ BROKER _ URL   - >   BROKER _ URL   那次   CELERY _ BEAT _ SCHEDULE   写成   CELERYBEAT _ SCHEDULE   老实 发现 周期性 程序 启动 不 。   第二行 一个 优化 细节 ， 函数 名字 ， 自动 发现 。 django app 新建 一个   tasks . py   ， celery 会 自动 发现 定义 。   __ init __. py   django 项目 project   settings . py   文件夹 ，   __ init __. py   推荐 写 上 几行 内容 ：     . celeryconfig   import   app     celery _ app   __ __   =   ( ' celery _ app ' , )   settings . py   celery 配置 统一 写   settings . py   文件 ， 提到 ， 都   CELERY _   开头 ， 大体 所示 ：   CELERY _ BROKER _ URL   =   ' redis : / / localhost : 6379 '   # CELERY _ RESULT _ BACKEND   =   ' redis : / / localhost : 6379 '   # CELERY _ ACCEPT _ CONTENT   =   [ ' application / json ' ]   # CELERY _ RESULT _ SERIALIZER   =   ' json '   # CELERY _ TASK _ SERIALIZER   =   ' json '   CELERY _ TIMEZONE   =   ' Asia / Shanghai '   #   schedules     celery . schedules   import   crontab   CELERY _ BEAT _ SCHEDULE   =   {   ' crawl _ juhe _ _ _ hour ' :   {   ' task ' :   ' wxarticles . tasks . crawl _ juhe ' ,   ' schedule ' :   crontab ( minute = 0 ,   hour = ' * / 3 ' ) ,   } ,   ' _ miniute _ _ test ' :   {   ' task ' :   ' wxarticles . tasks . test _ celery ' ,   ' schedule ' :   crontab ( ) ,   } ,   }   定义   好 ， 定义 ， 实际上 定义 一个 函数 ， 简单 打印函数 确认 celery 周期 程序 工作 ：     celery   import   shared _ task   @ shared _ task ( )   def   test _ celery ( ) :   print ( ' celery     working . ' )   celery crontab 功能 很 强大 ，   crontab ( )   每分钟 执行 。 请 参看   官方 文档   。   启动   celery 操作 都 ， 启动 worker ：   celery   - A   project _   worker   - l   info   - A   选项 跟着   celery   app 名字 ， django 项目 名字 。   - l   选项 设置 日志 打印 级别 。   还 加上   - B   启动 周期性 。   开个 命令 ：   celery   - A   project _   beat   - l   info   制作 脚本 ， 制作 后台程序 ， 制作 服务 ， supervisor ， 实际上 celery 关系 不大 ， 不 说 。   手工 启动   参考   网页   。   $   python   manage . py   shell   > > >     myapp . tasks   import   _ task   > > >   eager _ result   =   _ task . apply ( )   翻译   django 翻译 很 便捷 ， 关注 后台 api 编写 ， 实际上 很多 教程 说 ：   TEMPLATES   =   [   {   ...   ' OPTIONS ' :   {   ' context _ processors ' :   [   ...   ' django . template . context _ processors . i18n ' ,   ] ,   } ,   } ,   ]   配置 只 模板 输出 翻译 ， 再 加上 。   MIDDLESWARES   加上 ：   ' django . middleware . locale . LocaleMiddleware ' ,   配置 ：   LANGUAGE _ CODE   =   ' zh - Hans '   USE _ I18N   =   True   设置 好 语言 代码 ， 这是 。   看   django   restframework   翻译 管理 相关 ， 发现 大体 配置 ， 很多 教程 说 设置   LOCALE _ PATHS   变量 没 ， 默认 app locale 文件夹 够用 。   目标 py 文件 下   字符串   装饰 ：     django . utils . translation   import   ugettext _ lazy     _   ...     username     None :   raise   TypeError ( _ ( ' Users       a   username . ' ) )   Model 字段 定义 名字 加上 ， verbose _   加上 ， 异常 信息 加上 。   加完 运行 ：   django - admin   makemessages   - l   zh _ Hans   app locale 文件夹 创建 ， 文件 不想 ，   manage . py   ， 加上   - - ignore   选项 即可 。   windows 下 很 ， 推荐 linux 服务器 下 创建 目标   django . po   文件 ， 再 修改 文件 即可 。 po 文件 头部 东西 ， 估计 ：   \" Language :   zh - Hans \\ n \"   必填 ， 时间 填上 。   运行 :   django - admin   compilemessages   不出意外 ， 翻译 生效 。   创建 复用 app   创建 复用 app 会 极大 降低 目标 django 项目 复杂度 ， ， app 复用 风格 首选 。   制作 django - pypi 包   pypi 包 制作 不 赘述 ， 官方 文档     基础 上 讨论 。   测试   我试 安装 测试 过程 ：   python   setup . py   sdist   pip   install   dist / . tar . gz   安装 官方 文档 ， INSTALL _ APPS 设置 好 。 app 。 安装 测试 过程 中 ， 实在 繁琐 。 推荐 app 文件夹 复制到 测试 webapp 去 ， 修改 看 。 测试 好 再 内容 同步 pypi 安装包 去 。   migrations   官方 文档 选择 制作 sdist pip   install   tar 包 风格 原因 ， 测试 egg 包在 访问 上 很 成问题 ， pip 安装 方法 ， site - packages 安装 才 文件夹 风格 那种 egg 文件 。 下 执行 ：   python   manage . py   makemigrations   app _   才 会 成功 。   生成 迁移 文件 放在 site - packages 目标 文件夹 下 。 制作 pypi 包 migrations 文件夹 迁移 文件 包含 进去 ， 包含 包含   __ init __. py   文件 即可 。   就算 制作 django 目标 pypi 包 ， django 项目   . gitignore   文件 上 加上 一行 不错 ：   * / migrations / *   PS :   stackoverflow 都 加上 ， 人 写 长篇大论 加上 。 一点 ： 早期 测试 开发 过程 ， migrations 文件夹 都   __ init __. py   空白 文件 ， 代码 整洁 ， 测试 开发阶段 不花 精力 ， 这是 争议 。   部署   部署 apache nginx web 服务器 对接 django 项目 ， 说 再 一点 django 一个 wsgi 程序 服务 。   本文 apache 部署 讲解 较为 成熟 。   apache   上 例子 ：   < IfModule   ! wsgi _ module >   LoadModule   wsgi _ module   modules / mod _ wsgi .   < / IfModule >   WSGIPythonHome   \" / home / wanze / venv \"   WSGIPythonPath   \" / home / wanze / venv / webapp \"   < VirtualHost   * : 80 >   ServerName   api . cdwanze . work   WSGIScriptAlias   /   / home / wanze / venv / webapp / webapp / wsgi . py   < Directory   / home / wanze / venv / webapp   >   < IfVersion   > =   2.4 >   Require     granted   < / IfVersion >   < IfVersion   <   2.4 >   Order   deny ,   Allow       < / IfVersion >   < / Directory >   Alias   \" / static \"   \" / home / wanze / venv / webapp / static \"   < Directory   / home / wanze / venv / webapp / static   >   < IfVersion   > =   2.4 >   Require     granted   < / IfVersion >   < IfVersion   <   2.4 >   Order   deny ,   Allow       < / IfVersion >   < / Directory >   < / VirtualHost >   检测 wsgi 模块 加载 ， 加载 上 。   WSGIPythonHome   设置 python 虚拟环境 所在 目录 ， 例子   venv / bin python 执行 脚本 。   WSGIPythonPath   设置 Django 项目 目录 所在   WSGIScriptAlias   设置 WSGI 文件 所在   Alias   Directory   设置 服务 项目 静态 文件 。   静态 文件   静态 文件 再 补充 下 ， 服务 静态 文件 项目 目录 下 static 文件夹 下 ， 静态 文件 djano djangorestframwork 框架 带 静态 文件 ，   python   manage . py   collectstatic   命令 生成 内容 。   settings 设置   STATIC _ ROOT   值 。   STATIC _ ROOT =   os . path . join ( BASE _ DIR ,   ' static ' )   django 站点 部署   多个 django 站点 都   mod _ wsgi   部署 写 ：   WSGIScriptAlias   /   / path / / mysite . / mysite / wsgi . py   WSGIPythonHome   / path / / venv   WSGIPythonPath   / path / / mysite .   deamon 模式 （ 参考   网页   ） ：   < VirtualHost   * : 80 >   ServerName   api . cdwanze . work   WSGIDaemonProcess   cdwanze _ api   processes = 1   python - path = / home / wanze / venv / myapi   python - home = / home / wanze / venv /   threads = 10   WSGIProcessGroup   cdwanze _ api   WSGIScriptAlias   /   / home / wanze / venv / myapi / myapi / wsgi . py   process - group = cdwanze _ api   ...     WSGIProcessGroup   来看 名字 随意 ， 写 。 定义 daemon 进程   python - path   定义 django   project ，   python - home   定义 python 虚拟环境 。   文件 权限   设置 好   Directory   之外 ， 还会 文件 读写 权限 ， 查看 日志 发现 提示 说 文件 权限 读写 。 httpd 执行 User Group ， 看 目标 文件夹 文件 权限 。   Django 项目 wsgi 文件 执行 权限 。 Django 项目 操纵 数据库 ， sqlite3 文件 数据库 ， 会 读写 权限 。   值得一提的是 母 文件夹 执行 权限 ， 文件 都 不 。   nginx   nginx 对接 wsgi 接口 uwsgi 模块 wsgi 接口 服务 。   pip   install   uwsgi   更 细节 请 参看 uwsgi   官方 文档   。   ngnix 配置 ：   upstream   django   {   server   127.0 . 0.1 : 8001 ;   }   server   {   location   /   {   uwsgi _ pass   django ;   include   / path / / / mysite / uwsgi _ params ;   }   }   nginx   serve   静态 文件   server   {   listen   80 ;   ......   client _ max _ body _ size   75M ;   location   / media   {   alias   / path / / media ;   }   location   / static   {   alias   / path / / static ;   }   ......   }   更 nginx 配置 细节 请 参看 写 nginx 配置 文章 。   对外 部署 必看   django 项目 对外 部署 ， python 一个 动态 脚本语言 ， 会 很多 安全性 检查 ， 项目 对外 会 很 不 。 本文 参看 官方 文档     。   第一 确保   DEBUG = False   ， 对外 开着   DEBUG = True   简单 开玩笑 。   运行 ：   python   manage . py   check   - - deploy   settings . py   里 密钥 外置   settings . py   文件 密钥 信息 ， 包括   SECRET _ KEY   数据库 连接 信息 密钥 ， 信息 都 环境变量 引入 配置文件 中 读取 。   ALLOWED _ HOSTS   限定 好域名 ， nginx 服务器 入口 请求 做好 限定 ， 凡是 不 域名 HOST 请求 都 抛出 444 错误 ：   server   {   listen   80   default _ server ;   return   444 ;   }   API 设计   讲 讨论 API 设计 网络 上 流行 Restful 风格 API 设计 都 一般性 原则 ， 强制性 。 API 还 分为 内部 对外 API ， 对外 API 接口 遵循 无 惊讶 原则 ， 遵循 都 通用 写法 风格 ， 内部 API ， 很多 情况 下 ， 还要 内部 便捷性 。   url 设计   url 域名 都 推荐   api . .   风格 ， API 版本 ， URL 上 加上 版本号 ， 一个 很 好 主意 。 端 分离 大 背景 下 ， 前端 后 端的 代码 都 带来 额外 复杂度 。   版本号   阮 一峰 篇文章   ， 推荐   Accept   字 段 ：   Accept :   vnd . - . foo + json ;   version = 2.0   url 第一个 字段 喜欢 django app 名字 ， 接下来 第二个 字 段 推荐   Restful   风格 写 上 目标 资源 名字 ， 并不一定 强制 写 上 名词 复数 形式 ， 两个 url ， 一个 操纵 目标 资源 集 ， 一个 定向 操纵 目标 资源 ， 尾缀 写 上 s 区分 推荐 风格 。   针对 资源 目标 资源 集 额外 动作 ， 额外 动作 指 常规 Restful 风格 增删 查改 动作 之外 额外 动作 需求 ， 讨论 Restful 风格 url 基础 上 加上 第三个 字 段 ， 第三个 字段 额外 动作 名字 不错 风格 。   方法 设计   方法 通用   GET   POST   ， GET 用于 查询 获取 资源 信息 ， POST 用于 创建 修改 信息 这是 疑问 。   Restful 风格 还 推荐 DELETE ， PATCH 方法 ， 编写 都 GET POST 方法 。   参数 设计   查询 操作 针对 目标 资源 集合 ， 参数 推荐 加上 ：   limit   返回 个数   offset   偏移 值 ， 分页 效果   sort   sortby ， 一个 排序 参数   reverse   排序 反转 参数   状态 码 设计   请 参看 HTTP 状态 码 。   返回 内容 结构设计   喜欢 风格 ：   成功 返回 ：   {   ' a ' : 1   }   人会 说 成功 加上 code : 200 代码 ， 这是 ， 获取数据 ， ， 怕 数据 不 ， 加个 针对 目标 数据 判断 即可 。 加个 code : 200 ， 目标 数据字 段 不 ， 程序 不 会 报错 ？   失败 带上 code 错误码 msg 错误信息   {   ' code ' :   10001 ,   ' msg ' :   '   error   msg '   }   错误码 软件系统 内部 一个 统一 规范 ， 常见 错误 类型 ：   资源 找到   找到 多个 资源   未知 错误   输入 缺少 参数   编写 文档   这是 。   技巧   模型 python2 兼容性   提高 模型 python2 兼容性 ， 推荐 模型 定义 上加个 装饰器 。     django . utils . encoding   import   python _ 2 _ unicode _ compatible   @ python _ 2 _ unicode _ compatible   class   Question ( models . Model ) :   #   ...   def   __ str __ ( ) :   return   . question _ text   不 加 装饰器 ， python2   __ unicode __   方法 。   重置 migrations   方法 migrations 文件 删掉 ， 表格 删掉 成功 ， 忽视 django _ migrations 表格 数据 （ 参考   网页   ） 。     django _ migrations   app 迁移 数据 删掉 ， 再 makemigrations migrate ， 更 。   python   manage . py   makemigrations   app _   python   manage . py   migrate   app _   列表 对象   自定义 一个 model 新 Field 对象 解决 ， ListField 。   def   parse _ _ python ( ) :   :     =   ast . literal _ eval ( )   return       Exception     e :   rasie   ValidationError   class   ListField ( models . TextField ) :   \" \" \"   存储 python 列表 对象   \" \" \"   description   =   _ ( \" Stores   a   python   list \" )   def   __ init __ ( ,   * args ,   * * kwargs ) :   super ( ListField ,   ) .__ init __ ( * args ,   * * kwargs )   def   _ python ( ,   ) :         None :     =       isinstance ( ,   list ) :   return     return   parse _ _ python ( )   def   _ prep _ ( ,   ) :         None :   return       =   . text _ type ( )   return     def   _ _ string ( ,   obj ) :     =   . _ _ object ( obj )   return   . _ prep _ ( )   def   _ db _ ( ,   ,   expression ,   connection ,   context ) :         None :   return     return   parse _ _ python ( )   _ db _   数据 数据库 读取 ， 总会 调用 方法 。 包括 （ including     aggregates     values ( )   calls 。   最 最 核心 一个 定制 方法 ， 含义 很 ， 不用 说 。   四个 方法 大体 流程 ：   python   < -   _ python   < -   _ db _ < -   database   python   - > _ _ string   - >   _ prep _   - >   database   NOTICE   上 图 读者 理解 ， 实际上 django 逐个 。 官方 文档 说法   _ python   django 反 序列 （ deserialization   ） ， 还 好 三种 情况 ： None ， 目标 对象 ， 字符串 情况 。   _ _ string   序列化 ，   _ python   。   _ prep _   输入 ( = ' 20170809 ' )   执行 查询 ， 讲过 转化 sql 查询 中 用到 字符串 （ 比如说 datetimefield ） 做 额外 工作 。   数据库   一个 django 项目 原因 ， app 单独 操作 数据库 ， 情况   settings   定义 好 数据库 配置 ：   DATABASES   =   {   ' default ' :   {   ...   } ,   ' newdb ' :   {   ' ENGINE ' :   ' django . db . backends . mysql ' ,   ...   } ,   加上 dbroute 对象 ：   DATABASE _ ROUTERS   =   [ ' articles . dbrouter . ArticlesRouter ' ]   app 定义 好 dbroute 对象 ：   class   ArticlesRouter ( object ) :   def   db _ _ read ( ,   model ,   * * hints ) :     model ._ meta . app _ label   = =   ' articles ' :   return   ' articles '   return   None   def   db _ _ write ( ,   model ,   * * hints ) :     model ._ meta . app _ label   = =   ' articles ' :   return   ' articles '   return   None   def   _ relation ( ,   obj1 ,   obj2 ,   * * hints ) :     obj1 ._ meta . app _ label   = =   ' articles '     \\   obj2 ._ meta . app _ label   = =   ' articles ' :   return   True   return   None   def   _ migrate ( ,   db ,   app _ label ,   model _ = None ,   * * hints ) :     app _ label   = =   ' articles ' :   return   db   = =   ' articles '   return   None   代码 看 ， 定义 模型   Meta   定义 好   app _ label   属性 。 更 信息 请 参看 官方 文档     。   django 模型 对象 获取 表格 名字   参看   网页   。   答 :   model _ instance ._ meta . db _ table   好 django ImageField   参考   篇文章   。   ImageField FileField 很 类似 ， 还   width     height   属性 ， 上传 确保 文件 图片 文件 。   模型 文件 中 定义 :   banner   =   models . ImageField ( upload _ = game _ 2048 _ images ,   blank = True ,   storage = OverwriteStorage ( ) ,   default = \" placeholder . jpg \" )     upload _   控制 图片 计算机 中 保存 路径 ， 指定 一个 文件夹 路径 ， 灵活 ， 一个 函数 灵活 路径 指定 :   def   game _ 2048 _ images ( instance ,   filename ) :   \" \" \"     image   upload   .   \" \" \"   return   ' game / 2048 / images / { } / { } ' . format ( instance . user . username ,   filename )   路径   settings   指定   MEDIA _ ROOT   ， 再 指定 文件夹 路径 。 函数 还 接受 模型 实例 ， 建立 自动 user 用户名 分配 文件夹 路径 。   storage = OverwriteStorage ( )   文件名 重复 覆盖 逻辑 :   class   OverwriteStorage ( FileSystemStorage ) :   ' ' '   存储 文件 图片 ， 文件名 重复 覆盖 。   ' ' '   def   _ _ ( ,   ) :     . exists ( ) :   os . remove ( os . path . join ( settings . MEDIA _ ROOT ,   ) )   return     ImageField   rest _ framework 序列化 类 很 好 联动 ， 序列化 返回 文件 路径 url 字符串 ， 测试 django 挂载 静态 资源 文件 ， 运营 推荐 nginx 设置 url 分发 。     django . conf . urls . static   import   static     django . conf   import   settings     settings . DEBUG :   urlpatterns   + =   static ( ' / data / ' ,   document _ root = settings . MEDIA _ ROOT )   保存 传过来 图片 文件 ， 常规 构建 form 对象 可行 :   form   =   Game2048InfoForm (   request . POST ,   request . FILES ,   instance = target _ info )     form . _ valid ( ) :   _ game _ info   =   form . save ( )   :   logger . warning ( ' form   invalid ' )   :   request . FILES [ ' imgfield ' ]   语法 获取 图片 内容 。   django messages 系统   小节 参看   网页   。   django messages 系统 ， 所示 settings 配置 ：   INSTALLED _ APPS   =   [   ' django . contrib . messages ' ,   ......   MIDDLEWARE _ CLASSES   =   [   ' django . contrib . messages . middleware . MessageMiddleware ' ,   ......   TEMPLATES   =   [   {   ' OPTIONS ' :   {   ' context _ processors ' :   [   ' django . contrib . messages . context _ processors . messages ' ,   ......   views ，   messages . add _ message ( )   来往 django 信息系统 发送 一个 信息 ， 快捷 方法 ：   messages . debug ( )   messages . info ( )   messages . success ( )   messages . warning ( )   messages . error ( )   还 设置 request 请求 下 信息系统 级别 ：     django . contrib   import   messages   messages . set _ level ( request ,   messages . DEBUG )   定义 一个 简单 flash 函数   def   flash   (   request   ,   title   ,   text   ,   level   =   ' info '   ) :   \" \" \"   利用 django message 系统 发送 一个 信息 ， 对接 模板 sweetalert 。   \" \" \"   level _ map   =   {   ' info '   :   messages   .   INFO   ,   ' debug '   :   messages   .   DEBUG   ,   ' success '   :   messages   .   SUCCESS   ,   ' warning '   :   messages   .   WARNING   ,   ' error '   :   messages   .   ERROR   }   level   =   level _ map   [   level   ]   messages   .   add _ message   (   request   ,   level   ,   text   ,   extra _ tags   =   title   )   return   ' '   做 封装 更好 对接 sweetalert javascript 库 ， 模块 内容 信息 弹 出 。   { %     messages   % }   < script   src = \" { %   static   ' js / sweetalert . min . js '   % } \" > < / script >   < script >   { %     msg     messages   % }   sweetAlert ( {   title :   ' { { msg . extra _ args } } ' ,   text :   ' { {   msg . message   } } ' ,   type :   ' { {   msg . level _ tag   } } ' ,   } )   { %   endfor   % }   < / script >   { %   endif   % }   csrf 认证 失败   提到 表单 加上 ：   < form   method = \" post \" > { %   csrf _ token   % }   csrf 认证 失败 ， 参考   答案   设置 才 。   CSRF _ TRUSTED _ ORIGINS   =   [ ' www . cdwanze . work ' ]",
            "tags":"web_server",
            "url":"articles/django-learning-notes.html"
        },
        {
            "title":"python语言学习教程四pypi生态圈",
            "text":"setup . py 配置   模块 一章 里 python 模块 包 知识 python 相关 生态圈 知识 谈及 ， 一并 本章 中 。 本章 知识 理解 前人 编写 有用 模块 包 基础 ， 编写 模块 包 基础 。   请 Github 上   pyskeleton 项目   阅读 本章 。   官方 内置 distutils 模块 类似 功能 ， 更 常用 第三方 模块 setuptools ， 相当于 distutils 模块 加强版 ， 初学者 推荐 setuptools 模块 。 更 内容 请 参看 setuptools 模块   官方 文档   。   安装 先 安装 pip3 ：   sudo   apt -   install   python3 - pip   pip3 安装 setuptools ：   sudo   pip3   install   setuptools   最 简单 \" setup . py \" 文件 所示 ：     setuptools   import   setup   ,   find _ packages   setup   (     =   \" HelloWorld \"   ,   version   =   \" 0.1 \"   ,   packages   =   find _ packages   ( ) ,   )   第一行 是从 setuptools 模块 中 引入 setup 函数   find _ packages   函数 。   setup 函数 接受 一系列 字典 值 ， setup 函数 字典 值 含义 慢慢 道 ：     软件 名字   version   软件 版本号   author   软件 作者   author _ email   软件作者 邮箱   maintainer   软件 维护者   maintainer _ email   软件维护 邮箱   contact   软件 联系人 。 不写 ， 维护者 名字 ， 作者 名字 。   contact _ email   软件 联系人 邮箱 ， 不写 ， 维护者 邮箱 ， 作者 邮箱 。   license   软件 license   url   软件 项目 主页 地址   description   软件 简要 描述   long _ description   软件 完整 描述   platforms   软件 测试 运行 平台   classifiers   软件 分类 ， 请 参考   网页   给出 值 。 字符串 列表 。   keywords   软件 pypi 上 搜索 关键词 ， 字符串 列表 。   packages   软件 依赖 模块 。 ：   packages   =   find _ packages ( )   文件夹 下   __ init __. py   文件 ， 都 视作 python 模块 包 ， 其内 py 文件 都 进去 。   手工 输入 模块 名字 ， 字符串 列表 。   entry _ point   entry _ points   =   {   ' console _ scripts '   : [   ' zwc = zwc . zwc : main ' , ] ,   }   zwc shell 调用 名字 ， zwc 模块 ， 一个 zwc 主 模块 子 模块 ， main main 函数 。 shell 调用 程序 接口 。 类似 gui _ script 控制 调用 GUI 图形 命令 入口 。   install _ requires   接受 字符串 列表 值 ， 依赖 pip 安装 模块 名 放入 进去 ， 软件 安装 会 自动检测 安装 依赖 模块 。   setup _ requires     install _ requires   类似 ， 侧重于   setup . py   依赖 。   setup _ requires   依赖 模块 下载 ， 还 安装 ，   setup . py   还 执行 。 希望 依赖 模块   setup . py   可用 ， 依赖 模块   install _ requires     setup _ requires   中 。   package _ data   软件 模块 额外 附加 （ py 文件 ） 文件 ， 设置 类似   { \" skeleton \" : [ ' * . txt ' ] , }   skeleton 软件 模块 （ 文件夹 名 ） ， 跟着 一系列 文件名 列表 ， 接受 glob 语法 。 只能 包含 模块 文件夹 packages 控制 文件夹 内容 。   include _ package _ data   设置 True   不 常用 属性 值列 ：   scripts   不 推荐 ， 推荐 entry _ point 生成 脚本 。   py _ modules   不 推荐 ， 推荐 packages 管理 模块 。   data _ files   package _ data 只能 模块 文件夹 数据文件 ， 数据文件 包含 ， data _ files 控制 ， 跟着 参数 格式 例子 所示 ：   data _ files   =   [ ( ' icos ' , [ ' icos / wise . ico ' ] ) ] ,   # 这是 添加 icos 文件夹 wise . ico 文件   data _ files   =   [ ( ' ' , [ ' skeleton . tar . gz ' ] ) ] ,   # 这是 添加 主目录 下 skeleton . tar . gz 文件   值得一提的是 data _ files 接受 glob 语法 。   data _ files 不 推荐 ， 推荐 package _ data 管理 ， pkg _ resources 方法 引用 资源 文件 。 请 看 。   pip develop 模式   小节 参考     。   第三方 包 不 修改 ，   python   setup . py   install   ， 写 包 ， 频繁 变动 ， 加载 引用 本地 文件夹 ， 推荐 采用   python   setup . py   develop   命令 安装 。     pip   install   - e   .   命令 ， 安装 本地 文件夹 develop 模式   python   install   .   。   pipenv   pipenv   install   - e   .   develop 模式 ， 修改 代码 会 实时 生效 。   pkg _ resources 模块 管理 读取 资源 文件   所示 ：     pkg _ resources   import   resource _ filename   resource _ stream ( ' wise ' , ' icos / Folder - Documents . ico ' )   第一个 参数 模块 名字 ， 第二个 参数 模块 中 文件 相对路径 表达 。   例子 resource _ filename ， 返回 引用 文件名 。 命令 ： resource _ string ， 参数 resource _ filename ， 返回 字节 流 。 字节 流 赋值 变量 ， 存储 文件 。   pypi 上传 软件   正确处理 README 文档   pypi 支持 markdow 文档 格式 。 推荐 官方 文档     ：     setuptools   import   setup   #   read     contents       README   file     os   import   path   _ directory   =   path   .   abspath   (   path   .   dirname   (   __ file __   ) )     open   (   path   .   join   (   _ directory   ,   ' README . md '   ) ,   encoding   =   ' utf - 8 '   )     f   :   long _ description   =   f   .   read   ( )   setup   (     =   ' _ _ package '   ,   #     arguments   omitted   long _ description   =   long _ description   ,   long _ description _ content _ type   =   ' text / markdown '   )   段时间 我用   codecs   读取 README 文件 奇怪 ， 原因 不明 。 如同 读取 即可 。   配置   long _ description _ content _ type   ， 喜欢   reStructuredText   格式 ， 设置   text / x - rst   即可 。   推荐 升级 最新 setuptools ， wheel twine 模块 。   这句 ：   python   setup . py   sdist   bdist _ wheel   dist 文件夹 生成 源码 tar 包 wheel 包 。   推荐 运行 下 ：   twine   check   dist / *   确保 文档 格式 没 。   推荐 twine 上传   twine 上 传到 pypi 很 简单 ：   twine   upload   dist / *   每次 都 输入 用户名 密码 ， 安装   keyring   模块 ， 运行 ：   keyring   set   https : / / upload . pypi . org / legacy /   - username   本地 保存 用户名 密码 。   pypi 下载 国内 源   豆瓣 pypi 源   https : / / pypi . douban . / simple     清华 pypi 源   https : / / pypi . tuna . tsinghua . . cn / simple   都 。   临时   - i     - - index   选项 ：   pip   install   - i   https : / / pypi . tuna . tsinghua . . cn / simple   - package   永久 更改 本地 配置 ：   pip   install   pip   - U   pip   config   set   global . index - url   https : / / pypi . tuna . tsinghua . . cn / simple   pypi 只 下载 软件 源文件   下载 pypi 上 目标软件 源文件 安装 。 参考   网页   。   pip   install   - - download = \" / pth / / downloaded / files \"   package _   python 虚拟环境 管理   Virtualenv 模块 作用 建立 一个 封闭 独立 python 开发 环境 ， 一个 python 项目 开发 会 涉及 多个 模块 ， 激活 virtualenv 环境 ， pip 命令 安装 模块 安装 项目 文件夹 内 ， 建立 单独 固定 模块 版本 开发 环境 。 python 虚拟环境 ， 控制 python 版本 ， 控制 python 模块 版本 ， 项目 类似 绿色 安装版 可移植性 。   安装 pip 安装 常规 安装 即可 。   sudo   pip   install   virtualenv   新建 一个 项目   新建 一个 项目 virutalenv 命令 ， 一个 文件夹 名字 ， 下 新建 文件夹 名字 。   virutalenv   [ path ]   path 项目 名字 ， 下会 创建 名字 文件夹 ， 设定   \" . \"   ， 文件夹 下 创建 。   常用 选项 ：   - - python = python2     - - python = python3   不 指定 选项 ， 虚拟环境 会 操作系统 默认 python 版本 。   - - system - site - packages   ， 加上 选项 ， 虚拟环境 安装 系统 里 去 python 模块 。 参考   网页   ， 很 值得一提 小 技巧 ， 设定 venv 引用 系统 级 python 模块 ， 不想 ， 不 重新安装 虚拟环境 ， 只 虚拟环境 中 创建 一个 空白 文件 即可 ：   lib / python3.5 / - global - site - packages . txt   想 引用 系统 级 python 模块 ， 文件 删除 即可 。   激活 本地 虚拟环境   运行 命令 本地 虚拟环境 ：   cd   venv   source   bin / activate   激活 虚拟环境 ， python 虚拟环境 设定 python 解释器 ， pip 安装 模块 安装 虚拟环境 之下 。   退出 本地 虚拟环境   运行 deactivate 命令 即可   deactivate",
            "tags":"python_language",
            "url":"articles/python-pypi.html"
        },
        {
            "title":"python语言学习教程五网络编程篇",
            "text":"只 讨论 TCP 套 接字 编程 ， UDP 协议 暂 不 讨论 。 TCP 套 接字 编程 过程 所述 :   套 接字 编程   客户机 负责 发起 连接 ， 新建 一个套 接字 对象 （ python 中是   socket   函数 创建 ） ， 好比 一个 封闭 黑箱子 里 开 一个 门 ， 创建 套 接字 对象 过程 中 ， 指定 连接 服务器 IP地址 端口号 （   connect   方法 ） 。   接下来 TCP 三路 握手 过程 ， 传输层 最底层 东西 ， 客户机 应用程序 服务器应用程序 都 不用 操心 ， 操作系统 程序 负责 。 服务器程序 关心 三路 握手 期间 ， 类似 听到 敲门声 ， 开出 一个 门 。 服务器程序 听到 敲门声 ， 处于 监听 端口 状态 。 服务器程序 创建 一个套 接字 对象 ，   bind   端口号 ， 调用   listen   方法 监听 端口 。   服务器 监听 套 接字 调用   accept   方法 ， 阻塞 ， 接下来 听到 敲门声 ， 敲门声 TCP 三路 握手 第一路 信号 发送 ， TCP 三路 握手 两路 ， 暂时 不 太 关心 。 等到 TCP 三路 握手 ， 服务器 accept 方法 创建 一个套 接字 对象 。 套 接字 对象 称之为   连接 套 接字   。 服务器 连接 套 接字 调用 accept 方法 理解 接受 客户机 敲门 ， 一切顺利 ， 客户机 新开 一个套 接字 ， 一个 新门 。   客户机 一个套 接字 ， 情况 稍微 简单 点 ， 其往 套 接字 塞 信息 （   sendall   方法 ） 发送信息 ， 从套 接字 读 （   recv   方法 ） ， 读 信息 。 服务器 ， 实际上 客户机 来看 ， 第二个 新建 连接 套 接字 看作 看作 类似 客户机 第一个 套 接字 ， 往里面 读 读 信息 ， 往里面 写 发送信息 。 服务器 新开 一个套 接字 ， 猜 ， 是因为 服务器 多个 客户机 请求 ， 第一个 监听 套 接字 理解 总 大门 ， 开启 连接 套 接字 理解 小门 ， 其才 客户机 一对一 管道 连接 。   简要 描述 太 过于 抽象 ， 再 来看 一个 最 简单 代码 ， python 官方 文档 socket 模块 第一个 例子 ， 地方 稍作 改动 。   服务器端   server . py   代码 :   import   socket   HOST   =   ' localhost '   PORT   =   50007   s   =   socket . socket ( socket . AF _ INET ,   socket . SOCK _ STREAM )   s . bind ( ( HOST ,   PORT ) )   s . listen ( 1 )   conn ,   addr   =   s . accept ( )   print ( ' Connected   ' ,   addr )     True :   data   =   conn . recv ( 1024 )       data : break   conn . sendall ( data )   conn . close ( )   运行 server . py ， 如前所述 ， socket 函数 创建 一个 监听 套 接字 ， 套 接字 监听 端口 bind 方法 指定 ， 监听 套 接字 监听 （ 调用 listen 方法 ） 。 调用 监听 套 接字 accept 方法 ， 收到 TCP 连接 请求 ， 返回 一个 连接 套 接字 ， conn 。 程序 主 循环 ， 连接 套 接字 recv 方法 来读 ， sendall 方法 写 。 close 方法 关闭 连接 套 接字 。   客户机 端   client . py   代码 :   import   socket   HOST   =   ' localhost '   PORT   =   50007   s   =   socket . socket ( socket . AF _ INET ,   socket . SOCK _ STREAM )   s . connect ( ( HOST ,   PORT ) )   s . sendall ( b ' Hello ,   world ' )   data   =   s . recv ( 1024 )   s . close ( )   print ( ' Received ' ,   repr ( data ) )   客户机 新建 一个套 接字 ， 套 接字 connect 方法 拨号 服务器 ， sendall 方法 写 ， recv 方法 来读 。 过程 大抵 。   一副 图画 加深 对本 小节 印象 。   更 讨论 套 接字 编程 ， 并用 python socket 模块 介绍 编码 细节 。   socket 模块   host 主机名   host 最 简单 熟知 IP地址 ， 本地 hosts 文件 解析 网络 DNS 系统 解析 名字 。   localhost     python . org   。 socket 模块   gethostbyname   函数 ， 获取 hostname IP地址 。   > > >   socket . gethostbyname ( ' python . org ' )   ' 104.130 . 43.121 '   gethostbyname 函数 只 支持 IPv4 地址 ， 推荐   getaddrinfo   函数 ， 支持 IPv4 IPv6 地址 。 参数设置 :   socket . getaddrinfo ( host ,   port ,   family = 0 ,   type = 0 ,   proto = 0 ,   flags = 0 )   port 填写 80 ' http ' 形式 ， 设置 None 。 family 地址 族 ， type 套 接字 类型 ， 先 暂时 略过 讨论 。   函数 返回值 一个 列表 ， 其内 元素 结构 :   ( family ,   type ,   proto ,   canonname ,   sockaddr )   所示 :   > > >   socket . getaddrinfo ( ' www . github . ' , ' https ' )   [ ( < AddressFamily . AF _ INET :   2 > ,   < SocketType . SOCK _ STREAM :   1 > ,   6 ,   ' ' ,   ( ' 192.30 . 252.131 ' ,   443 ) ) ,   ( < AddressFamily . AF _ INET :   2 > ,   < SocketType . SOCK _ DGRAM :   2 > ,   17 ,   ' ' ,   ( ' 192.30 . 252.131 ' ,   443 ) ) ,   ( < AddressFamily . AF _ INET :   2 > ,   < SocketType . SOCK _ STREAM :   1 > ,   6 ,   ' ' ,   ( ' 192.30 . 252.128 ' ,   443 ) ) ,   ( < AddressFamily . AF _ INET :   2 > ,   < SocketType . SOCK _ DGRAM :   2 > ,   17 ,   ' ' ,   ( ' 192.30 . 252.128 ' ,   443 ) ) ]     AF _ INET   地址 族 创建 socket 套 接字 对象 时 默认 地址 族 ， IPv4 地址 。 套 接字 类型   SOCK _ STREAM   创建 套 接字 对象 默认值 ， 其是 字节 流套 接字 。   getaddrinfo 函数 返回   family , type , proto   三个 参数 传递 socket 函数 用于 创建 一个套 接字 对象 。 canonname 冷门 ，   sockaddr   传递 套 接字 对象   connect   方法 套 接字 连接 操作 。   脚本 试一下 :   import   socket   socket . setdefaulttimeout ( 10 )   addrinfos   =   socket . getaddrinfo ( ' www . baidu . ' ,   ' http ' )     addrinfo     addrinfos :   socket _ parameter   =   addrinfo [ : 3 ]   print ( socket _ parameter )   addr   =   addrinfo [ - 1 ]   print ( addr )   s   =   socket . socket ( * socket _ parameter )   :   s . connect ( addr )   print ( ' connected ' )   print ( ' peername ' , s . getpeername ( ) )   print ( ' hostname ' , s . getsockname ( ) )   #   socket . timeout :   # print ( ' socket   timeout ' )     Exception     e :   print ( e )   读者 还 域名 试一下 。   地址 族   AF _ INET   IPv4 地址   AF _ INET6   IPv6 地址   冷门 地址 族 :   AF _ UNIX   ，   AF _ NETLINK   ，   AF _ TIPC   套 接字 类型   SOCK _ STREAM   字节 流套 接字   SOCK _ DGRAM   数据 报套 接字   两个 套 接字 类型 全 平台 。 冷门 套 接字 类型 :   SOCK _ RAW   ，   SOCK _ RDM   ，   SOCK _ SEQPACKET   传输 协议   传输 协议   proto   设置 0 。 指定 传输 协议 :   IPPROTO _ CP   TCP 传输 协议   IPPROTO _ UDP   UDP 传输 协议   IPPROTO _ SCTP   SCTP 传输 协议   timeout   socket . settimeout ( None )   socket . settimeout ( 0 )   socket . settimeout ( sec )   设置 None ， 套 接字 阻塞 模式   设置 0 ， 套 接字 非 阻塞 模式   设置 sec 秒 ， 套 接字 会 等待 sec 秒 ， 抛出   socket . timeout   异常 。     setdefaulttimeout   函数 全局 设置 创建 socket 对象 timeout 。   socket . setdefaulttimeout ( 10 )   阻塞 模式 还 设置 ：   socket . setblocking ( True )   socket . setblocking ( False )   listen 方法   服务器端 套 接字 监听 。   socket . listen ( [ backlog ] )   python3.5 ， backlog 参数 可选 参数 。 backlog 等待 连接数 （ 超过 数 ， 新 连接 拒绝 ） 。 数 设置 5 ， 系统 才 5 ， 再 提高 一点 ， python3.5 ， 数 选 参数 ， 文档 上 说 会 自动 设置 一个 合适 数 ， 不 操心 。   更 细节 请 参看 官方 文档 。   异步 编程   常规 同步 ( synchronous ) 编程 平时 编程 模型 ， 顺序 结构 ， 阻塞 式 ， 多个 函数 逐个 执行 ， 一个 执行 完 才能 执行 下 一个 ， 图 所示 :   tong - bu - bian - cheng - mo - xing   一种 线程 并发 模型 :   xian - cheng - bing - fa - mo - xing   python GIL 概念 ， 很多 人 指责 ， 实际上 支持 多线程 并发 语言 ， 怕 便利 带来 更 困扰 。 想一想 人脑 思考问题 同一时间 只能 做 一件 事 ， 也许 python GIL 一种 。 实际上 多线程 并发 ， 建立 好 模型 ， 最终 多个 分支 线路 互不 干扰 ， 平行 放入 一个 列表 中 约束 ， 才能 放心 多线程 并发 。 约束 模型 下 ， python   multiprocess   模块 很 好 胜任 类型 工作 。   讨论 异步 编程 模型 :   yi - bu - bian - cheng - mo - xing   异步 编程   一个 名字   非 阻塞 编程   ， 主程序 建立 事件 循环 ， 主 事件 循环 过程 阻塞 程序 过程 ， 插入 执行 。 实际上 类似 GUI 程序 主 设计 理念 - - - - - - 事件驱动 循环 机制 ， 异步 编程 一个 名字   事件驱动 编程   。   例子 学习 。   低效 诗歌 服务器   例子 来自 参考资料   [ @ twisted 异步 编程 入门 ]   ， 改成 python3 版本   slowpoetry . py   。   1   2   3   4   5   6   7   8   9   10   11   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32   33   34   35   36   37   38   39   40   41   42   43   44   45   46   47   48   49   50   51   52   53   54   55   56   57   58   59   60   61   62   63   64   65   66   67   68   69   70   71   72   73   74   75   76   77   78   79   80   81   82   83   84   85   86   87   88   89   90   91   92   93   94   95   96   97   98   99   # ! / usr / bin / env   python3   #   - * -   coding :   utf - 8   - * -   import   argparse   ,   os   ,   socket   ,   time   def   parse _ args   ( ) :   usage   =   \" \" \" usage :   % prog   [ options ]   poetry - file   This       Slow   Poetry   Server ,   blocking   edition .   Run       :   python3   slowpoetry . py   ecstasy . txt   \" \" \"   parser   =   argparse   .   ArgumentParser   (   usage   )     =   \" The   port     listen   .   Default     a   random     port . \"   parser   .   add _ argument   (   ' - p '   ,   ' - - port '   ,   type   =   int   ,     =     )     =   \" The   interface     listen   .   Default     localhost . \"   parser   .   add _ argument   (   ' - - iface '   ,     =     ,   default   =   ' localhost '   )     =   \" The   number     seconds     sending   bytes . \"   parser   .   add _ argument   (   ' - - delay '   ,   type   =   float   ,     =     ,   default   = .   1   )     =   \" The   number     bytes     send     a   time . \"   parser   .   add _ argument   (   ' - - num - bytes '   ,   type   =   int   ,     =     ,   default   =   20   )   parser   .   add _ argument   (   ' poetry _ file '   )   args   =   vars   (   parser   .   parse _ args   ( ) )   poetry _ file   =   args   [   ' poetry _ file '   ]       poetry _ file   :   parser   .   error   (   ' No     file :   % s   '   %   poetry _ file   )   return   args   def   send _ poetry   (   sock   ,   poetry _ file   ,   num _ bytes   ,   delay   ) :   \" \" \" Send     poetry   slowly       socket . \" \" \"   inputf   =   open   (   poetry _ file   )     True   :   bytes   =   inputf   .   read   (   num _ bytes   )   .   encode   ( )       bytes   :   sock   .   close   ( )   inputf   .   close   ( )   return   ' end '   print   (   ' Sending   % d   bytes '   %   len   (   bytes   ) )     :   sock   .   sendall   (   bytes   )     socket   .   error   :   sock   .   close   ( )   inputf   .   close   ( )   return   ' error '   time   .   sleep   (   delay   )   def   serve   (   listen _ socket   ,   poetry _ file   ,   num _ bytes   ,   delay   ) :     True   :   sock   ,   addr   =   listen _ socket   .   accept   ( )   print   (   ' Somebody     % s     poetry ! '   %   (   addr   , ) )   result   =   send _ poetry   (   sock   ,   poetry _ file   ,   num _ bytes   ,   delay   )     result   = =   ' end '   :   print   (   ' sending   complete '   )   elif   result   = =   ' error '   :   print   (   ' error ,   sending   stopped '   )   def   main   ( ) :   args   =   parse _ args   ( )   poetry _ file   =   args   [   ' poetry _ file '   ]   port   =   args   [   ' port '   ]   iface   =   args   [   ' iface '   ]   num _ bytes   =   args   [   ' num _ bytes '   ]   delay   =   args   [   ' delay '   ]   sock   =   socket   .   socket   ( )   sock   .   bind   ( (   iface   ,   port     0   ) )   sock   .   listen   (   5   )   print   (   ' Serving   % s     port   % s   . '   %   (   poetry _ file   ,   sock   .   getsockname   ( ) [   1   ] ) )   serve   (   sock   ,   poetry _ file   ,   num _ bytes   ,   delay   )   sock   .   close   ( )     __ __   = =   ' __ main __ '   :   main   ( )   获取 诗歌 client 端 程序   _ poetry . py   。   1   2   3   4   5   6   7   8   9   10   11   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32   33   34   35   36   37   38   39   40   41   42   43   44   45   46   47   48   49   50   51   52   53   54   55   56   57   58   59   60   61   62   63   64   65   66   67   68   69   70   71   72   73   74   75   76   77   78   79   80   81   82   83   84   85   86   87   88   89   # ! / usr / bin / env   python3   #   - * -   coding :   utf - 8   - * -   import   datetime   ,   argparse   ,   socket   def   parse _ args   ( ) :   usage   =   \" \" \" usage :   % prog   [ options ]   [ hostname ] : port   ...   This       Get   Poetry   Now !   client ,   blocking   edition .   Run       :   python3   _ poetry . py   port1   port2   port3   ...   \" \" \"   parser   =   argparse   .   ArgumentParser   (   usage   )   parser   .   add _ argument   (   ' port '   ,   nargs   =   ' + '   )   args   =   vars   (   parser   .   parse _ args   ( ) )   addresses   =   args   [   ' port '   ]       addresses   :   print   (   parser   .   format _   ( ) )   parser   .   exit   ( )   def   parse _ address   (   addr   ) :     ' : '       addr   :   host   =   ' 127.0 . 0.1 '   port   =   addr     :   host   ,   port   =   addr   .   split   (   ' : '   ,   1   )       port   .   isdigit   ( ) :   parser   .   error   (   ' Ports       integers . '   )   return   host   ,   int   (   port   )   return   map   (   parse _ address   ,   addresses   )   def   _ poetry   (   address   ) :   \" \" \" Download   a   piece     poetry         address . \" \" \"   sock   =   socket   .   socket   (   socket   .   AF _ INET   ,   socket   .   SOCK _ STREAM   )   sock   .   connect   (   address   )   poem   =   b   ' '     True   :   data   =   sock   .   recv   (   1024   )       data   :   sock   .   close   ( )   break     :   print   (   data   .   decode   (   ' utf - 8 '   ) ,   end   =   ' '   )   poem   + =   data   return   poem   def   format _ address   (   address   ) :   host   ,   port   =   address   return   '   % s   :   % s   '   %   (   host     ' 127.0 . 0.1 '   ,   port   )   def   main   ( ) :   addresses   =   parse _ args   ( )   elapsed   =   datetime   .   timedelta   ( )     i   ,   address     enumerate   (   addresses   ) :   addr _ fmt   =   format _ address   (   address   )   print   (   ' Task   % d   :     poetry   :   % s   '   %   (   i   +   1   ,   addr _ fmt   ) )   start   =   datetime   .   datetime   .     ( )   poem   =   _ poetry   (   address   )   time   =   datetime   .   datetime   .     ( )   -   start   msg   =   ' Task   % d   :     % d   bytes     poetry     % s     % s   '   print   (   msg   %   (   i   +   1   ,   len   (   poem   ) ,   addr _ fmt   ,   time   ) )   elapsed   + =   time   print   (   ' Got   % d   poems     % s   '   %   (   len   (   list   (   addresses   ) ) ,   elapsed   ) )     __ __   = =   ' __ main __ '   :   main   ( )   读者 利用 两个 脚本 测试 效果 。 两个 脚本 ， 客户端 服务器端 都 阻塞 式 。 先开 一个 服务器端 :   python3   slowpoetry . py   - p   10000   ecstasy . txt   开 两个 终端 ， 刷 命令 ， 后 执行 终端 获取 文本 阻塞 - - - - - - 这是 服务器 阻塞 。   python3   slowpoetry . py   - p   10000   ecstasy . txt   开 一个 服务器端 :   python3   slowpoetry . py   - p   10001   fascination . txt   一个 客户端 运行 :   python3   _ poetry . py   10000   10001   客户端 获取 文本 一个个 ， 这是 客户端 阻塞 。   一个个 ， 一个 做 完 才能 下 一个 模式 很 好 理解 ， 进程 间 通信 ， 请 看 select 风格 I / O 复用 讨论 。   Select 风格 诗歌 服务器   Unix 五种 I / O 模型   讨论一下 Unix 五种 I / O 模型 ：   阻塞 式 I / O   ， 默认 阻塞 式 I / O 。   非 阻塞 式 I / O ， 应用程序 持续 轮询 内核 操作 准备就绪 。   I / O 复用 ， select poll 文件 描述符 管理 I / O 。   信号 驱动 式 I / O   异步 I / O   这五种 I / O 模型 中 ， 最 阻塞 式 I / O 模型 ， 非 阻塞 I / O 轮询 机制 太 过于 浪费资源 ， 信号 驱动 I / O 异步 I / O 很少 ， 最   I / O 复用 模型   。 python 中 twisted 模块 python3.4 新   asyncio   模块 事件 循环 都 基于   再 建立 类 异步 I / O 概念 。   重点 python selectors 模块 分析 I / O 复用 模型 。 selectors 模块 python3.4 才 ， 建构 select 模块 之上 。 其有 五种 内置 Selector :   -   SelectSelector   -   PollSelector   -   EpollSelector   -   DevpollSelector   -   KqueueSelector     DefaultSelector   即可 ， python 会 自动 选择 平台 Selector 。   创建 一个 Selector 对象 所示 :   sel   =   selectors . DefaultSelector ( )   监控 文件 读写 事件   Selector 对象 有个 register 方法 ， 所示 ：   register ( fileobj ,   events ,   data = None )   fileobj 文件 对象 （ Linux 中 皆 文件 ， 套 接字 视为 一个 文件 。 ） 。   监控 事件 :   EVENT _ READ   读 事件 ， 可读 定义 参考资料   [ @ Unix 网络 编程 卷 1 ]   描述 :   该套 接字 接受 缓冲区 中 数据 字节数 大于 等于 套 接字 接受 缓冲区 低水平 标记 大小 。 套 接字 读 阻塞 ， 返回 一个 大于 0 值 （ 读入 字节数 ） 。   SO _ RCVLOWAT   套 接字 选项 设置 该套 接字 低水平 标记 ， TCP UDP 套 接字 默认值 1 。 【 很 好 理解 ， 1 字节 ， 接受 1 字节 更 字节 可读 事件 。 】   连接 读 半部 关闭 ， 套 接字 读 操作 不 阻塞 返回 0 （ 返回 EOF ） 。 【 套 接字 对面 关闭 ， 可读 ，   '   read '   判断 读 结束 后续 。 】   该套 接字 一个 监听 套 接字 已 连接数 不为 0 。 【 指 服务器端 创建 监听 套 接字 ， accept 阻塞 ，   conn ,   addr   =   s . accept ( )   ， 客户端 敲门 ， 会 一个 读 事件 ， 会 批准 自动 创建 一个 监听 套 接字 ， 已 连接数 0 - - - - - - 已 连接数 含义 还 不 。 】   情况 中 ， 一个套 接字 错误 待处理 ， 套 接字 读 操作 不 阻塞 返回 - 1 。 【 细节 暂时 还 不 。 】   EVENT _ WRITE   写 事件 ， 可写 定义 参考资料   [ @ Unix 网络 编程 卷 1 ]   描述 :   该套 接字 发送缓冲区 中 可用 空间 字节数 大于 等于 套 接字 发送缓冲区 低水平 标记 大小 ， 该套 接字 已 连接 （ 该套 接字 不 连接 ， UDP 套 接字 ） 。 套 接字 设置 非 阻塞 ， 写 操作 返回 一个 正值 （ 传输层 接受 字节数 ） 。   SO _ SNDLOWAT   套 接字 选项 设置 该套 接字 写 低水平 标记 ， TCP UDP 套 接字 默认值 2048 。 【 套 接字 阻塞 ， 写 操作 会 套 接字 另一端 recv 阻塞 阻塞 ， 一个 猜测 。 读 实际上 反 ， 可读 相当于 数据量 超过 标记 ， 往里面 送 一点点 数据 不行 ， 还 送到 量 ， 才 可读 ； 写 送 一点点 数据 都 写 ， 送 数据量 很大 ，   可用   缓冲区 空间   小于   标记 ， 写 。 】   连接 写 半部 关闭 。 套 接字 写 操作 SIGPIPE 信息 。 【 我试 ， 后续 程序 会 出错 。 服务器 主动 发动 数据 模式 ， 都 情况 捕捉 好 异常 。 】   非 阻塞 连接 套 接字 已 连接 连接 已 失败 。 【 非 阻塞 连接 初次 连接 成功 可写 很 好 理解 ， 连接 失败 写 ？ 非 阻塞 初次 连接 失败 连接 半部 关闭 情况 ， 哪一条 。 】   情况 中 ， 一个套 接字 错误 待处理 ， 套 接字 写 操作 不 阻塞 返回 - 1 。   更 内容 请 参看   selectors   模块 官方 文档 。   例子 诗歌 服务器 写成 Select 风格 异步 版本   select _ slowpoetry . py   :   1   2   3   4   5   6   7   8   9   10   11   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32   33   34   35   36   37   38   39   40   41   42   43   44   45   46   47   48   49   50   51   52   53   54   55   56   57   58   59   60   61   62   63   64   65   66   67   68   69   70   71   72   73   74   75   76   77   78   79   80   81   82   83   84   85   86   87   88   89   90   91   92   93   94   95   96   97   98   99   100   101   102   103   104   105   106   107   108   # ! / usr / bin / env   python3   #   - * -   coding :   utf - 8   - * -   import   argparse   import   os   import   socket   import   time   import   selectors   sel   =   selectors   .   DefaultSelector   ( )   def   parse _ args   ( ) :   usage   =   \" \" \" usage :   % prog   [ options ]   poetry - file   python3   select _ slowpoetry . py   ecstasy . txt   \" \" \"   parser   =   argparse   .   ArgumentParser   (   usage   )     =   \" The   port     listen   .   Default     a   random     port . \"   parser   .   add _ argument   (   ' - p '   ,   ' - - port '   ,   type   =   int   ,     =     )     =   \" The   interface     listen   .   Default     localhost . \"   parser   .   add _ argument   (   ' - - iface '   ,     =     ,   default   =   ' localhost '   )     =   \" The   number     seconds     sending   bytes . \"   parser   .   add _ argument   (   ' - - delay '   ,   type   =   float   ,     =     ,   default   = .   1   )     =   \" The   number     bytes     send     a   time . \"   parser   .   add _ argument   (   ' - - num - bytes '   ,   type   =   int   ,     =     ,   default   =   20   )   parser   .   add _ argument   (   ' poetry _ file '   )   args   =   vars   (   parser   .   parse _ args   ( ) )   poetry _ file   =   args   [   ' poetry _ file '   ]       poetry _ file   :   parser   .   error   (   ' No     file :   % s   '   %   poetry _ file   )   return   args   def   send _ poetry   (   sock   ,   poetry _ file   ,   num _ bytes   ,   delay   ,   inputf   ) :   \" \" \" Send     poetry   slowly       socket . \" \" \"   bytes   =   inputf   .   read   (   num _ bytes   )       bytes   :   sel   .   unregister   (   sock   )   sock   .   close   ( )   inputf   .   close   ( )   print   (   ' sending   complete '   )   return   True     :   sock   .   sendall   (   bytes   )     socket   .   error   :   sel   .   unregister   (   sock   )   sock   .   close   ( )   inputf   .   close   ( )   print   (   '   error ,   sending   stoped '   )   return   False   time   .   sleep   (   delay   )   def   serve   (   listen _ socket   ,   poetry _ file   ,   num _ bytes   ,   delay   ) :   sock   ,   addr   =   listen _ socket   .   accept   ( )   print   (   ' Somebody     % s     poetry ! '   %   (   addr   , ) )   sock   .   setblocking   (   False   )   inputf   =   open   (   poetry _ file   ,   ' rb '   )   sel   .   register   (   sock   ,   selectors   .   EVENT _ WRITE   ,   data   =   {   ' callback '   :   send _ poetry   ,   ' args '   :   [   poetry _ file   ,   num _ bytes   ,   delay   ,   inputf   ] } )   def   main   ( ) :   args   =   parse _ args   ( )   poetry _ file   =   args   [   ' poetry _ file '   ]   port   =   args   [   ' port '   ]   iface   =   args   [   ' iface '   ]   num _ bytes   =   args   [   ' num _ bytes '   ]   delay   =   args   [   ' delay '   ]   sock   =   socket   .   socket   ( )   sock   .   bind   ( (   iface   ,   port     0   ) )   sock   .   listen   (   100   )   sock   .   setblocking   (   False   )   print   (   ' Serving   % s     port   % s   . '   %   (   poetry _ file   ,   sock   .   getsockname   ( ) [   1   ] ) )   sel   .   register   (   sock   ,   selectors   .   EVENT _ READ   ,   data   =   {   ' callback '   :   serve   ,   ' args '   :   [   poetry _ file   ,   num _ bytes   ,   delay   ] } )     True   :   events   =   sel   .   select   ( )     key   ,   mask     events   :   callback   =   key   .   data   [   ' callback '   ]   callback   (   key   .   fileobj   ,   *   key   .   data   [   ' args '   ] )   sock   .   close   ( )     __ __   = =   ' __ main __ '   :   main   ( )   客户端 编写 简单 一点 ， 代码 所示   select _ _ poetry . py   :   1   2   3   4   5   6   7   8   9   10   11   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32   33   34   35   36   37   38   39   40   41   42   43   44   45   46   47   48   49   50   51   52   53   54   55   56   57   58   59   60   61   62   63   64   65   66   67   68   69   70   71   72   73   74   75   76   77   78   79   80   81   82   83   84   85   86   87   88   89   90   91   92   93   # ! / usr / bin / env   python3   #   - * -   coding :   utf - 8   - * -   import   datetime   import   argparse   import   socket   import   selectors   sel   =   selectors   .   DefaultSelector   ( )   def   parse _ args   ( ) :   usage   =   \" \" \" usage :   % prog   [ options ]   [ hostname ] : port   ...   python3   select _ _ poetry . py   port1   port2   port3   ...   select   I / O 复 用来 建立 一个 异步 诗歌 下载 客户端 ， 面向 多个 诗歌 服务器 下载 。   \" \" \"   parser   =   argparse   .   ArgumentParser   (   usage   )   parser   .   add _ argument   (   ' port '   ,   nargs   =   ' + '   )   args   =   vars   (   parser   .   parse _ args   ( ) )   addresses   =   args   [   ' port '   ]       addresses   :   print   (   parser   .   format _   ( ) )   parser   .   exit   ( )   def   parse _ address   (   addr   ) :     ' : '       addr   :   host   =   ' 127.0 . 0.1 '   port   =   addr     :   host   ,   port   =   addr   .   split   (   ' : '   ,   1   )       port   .   isdigit   ( ) :   parser   .   error   (   ' Ports       integers . '   )   return   host   ,   int   (   port   )   return   map   (   parse _ address   ,   addresses   )   def   download _ poetry   (   sock   ,   infile   ) :   \" \" \" Download   a   piece     poetry         address . \" \" \"   bstring   =   sock   .   recv   (   1024   )       bstring   :   #   end   fo   reading   sel   .   unregister   (   sock   )   infile   .   close   ( )   print   (   ' end     reading '   )   return   True     :   print   (   ' writing     { }   '   .   format   (   infile   .     ) )   infile   .   write   (   bstring   )   def   connect   (   address   ) :   \" \" \" Connect         server     return   a   - blocking   socket . \" \" \"   sock   =   socket   .   socket   ( )   sock   .   connect   (   address   )   sock   .   setblocking   (   False   )   return   sock   def   format _ address   (   address   ) :   host   ,   port   =   address   return   '   % s   :   % s   '   %   (   host     ' 127.0 . 0.1 '   ,   port   )   def   main   ( ) :   addresses   =   parse _ args   ( )   elapsed   =   datetime   .   timedelta   ( )   sockets   =   map   (   connect   ,   addresses   )     sock     sockets   :   filename   =   str   (   sock   .   getpeername   ( ) [   1   ] )   +   ' . txt '   infile   =   open   (   filename   ,   ' wb '   )   sel   .   register   (   sock   ,   selectors   .   EVENT _ READ   ,   data   =   {   ' callback '   :   download _ poetry   ,   ' args '   :   [   infile   ] } )     True   :   events   =   sel   .   select   ( )     key   ,   mask     events   :   callback   =   key   .   data   [   ' callback '   ]   callback   (   key   .   fileobj   ,   *   key   .   data   [   ' args '   ] )     __ __   = =   ' __ main __ '   :   main   ( )   改动 两点 :   1 .   客户端 开启 几个 sock ， sock 可读 时间 绑定 download _ poetry 方法 ， 数据 可读 ， 会 执行 操作 。   2 .   下载 目标 fileobj write ， 接受 字节 流给 写进去 即可 。   Asyncio 风格 诗歌 服务器   Selectors 模块 ， 程序 高效 异步 模式 ， 代码 中 几个 丑陋     True   压缩 一个 ， 追求 代码 美观 程序员 来说 会 会 感到 很 满意 。 程序 刚     True   看 不 习惯 。 慢慢 构建 出 \\ \"   reactor   \\ \" 术语 取代 主 循环 ， 图 所示 :   reactor   twisted 模块 中 实际上 一个 reactor 变量 ， 主 Selector 事件驱动 。 asyncio 模块 类似 eventloop 概念 :   import   asyncio   eventloop   =   asyncio . _ event _ loop ( )   事件驱动 编程 还 一点 ， 上 图   事件 循环   概念 事件驱动 编程 核心 概念 ， 实际上 select 风格 异步 编程 中 ， 影子 ， 开启 事件 循环 ， 剩下 工作 挂载 函数 ， 函数 会 涉及 函数 挂载 取消 挂载 操作 ， 脑海中 想象 一个 事件 循环 大 圈 ， 四周 八围 挂载 函数 操作 ， 事件驱动 编程 风格 。 实际上 事件驱动 编程 会 很多 工作 变得 简单 ， 事情 变得复杂 ， 关键 头脑 习惯 编程 风格 ， 脑海 里 还 熟悉 事件驱动 模型 。   常规 eventloop 版   Asyncio 风格 诗歌 服务器 第一版 ， asyncio 模块 不 懂 读者 请 参看 模块 官方 文档 。   1   2   3   4   5   6   7   8   9   10   11   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32   33   34   35   36   37   38   39   40   41   42   43   44   45   46   47   48   49   50   51   52   53   54   55   56   57   58   59   60   61   62   63   64   65   66   67   68   69   70   71   72   73   74   75   76   77   78   79   80   81   82   83   84   85   86   87   88   89   90   91   92   93   94   95   96   97   98   99   100   101   102   103   104   # ! / usr / bin / env   python3   #   - * -   coding :   utf - 8   - * -   import   argparse   import   os   import   socket   import   time   import   asyncio   def   parse _ args   ( ) :   usage   =   \" \" \" usage :   % prog   [ options ]   poetry - file   python3   asyncio _ slowpoetry . py   ecstasy . txt   \" \" \"   parser   =   argparse   .   ArgumentParser   (   usage   )     =   \" The   port     listen   .   Default     a   random     port . \"   parser   .   add _ argument   (   ' - p '   ,   ' - - port '   ,   type   =   int   ,     =     )     =   \" The   interface     listen   .   Default     localhost . \"   parser   .   add _ argument   (   ' - - iface '   ,     =     ,   default   =   ' localhost '   )     =   \" The   number     seconds     sending   bytes . \"   parser   .   add _ argument   (   ' - - delay '   ,   type   =   float   ,     =     ,   default   = .   1   )     =   \" The   number     bytes     send     a   time . \"   parser   .   add _ argument   (   ' - - num - bytes '   ,   type   =   int   ,     =     ,   default   =   20   )   parser   .   add _ argument   (   ' poetry _ file '   )   args   =   vars   (   parser   .   parse _ args   ( ) )   poetry _ file   =   args   [   ' poetry _ file '   ]       poetry _ file   :   parser   .   error   (   ' No     file :   % s   '   %   poetry _ file   )   return   args   def   send _ poetry   (   eventloop   ,   sock   ,   poetry _ file   ,   num _ bytes   ,   delay   ,   inputf   ) :   \" \" \" Send     poetry   slowly       socket . \" \" \"   bytes   =   inputf   .   read   (   num _ bytes   )       bytes   :   eventloop   .   remove _ writer   (   sock   )   sock   .   close   ( )   inputf   .   close   ( )   print   (   ' sending   complete '   )   return   True     :   sock   .   sendall   (   bytes   )     socket   .   error   :   eventloop   .   remove _ writer   (   sock   )   sock   .   close   ( )   inputf   .   close   ( )   print   (   '   error ,   sending   stoped '   )   return   False   time   .   sleep   (   delay   )   def   serve   (   eventloop   ,   listen _ socket   ,   poetry _ file   ,   num _ bytes   ,   delay   ) :   sock   ,   addr   =   listen _ socket   .   accept   ( )   print   (   ' Somebody     % s     poetry ! '   %   (   addr   , ) )   sock   .   setblocking   (   False   )   inputf   =   open   (   poetry _ file   ,   ' rb '   )   eventloop   .   add _ writer   (   sock   ,   send _ poetry   ,   eventloop   ,   sock   ,   poetry _ file   ,   num _ bytes   ,   delay   ,   inputf   )   def   main   ( ) :   args   =   parse _ args   ( )   poetry _ file   =   args   [   ' poetry _ file '   ]   port   =   args   [   ' port '   ]   iface   =   args   [   ' iface '   ]   num _ bytes   =   args   [   ' num _ bytes '   ]   delay   =   args   [   ' delay '   ]   sock   =   socket   .   socket   ( )   sock   .   bind   ( (   iface   ,   port     0   ) )   sock   .   listen   (   100   )   sock   .   setblocking   (   False   )   print   (   ' Serving   % s     port   % s   . '   %   (   poetry _ file   ,   sock   .   getsockname   ( ) [   1   ] ) )   eventloop   =   asyncio   .   _ event _ loop   ( )   eventloop   .   add _ reader   (   sock   ,   serve   ,   eventloop   ,   sock   ,   poetry _ file   ,   num _ bytes   ,   delay   )     :   eventloop   .   run _ forever   ( )   finally   :   eventloop   .   close   ( )   sock   .   close   ( )     __ __   = =   ' __ main __ '   :   main   ( )   诗歌 获取 客户端 写成 asyncio 版本 。 代码 所示 ， 改动 很大 。   1   2   3   4   5   6   7   8   9   10   11   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32   33   34   35   36   37   38   39   40   41   42   43   44   45   46   47   48   49   50   51   52   53   54   55   56   57   58   59   60   61   62   63   64   65   66   67   68   69   70   71   72   73   74   75   76   77   78   79   80   81   82   83   84   85   86   87   88   89   # ! / usr / bin / env   python3   #   - * -   coding :   utf - 8   - * -   import   datetime   import   argparse   import   socket   import   asyncio   def   parse _ args   ( ) :   usage   =   \" \" \" usage :   % prog   [ options ]   [ hostname ] : port   ...   python3   select _ _ poetry3 . py   port1   port2   port3   ...   \" \" \"   parser   =   argparse   .   ArgumentParser   (   usage   )   parser   .   add _ argument   (   ' port '   ,   nargs   =   ' + '   )   args   =   vars   (   parser   .   parse _ args   ( ) )   addresses   =   args   [   ' port '   ]       addresses   :   print   (   parser   .   format _   ( ) )   parser   .   exit   ( )   def   parse _ address   (   addr   ) :     ' : '       addr   :   host   =   ' 127.0 . 0.1 '   port   =   addr     :   host   ,   port   =   addr   .   split   (   ' : '   ,   1   )       port   .   isdigit   ( ) :   parser   .   error   (   ' Ports       integers . '   )   return   host   ,   int   (   port   )   return   map   (   parse _ address   ,   addresses   )   def   download _ poetry   (   eventloop   ,   sock   ,   infile   ) :   \" \" \" Download   a   piece     poetry         address . \" \" \"   bstring   =   sock   .   recv   (   1024   )       bstring   :   #   end   fo   reading   eventloop   .   remove _ reader   (   sock   )   sock   .   close   ( )   infile   .   close   ( )   print   (   ' end     reading '   )   return   True     :   print   (   ' writing     { }   '   .   format   (   infile   .     ) )   infile   .   write   (   bstring   )   def   connect   (   address   ) :   \" \" \" Connect         server     return   a   - blocking   socket . \" \" \"   sock   =   socket   .   socket   ( )   sock   .   connect   (   address   )   sock   .   setblocking   (   False   )   return   sock   def   format _ address   (   address   ) :   host   ,   port   =   address   return   '   % s   :   % s   '   %   (   host     ' 127.0 . 0.1 '   ,   port   )   def   main   ( ) :   addresses   =   parse _ args   ( )   sockets   =   map   (   connect   ,   addresses   )   eventloop   =   asyncio   .   _ event _ loop   ( )     sock     sockets   :   filename   =   str   (   sock   .   getpeername   ( ) [   1   ] )   +   ' . txt '   infile   =   open   (   filename   ,   ' wb '   )   eventloop   .   add _ reader   (   sock   ,   download _ poetry   ,   eventloop   ,   sock   ,   infile   )     :   eventloop   .   run _ forever   ( )   finally   :   eventloop   .   close   ( )     __ __   = =   ' __ main __ '   :   main   ( )   值得一提的是 读 完毕 判断 逻辑 :       bstring : ## end   fo   reading   eventloop . remove _ reader ( sock )   sock . close ( )   infile . close ( )   print ( ' end     reading ' )   return   True   读 半部 关闭 ， 返回 0 ， 判断 读 操作 完毕 。   自定义 协议 版   asyncio 模块 还 提供 很多 功能 读者 不用 socket 模块 ， 更 高层 基于 协议 编写 网络 程序 。   诗歌 服务器 第二 版 ， 例子 参考   网页   修改 而成 。   1   2   3   4   5   6   7   8   9   10   11   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32   33   34   35   36   37   38   39   40   41   42   43   44   45   46   47   48   49   50   51   52   53   54   55   56   57   58   59   60   61   62   63   64   65   66   67   68   69   70   71   72   73   74   75   76   77   78   79   80   81   82   83   # ! / usr / bin / env   python3   #   - * -   coding :   utf - 8   - * -   import   argparse   import   os   import   time   import   asyncio   def   parse _ args   ( ) :   usage   =   \" \" \" usage :   % prog   [ options ]   poetry - file   python3   asyncio _ slowpoetry3 . py   ecstasy . txt   \" \" \"   parser   =   argparse   .   ArgumentParser   (   usage   )     =   \" The   port     listen   .   Default     a   random     port . \"   parser   .   add _ argument   (   ' - p '   ,   ' - - port '   ,   type   =   int   ,     =     )     =   \" The   interface     listen   .   Default     localhost . \"   parser   .   add _ argument   (   ' - - iface '   ,     =     ,   default   =   ' 127.0 . 0.1 '   )     =   \" The   number     bytes     send     a   time . \"   parser   .   add _ argument   (   ' - - num - bytes '   ,   type   =   int   ,     =     ,   default   =   20   )   parser   .   add _ argument   (   ' poetry _ file '   )   args   =   vars   (   parser   .   parse _ args   ( ) )   poetry _ file   =   args   [   ' poetry _ file '   ]       poetry _ file   :   parser   .   error   (   ' No     file :   % s   '   %   poetry _ file   )   return   args   class   PoetryServeProtocol   (   asyncio   .   Protocol   ) :   def   __ init __   (     ,   inputf   ,   num _ bytes   ) :     .   inputf   =   inputf     .   num _ bytes   =   num _ bytes   def   connection _ made   (     ,   transport   ) :     .   transport   =   transport   print   (     .   transport   )   def   data _ received   (     ,   data   ) :     data   = =   b   ' poems '   :   poem   =     .   inputf   .   read   (     .   num _ bytes   )     poem   :     .   transport   .   write   (   poem   )     :     .   transport   .   write _ eof   ( )   def   main   ( ) :   args   =   parse _ args   ( )   poetry _ file   =   args   [   ' poetry _ file '   ]   num _ bytes   =   args   [   ' num _ bytes '   ]   port   =   args   [   ' port '   ]   iface   =   args   [   ' iface '   ]   inputf   =   open   (   poetry _ file   ,   ' rb '   )   eventloop   =   asyncio   .   _ event _ loop   ( )   print   (   iface   ,   port   )   coro   =   eventloop   .   create _ server   (   lambda   :   PoetryServeProtocol   (   inputf   ,   num _ bytes   ) ,   iface   ,   port   )   server   =   eventloop   .   run _ _ complete   (   coro   )   print   (   server   )     :   eventloop   .   run _ forever   ( )   finally   :   eventloop   .   close   ( )     __ __   = =   ' __ main __ '   :   main   ( )   代码 变得 简单 可怕 。   create _ server   方法 。 方法 ， 基于 定义 协议 创建 一个 TCP   server （ 返回 协程 对象 ） 。 创建 协议 对象 。   自定义 协议 继承 Protocol 类 ， 定义 方法 :   connection _ made   callback 继承 Protocol 类 ， 逻辑 一个 连接 建好 ， 执行 函数 。 接受 一个 参数 transport 。 协议 传输层 。   data _ received   callback 继承 Protocol 类 ， 数据 传 进来 ， 函数 执行 。 接受 一个 参数 传 进来 data 。   eof _ received   数据 结束 完毕 调用 。 一端 transport 发送 写入 结束 信号   write _ eof ( )   。   配套 获取 诗歌 客户端 所示 :   1   2   3   4   5   6   7   8   9   10   11   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32   33   34   35   36   37   38   39   40   41   42   43   44   45   46   47   48   49   50   51   52   53   54   55   56   57   58   59   60   61   62   63   64   65   66   67   68   69   70   71   72   73   74   75   76   77   78   79   80   81   82   83   # ! / usr / bin / env   python3   #   - * -   coding :   utf - 8   - * -   import   datetime   import   argparse   import   asyncio   def   parse _ args   ( ) :   usage   =   \" \" \" usage :   % prog   [ options ]   [ hostname ] : port   ...   python3   select _ _ poetry3 . py   port1   port2   port3   ...   \" \" \"   parser   =   argparse   .   ArgumentParser   (   usage   )   parser   .   add _ argument   (   ' port '   ,   nargs   =   ' + '   )   args   =   vars   (   parser   .   parse _ args   ( ) )   addresses   =   args   [   ' port '   ]       addresses   :   print   (   parser   .   format _   ( ) )   parser   .   exit   ( )   def   parse _ address   (   addr   ) :     ' : '       addr   :   host   =   ' 127.0 . 0.1 '   port   =   addr     :   host   ,   port   =   addr   .   split   (   ' : '   ,   1   )       port   .   isdigit   ( ) :   parser   .   error   (   ' Ports       integers . '   )   return   host   ,   int   (   port   )   return   map   (   parse _ address   ,   addresses   )   class   PoetryClientProtocol   (   asyncio   .   Protocol   ) :   def   __ init __   (     ,   infile   ) :     .   infile   =   infile   def   connection _ made   (     ,   transport   ) :   print   (   transport   .   _ extra _ info   (   ' peername '   ) )     .   transport   =   transport     .   transport   .   write   (   b   ' poems '   )   def   data _ received   (     ,   data   ) :     data   :   print   (   data   )   print   (   ' writing     { }   '   .   format   (     .   infile   .     ) )     .   infile   .   write   (   data   )     .   transport   .   write   (   b   ' poems '   )   def   eof _ received   (     ) :   print   (   ' end     writing '   )     .   infile   .   close   ( )   def   main   ( ) :   addresses   =   parse _ args   ( )   eventloop   =   asyncio   .   _ event _ loop   ( )     address     addresses   :   host   ,   port   =   address   filename   =   str   (   port   )   +   ' . txt '   infile   =   open   (   filename   ,   ' wb '   )   coro   =   eventloop   .   create _ connection   (   lambda   :   PoetryClientProtocol   (   infile   ) ,   host   ,   port   )   t   ,   p   =   eventloop   .   run _ _ complete   (   coro   )   print   (   t   ,   p   )     :   eventloop   .   run _ forever   ( )   finally   :   eventloop   .   close   ( )     __ __   = =   ' __ main __ '   :   main   ( )",
            "tags":"python_language",
            "url":"articles/python-web-programming.html"
        },
        {
            "title":"python语言学习教程二进阶篇",
            "text":"类   python 中 皆 对象 。 学 操作 对象 都 python 程序语言 内部 定义 对象 （ Object ） ， 接下来 介绍 类 语法 更好 理解 对象 之外 ， 再就是 创造 操作 对象 。 面向对象 ( OOP ) 编程 基本概念 不 重复 ， 不明 请 读者 随便 搜索 一篇 网页 阅读 下 即可 。   python 中类 结构   python 中 类 好像 树叶 ， 类 一棵树 ， python 中超类 ， 子类 ， 实例 重载 继承 关系 一种 搜索 机制 ：   python 搜索 有没有 属性 方法 ， ， 向上 搜索 。 比如说 实例 l1 ， 向上 搜索 C1 ， C1 向上 搜索 C2 C3 。   实例 继承 创造 类 属性 ， 创造 类 更 上层 超类 ， 类似 概念 子类 ，   类 树形 层次 中 低 。   ， 简单 来说 类 结构 搜索 机制 ， 很 好 模拟 真实世界 知识 树形 层次结构 。   副 图 编写 代码 ：   class   C2 :   ...   class   C3 :   ...   class   C1 ( C2 , C3 ) :   ...   l1 = C1 ( )   l2 = C1 ( )   class 语句 创造 类 ， C1 继承 C2 C3 ， 这是 多重 继承 ， 从左到右 内部 搜索 顺序 （ 会 影响 重载 ） 。 l1 l2 类 C1 创造 两个 实例 。   初次 接触 类 概念 读者 不 指望 马上 弄懂 类 概念 ， 概念 倒 涉及 很多 哲学 纯 思考 东西 ， 看作 一种 编程 经验 技术 。 接触 也许 对类 学习 更 ， 纯 哲学 抽象概念 讨论 ， 毕竟 类 东西 创造 更好 描述 现实 世界 。   别人 编写 很多 模块 一堆 类 ， 类来 情况 情况 编写 子类 ， 更好 利用 前人 成果 ， 成果 更好 别人 快速 上 手 ， 好好 类 工具 。   类 最 基础知识   类 创建   class   MyClass :     类 创建 语法 上 所示 ， 想 一个 好 一点 类名 。 类名 规范 写法 首字母 大写 ， 好 变量 区分 。   类 创建 实例   语句 格式 MyClass 类 创建 一个 实例 myclass001 。   myclass001 = MyClass ( )   类 属性   > > >   class   MyClass :   ...   = ' myclass '   ...   > > >   myclass001 = MyClass ( )   > > >   myclass001 .   ' myclass '   > > >   MyClass .   ' myclass '   > > >   myclass001 . = ' myclass001 '   > > >   myclass001 .   ' myclass001 '   > > >   MyClass .   ' myclass '   上 代码 所示 ， 创建 一个 类 ， 类 加上 一个 属性 ， 创建 一个 实例 myclass001 ， 实例 类 都 属性 。 实例 加上 点 加上 格式 引用 实例 属性 ， 其值 做 修改 。   例子 简单 演示 类 创建 ， 属性 添加 ， 实例 创建 ， 多态 核心 概念 。 类 继承 概念 都 大同小异 。   类 方法   类 方法 类似 类 属性 加上 def 语句 定义 一个 函数 ， 函数 类 称之为 方法 。 演示 一个 例子 ， 读者 看 明白 。   > > >   class   MyClass :   ...   = ' myclass '   ...   def   double ( ) :   ...   . = . * 2   ...   print ( . )   ...   > > >   myclass001 = MyClass ( )   > > >   myclass001 .   ' myclass '   > > >   myclass001 . double ( )   myclassmyclass   > > >   myclass001 .   ' myclassmyclass '   类 定义 结构 ， 代表 类 （ 更 意义 细节 请 参看   12.4 . 2   { reference - type = \" ref \"   reference = \" sec : 含义 \" } ） ， . 代表 属性 引用 。 实例 调用 方法 时用 myclass001 . double ( ) 结构 ， double 函数 实际上 接受 第一个 参数 ， myclass001 ， 无 参数 函数 。 类 方法 一个 参数 。   类 继承   实例 说 类 创建 ， 实际上 实例 类 一种 继承 关系 ， 实例 继承 自类 ， 而类 类 继承 关系 类似 ， 语法 稍 。 来看 例子 ：   class   Hero ( ) :   def   addlevel ( ) :   . level = . level + 1   . hp = . hp + . addhp   class   Garen ( Hero ) :   level = 1   hp = 455   addhp = 96   garen001 = Garen ( )     i     range ( 6 ) :   print ( ' 级别 : ' , garen001 . level , ' 生命 值 ： '   , garen001 . hp )   garen001 . addlevel ( )   级别 :   1   生命 值 ：   455   级别 :   2   生命 值 ：   551   级别 :   3   生命 值 ：   647   级别 :   4   生命 值 ：   743   级别 :   5   生命 值 ：   839   级别 :   6   生命 值 ：   935   简单 两个 类 ， 盖伦 Garen 类 继承 Hero 类 ， 实例 garen001 继承 Garen 类 ， garen001 addlevel 方法 ， level 属性 加一 ， hp 生命 值 加上 值 ， 过程 很 直观 。   类 内置 方法   构建 一个 类 ， 简单 加上 pass 语句 ， 都 不 做 ， python 会为 类 自动 创建 属性 方法 。   > > >   class   TestClass :   ...   pass   ...   > > >   dir ( TestClass )   [ ' __ class __ ' ,   ' __ delattr __ ' ,   ' __ dict __ ' ,   ' __ dir __ ' ,   ' __ doc __ ' ,   ' __ eq __ ' ,   ' __ format __ ' ,   ' __ ge __ ' ,   ' __ getattribute __ ' ,   ' __ gt __ ' ,   ' __ hash __ ' ,   ' __ init __ ' ,   ' __ le __ ' ,   ' __ lt __ ' ,   ' __ module __ ' ,   ' __ ne __ ' ,   ' __ __ ' ,   ' __ reduce __ ' ,   ' __ reduce _ __ ' ,   ' __ repr __ ' ,   ' __ setattr __ ' ,   ' __ sizeof __ ' ,   ' __ str __ ' ,   ' __ subclasshook __ ' ,   ' __ weakref __ ' ]   变量 名字 都 加上 双 下划线 python 语言 设计者 ， 开发者 命名 变量 。   内置 方法 用户 重 定义 从来 覆盖 掉 定义 ， 特别 值得 一讲   __ init __   方法 称之为 构造函数 。   __ init __ 方法   __ init __   方法 该类 创建 实例 构造函数 。 ：   > > >   class   Point :   ...   def   __ init __ ( , x , y ) :   ...   . x = x   ...   . y = y   ...   > > >   point001 = Point ( 5 , 4 )   > > >   point001 . x   5   > > >   point001 . y   4   例子 重载   __ init __   函数 ， 接受 三个 参数 ， 下 创建 实例 ， x ， y 语句 创建 实例 属性 x y 赋 值 。   意味着   类 中 一个 很 概念 ， 当类 结构 层次 简单 时 还 看 ，   当类 层次结构 很 ， 会 弄 糊涂 。 。 调用 实例 方法 ， 方法 一个 远在天边 类 给出 定义 ， 就算 ， 定义 指 调用 方法 实例 ， 一点 牢记于心 。   例子 ：   class   Test ( ) :   x   =   5   def   __ init __ ( ) :   . x   =   10   test   =   Test ( )   > > >   test . x   10   > > >   Test . x   5   . x 创建 实例 属性 x ， 定义 x 类 Test 属性 x 。   类 操作 第二 版   写出 版本 相比 专业 类 版本 。   class   Hero ( ) :   def   addlevel ( ) :   . level = . level + 1   . hp = . hp + . addhp   class   Garen ( Hero ) :   def   __ init __ ( ) :   . level = 1   . hp = 455   . addhp = 96   . skill = [ ' 不屈 ' , ' 致命 打击 ' , ' 勇气 ' , ' 审判 ' , ' 德玛 西亚 正义 ' ]   garen001 = Garen ( )     i     range ( 6 ) :   print ( ' 级别 : ' , garen001 . level , ' 生命 值 ： '   , garen001 . hp )   garen001 . addlevel ( )   print ( ' 盖伦 技能 ： ' , \" \" . join ( [ x   +   '   '     x     garen001 . skill ] ) )   级别 :   1   生命 值 ：   455   级别 :   2   生命 值 ：   551   级别 :   3   生命 值 ：   647   级别 :   4   生命 值 ：   743   级别 :   5   生命 值 ：   839   级别 :   6   生命 值 ：   935   盖伦 技能 ：   不屈   致命 打击   勇气   审判   德玛 西亚 正义   专业 做法 类 多放点 方法 ， 放 属性 ， 不太 。 确实 写给 人 感觉 更 干净 点 ， 方法 方法 ， 调用 代码 放在 不用 管它 ， 构造函数 去 查看 相关 类 构造方法 ， 很省 精力 。   类 操作 第三版   class   Unit ( ) :   def   __ init __ ( , hp , atk , color ) :   . hp = hp   . atk = atk   . color = color   def   __ str __ ( ) :   return   ' 生命 值 ： { 0 } ， 攻击力 ： { 1 } ， 颜色 ： \\   { 2 } ' . format ( . hp , . atk , . color )   class   Hero ( Unit ) :   def   __ init __ ( , level , hp , atk , color ) :   Unit .__ init __ ( , hp , atk , color )   . level = level   def   __ str __ ( ) :   return   ' 级别 ： { 0 } , 生命 值 ： { 1 } ， 攻击力 ： { 2 } ， \\   颜色 ： { 3 } ' . format ( . level , . hp , . atk , . color )   def   addlevel ( ) :   . level = . level + 1   . hp = . hp + . addhp   . atk = . atk + . addatk   class   Garen ( Hero ) :   def   __ init __ ( , color = ' blue ' ) :   Hero .__ init __ ( , 1 , 455 , 56 , color )   . = ' 盖伦 '   . addhp = 96   . addatk = 3.5   . skill = [ ' 不屈 ' , ' 致命 打击 ' , ' 勇气 ' , ' 审判 ' , ' 德玛 西亚 正义 ' ]     __ __   = =   ' __ main __ ' :   garen001 = Garen ( ' red ' )   garen002 = Garen ( )   print ( garen001 )   unit001 = Unit ( 1000 , 1000 , ' gray ' )   print ( unit001 )     i     range ( 6 ) :   print ( garen001 )   garen001 . addlevel ( )   print ( ' 盖伦 技能 ： ' , \" \" . join ( [ x   +   '   '     x     garen001 . skill ] ) )   级别 ： 1 , 生命 值 ： 455 ， 攻击力 ： 56 ，   颜色 ： red   生命 值 ： 1000 ， 攻击力 ： 1000 ， 颜色 ：   gray   级别 ： 1 , 生命 值 ： 455 ， 攻击力 ： 56 ，   颜色 ： red   级别 ： 2 , 生命 值 ： 551 ， 攻击力 ： 59.5 ，   颜色 ： red   级别 ： 3 , 生命 值 ： 647 ， 攻击力 ： 63.0 ，   颜色 ： red   级别 ： 4 , 生命 值 ： 743 ， 攻击力 ： 66.5 ，   颜色 ： red   级别 ： 5 , 生命 值 ： 839 ， 攻击力 ： 70.0 ，   颜色 ： red   级别 ： 6 , 生命 值 ： 935 ， 攻击力 ： 73.5 ，   颜色 ： red   盖伦 技能 ：   不屈   致命 打击   勇气   审判   德玛 西亚 正义   例子 第二 版所作 改动 ， 核心 知识点 。 函数 参量 列表 中 表述   color = ' blue '   blue color 变量 备选 值 ， color 成 可选 参量 。   构造函数 继承 重载   例子 很 核心 一个 概念   __ init __   构造函数 继承 重载 。 garen001 实例 创建 ， 引用 Hero 构造函数 ， 特别强调 ，   Hero .__ init __ ( , 1 , 455 , 56 , color )   调用 Hero 类 构造函数 ， 写 上 ， 最终 创建 实例 garen001 ， Hero ， 调用 Hero 类 构造函数 参量 列表 形式 。 概念 弄清楚 ！   理解 一点 ， 类 继承 关系 中 构造函数 继承 重载 好看 。 Hero 类 构造函数 继承 Unit 类 构造函数 ， Hero 类 额外 一个 参量 level 接下来 开辟 存储空间 配置 好 。   __ str __ 函数 继承 重载   第二个 修改 重 定义 类   __ str __   函数 ， 定义 改变 默认 print 类 对象 输出 。 默认 一段 类 无 具体内容 信息 。 return 一段 想要 字符串 样式 即可 。   类 高级 知识   说 下 python2 python3 兼容性 ， 读者 python2.7 环境 下 ， 推荐 定义 class 都 跟上 object ：   class   Test ( object ) :   pass   章节 围绕 内容 展开 ， python 类 深度 定制 。   内省 属性 ：   __ dict __   ，   __ class __   某种 运算符 操作 调用 常见 方法 时 重载 。   函数 装饰器 ：   函数调用 定制   属性 访问 定制   特定 属性 访问 时 定制   类 实例 创建 时 定制 - - - - - - 类 装饰器   类 对象 创建 时 定制 - - - - - - metaclass   __ dict __   参考   网页   。   读者 记住 class 类似 def 语句 ， 管理 一个 名字 空间 ， 区块 语句 执行 。 看 例子 ：   class   A   ( ) :   def   __ init __   (     ,   a   ) :     .   a   =   a   def   fun2   (     ,     ) :   print   (   ' fun '   ,     )   @ property   def   x   (     ) :   return   1   class   B ( A ) :   def   __ init __ ( ) :   . d   =   5   b   =   2   def   fun3 ( ) :   print ( ' fun3 ' )   b   =   B ( )   b .__ class __   = >   < class   ' B ' >   B .__ class __   = >   < class   ' type ' >   b .__ dict __   = >   { ' d ' :   5 }   B .__ dict __   = >   mappingproxy ( { ' __ module __ ' :   ' builtins ' ,   ' __ init __ ' :   < function   B .__ init __     0x7f13586057b8 > ,   ' b ' :   2 ,   ' fun3 ' :   < function   B . fun3     0x7f1358605840 > ,   ' __ doc __ ' :   None } )   A .__ dict __   = >   mappingproxy ( { ' __ module __ ' :   ' builtins ' ,   ' __ init __ ' :   < function   A .__ init __     0x7f1358605620 > ,   ' fun2 ' :   < function   A . fun2     0x7f13586056a8 > ,   ' x ' :   < property   object     0x7f1358604188 > ,   ' __ dict __ ' :   < attribute   ' __ dict __ '     ' A '   objects > ,   ' __ weakref __ ' :   < attribute   ' __ weakref __ '     ' A '   objects > ,   ' __ doc __ ' :   None } )   例子 很 东西 ，   b .__ class __   查看 实例 b 类型 ， 大体 输出 接近   type ( b )   ， 类 B 类型 type 。 metaclass 会 讲 ， 记住 实例 类 创建 ， 而类 元类 type 创建 。   实例 b 类 B 类 A 都 记忆 属性 ， 继承 属性 不 重复 记忆 。   类   __ dict __     mappingproxy 对象 ， 其是 只读 ， 实例 b   __ dict __     dict 类型 ， 读写 （ 参考   篇文章   ） 。     @ property   装饰器 修饰 函数 ， 会 一个   property   object ， 会谈 ， 特定 属性 访问 定制 ， 描述符 对象 。   __ getitem __   __ getitem __ ( ,   key )   方法 定义 实例 形式   Class [ ' key ' ]   。   class   Test   ( ) :   a   =   1   def   __ getitem __   (     ,   key   ) :   print   (   ' i   accpeted :   { 0 }   '   .   format   (   key   ) )   return     .   a   t   =   Test   ( )   > >   t   [   ' a '   ]   i   accpeted   :   a   = >   1   类 初步 测试 不 支持   Test [ ' x ' ]   写法 。     __ setitem __ ( ,   key ,   )   方法     t [ ' x ' ] = 3   赋值 形式 ；   __ delitem ( ,   key ) __   方法 运算 符号 ：   del   t [ ' x ' ]   。   数学 运算 符号 重载   层面 很少 需求 去 重载 数学 运算 符号 操作 。 稍微 下 即可 。   加法   X   +     ,   __ add __ ( , )   右侧 加法   加法 X + ， 右侧 加法 ， radd ， 公式 ： + X 。 不 区分 加法 。   +   ​   X   ,   __ radd __ ( , )   增强 加法   X   + =   ，   __ iadd __ ( . )   减法   X   -     ,   __ __ ( , )   ​   。 情况 类似 rsub isub 。   *   乘法 ，   __ mul __ ( , )   ， 类似 都 右侧 运算 增强 运算 ， 不再 赘述 。   / /   整除 ，   __ floordiv __   ， 类似 参数 都 ， 不再 赘述 。   /   除法   ，   __ div __   %   取余 ，   __ mod __   * *   开方 ，   __ pow __   \\ < \\ <   左移 运算 ，   __ lshift __   > >   右移 运算 ，   __ rshift __   &   位 ，   __ __   |   位 ，   __ __   &# 94 ;   位 异或 ，   __ xor __   类似 右侧 运算 名字 加上 r ， 增强 运算 名字 加上 i ， 不 赘述 。   逻辑运算   bool 函数   bool ( X )   __ bool __ ( )   __ eq __   __ eq __   方法 定义 两个 对象 之间 A   = =   B 。   ：   def   __ eq __   (     ,     ) :       .   __ dict __   .   keys   ( )   = =     .   __ dict __   .   keys   ( ) :     key       .   __ dict __   .   keys   ( ) :         .   __ dict __   .     (   key   )   = =     .   __ dict __   .     (   key   ) :   return   False   return   True     :   return   False   定义   __ eq __   方法 ， 运行 = = 语句 ， 两个 对象 之间 内置 字典 键和值 都 ， 返回 True 。   > > >   test = GClass ( )   > > >   test . a = 1   > > >   test2 = GClass ( )   > > >   test2 . a = 1   > > >   test   = =   test2   True   > > >   test     test2   False   不 重 定义   __ eq __   方法 ， test test2 会 原始 object 类 继承   __ eq __   方法 ， 返回 False ， 想 两个 实例 内部 值 差异 ， 基于 id 。   判断 操作   类似 = = 操作 ， 判断 操作 内置 方法 重 定义 。   X   ! =   Y   ，   __ ne __ ( , )   定义 。   X   > =   Y   ，   __ ge __ ( , )   定义 。   X   \\ < =   Y   ，   __ le __ ( , )   定义 。   X   >   Y   ，   __ gt __ ( , )   定义 。   X   \\ <   Y   ，   __ lt __ ( , )   定义 。   语句   所示 ：   def   __ __   (     ,     ) :     key       .   __ dict __   .   keys   ( ) :         .   __ dict __   .     (   key   )   = =     .   __ dict __   .     (   key   ) :   return   False   return   True   提供       X   语句 支持 ， 例子 基于 类 其内 字典 内容 做出 判断 。   类 之间 判断   参考 网站   。   先 下 语句 = = 判断 isinstance id type 函数 ， 再 提及 python 类 内置 方法   __ eq __   。   python 一个 彻头彻尾 面向对象 语言 ， python 内部 数据 都 对象 ， 对象 类型 type 区别 。 内置 对象 类型 ：   > > >   type ( ' abc ' )   < class   ' str ' >   > > >   type ( 123 )   < class   ' int ' >   > > >   type ( [ 1 , 2 , 3 ] )   < class   ' list ' >   对象 type 类型 之外 ， id 属性 ， id 对象 内存 中 存储 位置 。   说 lst = [ 1 , 2 , 3 ] ， 程序 内存 中 创建 对象 [ 1 , 2 , 3 ] ， lst 变量名 一个 引用 。 看 例子 ：   > > >   x = [ 1 , 2 , 3 ]   > > >   y = [ 1 , 2 , 3 ]   > > >   type ( x )   < class   ' list ' >   > > >   type ( y )   < class   ' list ' >   > > >   id ( x )   3069975884   > > >   id ( y )   3062209708   > > >   x = = y   True   > > >   x     y   False   type 函数 返回 对象 类型 ， id 函数 返回 对象 内存 中 存储 位置 ， = = 判断 确保 值 ， 语句 返回 True ， 对象 内存 上 （ id ） 同一个 东西 。   对象 之间 类型 语句 ：   > > >   x = 10   > > >   type ( x )   = =   int   True   > > >   type ( x )   = =   type ( 0 )   True   特别 好用 ， 假设 fun 定义 一个 函数 ， type ( fun )   = =   function 会 出错 ， type 还要 小心 NoneType 空 列表 类型 ， type 将类 继承 进去 。   推荐 isinstance 函数 类型 ， 请 参考   网站   。 推荐 types 模块 特定 名字 判断 类型 ， ：   types . NoneType   None 值 类型   types . TypeType   type 对象 。   types . BooleanType   还   bool   。   types . IntType   还   int   ， 类似   long   ，   float   。   types . ComplexType   复数 类型   types . StringType   字符串 类型 ， 还   str   。   types . TupleType   元组 ， 还   tuple   ， 类似   list   ，   dict   。   types . FunctionType   定义 函数 类型 ，   types . LambdaType   。   值得一提的是 print 内置 函数 FunctionType BuiltinFunctionType 。   > > >   import   types   > > >   isinstance ( print , types . FunctionType )   False   > > >   isinstance ( print , types . BuiltinFunctionType )   True   更 内容 请 参见   types 模块 官方 文档   。   强制 类型 变换   包含 内置 方法 ：   __ int __ ( )   返回 整型   __ long __ ( )   长 整型   __ float __ ( )   浮点 型   __ complex __ ( )   复数 型   __ str __ ( )   字符 型   __ oct __ ( )   八进制   __ hex __ ( )   十六进制   __ index __ ( )   切片 操作   len ( )   len ( )     __ len __ ( )   提供 支持 。   copy 方法 deepcopy 方法   X . copy ( )     ___ copy __ ( )   提供 。   X . deepcopy ( )     __ deepcopy __ ( )   提供 。   就要 提 python copy 模块 ， 很少 有人 去 针对 类 单独 编写   __ deepcopy __   方法 ， 会 情况 ， 很多 情况   copy . deepcopy ( )   够用 。   语句 支持   PEP343 说法 ：     VAR   =   EXPR :   BLOCK     EXPR     VAR :   BLOCK   实际上 ：   VAR   =   EXPR   VAR .__ enter __ ( )   :   BLOCK   finally :   VAR .__ exit __ ( )   执行     open ( ... )     f   这类 语句 ， 最终 离开 调用 文件 对象   __ exit __   方法 ：     open ( ... )     f :   BLOCK   f   =   open ( ... )   f .__ enter __ ( )   :   BLOCK   finally :   f .__ exit __ ( )     contextlib   还 提供 一个   contextmanager   装饰器 ， 写法 差异 ， 效果 大致 类似 。 一个 演示 例子 ：   class   Mylock   ( ) :   def   __ enter __   (     ) :     .   lock   =   acquire _ lock   ( )   return     .   lock   def   __ exit __   (     ) :     .   lock   .   release   ( )     Mylock   ( )     lock   :   #         contextlib   import   contextmanager   @ contextmanager   def   _ lock   (   ...   ) :   lock   =   acquire _ lock   ( )     :   yield   lock   finally   :   lock   .   release   ( )     _ lock   (   ...   )     lock   :   #       __ call __   请 看 例子 ：   class   Position   ( ) :   def   __ init __   (     ,   x   =   0   ,   y   =   0   ) :     .   x   =   x     .   y   =   y   def   __ call __   (     ,   x   ,   y   ) :     .   x   =   x     .   y   =   y   def   __ repr __   (     ) :   return   ' ( '   +   str   (     .   x   )   +   ' , '   +   str   (     .   y   )   +   ' ) '   > > >   p1   =   Position   ( )   > > >   print   (   p1   )   (   0   ,   0   )   > > >   p1   (   4   ,   5   )   > > >   print   (   p1   )   (   4   ,   5   )   > > >     __ call __ ( , args )   方法 ， 实例 好像 函数 调用 。   __ repr __     __ str __   区别   简单 来说   repr ( )   调用   __ repr __   方法 ， str ( )   调用   __ str __   方法 。 再 简单 实验 ， print 函数 字符串 format 相关   __ str __   方法 ， python REPL 环境 下 ， 简单 输入 变量 回显   __ repr __   方法 。 不   __ str __   方法 ， print 函数 字符串 format 相关 会 调用   __ repr __   方法 ，   __ repr __   方法 就算 不 python 对象 都 默认   __ repr __   方法 。   __ __   一个 类 创造 出 一个 实例 调用   __ __   方法 ， 才 调用   __ init __   方法 。 一个 单例 模式 ， 一个 类 只能 创造 一个 实例 ， 请 参看   篇文章   。   class   Singleton   (   object   ) :   _ instance   =   None   def   __ __   (   cls   ,   *   args   ,   * *   kw   ) :       cls   .   _ instance   :   cls   .   _ instance   =   super   (   Singleton   ,   cls   )   .   __ __   (   cls   ,   *   args   ,   * *   kw   )   return   cls   .   _ instance   class   MyClass   (   Singleton   ) :   a   =   1   > > >     =   MyClass   ( )   > > >     =   MyClass   ( )   > > >     = =     True   > > >         True   > > >   id   (     ) ,   id   (     )   (   4303862608   ,   4303862608   )   一个点 ，   _ instance   两个 类 初始化 过程 中 指向 同一个 对象 。   _ instance   类 ， 实例 基于 类   __ __     __ init __   方法 生成 ， 假设 python 程序 ， 类 （ class def 一种 东西 ） 不 内存 里 编译 好 ， 都 引用 类 就行了 。 内存 编译 好 类   _ instance   变量 封装 好 。 理解 过程 有助于 进一步 理解 类 变量 作用 。   __ del __   对象 内存 存储 回收 时 ， python 执行 一个 内置 方法   __ del __   。 定义 管理 额外 资源 ， 定制 函数 确保 python 程序 关闭 时 目标 资源 自动 关闭 回收 。   __ getattr __   属性 不 对象   __ dict __   ， python 会 调用   __ getattr __ ( , )   方法 （ 参考   篇文章   ） 。 没 定义 方法 抛出   AttributeError   。     __ setattr __ ( , , )     __ delattr __ ( , )   ， 两个 方法 原 属性 不 都 会 操作 ， 谨慎 ！   迭代 器 生成器   推荐   篇文章   ， 对本 小节 概念 理清 很大 。 慢慢 来说 。   Iterable 迭代 对象 ， Iterator 迭代 器 。 collections 两个 类 ， 做出 判断 ：     collections   import   Iterable , Iterator   isinstance ( obj ,   Iterable )   isinstance ( obj ,   Iterator )   再 来看 官方 文档 词语 解释 ：   iterable   - -   迭代 对象   逐一 返回 成员 项 对象 。 迭代 对象 例子 包括 序列 类型 （   list   、   str     tuple   ） 非 序列 类型   dict   、   文件 对象   定义   __ iter __ ( )   方法   Sequence   语义   __ getitem __ ( )   方法 任意 自定义 类 对象 。   迭代 对象 用于     循环 一个 序列 地方 （   zip ( )   、   map ( )   ... ） 。 一个 迭代 对象 参数 传给 内置 函数   iter ( )   时 ， 它会 返回 对象 迭代 器 。 迭代 器 对值 集合 一次性 遍历 。 迭代 对象 时 ， 不 调用   iter ( )   迭代 器 对象 。     语句 会为 自动 操作 ， 创建 一个 临时 未命名 变量 用来 循环 期间 保存 迭代 器 。 参见   iterator   、   sequence     generator   。   iterator   - -   迭代 器   用来 一连串 数据流 对象 。 重复 调用 迭代 器   __ __ ( )   方法 （ 传给 内置 函数   ( )   ） 逐个 返回 流中 项 。 数据 可用 时则 引发   StopIteration   异常 。 迭代 器 对象 中 数据项 已 耗尽 ， 调用   __ __ ( )   方法 只会 再次 引发   StopIteration   异常 。 迭代 器   __ iter __ ( )   方法 用来 返回 迭代 器 对象 ， 迭代 器 必定 迭代 对象 ， 用于 迭代 对象 大部分 场合 。 一个 例外 会 多次重复 访问 迭代 项 代码 。 容器 对象 （   list   ） 每次 传入   iter ( )   函数     循环 中 时 都 会 一个 新 迭代 器 。 情况 下 尝试 迭代 器则 会 返回 迭代 过程 中 耗尽 迭代 器 对象 ， 使 看起来 像是 一个 空 容器 。   生成器 函数 区别 函数 yield 语句 返回 ， 这块 python 异步 相关 ， 。 生成器 表达式 ：   test1   =   ( i + 1     i     range ( 5 ) )   isinstance ( test1 ,   Iterator )   > > >   True   isinstance ( test1 ,   Iterable )   > > >   True   都 生成器 ， 生成器 某种 简化版 迭代 器 ， 迭代 器 迭代 对象 。 迭代 对象   iter   函数 成   迭代 器 。 一般而言 简单 理解 ， 对象   __ iter __   方法 ， 一个 迭代 对象 ， 对象   __ __   方法 ， 一个 迭代 器 。   常见 遍历 过程 所示 ：   > > >   list   =   [   1   ,   2   ,   3   ]   > > >   iter   =   iter   (   list   )   > > >     True   :   ...     :   ...   x   =     (   iter   )   ...     StopIteration   :   ...   break   ...   print   (   x   )   ...   1   2   3   iter 函数 调用 目标 对象   __ iter __   方法 （ 对象 迭代 对象 方法 ） ， 一般而言 简单 情况 ，   __ iter __   方法 返回 目标 对象 ， 目标 对象 定义   __ __   方法 。   迭代 器 来说 ， 迭代 过程 调用   __ __   方法 获取 下 一个 值 ，   StopIteration   异常 停止 获取 。   提到 语句 ， map   zip   函数 过程 自动 做 。 包括 iter 函数 捕获 终止 异常 。   文件 对象 本身 迭代 ， 调用   __ __   方法 返回 文件 中 下 一行 内容 ， 到达 文件 尾 迭代 越界 返回 ：   StopIteration   异常 。   函数 ( f ) 等价   f .__ __ ( )   。   > > >     line     open ( ' removeduplicate . py ' ) :   ...   print ( line , end = ' ' )   ...   # ! / usr / bin / env   python3   # - * - coding : utf - 8 - * -   # 此处 内容 省略 。   > > >   f = open ( ' removeduplicate . py ' )   > > >   ( f )   ' # ! / usr / bin / env   python3 \\ n '   定义 类   __ __   方法 类 函数 时 。   序列 （ 列表 ， 元组 ， 字典 ， ranges 对象 ） 迭代 对象 ， 迭代 器 。 iter 函数 成 迭代 器 。   提及 常规 操作 ，   __ iter __   返回 ， 构建   __ __   方法 定制 迭代 器 外 ：   class   Test   (   object   ) :   def   __ init __   (     ) :     .   count   =   0   def   __ iter __   (     ) :   return     def   __ __   (     ) :     .   count   + =   1       .   count   > =   3   :   raise   StopIteration   return     .   count   isinstance ( t ,   Iterator )   > > >   True   list ( t )   > > >   [ 1 ,   2 ]   定义   __ iter __   方法 返回 一个 生成器 对象 （ generator   object ） ， 生成器 迭代 器 。   例子 定义 字典 类   __ iter __   方法 一个 新类 ， 类用 iter 函数 迭代 器 返回 排序 字典 键 。   class   SortedDict   (   dict   ) :   def   __ init __   (     ,   dict   =   { } ) :   super   ( )   .   __ init __   (   dict   )   def   __ iter __   (     ) :     .   _ keys   =   sorted   (     .   keys   ( ) )     i       .   _ keys   :   yield   i   dict02   =   SortedDict   ( )   dict02   [   ' a '   ]   =   1   dict02   [   ' b '   ]   =   1   dict02   [   ' d '   ]   =   1   dict02   [   ' c '   ]   =   1     i     dict02 :   print ( i )   a   b   c   d   例子 ， 只 语句 迭代 目标 对象 时才 会 调用   __ iter __   方法 。   理解 python 迭代 操作   python 中 代码 运算 效率 会 低 一点 ， 类似 工作 更 简单 语句 运算 效率 会 高 一点 。 python 一个 设计 理念 ， 不尽然 ， 确实 很 有意思 。   程序结构 中 最 有用 多个 操作 重复 ， 迭代 递归 循环 语句 。 递归 函式 感觉 很 有用 ， 基于 数据结构 特别 操作 重复 迭代 语句 即可 ， 才 循环 语句 。   迭代 语句 中 语句 运算 效率 最低 ， map 函数 （ 不尽然 ） ， 列表 解析 。 最 pythonic 风格 ， 运算 效率 列表 解析 ， 一个 列表 解析 解决 列表 解析 解决 ， python 设计者 很多 优化 工作 都 针对 迭代 操作 ， python3 进一步 深化 迭代 思想 ， python 中 迭代 c 语言 。   反思 列表 解析 通用 ？ 比如说 range 函数 文件 对象 列表 字符串 ， 都 称之为 迭代 对象 。 迭代 对象 内置 方法   __ __   谈及 ， 迭代 对象 特色 一系列 元素 ， 一系列 元素 内置 方法 逐个 调 ， 列表 解析 调 元素 表达式 操作 ， 收集 。 这是 ？ 看 这张 图片 ：   这张 图片 告诉 列表 解析 数学 上 集合 函数 定义 类似 ， 迭代 对象 好像 一个 集合 （ 顺序 没 顺序 都行 ） ， 集合 中 元素 操作 ， 操作 数学 中 定义 函数 ， 加上 过滤 条件 ， 元素 不 参加 运算 ， 生成 第二个 迭代 对象 （ 列表 字典 。 ）   一个 哲学 上 假定 ， 世界 都 数学 描述 ， 数学 都 函数 上 信息 操作 过滤 流 描述 。 不尽然 ， 列表 解析 上 很 通用 思想 。   有限 元素 集合 适合 迭代 ， 无限 元素 集合 也许 递归 循环 更 适合 。 想到 集合 描述 分为 列举 描述 （ 有限 元素 列举 ） 定义 描述 。 比如说   1 < x < 10   ， x 整数 ， 定义 一个 集合 。 想到 python 描述 列举 （ 列表 ） 集合 ？ range 函数 目的 而生 ， 比如说   range ( 10 )   定义   [ 0 , 10 )   一系列 整数 集合 ， range 函数 生成 一个 range 对象 ， range 对象 一个 迭代 对象 ， 看作 迭代 对象 中 描述 集合 类型 。 问 ，   0 < = x < 10   整数 集合 描述 ， 函数 描述 可不可以 ？ 可不可以 建立 类似 range 对象 描述性 迭代 对象 ？   map filter 函数   迭代 模式 描述 ， 常见 列表 解析 格式 ( 语句 ) 集合 中 元素 操作 过滤 ， python 中 两个 函数 类似 功能 ， map 集合 中 元素 函数 操作 （ 接受 lambda 函式 ） ， filter 过滤 功能 。 值得一提的是 python3 map 函数 filter 函数 返回 都 一个 迭代 对象 列表 ， range 函数 迭代 对象 用于 列表 解析 结构 。   map 函数   列出 例子 ：   > > >   map ( abs ,   [ - 2 , - 1 , 0 , 1 , 2 ] )   < map   object     0xb707dccc >   > > >   [ x     x     map ( abs ,   [ - 2 , - 1 , 0 , 1 , 2 ] ) ]   [ 2 ,   1 ,   0 ,   1 ,   2 ]   > > >   [ x     x     map ( lambda   x   :   x + 2 ,   [ - 2 , - 1 , 0 , 1 , 2 ] ) ]   [ 0 ,   1 ,   2 ,   3 ,   4 ]   map 函数 还 接受 两个 迭代 对象 协作 参数 模式 ， 学过 lisp 语言 会 很 眼熟 ， 理解 很 便捷 。 第一个 迭代 对象 取出 一个 元素 map 函数 第一个 参数 ， 第二个 迭代 对象 取出 第二个 参数 ， 函数 运算 ， 一个 ， 不 列表 解析 一个 map 对象 （ 迭代 对象 ） ， 展开 以此类推 。 值得一提的是 两个 迭代 对象   深度 最 短   ， 请 看 例子 ：   > > >   [ x     x     map ( lambda   x , y   :   x + y ,   [ - 2 , - 1 , 0 , 1 , 2 ] , [ - 2 , - 1 , 0 , 1 , 2 ] ) ]   [ - 4 ,   - 2 ,   0 ,   2 ,   4 ]   > > >   [ x     x     map ( lambda   x , y   :   x + y ,   [ - 2 , - 1 , 0 , 1 , 2 ] , [ - 2 , - 1 , 0 , 1 ] ) ]   [ - 4 ,   - 2 ,   0 ,   2 ]   filter 函数   谈及 类似 ， filter 函数 过滤 一个 迭代 对象 一个 迭代 对象 。 类似 功能 列表 解析 后 语句 。 谈到 map 函数 提及 优先 列表 解析 模式 ， filter 函数 ， 列表 解析 跟个 会 人 困惑 ， 推荐 filter 函数 迭代 对象 过滤 操作 。   filter 函数 逻辑   return   True   （ lambda 表达式 表达式 值 真 )   元素 才 收集 ， 或者说 过滤出来 。   请 参看 例子 理解 ：   > > >   [ x     x     filter ( lambda   x : x & 1 , [ 1 , 2 , 3 , 5 , 9 , 10 , 155 , - 20 , - 25 ] ) ]   [ 1 ,   3 ,   5 ,   9 ,   155 ,   - 25 ]   > > >   [ x     x     filter ( lambda   x :   x & 1 , [ 1 , 2 , 3 , 5 , 9 , 10 , 155 , - 20 , - 25 ] ) ]   [ 2 ,   10 ,   - 20 ]   传统 编写 函数 ：   > > >   def   ( n ) :   ...     n   %   2   = = 0 :   ...   return   True   > > >   [ x     x     filter ( , [ 1 , 2 , 3 , 5 , 9 , 10 , 155 , - 25 ] ) ]   [ 2 ,   10 ]   zip 函数   顺便 zip 函数 提了 ， zip 函数 返回 一个 迭代 对象 ， 接受 任意 数目 迭代 对象 ， 逐个 取出 迭代 对象 元素 一个 元 一个 元素 。 map 函数 类似   迭代 深度 最 短 迭代 对象   。   > > >   zip ( [ ' a ' , ' b ' , ' c ' ] , [ 1 , 2 , 3 , 4 ] )   < zip   object     0xb7055e6c >   > > >   [ x     x     zip ( [ ' a ' , ' b ' , ' c ' ] , [ 1 , 2 , 3 , 4 ] ) ]   [ ( ' a ' ,   1 ) ,   ( ' b ' ,   2 ) ,   ( ' c ' ,   3 ) ]   > > >   list ( zip ( [ ' a ' , ' b ' , ' c ' ] , [ 1 , 2 , 3 , 4 ] ) )   [ ( ' a ' ,   1 ) ,   ( ' b ' ,   2 ) ,   ( ' c ' ,   3 ) ]   > > >   dict ( zip ( [ ' a ' , ' b ' , ' c ' ] , [ 1 , 2 , 3 , 4 ] ) )   { ' c ' :   3 ,   ' b ' :   2 ,   ' a ' :   1 }   字典 列表   例子 价值 不 大 ， zip 函数 接受 任意 数目 参数 情况 。 y . items ( ) 解包 4 参数传递 zip 函数 ， zip 函数 封装 逻辑 有人 问 ， 迭代 对象 取出 一个 元素 ， 元组 包装 返回 。   x1   =   [ ' a ' , ' b ' , ' c ' , ' e ' ]   x2   =   [ 1 , 2 , 3 , 4 ]   y   =   dict ( zip ( x1 , x2 ) )   print ( ' 列表 字典 ： ' , y )   _ x1 , _ x2   =   zip ( * y . items ( ) )   print ( _ x1 , _ x2 )   列表 字典 ：   { ' b ' :   2 ,   ' c ' :   3 ,   ' a ' :   1 ,   ' e ' :   4 }   ( ' b ' ,   ' c ' ,   ' a ' ,   ' e ' )   ( 2 ,   3 ,   1 ,   4 )   例子 情况 ， 跳过 字典 形式 ， 来个 数据 映射 ：   > > >   x1   =   [ ' a ' , ' b ' , ' c ' , ' e ' ]   > > >   x2   =   [ ' red ' , ' yellow ' , ' red ' , ' blue ' ]   > > >   x3   =   [ 1 , 2 , 3 , 4 ]   > > >   list ( zip ( x1 , x2 , x3 ) )   [ ( ' a ' ,   ' red ' ,   1 ) ,   ( ' b ' ,   ' yellow ' ,   2 ) ,   ( ' c ' ,   ' red ' ,   3 ) ,   ( ' e ' ,   ' blue ' ,   4 ) ]   > > >   _ x1 , _ x2 , _ x3   =   zip ( * list ( zip ( x1 , x2 , x3 ) ) )   > > >   _ x1   ( ' a ' ,   ' b ' ,   ' c ' ,   ' e ' )   > > >   _ x2   ( ' red ' ,   ' yellow ' ,   ' red ' ,   ' blue ' )   > > >   _ x3   ( 1 ,   2 ,   3 ,   4 )   属性数据 推荐 类来 ， 情况 下 不 类 ， 简单 。   值得一提的是 数据 存储 形式 sql 存储 ， 不 ， 矩阵 转置 功能 。   装饰器   装饰器 作用 机制 接下来 函数 进一步 封装 ， ：   @ staticmethod   def   ( ) :   pass   #   等价 类 声明 语句 里 写 上 一句 。     =   staticmethod ( )   装饰器 一个 神秘 难懂 概念 ， 定义 函数 ， 函数 函数 对象 ， 某种 封装 。   自定义 装饰器   def   print1 ( f ) :   print ( ' 1 ' , f )   return   f   @ print1   def   print3 ( c ) :   print ( c )   print3 ( ' c ' )   #   print1 ( print3 ) ( ' c ' )   print1 函数 做成 一个 装饰器 函数 ， print3 函数 理解   print3 = print1 ( print3 )   。 — — 理解 关键在于 理解 python 中 函数 名字 无关紧要 ， 关键 函数 对象 。 右边 print3   def   print3   时 生成 函数 对象 ， 函数 对象 送给 print1 封装 一个 新 函数 对象 ， 再 函数 对象 赋值 变量 print3 。   多个 装饰器   def   print1 ( f ) :   print ( ' 1 ' , f )   return   f   def   print2 ( f ) :   print ( ' 2 ' , f )   return   f   @ print2   @ print1   def   print4 ( c ) :   print ( c )   print4 ( ' c ' )   多个 装饰器 装饰 顺序 是从 下往 上 ， 例子 原 print4 函数 对象 先 print1 ， 再 print2 ， 函数 对象 赋值 变量 print4 。   装饰器 带上 参数   例子 中 ， 简单 装饰器 函数 理解 一个 接受 函数 对象 返回 返回 函数 对象 函数 ， 很 直观 简单 。 实际上 装饰器 带上 参数 ， 函数 闭包 结构 【 函数 定义 函数 结构 ， 内部 函数 外部 函数 参数 变量 】 才能 ， 例子 所示 :   def   print1 ( f ) :   print ( ' 1 ' , f )   return   f   def   print2 ( b ) :   def   test ( f ) :   print ( ' 2 ' , f , b )   return   f   return   test   @ print2 ( ' b ' )   @ print1   def   print4 ( c ) :   print ( c )   print4 ( ' c ' )   装饰器 写法   小节 参考   网页   。 书写 一个 装饰器 函数 通用 写法 ：   无 参数 装饰器 版本     functools   import   wraps   def   mydecorator   (   func   ) :   @ wraps   (   func   )   def   wraper _ func   (   *   args   ,   * *   kwargs   ) :   #       return   func   (   *   args   ,   * *   kwargs   )   return   wraper _ func   @ mydecorator   def   test   (   *   args   ,   * *   kwargs   ) :   \" \" \"       test   function   \" \" \"   print   (   args   ,   kwargs   )   test   (   ' test '   ,   a   =   1   )   print   (   test   .   __ doc __   )     functools   模块   wraps 装饰器 ， 接受 装饰 函数 参数 。 不 这样的话 ， 原 test 函数 中 定义 文字 丢失 ，   test = mydecorator ( test )   ， 实际上 test 变量 接受 函数 对象   wraper _ func   ， 不信 查看   test .__ __   其是 等于   wraper _ func   。 上 wraps 装饰器 ， 原 test 函数 中 定义 名字 文档 都 保留 。   带 参数 装饰器 版本     functools   import   wraps   def   mydecorator   (   arg1   ,   arg2   ) :   def   _ mydecorator   (   func   ) :   @ wraps   (   func   )   def   wraper _ func   (   *   args   ,   * *   kwargs   ) :   print   (   ' i       pass     decorator   parameters : '   ,   arg1   ,   arg2   )   #       return   func   (   *   args   ,   * *   kwargs   )   return   wraper _ func   return   _ mydecorator   @ mydecorator   (   ' a '   ,   ' b '   )   def   test   (   *   args   ,   * *   kwargs   ) :   \" \" \"       test   function   \" \" \"   print   (   args   ,   kwargs   )   test   (   ' test '   ,   a   =   1   )   print   (   test   .   __ doc __   )   静态方法 装饰器   class   Test :   #   @ staticmethod   def   ( ) :   print ( ' aaa ' )   test = Test ( )   test . ( )   例子 中 ， 希望 创造 一个 函数 ， 函数 实例 关系 （ 指 函数 不 接受 默认 参数 ） 。 上 所示 ， 函数 希望 简单 打印 一小 段 字符 ，   代码 错误   ， 函数 加上   @ staticmethod   ， 段 代码 报错 ，   class   Test :   @ staticmethod   def   ( ) :   print ( ' aaa ' )   test = Test ( )   test . ( )   类 定义 函数 类 静态方法 ， 静态方法 继承 ， 静态方法 特色 不 建立 实例 ， 从类 调用 ， 所示 ：   class   Test :   @ staticmethod   def   ( ) :   print ( ' aaa ' )   Test . ( )   静态方法 pyqt 中   QtGui . QFileDialog . getOpenFileName ( ...... )   一个 静态方法 ， 调用 方法 来弹 出 询问 打开 文件 窗口 ， 并不需要 先 实例 化 一个 对象 ， . 类似 形式 调用 。   类 方法 装饰器   一个 装饰器 会 用到 ，   @ classmethod   ， 类 方法 装饰器 。 静态方法 不 新建 实例 ， 类来 调用 。 静态方法 区别 静态方法 调用 默认 第一 参数 ， 而类 方法 调用 默认 第一 参数 调用 类 。   class   Test :   @ classmethod   def   ( cls ) :   print ( '   class : ' ,   cls ,   '   ' )   Test . ( )     class :   < class   ' __ main __. Test ' >       classmethod 装饰器 实际上 东西 ， 传 进去 第一个 参数 cls 看 ，   cls ( ... )   类来 生成 一个 实例 。   属性 装饰器   编程语言 开发者 会 类里 定义 针对 属性 set 方法 ， Pythonic 风格 ， 特定 名字 属性 ， 利用 属性 装饰器 构建 ， 所示 ：   class   Apple ( ) :   def   __ init __ ( ) :   ._ color   =   ' red '   @ property   def   color ( ) :   return   ._ color   apple   =   Apple ( )   类 定义 属性 ， 调用 属性 点 号 引用 即可 ， 执行   @ property   装饰 函数 。   color 属性 只 可读 ， 更改 。   > > >   apple . color   ' red '   > > >   apple . color   =   ' yellow '   Traceback   (   recent   call   ) :   File   \" < stdin > \" ,   line   1 ,     < module >   AttributeError :   ' t   set   attribute   请 参看   网页   ， 讲到   @ color . setter   装饰器 ， 装饰 函数 ， 函数 修改 color 属性 。   @ color . deleter   装饰 函数 ， 函数 删除 属性 。 deleter 少 ，   @ property   大部分 需求 ， 修改 属性 定义 setter 。   一个 简单 setter 例子 所示 ：   class   Apple ( ) :   def   __ init __ ( ) :   ._ color   =   ' red '   @ property   def   color ( ) :   return   ._ color   @ color . setter   def   color ( ,   color ) :   ._ color   =   color   apple   =   Apple ( )   print ( apple . color )   apple . color   =   ' yellow '   print ( apple . color )   类 装饰器   类 装饰器 利用 类   __ call __   内置 方法 ， 这段 代码 粘贴 ， 看 别人 源码 有用 ， 装饰器 这部分 到此为止 ， 没 弄 。   class   MyDecorator ( object ) :   \" \" \" Decorator     mixing   class     function   definitions . \" \" \"   def   __ init __ ( ,   func ,   param1 ,   param2 ) :   . func   =   func   . param1 ,   . param2   =   param1 ,   param2   def   __ call __ ( ,   * args ,   * * kwargs ) :   ...   #   . param1   result   =   . func ( * args ,   * * kwargs )   #   . param2   return   result   def   _ dec _ factory ( param1 ,   param2 ) :   def   decorator ( func ) :   return   MyDecorator ( func ,   param1 ,   param2 )   return   decorator   讲到 class 声明 语句 def 语句 很 类似 ， def 语句 利用 缩进 区块 内 代码 （ 简单 理解 执行 编译 一遍 ， ） 构建 出 一个 函数 对象 ， 函数 对象 名字 绑定 。 class 语句 利用 缩进 区块 内 代码 构建 出 一个 类 对象 ， 类 对象 名字 绑定 。   类 装饰器 ， 类 挂个 装饰器 ， 所示 ：   def   decorator ( C ) :   return   ProcessedC   @ decorator   class   C :   ....   C ：   C   =   decorator ( C )   函数 装饰器 相当于 函数 对象 创建 过程 深度 定制 DIY ， 而类 装饰器 相当于 类 对象 创建 过程 深度 DIY 。   多重 继承 顺序   来看 例子 ：   class   B1 ( ) : x = ' B1 '   class   B2 ( ) : x = ' B2 '   class   B3 ( ) : x = ' B3 '   class   B ( B1 , B2 , B3 ) : x = ' B '   class   A1 ( ) : x = ' A1 '   class   A2 ( ) : x = ' A2 '   class   A ( A1 , A2 ) : x = ' A '   class   D ( B , A ) : x = ' D '   test = D ( )   print ( test . x )   测试 例子 ， D x 先 查找 ， 返回   ' D '   ， 类 D x 定义 语句 换成 pass ，   ' B '   。 程序 逻辑 test 实例 找 不到 x ， 再 找 D ， D 找 不到 再 接下来 找 D 继承 父类 ， B ， 目前为止 ， 没什么 新鲜事 发生 。   再 B x 赋值 语句 换成 pass ，   ' B1 '   ， 没什么 好 惊讶 。 类似 操作 ， 会 发现 python 值 查找 顺序 ： D ， B ， B1 ， B2 ， B3 ， A ， A1 ， A2 。   道 ： 恩 ， 类 多重 继承 深度 优先 法则 ， 先 把子 类 子类 子类 都 查找 完 ， 确认 值 再 从左到右 查找 。   情况 来说 理解 ， 编程 界 多重 继承 中有 有名 - - - - - - 菱形 难题 。   菱形 难题   参考资料 ：   维基百科 菱形 难题   菱形 难题 上 类 继承 中 ， C A 都 同名 属性 x ， D 会 调用 ？ 读者 测试 例子 ：   class   E ( ) : x = ' E '   class   F ( ) : x = ' F '   class   G ( ) : x = ' G '   class   A ( F , G ) : x = ' A '   class   B ( E , F ) : x = ' B '   class   D ( B , A ) : pass   test = D ( )   print ( test . x )   运行 DBE 都 出奇 ，   接下来 DBEF [ &# 94 ; 15 ] ， DBEA ， 程序   ' A '   。 情况 确实 纠结 ， F 菱形 难题 交叉点 ， 似 层次分明 ， 简单 理解 深度 优先 即可 ， python3 选择   ' A '   ， 不 选择 。   再 来看 例子 ：   class   E ( ) : x = ' E '   class   F ( ) : x = ' F '   class   G ( ) : x = ' G '   class   A ( F , G ) : x = ' A '   class   B ( F , E ) : pass   class   D ( B , A ) : pass   test = D ( )   print ( test . x )     ' A '   ， E 都 跳过去 ， 横向 优先 原则 。   程序 菱形 难题 ， 情况 变得 琢磨 。 三个 情况   D ( B ( B1   B2   B3 )   A ( A1   A2 ) )   →   D   B   B1   B2   B3   A   A1   A2   D ( B ( E   F )   A ( F   G ) )   →   D   B   E   A   F   G   D ( B ( F   E )   A ( F   G ) )   →   D   B   A   F   E   G   ， 很 冷门 领域 。 。 简单 理解 深度 搜索 ， 类似 flatten 函数 ， 子元 下 一个 平行 级别 子元 中 含有 ， 本子 元会 略过 ， 做个 记号 ， 分叉 跳过去 跑 A ， 执行 完 子元 ， 会 调 操作 点上 。 python 怎么弄 古怪 逻辑 。 。   super 面对 菱形 难题   第一种 情况 单 继承 类 系统 ， super ( ) 形式 父类 。 super ( ) . 引用 父类 变量 方法 。   第二种 情况 多重 继承 ， 搜索 顺序 多重 继承 搜索 顺序 ， 从左到右 。 请 调试 例子 ， 调用 c . d 会 返回 错误 ， 调用 类 A 构造函数 。   class   A ( ) :   def   __ init __ ( , a ) :   . a = a   def   fun ( ) :   print ( ' fun ' )   def   fun2 ( , ) :   print ( ' fun ' , )   class   B ( ) :   def   __ init __ ( ) :   . d = 5   b = 2   def   fun3 ( ) :   print ( ' fun3 ' )   class   C ( A , B ) :   def   __ init __ ( ) :   super ( ) .__ init __ ( 3 )   super ( ) . fun ( )   super ( ) . fun2 ( ' ' )   super ( ) . fun3 ( )   print ( super ( ) . b )   c = C ( )   print ( c . a , c . b )   fun   fun     fun3   2   3   2   A 类 定义 fun 函数 写 函数 上 有个 参数 ，   super ( )   调用 形式 意义 上 父类 ， 默认 第一个 参数 。 super ( ) 类 编写 中 引用 本类 父类 属性 方法 很 便捷 ，   。 例子 中 fun3 调用 是因为 多重 继承 机制 ， 它会 逐个 找 父类 。 c . d 会 出错 ， 初始化 A 类 构造函数 。   描述 器   小节 参考   网页   。   谈及 属性 装饰器 ， 实际上 调用 property 函数 ，   property ( fget ,   fset ,   fdel ,   descrition )   函数 返回 一个 描述 器 对象 （ Desriptor ） 。 一个 描述 器 对象 ， 简单 来说 对象 定义 三个 方法 （ 最   __ __   方法 定义 ） 。   思路 再理 ， instance . a 表达 ， python 视图   __ dict __   去 找 属性 ， 找   instance [ ' a ' ]   表达 值 （ 类 属性 继承 先 不 涉及 ） ，   __ dict __   属性 ， python 会 去 找   __ getattr __ ( , )   方法 ， 找 不到 会 报错 。   找 属性 过程 中 ， 查找 描述 器 很 前 。 找到 属性 一个 描述 器 ， python 会 描述 器 对象 提取 属性 ， 修改 属性 。   理解 property 函数 返回 一个 描述 器 ， 看 python 代码 等价 最 直观 ：   class   Property ( object ) :   \" Emulate   PyProperty _ Type ( )     Objects / descrobject . c \"   def   __ init __ ( ,   fget = None ,   fset = None ,   fdel = None ,   doc = None ) :   . fget   =   fget   . fset   =   fset   . fdel   =   fdel   .__ doc __   =   doc   def   __ __ ( ,   obj ,   objtype = None ) :     obj     None :   return       . fget     None :   raise   AttributeError ,   \" unreadable   attribute \"   return   . fget ( obj )   def   __ set __ ( ,   obj ,   ) :     . fset     None :   raise   AttributeError ,   \" ' t   set   attribute \"   . fset ( obj ,   )   def   __ delete __ ( ,   obj ) :     . fdel     None :   raise   AttributeError ,   \" ' t   delete   attribute \"   . fdel ( obj )   def   getter ( ,   fget ) :   return   type ( ) ( fget ,   . fset ,   . fdel ,   .__ doc __ )   def   setter ( ,   fset ) :   return   type ( ) ( . fget ,   fset ,   . fdel ,   .__ doc __ )   def   deleter ( ,   fdel ) :   return   type ( ) ( . fget ,   . fset ,   fdel ,   .__ doc __ )   缓存 属性   例子 灵感 来自 python 官方 装饰器   @ property   源码 ， 稍作 修改 对象 属性 记忆 特性 。   import   time   import   logging   class   memorized _ property   (   property   ) :   def   __ init __   (     ,   *   args   ,   * *   kwargs   ) :   super   (   memorized _ property   ,     )   .   __ init __   (   *   args   ,   * *   kwargs   )     .     =   ' _   { }   '   .   format   (     .   fget   .   __ __   )   def   __ __   (     ,   obj   ,   objtype   =   None   ) :     obj     None   :   return         .   fget     None   :   raise   AttributeError   (   \" unreadable   attribute \"   )       .       obj   .   __ dict __   :   logging   .   debug   (   '   memory - - - - - - - - - - - - - - - - - - - - '   )   return   obj   .   __ dict __   [     .     ]     :   logging   .   debug   (   '   computing ########## '   )     =   obj   .   __ dict __   [     .     ]   =     .   fget   (   obj   )   return     def   __ set __   (     ,   obj   ,     ) :       .   fset     None   :   raise   AttributeError   (   \" ' t   set   attribute \"   )   obj   .   __ dict __   [     .     ]   =     def   __ delete __   (     ,   obj   ) :       .   fdel     None   :   raise   AttributeError   (   \" ' t   delete   attribute \"   )   del   obj   .   __ dict __   [     .     ]   class   Test   (   object   ) :   def   __ init __   (     ) :   pass   @ memorized _ property   def   x   (     ) :   return   time   .   time   ( )   @ x   .   setter   def   x   (     ,     ) :   pass   @ x   .   deleter   def   x   (     ) :   pass     __ __   = =   ' __ main __ '   :   logging   .   basicConfig   (   level   =   logging   .   DEBUG   )   t   =   Test   ( )   print   (   t   .   x   )   print   (   t   .   x   )   metaclass   类 都 由元类 （ type 类 ） 创建 ， 语句 ：   class   =   type ( classname ,   superclasses ,   attributedict )   type 调用   __ call __   方法 ， 方法 运行 type 两个 方法 ：   __ __   ，   __ call __   。   创造 一个 类 ， 提到 ：   类 还要 调用   __ __   ，   __ call __   ， 创造 出 一个 实例 。   提到 type type type ， type 大体 看作 python 中 类型 最底层 原子结构 。 元类 创造 类 ， 类 创造 实例 。   定义 一个 元类   class   Meta ( type ) :   def   __ __ ( meta ,   classname ,   supers ,   classdict ) :   #       return   type .__ __ ( meta ,   classname ,   supers ,   classdict )   一个 元类   class   Test ( Super ,   metaclass = Meta ) :   pass   元类 理解 不难 ， 关键 把握 合适 合适 。   进程 线程   进程 定义 :   一个 执行 程序 实例 。 进程 都 一个 唯一 进程 ID ，   PID   。   ps   命令 第一个 列 进程 PID 属性 。 python 中   os . getpid ( )   查看 进程 PID 。   一个 CPU 机器 上 ， 多任务 操作系统 实际上 只能 运行 一个 进程 ， 操作系统 切换 进程 一种 多任务 运行 多个 程序 感觉 。 CPU 机器 上 真的 运行 多个 进程 。   进程 fork   进程 fork 简单 来说 类似 git 项目 fork ， 代码 信息 配置 相关 信息 复制 注册 。 相当于 代码 环境 下 ， 两个 单独 运行 程序 实例 。   一个 非常简单 小 例子 ， os . fork ( ) 语句 移到 print ( '   fork ' ) 变化 。   import   os ,   time   print ( '   fork   ' )   os . fork ( )   print ( '     ' ,   os . getpid ( ) )   time . sleep ( 1 )   print ( '   fork ' )   程序 简单 理解 ， py 文件 编译成 字节 码 内存 一个 程序 实例 （ 还 包含 信息 ） ， 程序 运行 会 os . fork 调用 系统 fork 函数 ， 复制本 程序 实例 （ 以本 程序 实例 所处 状态 ） ， print ( '   fork ' ) 执行 ， 子 进程 执行 一行 代码 ， os . fork ( ) 代码 继续执行 。 相当于 两个 程序 运行 ， 打印 顺序 说 不准 。   操作系统 fork 暂时 不 ， 两个 程序 实例 变量 运行 环境 基本上 一模一样 ， 运行 状态 有所不同 之外 。 fork 做出 一种 程序 多任务处理 方案 ， os 模块 fork 方法 只 支持 unix 环境 。   子 进程 父 进程 分开   请 看 代码 :   import   os ,   time   print ( '   fork   ' )   pid   =   os . fork ( )     pid :   print ( pid )   print ( '       parent ' ,   os . getpid ( ) )   :   print ( pid )   print ( '       child ' ,   os . getpid ( ) )   time . sleep ( 1 )   print ( '   fork ' )   运行 大致 :     fork   13762         parent   13761   0         child   13762     fork     fork   父 进程 ， pid 本父 进程 子 进程 PID ， 子 进程 ， os . fork ( ) 返回 0 。 利用 将父 进程 操作 和子 进程 操作 分开 。 代码   pid   一块 父 进程 ， 一块 是子 进程 。   线程 入门   线程 内部 实施 细节 进程 ， 通俗 说法 线程 轻量级 进程 ， 不 讨论 线程 细节 。   python 操作 线程 模块   threading   模块 ， 简单 新建 一个 线程 对象 ( Thread ) ， 调用   start   方法 启动 ， 线程 做些 由本 线程 对象   run   ， 重 定义 ， 默认 调用 线程 Thread 类 新建 输入   target   参数 ， target 参数 指向 函数 。 一个 简单 例子 :   import   random ,   threading   result   =   [ ]   def   randchar _ number ( i ) :   number _ list   =   list ( range ( 48 , 58 ) )   coden   =   random . choice ( number _ list )   result . append ( chr ( coden ) )   print ( ' thread : ' ,   i )     i     range ( 8 ) :   t   =   threading . Thread ( target   =   randchar _ number ,   args = ( i , ) )   t . start ( )   print ( ' ' . join ( result ) )   thread :   0   thread :   1   thread :   2   thread :   3   thread :   4   thread :   5   thread :   6   thread :   7   22972371   :   控制参数 逗号 加上 。   不 太 喜欢 风格 ， 线程 对接 函数 实际上 return   值 ， 保存 值 依赖于 定义 ， 称之为 意义 上 函数 （ 一个 定义 很 好 函数 复用 特性 很强 ） 。 线程 类 风格 编写 。 代码 参考   网页   。   import   random ,   threading   threads   =   [ ]   class   MyThread ( threading . Thread ) :   def   __ init __ ( ) :   threading . Thread .__ init __ ( )   . result   =   ' '   def   run ( ) :   number _ list   =   list ( range ( 48 , 58 ) )   coden   =   random . choice ( number _ list )   . result   =   chr ( coden )   def   getvalue ( ) :   return   . result     i     range ( 8 ) :   t   =   MyThread ( )   t . start ( )   t . join ( )   threads . append ( t )   result   =   ' '     t     threads :   result   + =   t . getvalue ( )   print ( result )   05649040   > > >   调用 线程 对象   join   方法 确保 线程 执行 完 ， 返回 异常 。 做法 不太 标准 ， 更 标准 做法 单独 写 一行 t . join 代码 :     t     threads :   t . join ( )   确保 线程 都 执行 完 ， 形式 多任务 并行处理 效果 。   例子 线程 执行 顺序 特殊要求 ， 推荐 python queue 模块 ， 略过 。   后台 线程   函数 一个 后台 警报 线程 ， 阻塞 主程序 。   def   beep ( a , b ) :   ' ' ' make   a   sound   ,   ref :   http : / / stackoverflow . / questions / 16573051 /   python - sound - alarm - - code - finishes       install   ` ` apt -   install   sox ` `   : param   a :   frenquency   : param   b :   duration   create   a   background   thread ,     function       block   ' ' '   def   _ beep ( a , b ) :   import   os   os . system ( ' play   - - - show - progress   - - null   - - channels   1   \\   synth   % s   sine   % f '   %   ( b , a ) )     threading   import   Thread   thread   =   Thread ( target = _ beep , args = ( a , b ) )   thread . daemon   =   True   thread . start ( )   上 所示 ， 原 beep 函数调用 系统 play 命令 制造 一个 声音 ， b 声音 持续 时间 ， 其是 阻塞 。 一个 线程 调用 ， 阻塞 主程序 。   daemon   线程 一个 后台 线程 ， 请 参看   网页   ， 说道 后台 线程 不用 ， 会 主程序 自动 关闭 。   多线程 :   一个 定时器   例子 参考   网页   。   import   time   import   threading   class   Timer   (   threading   .   Thread   ) :   def   __ init __   (     ,   interval   ,   action   =   lambda   :   print   (   '   \\ a   '   ) ) :   threading   .   Thread   .   __ init __   (     )     .   interval   =   interval     .   action   =   action   def   run   (     ) :   time   .   sleep   (     .   interval   )     .   action   ( )   def   set _ interval   (     ,   interval   ) :     .   interval   =   interval   # timer   =   Timer ( 5 )   # timer . start ( )   class   CountDownTimer   (   Timer   ) :   def   run   (     ) :   counter   =     .   interval     sec     range   (     .   interval   ) :   print   (   counter   )   time   .   sleep   (   1.0   )   counter   - =   1   ##     .   action   ( )   # timer   =   CountDownTimer ( 5 )   # timer . start ( )   def     ( ) :   print   (   '   \\ a   '   )   timer   =   CountDownTimer   (   5   ,   action   =     )   timer   .   start   ( )   很 简单 ， 线程 timer . sleep 函数 不 冻结 主程序 。   多线程 下载 大 文件   小节 参考   网页     网页   。     _ content _ tofile   函数 目标 内容 大小 大于 1M 启动 多线程 下载 方法 。   guess _ url _ filename   函数 url 猜测 目标 下载 文件 名字 ， 还 一个 尝试 版本 。   requests . 函数 加上   stream = True   参数 ， 连接 目标 url 头文件 信息 进一步 下载 content 内容 。 早期 headers 信息 做出 判断 。   接下来 HTTP 头文件   content - length   判断 下载 内容 大小 ， 属性 ， 目标 url content 内容 ， 函数 情况 做出 ， 单 网页 url ， requests 方法 获取 网页 文本 内容 即可 。   目标 长度 小于 1M ， 打开 文件 ， requests 模块 里 response 对象   iter _ content   方法 迭代 完 content 内容 。   目标 长度 大于 1M ， 采用 一种 多线程 下载 方法 。   _ content _ partly   函数 ， 接受 url index ， index 一个 简单 索引 ， bytes 还 计算 。 多线程 操作 bytes 计算 细节 略过 讨论 。 唯一 值得一提 HTTP 协议 Range 属性 ， begin - end ， 0 - 1024 ， 还 包括 1024 位 ， 实际上 1025 bytes ， python 中 体验 ， end begin + 1024 - 1 。 1024 bytes 位 ， 定位 ( 0 ,   1024 ) ， python 中 ， 不 包括 1024 位 。   一个 小 信息 ， HTTP 协议 返回 头文件 中   content - range   属性 ， 请求 Range 越界 ， 属性 。 begin 越界 ， end 越界 请求 ？ HTTP 协议 很 好 ， 跨界 情况 都 只 返回 那点 content 内容 。   写 文件 降低 内存 消耗 ， 语句 强制 文件 流 写入 文件 中 ， 好 释放 内存 ， 下载 程序 内存 使用率 剧增 。   f   .   flush   ( )   os   .   fsync   (   f   .   fileno   ( ) )   import     def   guess _ url _ filename   (   url   ) :   ' ' ' url 猜测 目标 文件名 ， ' ' '   response   =   requests   .     (   url   ,   stream   =   True   )   ## 一个 content - type 信息 利用   s   =   urlsplit   (   url   )   guess _ element   =   s   .   path   .   split   (   ' / '   ) [   -   1   ]   guess _ pattern   =     .   compile   (   r   ' ' '   ( . png | . flv )   $   #   end     string   ' ' '   ,     .   VERBOSE   |     .   IGNORECASE   )       .   search   (   guess _ pattern   ,   guess _ element   ) :   filename   =   guess _ element     :   filename   =   guess _ element   +   ' . html '   return   filename   import   threading   import   os   class   DownloadThread   (   threading   .   Thread   ) :   def   __ init __   (     ,   url   ,   begin   ,   chunk _ size   =   1024   *   300   ) :   threading   .   Thread   .   __ init __   (     )     .   url   =   url     .   begin   =   begin     .   chunk _ size   =   chunk _ size     .   result   =   b   ' '   def   run   (     ) :   headers   =   {   ' Range '   :   ' bytes =   { begin }   -   { end }   '   .   format   (   begin   =   str   (     .   begin   ) ,   end   =   str   (     .   begin   +     .   chunk _ size   -   1   ) ) }   response   =   requests   .     (   url   ,   stream   =   True   ,   headers   =   headers   )     response   .   headers   .     (   ' content - range '   )     None   :     .   result   =   0   ## 越界     :     .   result   =   response   .   content   print   (   ' start   download ... '   ,     .   begin   /   1024   ,   ' KB '   )   def   getvalue   (     ) :   return     .   result   def   _ content _ partly   (   url   ,   index   ) :   threads   =   [ ]   content   =   b   ' '   chunk _ size   =   1024   *   300   #   设置 太大 设置 太小   block _ size   =   10   *   chunk _ size   #   线程 数     i     range   (   10   ) :   t   =   DownloadThread   (   url   ,   index   *   block _ size   +   i   *   chunk _ size   )   t   .   start   ( )   threads   .   append   (   t   )     i   ,   t     enumerate   (   threads   ) :   t   .   join   ( )     t     threads   :     t   .   getvalue   ( ) :   content   + =   t   .   getvalue   ( )   return   content   import   os   def   _ content _ tofile   (   url   ,   filename   =   ' '   ) :   ' ' ' 简单 url 获取 content ， 存入 内容 存入 文件 中 。   内容 size   小于 1M   1000000   byte   ， 采用 多线程 下载 法 ' ' '       filename   :   filename   =   guess _ url _ filename   (   url   )   #   NOTE     stream = True   parameter   response   =   requests   .     (   url   ,   stream   =   True   )       response   .   headers   .     (   ' content - length '   ) :   print   (   '   url         a   content   . '   )   return   0   elif   response   .   headers   .     (   ' content - length '   )   <   ' 1000000 '   :     open   (   filename   ,   ' wb '   )     f   :     chunk     response   .   iter _ content   (   chunk _ size   =   1024   ) :     chunk   :   #   filter     - alive     chunks   f   .   write   (   chunk   )   f   .   flush   ( )   os   .   fsync   (   f   .   fileno   ( ) )     :     open   (   filename   ,   ' wb '   )     f   :     i     range   (   1000000   ) :   ##   huge   content   =   _ content _ partly   (   url   ,   i   )     content   :   f   .   write   (   content   )   f   .   flush   ( )   os   .   fsync   (   f   .   fileno   ( ) )     :   print   (   ' end ... '   )   break   线程 锁   python 两种 类型 线程 锁   Lock     RLock   ， 都   acquire   获取 锁   release   释放 锁 。 一个 线程 试着 访问 unlocked 锁 ，   acquire   返回 ； 访问 locked 锁 ， 线程 阻塞 ， 一个   release   释放 锁 。   RLock Lock 区别 RLock 线程 acquire ， RLock 称之为 递归 锁 ， （ 递归 ） 函数 线程 中 访问 资源 ， ， RLock 。   RLock 常 语句 ：   lock   =   threading . RLock ( )     lock :     ...",
            "tags":"python_language",
            "url":"articles/python-advanced.html"
        },
        {
            "title":"python语言学习教程三模块篇",
            "text":"引入 模块   import 语句   import 语句 方法 已有 接触 ，   import   math   ， math 模块 函数 类 带点 变量名 结构 ： math . pi 。   import 语句 一个 常见 缩写 名 技巧 ， import   numpy     np ， 写 ，   np . array ， numpy . array 。   语句   语句 两种 情况 ：       import         import   *   第一种 形式 点名 只 导入 变量 ， 第二种 形式 都 导入 进来 。 想 读者 肯定 ， 第二种 导入 形式 小心 变量名 覆盖 ， 心里有数 即可 。   reload 函数   reload 函数 载入 模块 ， reload 函数 优点 不 重新启动 应用程序 ， 动态 重载 模块 。 reload 只能 用于 python 编写 模块 ， python3 中 ， reload 函数 移到 imp 模块 去 ， import   imp 才能 。 比如说 ：     imp   import   reload   reload ( somemodule )   time 模块   time 模块 提供 时间 相关 函数 ， 底层 ， 函数 平台 不 。 类似 模块 datetime 模块 ， datetime 以类 框架 解决 时间 。 简单 调用 时间 ， time 模块 ， 时间 相关 ， 推荐 datetime 模块 。   time 函数   > > >   import   time   > > >   time . time ( )   1404348227.07554   time 函数 返回 一个 数值 ， 数值 1970 年 1 月 1 号 0 时 0 分 0 秒 时间 秒 。   gmtime 函数   函数 接受 一个 参数 ， 参数 秒 ， 返回 一个 特定 格式 时间 数组   struct _ time   。 不 接受 参数 ， 默认 接受 秒数 time 函数 返回 ， 是从 特定 时间 秒 ， 特定 格式 时间 数组 时间 。   > > >   time . gmtime ( )   time . struct _ time ( tm _ year = 2014 ,   tm _ mon = 7 ,   tm _ mday = 3 ,   tm _ hour = 0 ,   tm _ min = 53 ,   tm _ sec = 0 ,   tm _ wday = 3 ,   tm _ yday = 184 ,   tm _ isdst = 0 )   > > >   time . gmtime ( 0 )   time . struct _ time ( tm _ year = 1970 ,   tm _ mon = 1 ,   tm _ mday = 1 ,   tm _ hour = 0 ,   tm _ min = 0 ,   tm _ sec = 0 ,   tm _ wday = 3 ,   tm _ yday = 1 ,   tm _ isdst = 0 )   localtime 函数   类似   localtime   函数 ， gmtime 用法 返回 一模一样 ， 唯一 区别 返回 当地 时间 。   > > >   time . strftime ( ' % Y - % m - % d   % H : % M : % S ' , time . localtime ( ) )   ' 2014 - 07 - 03   09 : 19 : 40 '   > > >   time . strftime ( ' % Y - % m - % d   % H : % M : % S ' , time . gmtime ( ) )   ' 2014 - 07 - 03   01 : 19 : 49 '   ctime 函数   > > >   time . ctime ( )   ' Thu   Jul   3   08 : 54 : 54   2014 '   > > >   time . ctime ( 0 )   ' Thu   Jan   1   07 : 00 : 00   1970 '   gmtime 类似 ， 返回 字符串 格式 时间 。 ctime 默认设置 时间 localtime 函数 。   strftime 函数   接受 特定 格式 时间 数组   struct _ time   参数 ， 返回 字符串 格式 时间 。 例子 请 参看 例子 。   最 常用 格式 符有 ：   % Y ， 年 ； % m ， 月 ； % d ， 日 ；   % H ， 小时 ； % M ， 分 ； % S ， 秒 。   % X   输出 09 : 27 : 19 格式 ， 小时 分 秒 一个 % X 即可 。   ， ： % I 小时 ， [ 0 - 12 ] 形式 ； % y 年 ， [ 00 - 99 ] 格式 ， 2014 年 输出 14 ； % p ， 本地 AM PM 文字 。 。   sleep 函数   sleep 函数 用到 ， 程序 休眠 几秒 。 接受 一个 数值 参数 ， 单位 秒 ， 零点 几秒 。 sleep 函数 大概 休眠 几秒 ， 不去 用来 计时 ， 不大 精确 。   更 内容 请 参见   官方 文档   。   sys 模块   sys 模块 功能 很 常用 ， 。   sys . argv   刚 python 执行 脚本 参数传递 时 讲 sys . argv 变量 。 这是 一个 字符串 列表 。   import   sys   print ( sys . argv )     i     range ( len ( sys . argv ) ) :   print ( sys . argv [ i ] )   新建 一个 test . py 文件 ， 执行 ：   python3   test . py   test1   test2   [ ' test . py ' ,   ' test1 ' ,   ' test2 ' ]   test . py   test1   test2   sys . argv [ 0 ] 脚本 文件名 ， 依次 参数 。   exit 函数   编写 GUI 程序 ， 脚本 程序 中 很 常用 。 不带 参数 退出 程序 ， 还 带 一个 字符串 参数 ， 返回 错误 提示信息 ， 带 一个 数字 ， 详细 讨论 略过 。   > > >   import   sys   > > >   sys . exit ( ' 出错 ' )   出错   wanze @ wanze - ubuntu : ~ $   sys . platform   返回 脚本 执行 操作系统 环境 。   Linux   返回 字符串 值 ： linux ； Windows 返回 win32 ； Mac   OS   X   返回 darwin 。   sys . path   一连串 字符串 列表 ， python 脚本 模块 搜索 路径 ， 自定义 python 模块 ， 只 sys . path 列表 上新加 一个 字符串 路径 即可 。   标准 输入输出 错误 输出 文件   sys . stdin ， sys . stdout ， sys . stderr 三个 文件 对象 linux 系统 标准 输入 标准 输出 错误 输出 文件 流 对象 。   sys . version   sys . version 输出 python 版本信息 编译 环境 详细信息 。   sys . version _ info [ 0 ]   返回 python 主 版本 标识 ， python3 返回 数字 3 。   sys . maxsize   返回 计算环境 下 整数 ( int ) 类型 最大值 ， 32 位 系统   \\ ( 2 * * 31 - 1 \\ )   。   > > >   2 * * 31 - 1   2147483647   > > >   import   sys   > > >   sys . maxsize   2147483647   sys . stdin . isatty ( )   测试 输入 流 终端 。 终端 ， 返回 True 。   更 内容 请 参见   官方 文档   。   subprocess 模块   想 都 计算机 都 多任务 ， 多任务 机制 多个 进程 运行 ， 计算机 一个 CPU （ 多核 越来越 普及 。 ） 计算机 只能 一个 进程 ， 进程 类似 人脑 （ 不 排除 极 个别现象 ） ， 看 电影 写 作业 ， 写 一会 作业 再 看 一会 电影 （ 不 推荐 做 、 ） ， 计算机 进程 机制 类似 ， 一会 干 进程 ， 一会儿 做 进程 。   计算机 一个 进程 还 分为 很多 线程 ， 较为 ， 不谈 。 编写 一个 脚本 程序 ， 系统 会 分配 一个 进程 号 ， cpu 会 转过 头来 执行 （ 计算机 进程 之间 切换 很快 ， 才 会 一种 多任务 错觉 。 ） 脚本 程序 还 再 开出 子 进程 ，   python subprocess 模块 负责 这方面 工作 。   call 函数   import   subprocess   #   Command     shell   expansion   subprocess . call ( [ \" echo \" ,   \"   world \" ] )   subprocess . call ( [ \" echo \" ,   \" $ HOME \" ] )   subprocess . call ( ' echo   $ HOME ' , shell = True )     world   $ HOME   / home / wanze   shell = True 选项 后 用法 简单 直观 ， 网上 提及 安全性 兼容性 ， 推荐 不 shell = True 选项 。   不 shell = True 选项 ，   $ HOME   系统 变量 正确 翻译 ， 实在 home 路径 ， os . path expanduser 函数 。   getoutput 函数   取出 进程 命令 输出 ， 返回 字符串 形式 。   import   subprocess   = subprocess . getoutput ( ' whoami ' )   print ( )   getstatusoutput 函数   进程 执行 状态 。   Popen 类   Popen 类 创建 一个 进程 管理 实例 ， 进程 沟通 ， 暂停 ， 关闭 操作 。 函数 基于 Popen 类 ， 这是 较高级 课题 ， 暂时 略过 。   更 内容 请 参见   官方 文档   。   shutil 模块   相当于 os 模块 补充 ， shutil 模块 进一步 提供 系统 级别 文件 文件夹 复制 ， 删除 ， 操作 。   复制 文件   shutil . copyfile ( src ,   dst )   shutil . copy ( src ,   dst )   shutil . copy2 ( src ,   dst )     copyfile   src dst 两个 参量 都 完整 文件 路径名 ， 第一个 参量 复制 文件 ， 第二个 参量 复制 后 文件名 ；   copy   函数 第一个 参量 复制 文件 ， 第二个 参量 目标 文件夹 路径 ；   copy2   函数 copy 函数 类似 ， 尝试 保留 文件 元 信息 metadata （ 模块 开头 理论 上 不尽然 ） 。   复制 文件夹   shutil . copytree ( src ,   dst )   copytree   函数 第一个 参量 复制 文件夹 路径名 ， 第二个 参量 目标 文件夹 路径名 ， 创建 不 。   删除 目录   shutil . rmtree ( path )   rmtree   函数 用于 删除 文件夹 ， path 目标 文件夹 路径名 。   文件夹   shutil . move ( src , dst )   move   函数 一个 文件 一个 文件夹 一个 文件夹 内 。   chown 函数   shutil . chown ( path ,   user = None ,   group = None )   chown   函数 类似 linux 系统 下 chown 函数 ， 函数 基于 os . chown 函数 ， 接口 更 友好 。   函数   shutil . ( cmd )     函数 类似 linux 系统 下 函数 。   更 shutil 模块 内容 请 参见   官方 文档   。   os 模块   getcwd 函数   终端 运行 python 运行 python 脚本 ， 总有 一个 变量 存储 当前工作 目录 位置 。 getcwd 命令 查看 当前工作 目录 。   import   os   print ( os . getcwd ( ) )   LaTeX 文件 运行 python 小 脚本 ， python 命令 运行 脚本 ， 调用 python 命令 地方 工作 目录 。 加载 模块 py 文件 运行 时 当前工作 目录 主 py 文件 脚本 当前目录 ， 都 运行 python 命令 地方 。   终端 调用 python 终端 当前工作 目录 所在 ， pwd 命令 查看 。 所示 ：   = > pwd   / home / wanze   = > python3   > > >   import   os   > > >   print ( os . getcwd ( ) )   / home / wanze   mkdir 函数   新建 一个 文件夹 。   os . mkdir ( str )   chdir 函数   os 模块 里 一个 chdir 函数 更改 当前工作 目录 所在地 。     .     ..   语法 ， 简单 \\ \" test \\ \" 调转 test 文件夹 。   > > >   os . chdir ( ' / home / wanze / pymf ' )   > > >   print ( os . getcwd ( ) )   / home / wanze / pymf   删除 文件   os . remove ( path )   支持 相对路径 表达 。 路径 目录 将会 抛出 一个 OSError 异常 。   os . rename   os . rename ( src ,   dst )   第一个 参数 目标 文件 目录 ， 第二个 参数 替换 名字 。 命令 重命名 文件 ， 文件 。   支持 相对路径 语法 表达 ， rename windows 下 不 替换 原文件 ， repalce 替换 文件 。   os . repalce   os . replace ( src ,   dst )   rename windows 下 不 替换 原文件 ， repalce 替换 文件 。   支持 相对路径 语法 表达 。   删除 空目录   os . rmdir ( path )   支持 相对路径 语法 表达 ， 只能 删除 空目录 。 删除 目录 ， 请 shutil . rmtree ( path ) 。   listdir 命令   os . listdir ( path = ' . ' )   相当于 简单 ls 命令 ， 返回 一个 字符串 列表 ， 其内 包含 path 下 文件 文件夹 名 （ 包括 链接 文件 ） 。   介绍 os . path 模块 isfile 函数 新建 一个 函数 listdir _ file ， listdir _ dir listdir _ link ， 文件 ， 目录 链接 文件 区分 开来 。   import   os   def   listdir _ dir ( path = ' . ' ) :   ' ' ' os listdir 函数 ， 只 返回 文件夹 。 ' ' '   return   [ dir     dir     os . listdir ( path )     os . path . isdir ( dir )   ]   def   listdir _ file ( path = ' . ' ) :   ' ' ' os listdir 函数 ， 只 返回 文件 ' ' '   return   [ file     file     os . listdir ( path )     os . path . isfile ( file )       os . path . islink ( file ) ]   def   listdir _ link ( path = ' . ' ) :   ' ' ' os listdir 函数 ， 只 返回 链接 文件 ' ' '   return   [ link     link     os . listdir ( path )     os . path . islink ( link )   ]   遍历 目录 树   os . walk ( ' . ' )   一个 生成器 对象 ， 数值 含义 ： （ dirpath ,   dirnames ,   filenames ） ， dirpath filenames 合并 出本 目录 下 文件 文件名 路径 ， dirpath dirnames 合并 出本 目录 下 目录 路径名 。   os . walk 函数 写 一个   gen _ file   函数 ， 其是 一个 生成器 函数 ， 会 遍历 目录 树 ， 返回 目录 下 文件 信息 。 代码 所示 :   def   gen _ file ( startpath = ' . ' , filetype = \" \" ) :   ' ' ' 利用 os . walk   遍历 目录 ， 收集 其内 文件 ， 返回   ( 文件 路径 列表 ,   路径 下 文件 列表 )   :   ( [ ' shortly ' ] ,   [ ' shortly . py ' ] )   ( [ ' shortly ' ,   ' templates ' ] ,   [ ' shortly . py ' ] )   ( [ ' shortly ' ,   ' static ' ] ,   [ ' shortly . py ' ] )   第一个 选 参数   startpath   默认值   ' . '   第二个 参数   filetype   正则表达式 模板   默认值 \" \"   作用 只 选择 文件   空值 ， 文件 都 选中 。   \" html $ | pdf $ \"   只 选中   html pdf 文件 。   ' ' '     root ,   dirs ,   files     os . walk ( startpath ) :   filelist   =   [ ]     f     files :   fileName , fileExt   =   os . path . splitext ( f )     filetype :     . search ( filetype , fileExt ) :   filelist . append ( f )   :   filelist   =   files     filelist : # 空 文件夹 不   dirlist   =   root . split ( os . path . sep )   dirlist   =   dirlist [ 1 : ]     dirlist :   yield   ( dirlist ,   filelist )   :   yield   ( [ ' . ' ] ,   filelist )   函数 管理 目录 下 （ 正则表达式 过滤 ） 感兴趣 文件 ， 都 刷 。 操作 ， 查找 。   environ 函数   os . environ ， 返回 一个 字典 值 ， 字典 值 存储 shell 变量 值 。 系统 中 \" HOME \" 路径名 ：   import   os   print ( os . environ [ ' HOME ' ] )   / home / wanze   > > >   getpid 函数   os . getpid 函数 ， 返回 运行 进程 pid 。   stat 函数   返回 文件 信息 。 st _ size 文件 大小 ， 单位 字节 。   st _ size 属性   import   os   import   glob   print ( [ os . path . abspath ( f )     f     glob . glob ( ' * . py ' ) ] )   print ( [ f     f     glob . glob ( ' * . py ' )     os . stat ( f ) . st _ size   >   400 ] )   [ ' / home / wanze / 桌面 / test . py ' ,   ' / home / wanze / 桌面 / flatten . py ' ]   [ ' flatten . py ' ]   例子 文件大小 输出 单位 优化 :   import   os   import   sys   filename   =   sys . argv [ 1 ]   filesize   =   os . stat ( filename ) . st _ size     unit     [ ' 字节 ' , ' KB ' , ' MB ' , ' GB ' , ' TB ' ] :     filesize   >   1024 :   filesize   =   filesize / 1024   :   break   print ( filename   +   ' 大小 '   + str ( int ( filesize ) )   +   unit )   python 小 脚本 自动 输出 合适 单位 ， 程序逻辑 很 简单 。   st _ mtime 属性   文件 修改 时间 。   st _ ctime 属性   文件创建 时间 ， windows 下 最初 文件创建 时间 ， unix 下 文件 metadata 改变 时间 。   进程 发送 信号   os 模块 kill 函数 进程 发送 信号 。   os . kill ( pid ,   sig )   函数 第一个 参数 进程 pid ， 第二个 参数 发送 信号 。 :   os . kill ( pid ,   signal . SIGSTOP )   暂停 进程 ，   os . kill ( pid ,   signal . SIGCONT )   进程 。     killpg   函数 进程 包括 其子 进程 发送 信号 ， 参考   网页   。     SIGINT   （ 终止 进程 信号 ）   SIGKILL   （ 强制 终止 进程 信号 ）   ， 更 信号 请 参看 unix 信号 块 ，   wiki 页面   。   更 os 模块 内容 请 参见   官方 文档   。   os . path 模块   提到 sys . argv 只能 返回 python 脚本 文件名 ， python 脚本 系统 中 具体位置 。 os . getcwd python 脚本 所在 目录 ， os . path 模块 一个 优点 跨平台 特性 支持 很 好 ， 方式 path 路径 都 会 模块 函数 辅助 。   来看 例子 ：   import   os   print ( os . path . abspath ( __ file __ ) )   print ( os . path . dirname ( os . path . abspath ( __ file __ ) ) )   print ( os . path . basename ( __ file __ ) )   print ( os . path . basename ( os . environ [ ' HOME ' ] ) )   / home / wanze / 桌面 / test . py   / home / wanze / 桌面   test . py   wanze     __ file __   脚本 文件 所在 路径 。   abspath 函数   abspath 函数 接受 一个 path 路径 值 返回 一个 正规 普适 路径 地址 。 效果 类似 执行 :   normpath ( join ( os . getcwd ( ) ,   path ) )   。   再 看 例子 演示 空 字符串 默认 当前工作 目录 ， 接受 绝对路径 。   > > >   import   os   > > >   os . path . abspath ( ' ' )   ' / home / wanze '   > > >   os . path . abspath ( ' test ' )   ' / home / wanze / test '   > > >   os . path . abspath ( ' / test ' )   ' / test '   > > >   os . path . abspath ( ' test / ' )   ' / home / wanze / test '   abspath 接收 空 字符串 ， 定位 脚本 工作 目录 ， 引用 模块   os . path . abspath ( ' ' )   ， 脚本 工作 目录 。 os . path . abspath ( \\ \" . \\ \" ) 返回 脚本 工作 目录 。   dirname 函数   dirname 函数 接受 一个 路径 值 返回 路径 除开 一个 元素 路径 值 。 例子 ， 路径 指向 文件 ， dirname 函数 返回 除开 文件名 路径 ； 接受 路径 指向 目录 ， 返回 除开 一个 文件夹 名 路径 值 。   basename 函数   例子 所示 ， basename 函数 接受 一个 路径 值 返回 路径 一个 元素 ， 路径 指向 文件 ， 返回 文件名 ； 路径 指向 目录 ， 返回 目录 文件夹 名 。 绝对路径 提取 出 文件名 功能 。   > > >   import   os . path   > > >   string   =   ' / home / wanze / test . txt '   > > >   fileName , fileExtension   =   os . path . splitext ( os . path . basename ( string ) )   > > >   fileName   ' test '   split 函数   路径 path 字符串 分割 ， 视作 dirname basename 组合 。   > > >   os . path . split ( ' / usr / local / bin / test . txt ' )   ( ' / usr / local / bin ' ,   ' test . txt ' )   > > >   os . path . dirname ( ' / usr / local / bin / test . txt ' )   ' / usr / local / bin '   > > >   os . path . basename ( ' / usr / local / bin / test . txt ' )   ' test . txt '   splitext 函数   路径 path 后缀 分开 ， 针对 文件名 输入 ， 第一个 文件 名字 ， 输出 数组 第二个 值 文件 后缀 。 函数 提取 文件名 后缀 名字 很 有用 ， 组合 出新 文件名 。   > > >   import   os   > > >   fileName ,   fileExtension   =   os . path . splitext ( ' / path / / somefile . ext ' )   > > >   fileName   ' / path / / somefile '   > > >   fileExtension   ' . ext '   join 函数   用于 连接 多个 路径 值 合并 成 一个 新 路径 值 ， 简单 字符串 拼接 ， 函数 路径 组合 操作系统 普适性 灵活性 。   > > >   os . path . join ( os . path . expanduser ( ' ~ ' ) , ' test ' , ' lib ' )   ' / home / wanze / test / lib '   join 函数 多个 参数 生成 新 path windows 下 输出 。   expanduser 函数   > > >   import   os   > > >   os . path . expanduser ( ' ~ ' )   ' / home / wanze '   > > >   os . path . expanduser ( ' ~ / pymf ' )   ' / home / wanze / pymf '   > > >   os . path . join ( os . path . expanduser ( ' ~ ' ) , ' pymf ' , ' mymodule ' )   ' / home / wanze / pymf / mymodule '   ~   符号 ， 展开 / home / wanze 基础 绝对路径 ， 兼容 大部分 系统 （ windows 下 。 ）   join 函数 接受 很多 不定量 参数 ， 组合 一个 新 路径 ， 不用 费心   /     \\   ， 不 写 ， join 函数 自然 料理 好 。   exists 函数   os . path . exists ( path ) ： 测试 路径 文件 。 返回 True ， 返回 False 。   isfile isdir islink   os . path . isfile ( path ) ： 接受 一个 字符串 路径 变量 ， 文件 返回 True ， 返回 False （ 文件 不 文件 文件夹 情况 都 会 返回 False ） 。   类似 isdir islink 函数 。   samefile 函数   os . path . samefile ( path1 , path2 ) ： 两个 文件 路径 返回 True \\   ， 返回 False 。   getmtime 函数   os . path . getmtime ( path )   返回 文件 修改 时间 ， 返回值 秒 ， 可用 time 模块 ctime localtime 函数 转换成 time . struct _ time   对象 ， strftime 更好 格式 输出 。   getctime 函数   类似 getmtime ， 返回 文件 创建 时间 。 unix 系统 中是 指 文件 元 信息 更改 时间 。   更 内容 请 参见   官方 文档   。   模块 基础知识 学习 ， 建立 编写 模块 ， 积累 知识 ， 变得 更强 。   实际上 接触 很多 python 标准 模块 作者 写 第三方 模块 ， import 语句 加载 模块 。   语句 import 语句 内部 作用 机制 很 类似 ， 变量名 方式 上 差异 （ 会 变量名 复制 ） 。 重点 import 工作 方式 ：   找到 模块 文件 。   模块 文件 编译成 位码 （ 时 ， 文件 时间 戳 。 ） ， 会 新多 一个   __ pycache __   文件夹 。   执行 编译 位码 ， 创建 py 文件 定义 对象 。   三个 步骤 第一次 import 会 执行 ， 第二次 import 会 跳过去 ， 引用 内存 中 已 加载 对象 。   shelve 模块   shelve 模块 基于 pickle 模块 ， pickle 模块 支持 对象 才 支持 。   提及 pickle 模块 只能 针对 一个 对象 ， 多个 对象 ， shelve 模块 ， shelve 模块 好像 自动 对象 字典 形式 包装 。 shelve 模块 简便 。   存入 多个 对象   import   shelve     Hero   import   Garen     __ __   = =   ' __ main __ ' :   garen1 = Garen ( )   garen2 = Garen ( ' red ' )   garen3 = Garen ( ' yellow ' )   db = shelve . open ( ' test . db ' )     ( key , item )     [ ( ' garen1 ' , garen1 ) , ( ' garen2 ' , garen2 ) , ( ' garen3 ' , garen3 ) ] :   db [ key ] = item   db . close ( )   过程 代码 变得 简洁 ， 一个个 对象 字典 形式 存入 进去 。   读取 对象   读取 对象 代码 很 简洁 ， shelve 模块 open 函数 打开 数据库 文件 ， open 函数 会 自动 返回 一个 字典 对象 ， 字典 对象 数据 存入 键值 对象 。   例子 发现 ， 定义 类 ， 提取 放入 一个 文件 ， shelve 模块 读取 文件 不 再 引入 定义 。 一点 值得 ， shelve 模块 内部 采用 pickle 机制 ， 猜测 pickle 例子 类 定义 写 写入 文件 代码 ， 载入 数据库 ； 类 定义 放入 一个 文件 ， 类以 模块 说 模块 载入 形式 引入 ， 读取 对象 一种 更 优雅 形式 。 所示 ：   import   shelve     __ __   = =   ' __ main __ ' :   db = shelve . open ( ' test . db ' )     key     sorted ( db ) :   print ( db [ key ] )   db . close ( )   简单 程序 原型 程序 数据库 ， shelve 模块 很 好 够用 。   更 内容 请 参见   官方 文档   。   pickle 模块   pickle 模块 对象 永久 存入 文件 中 ， 再 导入 文件 ， 自动 对象 导入 进来 。   对象 存入 文件   import   pickle   class   Test :   def   __ init __ ( ) :   . a = 0   . b = 0   . c = 1   . d = 1   def   __ str __ ( ) :   return   str ( .__ dict __ )     __ __   = =   ' __ main __ ' :   test001 = Test ( )   print ( test001 )   testfile = open ( ' data . pkl ' , ' wb ' )   pickle . dump ( test001 , testfile )   testfile . close ( )   从文件 中 取出 对象   值得一提的是 从文件 中 取出 对象 ， 类 定义 ， 声明 内存 中 ， 会 出错 。   import   pickle   class   Test :   def   __ init __ ( ) :   . a = 0   . b = 0   . c = 1   . d = 1   def   __ str __ ( ) :   return   str ( .__ dict __ )     __ __   = =   ' __ main __ ' :   testfile = open ( ' data . pkl ' , ' rb ' )   test001 = pickle . load ( testfile )   print ( test001 )   testfile . close ( )   pickle 模块 dump 函数 对象 存入 文件 中 ， 文件 load 函数 加载 ， 对象 会 自动 返回 。   更 内容 请 参见   官方 文档   。   pathlib 模块   python3.4 ， python3 内置 pathlib 模块 。 python 版本 ， pip 安装 pathlib ， 差 不了 太多 。 讨论 参考 python3.4 pathlib 模块 官方 文档 ， 为准 。   模块 对系统 路径 灵活 操作 ， python 取代 bash 系统 运维 ， 文件名 ， 路径 操作 ， pathlib 大大简化 一块 工作量 。 来看 一个 例子 ：     pathlib   import   Path   import   os   p1   =   Path ( os . path . expanduser ( ' ~ ' ) )   p2   =   Path ( ' . ' )   print ( [ x     x     p1 . glob ( \" * . pdf \" )     x . _ file ( ) ] )   print ( [ x     x     p2 . iterdir ( )     x . _ dir ( ) ] )   Path 接受 相对路径 语法 ， \\ \" . \\ \" \\ \" .. \\ \" 都 可用 。 Path 对象 方法 glob iterdir 方法 ， glob 类似 linux glob 命令 ； iterdir 遍历 当前目录 。 遍历 返回 一个 迭代 对象 （ 读者 看 ， 一个 生成器 对象 ） ， 展开 一个 Path 对象 。 Path 对象   _ file   方法   _ dir   方法 判断 Path 对象 文件夹 文件 路径 。   Path 对象 很多 便捷 方法 ， 很 好 ， ：   iterdir   ，   exists   ，   _ file   ，   _ dir   ，   parents   ，   cwd   。 更 信息 请 参看 官方 文档 。   marshal 模块 python 变量 二进制 形式 读写 入 文件 中 ， jieba 分词 词典 缓存 做 。   官方 文档 推荐 确实 类似 简单 存储 需求 ， 推荐 pickle shelve 模块 ， 不管怎么 说 ， 模块 简单 下 。   支持 对象 类型 ：   The     types     supported :   booleans ,   integers ,   floating   point   numbers ,   complex   numbers ,   strings ,   bytes ,   bytearrays ,   tuples ,   lists ,   sets ,   frozensets ,   dictionaries   简单 ：     open   (   cache _ file   ,   ' rb '   )     cf   :     .   FREQ   ,     .   total   =   marshal   .   load   (   cf   )     open   (   cache _ file   ,   ' wb '   )     temp _ cache _ file   :   marshal   .   dump   ( (     .   FREQ   ,     .   total   ) ,   temp _ cache _ file   )   load 方法 加载 目标 文件 对象 ， 返回值 送入 对象 。   dump 方法 想要 送进去 对象 ， 送入 文件 中 去 。   logging 模块   软件开发 中 ， 两个 东西 最易 初学者 忽视 ， 实际上 却是 最 有用 工具 :   一个 单元测试 ； 一个 日志 输出 管理 。 python 官方 内置 模块 logging 更好 管理 日志 汇报 系统 。 一个 好 日志 汇报 系统 程序员 调试 debug ， 用户 专业 人员 汇报 发生 错误 信息 ， 还 理解 程序 运行 运行 ， 干些 ， 都 有用 。   logging   简单 函数 调试 print 函数 输出 信息 ， 编程 早期 有用 。 后续 调试 编程 都 推荐 单元测试 方法 。 大型软件 项目 中 ， print 函数 更 少 ， 程序员 希望 用户 信息 才能 print 函数 （ io 重定向 print 函数 不 讨论 之内 ） 。   程序员 想要 大型软件 内部 运作 ， 丑陋 做法 print ， 注释 掉 。 不 ， 程序员 做 工作 都 保存起来 拿到 台 面上 ， 毕竟 都 劳动 。 logging 模块 第一个 用途 :     logging . info ( )   函数 ， 输出 信息 ， 信息 调低 logging 等级 （ 默认   WARNING   ） ， 才 会 显示 。 低于   WARNING   等级 一个 函数   logging . debug ( )   。 info 函数 信息 程序员 用来 确认 程序 预期 运行 ， debug 函数 信息 bug ， 程序员 希望 有助于 debug 输出 信息 。   logging . warn ( )   函数 用来 发出 警告 信息 ， 程序员 修改 程序 信息 ；   logging . warning   函数 用来 发出 警告 信息 ， 情况 程序员 预料之中 ， 用户 不 做 ， 程序 不 修改 ， 信息 记录 。   特别 错误 异常 捕捉 ， python   ...   ...   语句 ， raise 抛出 异常 ， 这自 不必 说 。 情况 ， 程序员 不愿 抛出 异常 ， 希望 压抑 错误 ， logging 模块   error ( )   函数   exception ( )   函数   critical ( )   函数 。   函数 等级 :   最 简单 一个 例子 所示 :   import   logging   logging . basicConfig ( level = logging . DEBUG )   logging . debug ( ' debug ' )   logging . info ( ' info ' )   logging . warning ( ' warning ' )   basicConfig 函数 日志 系统 配置 。 设置 日志 报告 等级   level = logging . DEBUG   ， 将会   DEBUG     DEBUG   等级 日志 信息 ； 设置   logging . INFO   ， 只   INFO     INFO   等级 信息 。   日志 信息 输出 文件   更 专业 做法 日志 输出 文件 中 去 ， 调试 ， 大型软件 项目 来说 ， 日志 信息 很多 ， 保存 文件 ， 编辑器 shell 工具 工具 查看 会 更 便捷 。 日志 信息 都 输出 文件 中 很 简单 ，   basicConfig   设置   filename   参数 即可 :   import   logging   logging . basicConfig ( filename = ' test . log ' ,   level = logging . DEBUG )   logging . debug ( ' debug ' )   logging . info ( ' info ' )   logging . warning ( ' warning ' )   默认   filemode     \\ \" a \\ \"   ， 日志 信息 累积 。 运行 几次 小 py 脚本 ， 效果 。   filemode   设置   \\ \" w \\ \"   ， 只 保存 那次 运行 日志 信息 。   logging 模块 中级 教程   logging 模块 中级 几个 词汇 ： loggers ,   handlers ,   filters ,     formatters 。   loggers   记录器   运行 logging . info ， 调用 默认 记录器 ， 会 针对 python 模块 文件创建 一个 记录器 。   logger   =   logging . getLogger ( __ __ )     __ __   一种 简便 命名 方法 ， 勤快 某种 情况 下 需要的话 手工 记录器 取个 名字 。     getLogger   函数 指定 名字 定义 （ 指 第三方 模块 下定义 ） ，   getLogger   指定 目标 名字 会 记录器 。 DIY 第三方 模块 日志 记录器 有用 。   记录器 挂载 卸载 处理器 对象 过滤器 对象 ：   logger . addHandler ( )   logger . removeHandler ( )   logger . addFilter ( )   logger . removeFilter ( )   记录器   setLevel ( )   方法 设置 最小 记录 级别 ， Handler 级别 协作关系 。   记录器 propagate 参数 值得 详细 说 下 ， 记录器 名字 定义 ，   __ __   python 自带 模块 结构 语法 ， 其有 上层 下层 关系 ， 比如说   main . test   记录器   main   记录器 。 讨论   propagate   参数 ， 默认 True ， 发送给   main . test   记录器 信息 会 传递 上层   main   记录器 。 设置 False 上 传递 。   handlers   处理器   负责 分发 日志 信息 目标 地去 。 介绍 几个 Handler 类 ：   StreamHandler   信息 以流 形式 输出 ， 指 输出 终端   FileHandler   信息 写入 文件 中 去   RotatingFileHandler   信息 写入 文件 ， 文件大小 超过 值 ， 新建 一个 文件 写 。   TimeRotatingFileHandler   信息 写入 文件 ， 每隔 一段时间 ， 比如说 ， 会 自动 再 新建 一个 文件 再 往里面 写 。   处理器 对象   setLevel   方法 ， 提及 ， 记录器   setLevel   协作关系 ， 更 详细 描述 ， 信息 先 记录器 并分 发给 处理器 对象 ， 再 处理器 再 分发 目的地 。   处理器 挂载   格式 器   对象   过滤器   对象 。   handler . setFormatter ( )   handler . addFilter ( )   handler . removeFilter ( )   filters   过滤器   formatters   格式 器   ， 信息 格式 定义 。   format 涉及 参数设置 所示 :   -   % ( levelname ) s   类似 ' DEBUG ' logging   level   -   % ( message ) s   输出 信息   -   % ( asctime ) s   时间 ， 默认 ' 2003 - 07 - 08   16 : 49 : 45 , 896 ' ，   * * datefmt * *   选项 进一步 设置 格式 ， 格式 设置 strftime 命令 类似 。   -   % ( filename ) s   文件名 ， 更 简洁 表达 模块 名 。   -   % ( module ) s   模块 名   -   % ( funcName ) s   函数 名   -   % ( lineno ) d   logging 代码 几行   -   % ( ) s   logger 名字 ， 默认 ' root ' 。   -   % ( process ) d   进程 号   -   % ( processName ) s   进程 名   -   % ( thread ) d   线程 号   -   % ( threadName ) s   线程 名   字典 统一 配置   django setting . py 会 配置 ， 含义 很 ， 定义 处理器 ， 格式 器 ， 记录器 。   LOGGING   =   {   ' version ' :   1 ,   ' disable _ existing _ loggers ' :   False ,   ' formatters ' :   {   ' simple ' :   {   ' format ' :   \" % ( asctime ) s   % ( ) s   [ % ( levelname ) s ]   % ( thread ) d   % ( module ) s   % ( funcName ) s   % ( lineno ) s :   % ( message ) s \"   }   } ,   ' handlers ' :   {   ' log _ file ' :   {   ' class ' :   ' sdsom . common . log . DedupeRotatingAndTimedRotatingFileHandler ' ,   ' filename ' :   config . ( ' web ' ,   ' log _ path ' ) ,   ' ' :   ' midnight ' ,   ' maxBytes ' :   int ( config . ( ' web ' ,   ' log _ max _ bytes ' ) ) ,   ' interval ' :   1 ,   ' backupDay ' :   int ( config . ( ' web ' ,   ' log _ backup _ days ' ) ) ,   ' dedupetime ' :   int ( config . ( ' web ' ,   ' log _ dedupe _ time ' ) ) ,   ' formatter ' :   ' simple '   } ,   } ,   ' loggers ' :   {   ' django . request ' :   {   ' handlers ' :   [ ' log _ file ' ] ,   ' level ' :   config . ( ' web ' ,   ' log _ level ' ) ,   ' propagate ' :   True ,   } ,   }   }   json 模块   json   json 全称 JavaScript   Object   Notation ， JavaScript 对象 表示法 。 json 一种 基于 文本 ， 人类 易读 数据 存储 交互 格式 。 json 文件 保存 后缀   . json   。 json 是从 javascript 语言 衍生 ， 数据 存储 交互 独立 语言 。 json xml 数据 存储 交互 方案 相比 更 易读 读写 速度 更快 。   json 存储 格式 语法   json 存储 格式 语法 很 简单 ， 最 数字 ， 支持 两种 数字 类型 ， 整数型 浮点 型 ， python int float ； 字符串 双引号 ， python 字符串 概念 ； 布尔值 true false ， python True False ， 一个 null python None ； json 数据   [ ]   ， 元素 逗号 分隔 ， 正是 python 列表 概念 ； json object 对象   { }   包围 ， 其内 key : 形式 ， 其正 python 字典 概念 。   python 语言 内置 json 模块 ， 读写 json 文件 只 简单   import   json   即可 。   小试牛刀 ，   [ 1 , 2 , 3 , 4 , 5 ]   这组 数存 (   dump   ) 进 test . json 文件 去 。   import   json   lst   =   [   1   ,   2   ,   3   ,   4   ,   5   ]     open   (   ' test . json '   ,   mode   =   ' w '   ,   encoding   =   ' utf - 8 '   )     f   :   json   .   dump   (   lst   ,   f   )   json 不 支持 元组 ( tuple ) 字节 ( bytes ) 类型 ， bytes 类型 去 惊扰 ， tuple 元组 存储 ， 转换成 列表 即可 。   简单 读取 json   load   函数 ， 所示 ：     open   (   ' test . json '   ,   mode   =   ' r '   ,   encoding   =   ' utf - 8 '   )     f   :   lst2   =   json   .   load   (   f   )   lst2 赋值   [ 1 , 2 , 3 , 4 , 5 ]   ， 运算 。   存储 字典 值   例子 稍作 修改 存储 字典 值 ：   import   json   dict01   =   {   ' a '   :   1   ,   ' b '   :   2   ,   ' c '   : [   1   ,   2   ,   3   ] }     open   (   ' test . json '   ,   mode   =   ' w '   ,   encoding   =   ' utf - 8 '   )     f   :   json   .   dump   (   dict01   ,   f   )     open   (   ' test . json '   ,   mode   =   ' r '   ,   encoding   =   ' utf - 8 '   )     f   :   dict02   =   json   .   load   (   f   )   print   (   dict02   )   存储 文件 美化   dump 函数 那句 读者   indent   选项 ：   json   .   dump   (   dict01   ,   f   ,   indent   =   4   )   test . json 文件 数据 会 缩进 ， 会 更好 看 。     sort _ keys   选项 会 很 有用 ， 默认 False ， 设置 True ， 输出 文件 key 排序   。     ensure _ ascii   选项 默认 True ， 中文 字符 保存 会 变为   \\ uabcd   东西 ， 设置 False ， 显示 中文 字符 。   dumps loads 函数   dumps loads 函数 是非 文件 接口 版 ， 简单 下 即可 。   itertools 模块   repeat 函数   定义 函数 ：   def   repeat ( object ,   times = None ) :   #   repeat ( 10 ,   3 )   - - >   10   10   10     times     None :     True :   yield   object   :     i     range ( times ) :   yield   object   返回 一个 迭代 对象 ， 封装 一个 用处 用于 填充 map 函数 zip 函数 常 数值 。 填写 repeat ( 5 ) 一个 返回 一个 迭代 对象 ， 不停 返回 数字 5 不 长度 。   starmap 函数   starmap 函数 定义 所示 ：   def   starmap ( function ,   iterable ) :   #   starmap ( pow ,   [ ( 2 , 5 ) ,   ( 3 , 2 ) ,   ( 10 , 3 ) ] )   - - >   32   9   1000     args     iterable :   yield   function ( * args )   接受 一个 迭代 对象 ， 逐个 迭代 对象 中 元素 解包 送入 函数 参数 （ 函数 执行 ） 。   inspect 模块   更 信息 请 参看   官方 文档 ] (   。   getfile 函数   传入 python   object ， 返回 定义 object 文件 中 。 获取 文件 系统 绝对路径 地址 :   os . path . abspath ( inspect . getfile ( func ) )   值得一提的是 ， 模块 安装 系统 ， 文件 地址 类似 形式 :   / usr / local / lib / python3.4 / dist - packages / infome - 15.10 . 30 - py3.4 . egg / infome / web / youdao . py   。   getcallargs 函数   所示 :   params   =   inspect . getcallargs ( func , * args , * * kargs )   相当于 模拟 执行 func 函数 ， 返回 执行 func 函数 时其 接受 参数 字典 值 （ 包括 必填 参数 可选 参数 ） 。   functools 模块   partial 类   functools 模块 定义 一个 partial 类 ， 输入 参数 所示 :   functools . partial ( func ,   * args ,   * * keywords )   返回 一个 partial 对象 ， 其有   __ call __   方法 ， 类似 函数 调用 。 其有   func   属性 ， 未来 函数 调用 ；   args   属性 ， 未来 函数 参数 ；   keywords   属性 ， 未来 函数 可选 参数 。   简单 来说 partial 原函数 对象 func 封装 （ 特别 适合 做 装饰器 ） ，   newfun = partial ( func , args , keywords )   ， 调用 newfun 对象 好像 调用 原 func ， 加上 额外 参数 ， args 非可选 参数 类似 列表 append 形式 ， keywords 可选 参数 说 关键字 参数 类似 字典 update 形式 。   一个 简单 演示 例子 :   import   functools   def   fun1 ( a , b = 2 ) :   print ( ' called   fun1   ' , a , b )   def   show _ details ( , f , _ partial = False ) :   print ( )   print ( f )     _ partial :   print ( f . func )   print ( f . args )   print ( f . keywords )   :   print ( f .__ __ )   show _ details ( ' fun1 ' , fun1 )   fun1 ( ' fun1   a ' )   p1   =   functools . partial ( fun1 , ' p1   a ' , b = 99 )   show _ details ( ' p1 ' , p1 , True )   p1 ( )   输出 :   fun1   < function   fun1     0xb705880c >   fun1   called   fun1     fun1   a   2   p1   functools . partial ( < function   fun1     0xb705880c > ,   ' p1   a ' ,   b = 99 )   < function   fun1     0xb705880c >   ( ' p1   a ' , )   { ' b ' :   99 }   called   fun1     p1   a   99   逻辑 执行 fun1 ， fun partial 封装 成 p1 ， 新增 参数 字符串 ' p1   a ' b = 4 ， p1 参数 都 加进去 。 执行 p1 参数 变化 。   datetime 模块   简单 日期 时间 操作 time 模块 函数 即可 ， datetime 模块 用类 方式 ， 适合 日期 时间 。 值得一提的是 mongodb python 接口   pymongo   （ 连接 mongodb python 第三方 模块 ） ， 日期 时间 输入输出 都   datetime   对象 ， 很 。   简要 介绍 ， 更 内容 请 参看   官方 文档   。   timedelta 对象   timedelta 函数 返回 一个 timedelta 对象 ， 一个 时间 间隔 对象 。 函数参数 情况 所示 :   class   datetime . timedelta ( [ days [ ,   seconds [ ,   microseconds [ ,   milliseconds [ ,   minutes [ ,   hours [ ,   weeks ] ] ] ] ] ] ] )   必填 参数 ， 简单 控制 第一个 整数 天 间隔 :   datetime . timedelta ( 10 )   两个 时间 间隔 对象 彼此之间 相加 相减 ， 返回 仍 一个 时间 间隔 对象 。 更 一个 datetime 对象 减去 一个 时间 间隔 对象 ， 返回 减去 datetime 对象 ， 两个 datetime 对象 相减 返回 一个 时间 间隔 对象 。 很 。   datetime 对象   datetime 函数 创建 一个 datetime 对象 :   class   datetime . datetime ( year ,   month ,   day [ ,   hour [ ,   minute [ ,   [ ,   microsecond [ ,   tzinfo ] ] ] ] ] )   year ， month day 必填 参数 。 一个 简单 例子 :   > > >   db _ t   =   {   ...   \" date \" :   datetime . datetime ( 1777 , 07 , 07 )   ...   }   > > >   db _ t   { ' date ' :   datetime . datetime ( 1777 ,   7 ,   7 ,   0 ,   0 ) }   pymongo 存入 mongodb 形式 :   ISODate ( \" 1777 - 07 - 07T00 : 00 : 00.000 Z \" )   utcnow 方法   datetime 对象       utcnow   两个   类 方法   （ classmethod ） 返回 日期 时间 datetime 对象 。 utcnow 不 接受 参数 ， 方法 接受 一个 tz 指定 时区 参数 ，   pytz   模块 （ 一个 时 区 推荐 第三方 模块 ） 指明 时 区 。   查看 pytz 时 区   参看   网页   。   > > >   pytz . _ timezones   [ ' Africa / Abidjan ' ,   ' Africa / Accra ' ,   ' Africa / Addis _ Ababa ' ,   ' Africa / Algiers ' ,   ......   方法 指定 一个 时 区   参看   网页   。   import   pytz   datetime . datetime . ( tz   =   pytz . timezone ( \" Asia / Hong _ Kong \" ) )   方法 utcnow 方法 区别   看 例子 :   > > >   datetime . ( tz   =   pytz . timezone ( \" UTC \" ) ) , datetime . utcnow ( )   ( datetime . datetime ( 2015 ,   7 ,   11 ,   9 ,   25 ,   20 ,   266863 ,   tzinfo = < UTC > ) ,   datetime . datetime ( 2015 ,   7 ,   11 ,   9 ,   25 ,   20 ,   266888 ) )   方法 指定 默认 时区 \\ \" UTC \\ \" ， 返回 datetime 对象 utcnow 返回 datetime 对象 基本上 没什么 区别 ， 微秒 （   \\ ( 10 &# 94 ; { - 6 } \\ )   秒 ） 区别 理解 。 再 看 方法 不 加 参数 会 :   > > >     datetime . datetime ( 2015 ,   7 ,   11 ,   16 ,   34 ,   43 ,   144018 )   > > >   utcnow   datetime . datetime ( 2015 ,   7 ,   11 ,   8 ,   34 ,   56 ,   319108 )   显示 时间 本地 时间 ， 默认 时区 本地 时区 参数 。 谈到 明白 ， 后台 数据库 日期 时间 输入 需求 ， 时间 戳 一致性 ， 推荐 都 utcnow 方法 生成 时间 戳 ， 实际上 都 UTC 格林威治 时 区 为准 。 前端 显示 用户 日期 时间 ， 引用 前端 数据库 日期 时间 ， 才 引入 时区 转换 。 前端 python 生成 实时 时间 ， 方法 再 引入 pytz 时区 控制 。   datetime 对象 属性   > > >     datetime   import   datetime   > > >   d   =   datetime . ( )   > > >   d . year   2015   > > >   d . month   11   > > >   d . day   3   > > >   d . hour   18   > > >   d . minute   42   > > >   d .   57   > > >   d . tzinfo   > > >   d   datetime . datetime ( 2015 ,   11 ,   3 ,   18 ,   42 ,   57 ,   919613 )   含义 所示 :   year   年   month   月   day   日   hour   时   minute   分     秒   microsecond   微秒   strftime 方法   datetime 对象 调用   strftime   方法   __ format __   方法 一个 好看 想要 日期 时间 字符串 格式 :   > > >     datetime   import   datetime   > > >   d   =   datetime . ( )   > > >   d . strftime ( ' % T ' )   ' 18 : 52 : 39 '   > > >   d .__ format __ ( ' % F ' )   ' 2015 - 11 - 03 '   格式 符号 python 官方 文档 述及 ， 更 实际上 linux 系统 下   date   命令 格式 符 ， 读者   date   - -   来看 ， 信息 :   %%   一个 文字   %   % a   locale   星期 名 缩写 ( ：   日 ， 代表 星期日 )   % A   locale   星期 名 全称   ( ： 星期日 )   % b   locale   月 名 缩写   ( ： ， 代表 一月 )   % B   locale   月 名 全称   ( ： 一月 )   % c   locale   日期 时间   ( ： 2005 年 3 月 3 日   星期四   23 : 05 : 25 )   % C   世纪 ；   % Y ， 省略 年份 后 两位 数字 ( ： 20 )   % d   按月计 日期 ( ： 01 )   % D   按月计 日期 ； 等于 % m / % d / % y   % e   按月计 日期 ， 添加 空格 ， 等于 %_ d   % F   完整 日期 格式 ， 等价   % Y - % m - % d   % g   ISO - 8601   格式 年份 两位   ( 参见 % G )   % G   ISO - 8601   格式 年份   ( 参见 % V ) ， 只   % V     % h   等于 % b   % H   小时 ( 00 - 23 )   % I   小时 ( 00 - 12 )   % j   按年计 日期 ( 001 - 366 )   % k   hour ,   space   padded   (   0 .. 23 ) ;       %_ H   % l   hour ,   space   padded   (   1 .. 12 ) ;       %_ I   % m   month   ( 01 .. 12 )   % M   minute   ( 00 .. 59 )   % n   换行   % N   纳秒 ( 000000000 - 999999999 )   % p   locale   下 \" 上午 \" \" 下午 \" ， 未知 时 输出 为空   % P   % p   类似 ， 输出 小写字母   % r   locale   下   12   小时 时钟 时间   ( ： 11 : 11 : 04   下午 )   % R   24   小时 时间 时 分 ， 等价   % H : % M   % s   UTC   时间   1970 - 01 - 01   00 : 00 : 00   秒数   % S   秒 ( 00 - 60 )   % t   输出 制表符   Tab   % T   时间 ， 等于 % H : % M : % S   % u   星期 ， 1   代表 星期一   % U   一年 中 几周 ， 周日 每星期 第一天 ( 00 - 53 )   % V   ISO - 8601   格式 规范 下 一年 中 几周 ， 周一 每星期 第一天 ( 01 - 53 )   % w   星期 中 几日 ( 0 - 6 ) ， 0   代表 周一   % W   一年 中 几周 ， 周一 每星期 第一天 ( 00 - 53 )   % x   locale   下 日期 描述   ( ： 12 / 31 / 99 )   % X   locale   下 时间 描述   ( ： 23 : 13 : 48 )   % y   年份 两位 数位   ( 00 - 99 )   % Y   年份   % z   + hhmm   数字 时 区 ( ， - 0400 )   % : z   + hh : mm   数字 时 区 ( ， - 04 : 00 )   % : : z   + hh : mm : ss   数字 时 区 ( ， - 04 : 00 : 00 )   % : : : z   数字 时 区 带有 精度   ( ， - 04 ， + 05 : 30 )   % Z   字母表 排序 时区 缩写   ( ， EDT )     % F     % T   python 官方 文档 中 无 ， 内部 API   date   命令 。   支持 时间 间隔 运算   提到 一个 datetime 对象 减去 一个 timedelta 对象 返回 一个 datetime 对象 ， 一个 datetime 对象 减去 一个 datetime 对象 返回 一个 时间 间隔 对象 。 一年 时间 表达   datetime . datetime . utcnow ( )   -   datetime . timedelta ( 365 )   。 爱因斯坦 生日 时间 间隔 表达 :   datetime . datetime . utcnow ( )   -   datetime . datetime ( 1879 , 03 , 14 )   利用 时间 间隔 操作 判断 。   > > >   delta   =   datetime . datetime . utcnow ( )   -   datetime . datetime ( 1879 , 03 , 14 )   > > >   delta   datetime . timedelta ( 49792 ,   35970 ,   903285 )   > > >   delta   >   datetime . timedelta ( 120 * 365 )   True   > > >   delta . days   / /   365   136   struct _ time   对象 转化   datetime   对象   参看   网页     time   import   mktime   mktime 函数 接受 time 模块   struct _ time   object ， 来自 time 模块   gmtime   、   localtime   、   strptime   函数 ， mktime 函数 返回 一个 时间 戳 ， datetime 模块   fromtimestamp   函数 接受 时间 戳 。   总 过程 :     time   import   mktime     datetime   import   datetime   dt   =   datetime . fromtimestamp ( mktime ( struct ) )   datetime   对象 转化   time _ struct   对象   参考   网页   > > >   t   =   datetime . datetime . ( )   > > >   t   datetime . datetime ( 2011 ,   11 ,   5 ,   11 ,   26 ,   15 ,   37496 )   > > >   time . mktime ( t . timetuple ( ) )   +   t . microsecond   /   1E6   1320517575.037496   模块   模块 提供 python 正则表达式 支持 ， 字符串 操作 ， 介绍 字符串 类型 方法 （ split ， replace ） ， 解决问题 ， 更快 更 简单 。 实在 动用 正则表达式 理念 才 模块 ， 克制 写 很多 很 （ 情况 ） 正则表达式 冲动 ， 正则表达式 引入 将会 程序 都 难懂 不可捉摸 。   更 内容 请 参见   官方 文档   。   模块 中 元 字符集   .   一行 内 任意 字符 ， . compile 指定   . DOTALL   ， 多行 内 任意 字符 ， 包括 换行符 。 还 字符串 模板 加上   ( s )   效果 。   *   字符 匹配 。   +   字符 匹配 。     字符 匹配 。   { m }   字符 匹配 ( ) m 次 。   { m , n }   字符 匹配 m 次到 n 次 ， n 次 省略 ， 视作 默认值 无穷大 。   \\ &# 94 ;   字符串 ， 加上   . MULTILINE   选项 ， 行首 。 字符串 模板 加上   ( m )   效果 。   \\ $   字符串 结束 ， \\ &# 94 ; 类似 ， 加上   . MULTILINE   选项 ， 行尾 ， 简单 理解   \\ n   换行符 。 字符串 模板 加上   ( m )   效果 。   \\   \\ ( 符号 . 函数 中 替换 一个 字符串 ， 效果 原 字符串 尾 加上 字符串 ， 类似 \\ &# 94 ; 替换成 字符串 ， 效果 原 字符串 头 加上 字符串 。 \\ &# 94 ; \\ \\ )   字符串 中 都 真实 字符 ， 标记 ， 替换 总给 人 怪怪的 感觉 。   [ ]   [ abc ] 字符 组 匹配 一个 字符 ， 字符 a b c 。 类似 [ a - z ] 匹配 小写字母 ，   [ \\ w ]   匹配 任意 字母 数字 ， 请 看 特殊字符 类 。   |   相当于 正则表达式 内 匹配 逻辑 。   ( )   圆括号 包围 将会 记忆 ， 调用 。 谈及 。   模块 中 特殊字符 类   \\ w   任意 字母 数字   [ a - zA - Z0 - 9 _ ]   ( meaning   word )   \\ W   匹配 非 字母 非 数字   [ &# 94 ; a - zA - Z0 - 9 _ ]   \\ d   [ 0 - 9 ]   ( digit )   数字   \\ D   [ &# 94 ; 0 - 9 ]   非 数字   \\ s   匹配 空白 字符   [   \\ t \\ n \\ r \\ f \\ v ]   。   \\ S   匹配 非 空白 字符   匹配 中文 : [ \\ u4e00 - \\ u9fa5 ]   \\ b   文档 说 定义 \\ w   \\ W   之间 边界 ， 反之亦然 。 粗略 理解 看作 英文单词 头 尾 。   \\ &# 94 ; 方括号 [ ] ， 最 ， 才 排除 型 字符 组 。   转义   正则表达式 转义 会 纠结 。 一个 简单 原则 谈及 特殊作用 字符 转义 ， python 中 字符 都 写成   r ' '   形式 ， raw   string 形式 ，   \\ n   写成   \\ n   ，   \\ section   简单 写为   \\ \\ section   即可 ，   \\   字符 转义 。   字符 组 方括号 内 [ ] 字符 不 转义 ， 实在 不 转义 ， 不 正则表达式 工具 测试 。   模块   compile 方法 生成 regular   expression   object 一条线 略过 ， 接下来 讨论 基于 （ 原始 ） 字符串 模板 。   字符串 模板 提及 ( m ) ( s ) 用法 ，   ( i )   忽略 大小写 。   匹配 查找   search ， match 方法 简单 用法 ：   . search ( 字符串 模板 ,   匹配 字符串 )   . match ( pattern ,   string )   将会 返回 一个 match   object ， match   object 逻辑 上 真值 。 match 字符串 匹配 精确 匹配 ， 正则表达式 0 突兀 。 推荐 search 方法 ， 限定 行首 ， 字符串 讨论 正则表达式 符号 表达 。 请 看 例子 。   import     string   =   ' ' '     test   line .           line .   today     sunday . ' ' '   match   =   . search ( ' ( m ) &# 94 ; today ' , string )     match :   print ( ' 正则表达式 ： ' , match . )   print ( ' 输入 字符串 ： ' , match . string )   print ( ' 匹配 ： ' , match . group ( 0 ) )   print ( ' 匹配 字符串 index ' , match . span ( ) )   :   print ( ' return       ' )   说道 圆括号 将会 记忆 ， 匹配 ， 默认 正则表达式 匹配 group 中 0 元素 ， 从左到右 ， 子 group 编号 依次 1 ， 2 ， 3 ...... 。   正则表达式 ：   . compile ( ' ( m ) &# 94 ; today ' ,   . MULTILINE )   输入 字符串 ：       test   line .           line .   today     sunday .   匹配 ：   today   匹配 字符串 index   ( 44 ,   49 )   信息 情况 ， 最 简单 情况 判断 真值 ， 字符串 模板 匹配 即可 。   分割 操作   模块 split 函数 看作 字符串 split 方法 升级 版本 ， 描述 正则表达式 ， 匹配 成功 都 一个 分隔符 ， 原 输入 字符串 分割 开来 。   写 zwc 小 脚本 最 核心 ， 用途 统计 中英文 文档 英文单词 中文 字符 个数 。 最 核心 split 函数 正则表达式 分割 ， 不用 圆括号 ， 分隔符 包含 进去 ， 匹配 中 文字 标点符号 。 圆括号 ， 圆括号 匹配 内容 会 进去 列表 。 分隔符 。   import     def   zwc ( string ) :   # 中英文 常用 标点符号   lst   =   . split ( ' ( [ \\ u4e00 - \\ u9fa5 \\ s ， 。 ； ] ) ' , string )   # 去除   空白   # 去除 \\ s   中英文 常用 标点符号   lst   =   [ i     i     lst       i     [ \" \" , \"   \" , \" \\ n \" , \" \\ t \" , \" \\ r \" , \" \\ f \" , \" \\ v \" , \" ； \" , \" ， \" , \" 。 \" ] ]   print ( lst )     __ __   = =   ' __ main __ ' :   string = ' ' ' 道 可道 ， 道 。 名可名 ， 名 。 無名 天地 之始 ， 有名 萬物 之母 。   故常 無欲 ， 以觀 其妙 ； 常有 欲 ， 以觀 徼 。 兩者 同出 異名 ，   同謂 玄 ， 玄之又玄 ， 眾妙 之門 。   ' ' '   zwc ( string )   字符 分割 做 一个 小 修正 ， 匹配 空白 字符 中英文 标点符号 都 删除 ， 不 统计 入 字数 。   github 项目 链接 ：   zwc 项目   。   替换 操作   基于 正则表达式 替换 操作 有用 ， search 方法 ， 再 加上 匹配 字符串 索引 值 ， 修改 原 字符串 ， 再 search 循环 操作 ， 一个 替换 操作 。 模块 方法 解决 。   非 最长 匹配   小节 参考   python   cookbook     2.7   小节 ， 比如说 ：   . compile ( r ' \" ( . * ) \" ' )   匹配 两个 双引号 之间 内容 ， 默认 最长 匹配 ， 多个 双引号 句子 都 会 匹配 进去 ， 最短 匹配 ：   . compile ( r ' \" ( . * ) \" ' )   非 捕获 组   看 正则表达式 ，   ( : ... )   括号 组 是非 捕获 组 ，   . group   去 。   . search ( r ' ( ( : . | \\ n ) * ) ' , text2 )   默认   .   匹配 换行符 号 ， 引入 换行符 上 所示 加上 。   argparse 模块   简要 介绍 python3 官方 文档 argparse 模块 用法 ， 用于 快速 制作 一个 刷 参数 python 脚本 。   看 简单 情况 :   import   argparse   usage   =   ' ' '       a       show   argparse   usage   ' ' '   parser   =   argparse . ArgumentParser ( usage = usage )   args   =   parser . parse _ args ( )   这是 简单 一个 例子 ， 脚本 还 不 接受 参数 ， 只   - h     - -   查看 信息 ， 所示 。   wanze @ wanze - ubuntu64 : ~ / 桌面 $   python3   . py   - h   usage :       a       show   argparse   usage   [ - h ]   optional   arguments :   - h ,   - -   show       message     exit   新建 一个 parser ， ArgumentParser usage 可选 参数 ， 命令行 描述 信息 。 调用 parser   parse _ args   方法 ， 命令行 接受 参数 刷 进去 。   简单 添加 一个 参数   例子 太 简单 ， 简单 添加 一个 参数 。   import   argparse   usage   =   ' ' '       a       show   argparse   usage   ' ' '   parser   =   argparse . ArgumentParser ( usage = usage )   parser . add _ argument ( ' - - config ' , = \"   config   file   path \" )   args   =   parser . parse _ args ( )   print ( args )   命令行 信息 所示 :   wanze @ wanze - ubuntu64 : ~ / 桌面 $   python3   . py   - h   usage :       a       show   argparse   usage   optional   arguments :   - h ,   - -   show       message     exit   - - config   CONFIG     config   file   path   输入 :   wanze @ wanze - ubuntu64 : ~ / 桌面 $   python3   . py   - - config = ' config . cfg '   Namespace ( config = ' config . cfg ' )     parse _ args   方法 返回 Namespace 对象 ， 推荐   vars   函数 字典 值 ， 会 更好 地方 便 。   import   argparse   usage   =   ' ' '       a       show   argparse   usage   ' ' '   parser   =   argparse . ArgumentParser ( usage = usage )   parser . add _ argument ( ' - c ' , ' - - config ' , = \"   config   file   path \" )   args   =   vars ( parser . parse _ args ( ) )   print ( args )   wanze @ wanze - ubuntu64 : ~ / 桌面 $   python3   . py   - h   usage :       a       show   argparse   usage   python3   . py   optional   arguments :   - h ,   - -   show       message     exit   - c   CONFIG ,   - - config   CONFIG     config   file   path   wanze @ wanze - ubuntu64 : ~ / 桌面 $   python3   . py   - - config = ' config . cfg '   { ' config ' :   ' config . cfg ' }   代码 稍作 修改 ， 长 名字 选 参数 还 加上 短 名字 选 参数 支持 ，   parse _ args   方法   vars   返回 字典 值 。 字典 key 默认 长 名字 选 参数 。 还 设置 目标 参数 名 :   添加 参数 选项 设置   演示 设置 目标 参数 脚本 中 变量名 :   import   argparse   usage   =   ' ' '       a       show   argparse   usage   ' ' '   parser   =   argparse . ArgumentParser ( usage = usage )   parser . add _ argument ( ' - c ' , ' - - config ' , dest = \" configpath \" , = \"   config   file   path \" )   args   =   vars ( parser . parse _ args ( ) )   print ( args )   字典 输入 :   wanze @ wanze - ubuntu64 : ~ / 桌面 $   python3   . py   - - config = ' config . cfg '   { ' configpath ' :   ' config . cfg ' }   默认设置 长 名字 选 参数 ， 没 折腾 。 类似 还   add _ argument   方法 添加 可选 参数 ，   add _ argument   选项 配置 :   required = True   参数 输入 值 ， 报错     描述 信息 ， 。   default   参数 默认值 ， 默认 None ， 选择 设置 成 一个 值 。   type   目标 参数 数据类型 ， 默认 字符串 ， 设置 int float 。 设置 格式 ， 字符串 那种 设置 形式 :   ​   parser . add _ argument ( ' - - delay ' , type = int )   必填 参数 添加 所示 ， \\ \" target \\ \" 名字   - -   之外 ， 可选 参数 用法 大致 类似 ， 其刷入 args 字典 key \\ \" target \\ \" 名字 。   parser . add _ argument ( ' target ' , = \" 必填 参数 \" )   必填 参数 可选 参数 细节 上 差异 ， 会 提及 。   nargs 选项 设置   nargs 设置 参数 脚本 中 变量 一个 列表 。 nargs 设置 一个 数字 ，   nargs = 4   ， 脚本 参数 接受 4 输入 值 ， 收集 进 一个 列表 。   :   nargs = ' * '   可选 参数 设置 ， 作用 必填 参数 ， 必填 参数 意义 。 收集 任意 输入 参数值 ， 多个 选 参数 之间 星号 ， 请 参看 官方 文档 。   nargs = ' + '   作用 必填 参数 ， 意义 类似 正则表达式 ' + ' 号 ， ' * ' 号 一个 输入 值 ， 报错 。   nargs = ' '   ' ' 号 情况 挺 ， 不 太 喜欢 ， nargs 设置 显得 格格不入 。 变量值 列表 单个 值 ！ 改变 默认值 。 参数 不 输入 ，   ​   - - foo   ​   东西 不 输入 命令行 ， foo 默认 取 default 值 ，   ​   - - foo   东西 不 值 ， foo 取   const   ​   选项 赋 值 。 不太 喜欢 东西 。   给出 一个 完整 例子 :   import   argparse   usage   =   ' ' '   resize     image   ' ' '   def   main   ( ) :   parser   =   argparse   .   ArgumentParser   (   usage   =   usage   )   parser   .   add _ argument   (   ' - c '   ,   ' - - config '   ,   dest   =   \" configpath \"   ,     =   \"   config   file   path \"   )   parser   .   add _ argument   (   ' inputimg '   ,     =   \"   input   image \"   ,   nargs   =   ' + '   )   parser   .   add _ argument   (   ' - - width '   ,     =   \"   input   image \"   ,   type   =   int   )   args   =   vars   (   parser   .   parse _ args   ( ) )   configpath   =   args   [   ' configpath '   ]   width   =   args   [   ' width '   ]   inputimg   =   args   [   ' inputimg '   ]     inputimg     args   [   ' inputimg '   ] :   print   (   ' resize   image '   )   print   (   '   input   image     { }   '   .   format   (   inputimg   ) )   print   (   '   target   width     { }   '   .   format   (   width   ) )     __ __   = =   ' __ main __ '   :   main   ( )   运行 情况 所示 :   wanze @ wanze - ubuntu64 : ~ / 图片 $   python3   resizeimg . py   - -   usage :   resize     image   positional   arguments :   inputimg     input   image   optional   arguments :   - h ,   - -   show       message     exit   - c   CONFIGPATH ,   - - config   CONFIGPATH     config   file   path   - - width   WIDTH     input   image   wanze @ wanze - ubuntu64 : ~ / 图片 $   python3   resizeimg . py   - - width = 300   * . png   resize   image     input   image     2015 - 01 - 27   13 : 16 : 46   屏幕 截图 . png     target   width     300   resize   image     input   image     2015 - 05 - 03   18 : 17 : 19 屏幕 截图 . png     target   width     300   resize   image     input   image     2015 - 05 - 03   18 : 20 : 45 屏幕 截图 . png     target   width     300   ....   命令行 选项 关联 动作   parser   add _ argument   方法   action   参数 用来 控制 命令行 选项 关联 动作 ， 都 不 设置 ， 默认   store   ， 存储 值 。 类似   store _ const   ,   store _ true     store _ false   。   store _ const   默认 store ， 指明 值 ， 设置 action   store _ const   :   parser . add _ argument ( ' - - foo ' ,   action = ' store _ const ' ,   const = 42 )   会 自动 设置 该值 ， default 默认值 区别 选项 值 常量 值 。   > >   python3   test2 . py   - - foo   Namespace ( foo = 42 )   store _ true     store _ false   写为 :   parser . add _ argument ( ' - - foo ' ,   action = ' store _ true ' )   存储   True   值 :   > >   python3   test2 . py   - - foo   Namespace ( foo = True )   讲 定义 动作 ， 类似   - - version   用法 ， 一种 影响 程序 工作 流 选项 ， 官方 文档 推荐 子 类化   argparse . Action   方法 ， 麻烦 。 发现   click   模块 好 （ 一个 解决 创建 命令行 脚本 工具 推荐 第三方 模块 ） ， 很 :   import   click   def   print _ version   (   ctx   ,   param   ,     ) :           ctx   .   resilient _ parsing   :   return   click   .   echo   (   ' Version   1.0 '   )   ctx   .   exit   ( )   def   quick   (   ctx   ,   param   ,     ) :   print   (   ctx   ,   param   ,     )   ctx   .   exit   ( )   @ click   .   command   ( )   @ click   .   option   (   ' - - version '   ,   _ flag   =   True   ,   callback   =   print _ version   ,   expose _   =   False   ,   _ eager   =   True   )   @ click   .   option   (   ' - - quick '   ,   callback   =   quick   ,   _ flag   =   True   )   def     ( ) :     True   :   userinput   =   input   (   ' input : '   )   click   .   echo   (   userinput   )     userinput   = =   ' exit '   :   break     __ __   = =   ' __ main __ '   :     ( )   ctx param click 模块 再细 讲 ， 过程 argparse 美观 。   configparser 模块   简单 配置文件 管理 python 内置 模块 configparser 。 python2 模块 名字   ConfigParser   。   python3 configparser 简单 ， 分为 几步 :   新建 一个 configparser 对象   import   configparser   config   =   configparser . ConfigParser ( )   读取 config 文件   调用 read 方法 读取 config 文件 。   config . read ( ' test . cfg ' )   如同 字典 操作 configparser 对象   接下来 如同 字典 操作 configparser 对象 。   ' DEFAULT '   section ， 大致 表达 :   config [ ' DEFAULT ' ]   =   { ' ServerAliveInterval ' :   ' 45 ' ,   ' Compression ' :   ' ' ,   ' CompressionLevel ' :   ' 9 ' }   config [ ' bitbucket . org ' ]   =   { }   config [ ' bitbucket . org ' ] [ ' User ' ]   =   ' hg '   config [ ' topsecret . server . ' ]   =   { }   调用 write 方法 写入     open ( ' . ini ' ,   ' w ' )     configfile :   config . write ( configfile )   不 默认 更改 大小写   请 参看   网页   ， configparser 模块 默认   option     section key   改成 小写 ， 不 太 喜欢 风格 ， configparser 刷成 字典 值时 ， 字典 key 大小写 区分 ， 改动 ， 不 自动 小写 操作 :   . cfg   =   configparser . ConfigParser ( )   . cfg . optionxform   =   str ##     auto   make     lowercase   configparse 特殊字符   configparse 特殊字符 会 报错 ， 参考     ， 推荐   RawConfigParser   ， 解决问题 。   csv 模块   csv 模块   reader     writer   两个 函数 ， 还 提供   DictReader     DictWriter   两个 基于   reader   writer 两个 辅助 类 。 reader writer 接受 文件 对象 ， 参见 官方 样例 ：   import   csv     open   (   ' eggs . csv '   ,   ' w '   ,   newline   =   ' '   )     csvfile   :   spamwriter   =   csv   .   writer   (   csvfile   ,   delimiter   =   '   '   ,   quotechar   =   ' | '   ,   quoting   =   csv   .   QUOTE _ MINIMAL   )   spamwriter   .   writerow   ( [   ' Spam '   ]   *   5   +   [   ' Baked   Beans '   ] )   spamwriter   .   writerow   ( [   ' Spam '   ,   ' Lovely   Spam '   ,   ' Wonderful   Spam '   ] )     open   (   ' eggs . csv '   ,   newline   =   ' '   )     csvfile   :   spamreader   =   csv   .   reader   (   csvfile   ,   delimiter   =   '   '   ,   quotechar   =   ' | '   )     row     spamreader   :   print   (   ' ,   '   .   join   (   row   ) )   reader writer 两个 函数 接受 参数 定制 ， csv 方言 格式 。 不 做 修改 ， 默认 采用 excel 格式 csv 方言 ：   class   excel   (   Dialect   ) :   \" \" \" Describe     usual   properties     Excel - generated   CSV   files . \" \" \"   delimiter   =   ' , '   quotechar   =   ' \" '   doublequote   =   True   skipinitialspace   =   False   lineterminator   =   '   \\ r \\ n   '   quoting   =   QUOTE _ MINIMAL   字段 含义 作出 ：   delimiter   分隔符 ， 意义 很 。   lineterminator   换行符 ， 意义 很 ， 两种 ：   \\ r \\ n     \\ n   。   skipinitialspace   默认 False ， 空格 设置 分隔符 时有 意义 ， 字符 空格 将会 忽略 ， 情况 设置 True False 区别 不 大 。   quoting   设置 quote 规则   csv . QUOTE _ MINIMAL   情况 下才 加上 双引号 ， 逗号 字符串 ， 双引号 字符串 ， 换行符 号 字符串 。   csv . QUOTE _ ALL   都 加上 双引号 ， 数字 。   csv . QUOTE _ NONNUMERIC   数字 不 加 ， 字符串 都 加上 双引号 。 （ 情况 下 csv 模块 才 会 正确 数字 解析 float 类型 ）   csv . QUOTE _ NONE   都 不加 （ 设置 好 escapechar 选项 ）   quotechar   设置 quote 字符 ， 设置 双引号 。   doublequote   用来 双引号 字符串 中 情况 ， 默认 True ， 字符串 将会 双引号 之外 再 加上 双引号 ， 设置 False ， 会 加上 一个   escapechar   。   csv 输出 格式 太 excel 格式 ， 简单 csv 文件 读写 所示 ， 不 太 参数 ：   import   csv     open   (   ' eggs . csv '   ,   ' w '   ,   newline   =   ' '   ,   encoding   =   ' utf8 '   )     csvfile   :   spamwriter   =   csv   .   writer   (   csvfile   )   spamwriter   .   writerow   ( [   ' Spam '   ]   *   5   +   [   ' Baked   Beans '   ] )   spamwriter   .   writerow   ( [   ' Spam '   ,   ' Lovely   Spam '   ,   ' Wonderful   Spam '   ] )     open   (   ' eggs . csv '   ,   newline   =   ' '   ,   encoding   =   ' utf8 '   )     csvfile   :   spamreader   =   csv   .   reader   (   csvfile   )     row     spamreader   :   print   (   ' ,   '   .   join   (   row   ) )   编写 csv 方言   所示 指定 csv 方言 选项 ， 所示 定义 一个 csv 方言 类 ：   import   csv   class   YourDialectCSV   (   csv   .   Dialect   ) :   delimiter   =   ' , '   #   分隔符   quotechar   =   ' \" '   #   quote 符号   doublequote   =   True   #   双引号 字符 中 情况   skipinitialspace   =   True   #   分隔符 后 空白 忽略   lineterminator   =   '   \\ n   '   #   换行符   quoting   =   csv   .   QUOTE _ MINIMAL   #   最小 quote   csv   .   register _ dialect   (   \" YourDialectCSV \"   ,   YourDialectCSV   )   csv 模块 reader writer 函数 加上   dialect = ' YourDialectCSV '   即可 。   DictReader DictWriter 类   开头 一行 字段名 csv 文件 ， 推荐 DictReader DictWriter 两个 类 ， 两个 类 初始 实例 化 接受 dialect 选项 参数 ， 参数 会 原封不动 传递 reader   class   DictReader   :   def   __ init __   (     ,   f   ,   fieldnames   =   None   ,   restkey   =   None   ,   restval   =   None   ,   dialect   =   \" excel \"   ,   *   args   ,   * *   kwds   ) :     .   reader   =   reader   (   f   ,   dialect   ,   *   args   ,   * *   kwds   )   class   DictWriter   :   def   __ init __   (     ,   f   ,   fieldnames   ,   restval   =   \" \"   ,   extrasaction   =   \" raise \"   ,   dialect   =   \" excel \"   ,   *   args   ,   * *   kwds   ) :     .   writer   =   writer   (   f   ,   dialect   ,   *   args   ,   * *   kwds   )   讨论 ， 很 简单 ， 看 下 官方 样例 即可 ：     open   (   ' names . csv '   ,   ' w '   ,   newline   =   ' '   ,   encoding   =   ' utf8 '   )     csvfile   :   fieldnames   =   [   ' _ '   ,   ' _ '   ]   writer   =   csv   .   DictWriter   (   csvfile   ,   fieldnames   =   fieldnames   )   writer   .   writeheader   ( )   writer   .   writerow   ( {   ' _ '   :   ' Baked '   ,   ' _ '   :   ' Beans '   } )   writer   .   writerow   ( {   ' _ '   :   ' Lovely '   ,   ' _ '   :   ' Spam '   } )   writer   .   writerow   ( {   ' _ '   :   ' Wonderful '   ,   ' _ '   :   ' Spam '   } )     open   (   ' names . csv '   ,   newline   =   ' '   ,   encoding   =   ' utf8 '   )     csvfile   :   reader   =   csv   .   DictReader   (   csvfile   )     row     reader   :   print   (   row   [   ' _ '   ] ,   row   [   ' _ '   ] )   tempfile 模块   tempfile 模块 用于 创建 临时文件 临时 文件夹 ， 模块 系统 平台 上 都 工作 ， 很 有用 。   windows 系统 下 临时 文件夹 所在 ：   > > >   import   os   > > >   os   .     ' nt '   > > >   import   tempfile   > > >   tempfile   .   gettempdir   ( )   ' C :   \\ \\   Users   \\ \\   a3580   \\ \\   AppData   \\ \\   Local   \\ \\   Temp '   最 核心 两个 函数   mkstemp     mkdtemp   。   mkstemp   mkstemp 函数 用于 新建 一个 临时文件   fd   ,   fpath   =   tempfile   .   mkstemp   (   dir   =   tmpdir   )     os   .   fdopen   (   fd   ,   ' wb '   )     temp _ cache _ file   :   marshal   .   dump   ( (     .   FREQ   ,     .   total   ) ,   temp _ cache _ file   )   返回 第二个 参数 目标 临时文件 路径名 ， 第一个 文件 参数 ， 操作系统 级别 文件 句柄 （ C语言 文件 句柄 ） ， 转成 python 文件 对象 上 所示 ，   os . fdopen   打开 。   textwrap 模块   textwrap 模块 编辑器 常见 换行 显示 功能 。 默认   width = 70   。     textwrap   import   fill   wrapped   =   fill   (   output   )   fill 函数 等于 ：   \" \\ n \" . join ( wrap ( text ,   ... ) )     ( ! document . getElementById ( ' mathjaxscript _ pelican _#% @ # $ @ # ' ) )   {   var   align   =   \" center \" ,   indent   =   \" 0em \" ,   linebreak   =   \" false \" ;     ( false )   {   align   =   ( screen . width   <   768 )     \" left \"   :   align ;   indent   =   ( screen . width   <   768 )     \" 0em \"   :   indent ;   linebreak   =   ( screen . width   <   768 )     ' true '   :   linebreak ;   }   var   mathjaxscript   =   document . createElement ( ' script ' ) ;   mathjaxscript . id   =   ' mathjaxscript _ pelican _#% @ # $ @ # ' ;   mathjaxscript . type   =   ' text / javascript ' ;   mathjaxscript . src   =   ' / theme / js / mathjax / MathJax . js ' ;   mathjaxscript [ ( window . opera     \" innerHTML \"   :   \" text \" ) ]   =   \" MathJax . Hub . Config ( { \"   +   \"   config :   [ ' MMLorHTML . js ' ] , \"   +   \"   TeX :   {   extensions :   [ ' AMSmath . js ' , ' AMSsymbols . js ' , ' noErrors . js ' , ' noUndefined . js ' , ' mhchem . js ' ] ,   equationNumbers :   {   autoNumber :   ' AMS '   }   } , \"   +   \"   jax :   [ ' input / TeX ' , ' input / MathML ' , ' output / HTML - CSS ' ] , \"   +   \"   extensions :   [ ' tex2jax . js ' , ' mml2jax . js ' , ' MathMenu . js ' , ' MathZoom . js ' ] , \"   +   \"   displayAlign :   ' \" +   align   + \" ' , \"   +   \"   displayIndent :   ' \" +   indent   + \" ' , \"   +   \"   showMathMenu :   true , \"   +   \"   messageStyle :   ' normal ' , \"   +   \"   tex2jax :   {   \"   +   \"   inlineMath :   [   [ ' \\ \\ \\ \\ ( ' , ' \\ \\ \\ \\ ) ' ]   ] ,   \"   +   \"   displayMath :   [   [ ' $ $ ' , ' $ $ ' ]   ] , \"   +   \"   processEscapes :   true , \"   +   \"   preview :   ' TeX ' , \"   +   \"   } ,   \"   +   \"   ' HTML - CSS ' :   {   \"   +   \"   styles :   {   ' . MathJax _ Display ,   . MathJax   . mo ,   . MathJax   . mi ,   . MathJax   . mn ' :   { color :   ' inherit   !   important ' }   } , \"   +   \"   linebreaks :   {   automatic :   \" +   linebreak   + \" ,   width :   ' 90%   container '   } , \"   +   \"   } ,   \"   +   \" } ) ;   \"   +   \"   ( ' default '   ! = =   ' default ' )   { \"   +   \" MathJax . Hub . Register . StartupHook ( ' HTML - CSS   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax [ ' HTML - CSS ' ] . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" MathJax . Hub . Register . StartupHook ( ' SVG   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax . SVG . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" } \" ;   ( document . body   | |   document . getElementsByTagName ( ' head ' ) [ 0 ] ) . appendChild ( mathjaxscript ) ;   }",
            "tags":"python_language",
            "url":"articles/python-modules.html"
        },
        {
            "title":"python语言学习之cookbook",
            "text":"前言   本文 列出 笔者 学习 实践 python 中 接触 小 技巧 ， 小 知识点 ， 汇总 整理 。   核心 内置   利用 int 函数 进位 转换   int 函数 用于 强制 类型转换 ， 一个 类 数值 字符串 integer ， 函数 还 隐藏 一个 强大 功能 ， 第二个 选 参数 ， 进位制 。   > > >   int   (   ' a '   ,   base   =   16   )   10   > > >   int   (   ' 0xa '   ,   base   =   16   )   10   效果 一个 十六进制 字符 十六进制 输出 一个 十进制 数值 。 需求 地方 别用 eval 。   assert 语句   assert 语句 简单 理解   assert   True   ， 刷 ，   assert   False   抛出   AssertionError   。   assert 语句 实际上 一个 语句 ， 程序员 编码 一种 防御型 编码 风格 ， 编码 规范 ， 重要性 更 高一 等级 编码 风格 ， 一种 思维 方式 。   防御型 编码 风格 ， 简言之 编码 ， 即将 面对 数据类型 预期 。 比如说   _   函数 一个 判断 输入 整数 是否是 偶数 函数 ， 预期 输入 数值 一个 整数 ， 加上   assert   isinstance ( x ,   int )   ， 防御 输入 x 参数 类型 。 程序运行 过程 中 抛出 地方 assert 异常 ， 函数 实际上 说 ， ， 参数 出 ， 调用 方法 出 。   防御型 编码 风格 一种 去 耦合 思维 ， 编写 函数 去 耦合 思维 ， 防御型 编码 风格 当成 某种 规范 ， 当作 某种 额外 约束 工作 ， 编写 函数 思维 方式 。 去 观察 防御型 编码 风格 初学者 ， 会 发现 函数 分离 工作 做 很 不好 ， 大段 代码 ， 参数 全局变量 局部变量 都 乱七八糟 ， 代码 文件 混乱 不堪 。 还会 嬉笑 道 ， 不 防御型 编码 ， ， 我学过 。   assert 语句 相关 条件 判断 抛 异常 语句 片段 都 防御型 编码 风格 ， assert 语句 ， 抛出 异常 。 实际上 assert 语句 抛 异常 ， assert 语句 抛 异常 语句 一个 很大 ：   assert 语句 设置 python 编译器 全局 跳过 ， 下 。 做 校验 ， 异常 语句 。   一般来说 项目 早期 写 上 很多 assert 语句 ， 时间 充裕 很多 assert 语句 替换 抛 异常 语句 。   locals globals   python   locals ( )   返回 函数 内 局部变量 字典 值 ，   globals ( )   返回 模块 文件 全局变量 。   locals   只读 ，   globals ( )   ， 利用   globals ( )   脚本 文件 玩 出 新花样 。       运算 优先级   推荐 括号 清晰 表达 ， 优先级 。 再 看 例子 :   > > >   True     True     False   True   例子 很 好 优先级 顺序 ，   优先级 高   。   关键词   这是 python 语言 关键词 函数 ， 源码 很 简单 ， 列出来 ， 看 :   def   ( iterable ) :     element     iterable :       element :   return   False   return   True   def   ( iterable ) :     element     iterable :     element :   return   True   return   False   语言 表述 :   ， 都 True ， 返回 True ， 返回 False   ， 一个 True 返回 True ， 返回 False 。   三元 运算符   类似 结构 :   loop   =   loop     loop       None     _ event _ loop ( )   处理函数 入口 参数 默认值 情况 会 用到 ， 函数参数 写   loop = None   ， 一行 形式 更 简洁 。 不 函数 定义 采用 默认值 两种 情况 ， 一是 默认值 不 默认值 ， 默认 None ； 一种 情况 默认值 函数 运算 。   属性 管理 函数   hasattr ， setattr ， getattr ， delattr ， 函数 都 python 中 对象 属性 管理 函数 ， 都 内置 函数 。   hasattr ( object ,   ) 检测 对象 有没有 属性 。   setattr ( object ,   ,   ) 用于 设置 对象 属性 值 ，   setattr ( x , a , 3 )     x . a   =   3   语法 。   getattr ( object ,   [ ,   default ] ) 用于 取 对象 属性 值 ，   object .   语法 。   delattr ( object , ) 用于 删除 对象 属性 ，   del   object .   语法 。   __ __     __ file __   脚本 引入 指用 import 语句 一个 脚本 引入 进去 ， 脚本 执行 指   python   test . py   形式 执行 py 脚本 。   两种 形式 很 区别 ， 慢慢 谈论 :   __ __   区别 。 很 熟悉 。 脚本 引入 ，   __ __   值 引入 脚本 文件名 ， 引入   test . py   ， 脚本 引入 ， test . py 文件 来说 ， 其内   __ __   值   test   ，   模块 名   ； 脚本 执行 ，   __ __     __ main __   。   __ file __   区别 。 脚本 执行 ， 假设 脚本 文件   . py   ， 执行 脚本 中 ，   __ file __   值   . py   ，   文件名   。 引用 ， 引入 脚本 来说 ，   __ file __   值 引入 脚本 系统 来说   完整 文件名   ，   / home / wanze / 桌面 / . py   。   __ missing __   方法   字典 字典 子类 ， 定义   __ missing __   方法 回避 找 不到 键值 抛出   KeyError   ， 参考   网页   。 所示 :   class   NestedDict   (   collections   .   UserDict   ) :   ' ' '   Implement     data   structure :   { \" section \" : { } ,   }   ' ' '   def   __ init __   (   data   =   None   ) :   super   ( )   .   __ init __   (   data   )   def   __ missing __   (     ,   key   ) :     =     [   key   ]   =   dict   ( )   return     def   update _ _ section   (     ,   section   ,   d   ) :     [   section   ]   .   update   (   d   )   def   _ _ section   (     ,   section   ,   key   ) :   return     [   section   ]   .     (   key   )   def   delete _ _ section   (     ,   section   ,   key   ) :   del     [   section   ] [   key   ]   def   set _ _ section   (     ,   section   ,   key   ,     ) :     [   section   ] [   key   ]   =     找 不到 key ， 该类 会 自动 赋值 一个 新   dict ( ) key 值 。 希望   type ( ) ( )   ， 风格 json 兼容性 不太好 ， 推荐 都 dict 类 。   python 中类 继承 顺序   python 中类 搜索 顺序 从左到右 ， ：   class   D ( A , B ) :   pass   D 属性 先 A 找 ， 再 B 找 。 类 继承 概念 上 来说 ， A 类 B 类 之间 层次 关系 ， 顺序 随便 都 没 ， B 类 更 底层 Base 类 ， 其是 放在 最 右边 。 Mixin 类中 写法 所示 ：   class   MyClass ( Mixin2 ,   Mixin1 ,   BaseClass ) :   pass   字符串 大小   读者 实验 python 中 字符串 之间 大小 ：   > > >   ' abc '   >   ' ab '   True   > > >   ' fabc '   >   ' abc '   True   > > >   ' 3.04 '   >   ' 3 '   True   特性 很 有用 ， 大小 ？ python 官方 文档 描述 ， 采用 词典 编纂 顺序 。 描述 信息 ：   序列 之间 大小 ， 两个 序列 第一个 元素 ， ， 下 一个 ， 一个 序列 穷尽 。 两个 序列 类型 都 ， 过程 。 两个 序列 ， 一个 序列 一个 序列 子 序列 ， 短 序列 比长 序列 小 。 一个 元素 大小 ， ASCII 顺序 。   中文 大小 ？   读者 会 想到 ， python 中 字符串 都 默认 unicode 编码 （ utf - 8 ） ， 中文 大小 ， 事实 确实 ：   > > >   ' 章 '   >   ' 张 '   True   > > >   ' 章 '   <   ' 张 '   False   > > >   ord ( ' 章 ' )   31456   > > >   ord ( ' 张 ' )   24352   感兴趣 读者 打开 字符 映射 表看 ， ' 张 ' unicode 编号 U + 5F20 ， 输入 0x5f20 ， 返回 正是 24352 。 输入 hex ( 24352 ) ， 返回 ' 0x5f20 ' 。   ord chr 函数   ord 函数 接受   一个 字符 ， 返回 unicode 编码 ， 十进制 。 chr 函数 ord 函数 反向 ， 输入 24352 十进制 uniocde ， 返回 字符 。   > > >   chr ( 24352 )   ' 张 '   ， python3 字符串 大小 ， 基于 utf - 8 编码 。   字符串   format 函数   format 函数 或者说 字符串 format 方法 ， 很 简单 ， 高级 需求 ， 渐渐 收集 。   更 python 中 format 函数 信息 请 参考   pyformat . info   。   宽 数字   { : 0 > 2d }   目标 数字 宽度 两位 ， 左边 填充 0   ，   >   左边 填充 ，   0 >   左边 填充 0 ，   >   右边 填充 。   花 括号   花 括号 特殊字符 ， 显示 花 括号 ， 输入 两次 ：   > > >   print ( f ' { { - - - - } } ' )   { - - - - }   f - string   python3.6 进来 特性 。 情况 ：   python 新 format 字符串   f \" .   { } \"   等价   \" .   { } \" . format ( = )   一个 变量 还好 ， 多个 变量 f - string 写法 好处 很 ， 环境 下 定义 好 变量名 ， 只能 一句 话 形容 ， 太好 ， 上 会 停不下来 。   字典   理解 字典 寻址   t   =   {   True   :   ' '   ,   1   :   ' '   ,   1.0   :   ' '   }   t   Out   [   3   ] :   {   True   :   ' '   }   python 字典 key 判断 机制 ，   值     hash   值   才   key 。   key key 不 做 改变 ， 而值 取 最新 。 正是 ， 字典 更新 语句 写法 可行 ：   x   =   { ' a ' : 1 ,   ' b ' : 2 }   y   =   { ' b ' : 3 }   z   =   { * * x ,   * * y }   z   Out [ 8 ] :   { ' a ' :   1 ,   ' b ' :   3 }   最快 字典 更新 方式 。   文件   读取 文件 推荐 方式   文件 对象 本身 迭代 ， 简单 迭代 文件 对象 文件 一行行 内容 操作 。 ：   f   =   open ( ' removeduplicate . py ' )     line     f :   print ( line , end = ' ' )   代码 打印 文件 ， end = \" 取消   \\ n   ， 行   \\ n   。   代码 稍作 修改 一行 加上   > > >   符号 。   f   =   open ( ' removeduplicate . py ' )     line     f :   print ( ' > > > ' , line , end = ' ' )   ？ 输出 终端 ， 文件 去 ， 行 ， 加上 file 参数 。 代码 ：   import   sys   f   =   open ( ' removeduplicate . py ' )   pyout = open ( sys . argv [ 1 ]   , \" w \" )     line     f :   print ( ' > > > ' , line , end = ' ' , file = pyout )   pyout . close ( )   f . close ( )   python 列表 解析 （ 迭代 ） 效率 很 高 ， 多用 列表 解析 模式 。   文件 对象 一个 readlines 方法 ， 一次性 文件 行 字符串 装入 一个 列表 中 。 再 列表 解析 操作 文件 内容 做出 修改 。 不 推荐 readlines 方法 ， 文件 装入 内存 方法 内存 爆炸 风险 ， 迭代 版本 更好 一点 。   模块   获取 模块 对象   所示 ， 获取 模块 内 变量 。   import   sys   current _ module   =   sys   .   modules   [   __ __   ]   _ module _ dict   =   copy   (   current _ module   .   __ dict __   )   #     k ,   v     _ module _ dict . items ( ) :   #     k   = =   ' case _ base ' :   #   pass   #   elif   k . startswith ( ' case _ ' ) :   #     issubclass ( v ,   case _ base ) :   #   URL _ CASES . append ( v )   字符串 获取 模块 对象   import   importlib   importlib . import _ module ( ' . ' )   检查 变量 模块 对象   参考   网页   > > >   import   os   ,   types   > > >   isinstance   (   os   ,   types   .   ModuleType   )   True   有用 内置 模块   迭代 对象 flatten 操作   a _ list   =   [ [ 1 ,   2 ] ,   [ 3 ,   4 ] ,   [ 5 ,   6 ] ]   print ( list ( itertools . chain . _ iterable ( a _ list ) ) )   #   Output :   [ 1 ,   2 ,   3 ,   4 ,   5 ,   6 ]   #     print ( list ( itertools . chain ( * a _ list ) ) )   #   Output :   [ 1 ,   2 ,   3 ,   4 ,   5 ,   6 ]   利用 abc 模块 抽象 基类   abc 模块 抽象 基类 ， 类似 java 中 抽象类 概念 。   所示 ：     abc   import   abstractmethod     abc   import   ABC   class   Graph   (   ABC   ) :   \" \" \"   图   \" \" \"   DIRECTED   =   None   @ abstractmethod   def   nodes   (     ) :   \" \" \"   : return :   \" \" \"   raise   NotImplementedError   (   \" Not   Implement   nodes   methods \"   )   抽象类 实例 化 ， 实例 化将会 报错 。 继承 类 ， 上 定义 抽象 方法 ， 继承 类 定义 好 方法 ， 将会 报错 。   抽象类 定义 抽象 方法 动作 方法 。   抽象类 还 定义 抽象 属性 。   logging 中 pprint   参考   网页   。   logging 输出 希望 调用 pprint 输出 打印 美观 些 ， 调用 pformat 函数 效果 ：     pprint   import   pprint   ,   pformat   ds   =   [ {   ' '   :   ' '   } ]   logging   .   debug   (   pformat   (   ds   ) )   利用 ast 模块 literal _ evel 函数 更 eval   literal _ eval   函数 一个 有用 函数 ， 用于 短小 python 字符串 转化成 python   object 。 所示 :   import   ast   def   str2pyobj ( val ) :   ' ' ' str     python   obj       changed ' ' '   :   val   =   ast . literal _ eval ( val )     Exception : ###   pass   return   val   支持 python   object :   strings ,   bytes ,   numbers ,   tuples ,   lists ,   dicts ,   sets ,   booleans ,     None .   字符串   \\ \" 1 \\ \"   \\ \" 3.14 \\ \"   \\ \" [ 1 , 2 , 3 ] \\ \"   转化 integer   float   list 小菜一碟 。 建立 异常 捕捉 ， 转化 失败 ， 原样 返回 字符串 即可 。   利用 itertools 模块 product 函数 遍历 组合   product 函数   itertools   模块 ， 官方 文档 product ( A ,   B ) 返回值 等价 ( ( x , y )     x     A     y     B ) ， 组合 情况 （ 类似 笛卡尔 积 概念 ） :   > > >   list ( product ( [ ' a ' , ' b ' ] , [ ' c ' ] ) )   [ ( ' a ' ,   ' c ' ) ,   ( ' b ' ,   ' c ' ) ]   单一 迭代 加上   repeat   参数 会 生成 很 有意思 :   > > >   list ( product ( [ ' True ' , ' False ' ] , repeat = len ( ' abc ' ) ) )   [ ( ' True ' ,   ' True ' ,   ' True ' ) ,   ( ' True ' ,   ' True ' ,   ' False ' ) ,   ( ' True ' ,   ' False ' ,   ' True ' ) ,   ( ' True ' ,   ' False ' ,   ' False ' ) ,   ( ' False ' ,   ' True ' ,   ' True ' ) ,   ( ' False ' ,   ' True ' ,   ' False ' ) ,   ( ' False ' ,   ' False ' ,   ' True ' ) ,   ( ' False ' ,   ' False ' ,   ' False ' ) ]   看作 :   > > >   list ( product ( [ ' True ' , ' False ' ] , [ ' True ' , ' False ' ] , [ ' True ' , ' False ' ] ) )   [ ( ' True ' ,   ' True ' ,   ' True ' ) ,   ( ' True ' ,   ' True ' ,   ' False ' ) ,   ( ' True ' ,   ' False ' ,   ' True ' ) ,   ( ' True ' ,   ' False ' ,   ' False ' ) ,   ( ' False ' ,   ' True ' ,   ' True ' ) ,   ( ' False ' ,   ' True ' ,   ' False ' ) ,   ( ' False ' ,   ' False ' ,   ' True ' ) ,   ( ' False ' ,   ' False ' ,   ' False ' ) ]   利用 collections 模块 deque 数据结构   小节 参考   网页   。   想 读者 接触 queue 结构 ， queue 结构 一端 进 data ， 另一端 出 data ， 先进先出 数据流 。 deque 结构 两端 都 进 两端 都 出 ， 看 上 古怪 ， 只 一端 ， 好像 一个 堆栈 结构 ， 先进后出 ； 一端 进 ， 另一端 出 ， 好像 一个 queue 结构 。 其有 优势 ？ deque 结构 优势 ， 原因 :   两端 插入 元素 删除 元素 时间 复杂度 O ( 1 ) ， 一个 常数 级 ， 列表 开头 插入 删除 元素 时间 复杂度 O ( N ) ， 一个 类似 列表 数据 存储 结构 ， 数据结构 中 ， 开头 几个 元素 末尾 几个 元素 都 ， 访问 ， deque 结构 。   网页 介绍 一个 函数 ， 用来 返回 一个 文件 几行 :     collections   import   deque   def   tail   (   filename   ,   n   =   10   ) :   ' Return       n   lines     a   file '     open   (   filename   )     f   :   return   deque   (   f   ,   n   )   其是 利用 deque 一个 size 定长 概念 ， 输入 队列 deque 时较 老 元素 会 丢弃 。 不 太 做法 效率 ， 写法 很 优雅 。   查找 多个 最小 元素 情况   想要 获知 数据 一个 最大值 一个 最小值 ，   max     min   方法 。 讨论 情况 想要 获知 数据 多个 最大值 多个 最小值 。 想到 先对 数据 排序 ， 切片 操作 。 参考资料 2 第一章 第四节 讨论 方法 实际上 利用 最小 堆 结构 堆排序 提出 最小 几个 元素 。   大体 过程 :   lst   =   [ 1 ,   8 ,   2 ,   23 ,   7 ,   - 4 ,   18 ,   23 ,   42 ,   37 ,   2 ]   import   heapq   heapq . heapify ( lst )   heapq . nlargest ( 3 , lst )   heapq . nsmallest ( 3 , lst )   利用 collections 模块 Orderdict 类   字典 排序 需求 ， 输出 再 排序 ， OrderedDict 字典 存储 开销 大 一倍 ， 不用 不用 。 情况 下 ， 类 确实 带来 便利 。 第一次 情况 大体 bilibili api 对接 ， 计算 密钥 参数 排序 urlencode 字符串 再 基于 字符串 计算 。   params   =   OrderedDict ( sorted ( params . items ( ) ,   key = lambda   t :   t [ 0 ] ) )   string   =   urlencode ( params )   大体 情况 下 ， 字典 值 变量 顺序 输出 ， OrderedDict 很 便利 。 顺序 插入 顺序 ， 做 字典 排序 工作 ， 看作 这是 一个 自动 某种 操作 便捷 对象 。   Counter 类   Counter 类 真 有用 ， 还 好 。 例子 来自 参考资料 2 ， 不多 说 ， 代码 大体 :   words   =   [   ' ' ,   ' ' ,   ' ' ,   ' eyes ' ,   ' ' ,   ' ' ,   ' ' ,   ' eyes ' ,   ' ' ,   ' eyes ' ,   ' ' ,   ' eyes ' ,   ' ' ,   ' eyes ' ,   ' ' ,   ' ' ,   ' ' ,   ' eyes ' ,   \" don ' t \" ,   ' ' ,   ' ' ,   ' ' ,   ' eyes ' ,   ' ' ,   ' ' ,   ' ' ,   ' eyes ' ,   \" ' \" ,   ' '   ]     collections   import   Counter   word _ counts   =   Counter ( words )   #   频率 3 单词   top _   =   word _ counts . _ common ( 3 )   print ( top _ )   #   Outputs   [ ( ' eyes ' ,   8 ) ,   ( ' ' ,   5 ) ,   ( ' ' ,   4 ) ]   Counter   对象 字典 子类 ， 字典 方法 都 ， 不 赘述 。   update   方法 理解 为同 key 之间 加法 ，     subtract   方法 看作 key 之间 减法 。 还 做 :   加减 运算 提及   update   方法   subtract   方法 区别 ， 加法 大体 类似 ， 减法 将会 自动 去掉 计数 小于 等于零 项 ，   subtract   方法 。   > > >   a   =   Counter ( words )   > > >   b   =   Counter ( morewords )   > > >   a   Counter ( { ' eyes ' :   8 ,   ' ' :   5 ,   ' ' :   4 ,   ' ' :   3 ,   ' ' :   3 ,   ' ' :   2 ,   \" ' \" :   1 ,   \" don ' t \" :   1 ,   ' ' :   1 ,   ' ' :   1 } )   > > >   b   Counter ( { ' eyes ' :   1 ,   ' ' :   1 ,   ' ' :   1 ,   ' ' :   1 ,   ' ' :   1 ,   ' ' :   1 ,   ' ' :   1 ,   ' ' :   1 } )   > > >   #   Combine   counts   > > >   c   =   a   +   b   > > >   c   Counter ( { ' eyes ' :   9 ,   ' ' :   5 ,   ' ' :   4 ,   ' ' :   4 ,   ' ' :   3 ,   ' ' :   2 ,   ' ' :   2 ,   \" ' \" :   1 ,   \" don ' t \" :   1 ,   ' ' :   1 ,   ' ' :   1 ,   ' ' :   1 ,   ' ' :   1 ,   ' ' :   1 ,   ' ' :   1 } )   > > >   #   Subtract   counts   > > >   d   =   a   -   b   > > >   d   Counter ( { ' eyes ' :   7 ,   ' ' :   5 ,   ' ' :   4 ,   ' ' :   3 ,   ' ' :   2 ,   ' ' :   2 ,   \" ' \" :   1 ,   \" don ' t \" :   1 ,   ' ' :   1 } )   > > >   数据结构 最为 数值 统计 频数 ， 调用   _ common ( n )   方法 ， n 排行榜 前 n 名 。   利用 collections 模块 namedtuple   collections 模块 namedtuple 函数 将会 一个 名字 数组 类 （ 有名 数组 ） ， 类 新建 类似 实例 。 ：     collections   import   namedtuple   Point3d = namedtuple ( ' Point3d ' , [ ' x ' , ' y ' , ' z ' ] )   p1 = Point3d ( 0 , 1 , 2 )   print ( p1 )   print ( p1 [ 0 ] , p1 . z )   Point3d ( x = 0 ,   y = 1 ,   z = 2 )   0   2   构建 一个 dataclass 类   python3.7 新 dataclass 类 一个 很 有用 特性 ， 代码 中 函数 之间 传输 特定 数据 ， 构建 一个 dataclass 类 ：   @ dataclass   class   InventoryItem :   ' ' ' Class     keeping   track       item     inventory . ' ' '   :   str   unit _ price :   float   quantity _ _ hand :   int   =   0   大致 效果 等于 ：   def   __ init __ ( ,   :   str ,   unit _ price :   float ,   quantity _ _ hand :   int = 0 ) :   .   =     . unit _ price   =   unit _ price   . quantity _ _ hand   =   quantity _ _ hand   编写 dataclass 类 项目 代码 数据 定义 清晰化 。   configparse 特殊字符   configparse 特殊字符 会 报错 ， 参考     ， 推荐   RawConfigParser   ， 解决问题 。   利用 collections 模块 ChainMap 定义 搜索 过程   多个 字典 组合 一个 map 字典 ， 想到 一个 配置 字典 流 ， 利用 ChainMap 定义 搜索 路 径流 ， 先 搜索 配置 优先 取用 。     collections   import   ChainMap   d1   =   {   ' a '   :   1   ,   ' b '   :   2   }   d2   =   {   ' a '   :   2   ,   ' d '   :   3   }   d3   =   ChainMap   (   d1   ,   d2   )   typing . NamedTuple   类 添加 python3.6 ，   collections . namedtuple   类似 。     typing   import   NamedTuple   class   Car   (   NamedTuple   ) :   color   :   str   mileage   :   float   automatic   :   bool   car1   =   Car   (   color   =   ' red '   ,   mileage   =   3512.5   ,   automatic   =   True   )   car1   .   color   不 赞同 达恩 · 巴德尔 观点 — — 推荐 typing . NamedTuple   ， namedtuple 优势 区分 字典 ， 其有 两个 ： ， key 变 ； 二 ， 轻量级 。 情况 下 namedtuple 优于 字典 。 采用 类 写法 ， 换 一个 情景 ， 情境 下 ， NamedTuple dict 都 不 太 合适 ， 而类 第一 公民 。   queue . PriorityQueue   queue . PriorityQueue   内部 基于 heapq 堆排序 ， 额外 做 ， 保证 操作 线程 。 一般来说 一个 优先级 队列 ， 推荐   PriorityQueue ：     queue   import   PriorityQueue   q   =   PriorityQueue   ( )   q   .   put   ( (   2   ,   ' code '   ) )   q   .   put   ( (   1   ,   ' eat '   ) )   q   .   put   ( (   3   ,   ' sleep '   ) )       q   .   empty   ( ) :   print   (   q   .     ( ) )   ( 1 ,   ' eat ' )   ( 2 ,   ' code ' )   ( 3 ,   ' sleep ' )   queue . Queue   线程 先进先出 【 队列 操作 】 数据结构 。     queue   import   Queue   q   =   Queue ( )   q . put ( ' a ' )   q . put ( ' c ' )   print ( q . ( ) )   print ( q . ( ) )   a   c   queue . LifoQueue   线程 后进先出 【 栈 操作 】 数据结构 。     queue   import   LifoQueue   q   =   LifoQueue ( )   q . put ( ' a ' )   q . put ( ' c ' )   print ( q . ( ) )   print ( q . ( ) )   c   a   multiprocessing . Queue   跨 进程 先进先出 队列 数据结构 ：     multiprocessing   import   Queue   q   =   Queue ( )   q . put ( ' a ' )   q . put ( ' c ' )   print ( q . ( ) )   print ( q . ( ) )   a   c   有用 第三方 模块   获取 一个月   要说 利用 python datetime timedelta   days   加减 操作 很 好 支持 跨 月 :   > > >     datetime   import   datetime   > > >   d   =   datetime . ( )   > > >   d   datetime . datetime ( 2016 ,   5 ,   29 ,   8 ,   50 ,   20 ,   337204 )   > > >     datetime   import   timedelta   > > >   d   -   timedelta ( days   =   29 )   datetime . datetime ( 2016 ,   4 ,   30 ,   8 ,   50 ,   20 ,   337204 )   > > >   d   -   timedelta ( days   =   28 )   datetime . datetime ( 2016 ,   5 ,   1 ,   8 ,   50 ,   20 ,   337204 )   获知 月份 30 31 ， 利用 replace 一个月 。 利用   calendar     monthrange   函数 。 参考   网页   。   > > >   d . replace ( year   =   2016 , month = 4 , day   =   monthrange ( 2016 , 4 ) [ - 1 ] )   datetime . datetime ( 2016 ,   4 ,   30 ,   8 ,   50 ,   20 ,   337204 )   附录   列出 技巧 。   对象 动态 加载 一个 方法   参考   网页   。   原理 很 简单 ， 构建 一个 函数 对象 ， 对象 赋值 对象 。 函数 对象 接受 参数 ， 类 方法 。   class   Test   ( ) :   pass   test   =   Test   ( )   def     (     ) :   print   (   \" \"   )   import   types   test   .     =   types   .   MethodType   (     ,   Test   )   test   .     ( )   types . MethodType 用来 构建 一个 类 方法 ， 第一个 参数 函数 对象 ， 第二个 参数 类 实例 。   例子 优化 形式 :   import   types   class   Test   ( ) :   @ classmethod   def   removeVariable   (   cls   ,     ) :   return   delattr   (   cls   ,     )   @ classmethod   def   addMethod   (   cls   ,   func   ) :   return   setattr   (   cls   ,   func   .   __ __   ,   types   .   MethodType   (   func   ,   cls   ) )   def     (     ) :   print   (   \" \"   )   test   =   Test   ( )   Test   .   addMethod   (     )   test   .     ( )   addMethod 作用 本类 ， 选择 作用 于本 实例 :   import   types   class   Test ( ) :   @ classmethod   def   removeVariable ( cls , ) :   return   delattr ( cls , )   @ classmethod   def   addMethod ( cls , func ) :   return   setattr ( cls , func .__ __ , types . MethodType ( func , cls ) )   def   addMethod2 ( , func ) :   return   setattr ( , func .__ __ , types . MethodType ( func , ) )   def   ( ) :   print ( \" \" )   test   =   Test ( )   test . addMethod2 ( )   test . ( )   函数 只加 实例 ， 用处 不太大 。",
            "tags":"python_language",
            "url":"articles/python-cookbook.html"
        },
        {
            "title":"python语言学习之资料参考",
            "text":"python 入门教程 ， python 官 网上 tutorial 。 原作者 ： Guido   van   Rossum   Fred   L .   Drake   ； 中文翻译 ： 刘鑫 ； 版本 ： 2013 - 10 - 28 ； pdf 下载 链接 ：   python 入门教程   。   learning   python ， python 语言 参考 ， 参看 python 学习 手册 （ 第四版 ） 。 原作者 ： Mark   Lutz ， 中文翻译 ： 李军 ， 刘红伟 。   programming   python ， 作者 Mark   Lutz python 编程 进阶 讨论 ； 版本 ： 第四版 。   python   官 网上 资料   。   第三方 模块 参考手册 ， numpy ,   scipy ,   matplotlib 第三方 模块 官 网上 发布 官方 参考手册 。   dive     python3   english   version   ,   这是   中文版   。   A   Guide     Python ' s   Magic   Methods ， 作者 ： Rafe   Kettler   , 版本 ： 2014 - 01 - 04 ，   Github   地址   .   Foundations     Python   Network   Programming   ， python 网络 编程 基础 ， [ 美 ]   John   Goerzen   著 ， 莫迟 译   。   这是   中文 在线 阅读 网页   ， 这是   english   version   。   Unix 网络 编程 卷 1 :   套 接字 联网 API   ,   Author :   W .   R .   Stevens   ,   Bill   Fenner   著   ,   version :   第三版   python   3   cookbook   Effective   Python   编写 高质量 Python 代码 59 方法 ， [ 美 ]   Brett   Slatkin   著 ，   爱 飞翔 译 。   计算机网络 自顶向下 方法   ,   Author :   James   F .   Kurose   ,   Keith   W .   Ross   , 陈鸣译   。 本书 入门 计算机网络 相关 知识 很 不错 。   SQL 必知 必会   [ 英 ]   Ben   Forta   著 ，   钟鸣   刘晓霞 译 。",
            "tags":"python_language",
            "url":"articles/python-references.html"
        },
        {
            "title":"python语言学习之编码风格推荐",
            "text":"PEP8 代码 风格 规范 python 程序员 都 内容 ， 具体内容 官方 文档     。   空白 格式 编辑器 加上 插件 都 自动 pep8 格式 调整 ，   autopep8   模块 ， 一块 不 说 。   简单 地说 变量名 命名 规范   【 高质量 python 代码 】 ：   字母 都 大写 变量 ， 模块 文件 级别 常量 ， 单词 下划线 隔开 。   首字母 大写 类 异常 名字 ， 多个 单词 驼峰 写法 。   一律 小写字母 ， 下划线 隔开 。   开发者 不 命名 下划线 开头 变量 ， 写 干什么 。   编码 风格 推荐   带 两个 语句 列表 解析 。   生成器 表达式 改写 数据量 较大 列表 解析 。     =   ( len ( x )     x     open ( ' / tmp / myfile . txt ' ) )   循环 写 上 语句 。 建议 有利于 程序 简洁 直观 ， 接受 。   函数 返回值 返回值 才 意义 ， ， 情况 ， 抛出 异常 。   python 哲学   参考   网页 翻译   。   美 优于 丑 。   直白 优于 隐晦 。   简单 优于 。   优于 纠结 。   扁平 优于 嵌套 。   稀疏 优于 稠密 。   可读性 价值 。   特例 ， 特例 打破 规则 。   纯粹 性 实用性 之间 倾向 实用性 。   出错 决不能 无声无息 忽略 。   无声无息 。   面对 二义性 情况 时 ， 拒绝 猜 诱惑 。   一件 事 一种 做法   — —   一种 做法   — —   一种 显而易见 做法 。   刚 做法 显而易见 ， 毕竟 荷兰人 。   『 』 优于 『 决不 』 。   『 决不 』 优于 『   马上   』 。   一个 难于 解释 ， 差 想法 。   一个 很 解释 ， 好 想法 。   命名 空间 拍案叫绝 想法   —   放手 多用 ！",
            "tags":"python_language",
            "url":"articles/python-style-guide.html"
        },
        {
            "title":"python2和python3的兼容性",
            "text":"2to3 内置 模块   python 有个   2to3   内置 模块 自动 python2 脚本 python3 脚本 移植 工作 ， 感觉 过分 依赖 工具 ， 适合 初学者 。 python2 python3 很多 地方 不 。 模块 很 深 ， 手工 修改 会 更 合适 （ 会 涉及 新 编写 思路 ） 。 模块 请 参看 官方 文档 。   / /     /   python2 中 ， 两个 整数 相除 会 返回 一个 整数 ， python3   / /   。   > > >   5 / 2   2   兼容 方案   文件 头上 加上 一行 ：     __ future __   import   division   都 python3 语法 规则 ， :   /   常规 除法 ，   / /   整除 — — 返回 商 。   print 函数   最 常见 错误 ， 推荐 第一步 文档 find   print 字符串 操作 ， ：   print   ...   形式 都 换成 ：   print ( ... )   这是 python2 python3 都 兼容 形式 ， 好 犹豫 ， 大胆 修改 。   python2   print   1 ,   2 ,   还 小 ， 简单 理解 python3   print ( 1 ,   2 ,   end = '   ' )   python2 支持 重定向 语法   print   > > sys . stderr ,   1 ,   2 ,   3   python3 file 选项 ：   print ( 1 ,   2 ,   3 ,   file = sys . stderr )   兼容性 方案   推荐 模块 最 写 上 :     __ future __   import   print _ function   python3 语法 print 函数 。 python2 运行 。   unicode 字符串   说 Unicode 字符串 历史 ， python2 诞生 Unicode 字符串 （ 宽 字符 解决 编码方案 统称 ） 早 ， python2 早期 基于 ASCII 编码 ， ASCII 编码 8 位值 编码 ， 单纯 ， python2 一个 str 类型 8 位 字符 二进制 数据 。 python2 才 引入 unicode 字符 类型 ， 宽 字符 文本 。   python2 兼容 python3 引入 bytes 类似 bytearray 类型 。 兼容性 。 python2 python3 代码 兼容 上 一个 坑 python2 str 类型 8 位 文本 二进制 数据 统称 ， 默认 ASCII 编码 情况 下 ， 不知不觉 ， 系统 默认 编码 默认 ASCII ， 8 位值 数据 不 到底 文本 。 （ python3 str 默认 UTF - 8 编码 ， 支持 8 位 文本 支持 宽 字符 文本 ， 真的 文本 含义 。 ）   都 同意 python3 新 分类 很 好 ：   str   文本 ，   bytes   字节 流 。 编程 都 一律 采用 思维 。   写 python2 代码 都 推荐 文件 头上 写 上 ：     __ future __   import   unicode _ literals   写 python2 中 随便 定义 字符串   > > > \" test \"   u ' test '   返回 unicode 类型 ， python3 str 类型 。 程序员   （ \\ cite { 高质量 python 代码 } ）   编码 时 更多地 业务 逻辑 字符 编码 二进制 形式 存放 。   简单 见 字符串 都 简单 字符串 （ 或者说 文本 ） ， 程序员 编码 ， 确实 点 ， 操作 字符 bytes 形式 ， 确实 ， 再 转换 操作 。   转换 ：   #   python2   def   _ unicode ( unicode _ _ str ) :     isinstance ( unicode _ _ str ,   str ) :     =   unicode _ _ str . decode ( ' utf - 8 ' )   :     =   unicode _ _ str   return     def   _ str ( unicode _ _ str ) :     isinstance ( unicode _ _ str ,   unicode ) :     =   unicode _ _ str . encode ( ' utf - 8 ' )   :     =   unicode _ _ str   return     历史 遗留 代码 ， 遗憾 ， python2 python3 一块 裂痕 ， 详细 阅读 修改 重写 代码 恐怕 不了 。   ​   input raw _ input   python2 中 raw _ input 函数 python3 input 函数 。 python2 一个 input 函数 ， python3 中 eval ( input ( ) ) ， 函数 推荐 废弃 掉 。   兼容 方案     builtins   import   input     =   input ( ' What         ' )   类 都 继承 object   python3 中 类 都 默认 object 子类 。   兼容 方案   兼容 方案 引入 builtns 引入 object ， 都 指明 继承 object 。     builtins   import   object   class   Upper ( object ) :   def   __ init __ ( ,   iterable ) :   ._ iter   =   iter ( iterable )   def   __ __ ( ) :   #   Py3 - style   iterator   interface   return   ( ._ iter ) . upper ( )   #   builtin   ( )   function   calls   def   __ iter __ ( ) :   return     execfile 函数   python2 中 execfile 内置 函数 ， 运行 ， 用来 执行 python 脚本 。   execfile ( join ( dirname ( __ file __ ) ,   ' openerp ' ,   ' release . py ' ) )   #   Load   release   variables   lib _   =   ' openerp '   exec ( compile ( open ( join ( dirname ( __ file __ ) ,   ' openerp ' ,   ' release . py ' ) ) . read ( ) ,   join ( dirname ( __ file __ ) ,   ' openerp ' ,   ' release . py ' ) ,   ' exec ' ) )   lib _   =   ' openerp '   兼容 方案   exec ( compile ( open ( ' myfile . py ' ) . read ( ) ) )   < > 替换   ! =   不 等于号 < > 废弃 ， 推荐 ! = ， python2 python3 都 兼容 。   模块 包 导入   python2 python3 模块 包 结构 很多 地方 发生 变动 ， 实际上 python3 ， 版本升级 ， 内置 模块 包 内部 发生 变动 ， 新 函数 类 。 这是 不可避免 ， python2 模块 包 官方 提醒 废弃 ， 值得 。 一块 ， 平时 阅读 官方 文档 （ 变动 官方 文档 都 会 ） 。",
            "tags":"python_language",
            "url":"articles/python2he-python3de-jian-rong-xing.html"
        },
        {
            "title":"sqlalchemy模块",
            "text":"前言   本文 分为 两个 ， sqlalchemy 非 ORM ORM 。 推荐 ORM ， 代码 更 python ， 更 易读 易懂 。 ORM 要用 好 ， 很多 非 ORM 知识 , ， 笔者 实践 列出 非 ORM 常用 知识 ：   创建 Engine   理解 创建 Engine 有助于 很多 地方 理解 配置 sqlalchemy 数据库 连接   列 属性   列 数据类型   两个 必看 ， 定义 ORM 模型 参考   select 语句 理解 RowProxy 对象   理解 query 中 编写 select 语句   安装   sqlalchemy 安装简单 pip 命令 安装 即可 :   pip   install   sqlalchemy   引用 惯例   都 默认 引用 :     sqlalchemy   import   *   再 提及 ， 凡是     sqlalchemy   import     语句 都 归于 上 一条 引用 。 实践 中 不 推荐 全局 引用 。   简介   sqlalchemy 连接 数据库 ， 工作 做 ， 参考   sqlalchemy   architecture   一文 描述 :   数据库 相连 熟悉 DBAPI 接口 模块 ， :   sqlite3 ,   pymysql ,   psycopg2 ， 核心层 Engine ， 连接池 ， 方言 ， SQL 表达 语言 类型 系统 。 core 层 很 ， 实际上 模块 建构 core 层 之上 ， 不 要用 ORM 方法 。   非 ORM 风格   创建 Engine   创建 一个   Engine   对象 实际上 数据库 连接 操作 。   create _ engine   函数 创建 Engine 对象 ， 连接 数据库 ， 操作 才 会 去 连接 。   连接 sqlite3   连接 sqlite3   - memory   engine   =   create _ engine ( ' sqlite : / / ' )   推荐 采用 写法 :   engine   =   create _ engine ( ' sqlite : / / / : memory : ' )   谈及 sqlalchmy _ utils   database _ exists   函数 工作 。   连接 sqlite3   - disk   engine   =   create _ engine ( ' sqlite : / / / sqlite3 _ learning _ . db ' )   db 文件 创建 命令行 当前工作 目录 下 ， 相对路径 表达 。 还 写 上 绝对路径 表达 :   engine   =   create _ engine ( ' sqlite : / / / / absolute / path / / foo . db ' )   三个 斜杠 线 基础 上 还 加上 一个 斜杠 线 。 形式 通用 表达 ， 必定 两个 斜杠 线 ， 第二个 斜杠 线 第三个 斜杠 线 之间 登录 信息 描述 ， sqlite3 信息 ， 空 ， 所示 :   dialect : / / username : password @ host : port / database   方言 系统 再 加上 驱动 :   dialect + driver : / / username : password @ host : port / database   方言 :   sqlite :   默认 driver 官方   sqlite3   模块 ， 不 改动 。   mysql :   默认 dirver   mysql - python   ， 推荐   pymysql   ， pip 安装 。   engine   =   create _ engine ( ' mysql + pymysql : / / root @ localhost / test ' )   postgresql :   默认 driver   psycopg2   ， 还 行 。   oracle :   默认 driver   cx _ oracle   。   mssql :   默认 driver   pyodbc   。   连接 mysql   engine   =   create _ engine ( ' mysql + pymysql : / / localhost / mysql _ db ' )   确保 安装 pymysql :   pip   install   pymysql   连接 postgresql   engine   =   create _ engine ( ' postgres : / / rick : foo @ localhost : 5432 / pg _ db ' )   MetaData 对象   MetaData 对象 看作 Table 层 更 高 一级 抽象 ， 存放 Table 对象 metadata 描述 信息 。 一个 简单 理解 一个 MetaData 对象 看作 sqlalchemy 内部 database 概念 。   创建 一个 unbound   MetaData 对象     MetaData ( )   默认 创建 一个 unbound   MetaData 对象 。   metadata   =   MetaData ( )   bind 一个 Engine 对象   一个 unbound   MetaData 对象   bind   一个 Engine 对象 。   engine   =   create _ engine ( ' sqlite : / / ' )   metadata   =   MetaData ( )   metadata . bind   =   engine   创建 指定 :   engine   =   create _ engine ( ' sqlite : / / ' )   metadata   =   MetaData ( engine )   还 engine URL 表达 后台 自动 创建 一个 engine ， :   metadata   =   MetaData ( ' sqlite : / / ' )   初学者 最   BoundMetaData   ， 谈及 方法 创建 一个   BoundMetaData   对象 ， Table 对象 关联   BoundMetaData   对象 ， Table 对象 :   table . create ( )   创建 。   测试 数据库     sqlalchemy _ utils   想法 来自   网页   。     sqlalchemy   import   *     sqlalchemy _ utils   import   database _ exists   ,   create _ database   def   init _ sqlalchemy   (   dburl   ,   echo   =   True   ) :   engine   =   create _ engine   (   dburl   ,   echo   =   echo   )       database _ exists   (   engine   .   url   ) :   ### 确保 目标 数据库 。   create _ database   (   engine   .   url   )   metadata   =   MetaData   (   bind   =   engine   )   return   metadata   metadata   =   init _ sqlalchemy   (   ' sqlite : / / / test . db '   )     sqlalchemy _ utils   额外 安装 ， 利用   database _ exists   函数 检测 数据库 ， 不   create _ database   函数 创建 。     init _ sqlalchemy   函数 最 一个 参数   dburl   ， 细节 已 叙述 ， 正是 创建 Engine ， 基于 Engine 对象 创建 MetaData 对象 ， MetaData 对象 bind engine ， 返回 metadata 即可 ， metadata 。   实际操作 创建 一个 Table 对象 ， database 操作 ， 建议 如同 ， 都 提到 顶层 sqlalchemy _ utils 模块 。 类似   drop _ database   :   删除 database ， 参数 create _ database Engine 对象 url 。   创建 一个 Table 对象   一个 完整 例子 ， 创建 一个 Table 表格 。   db   谈及 MetaData 对象 ， 创建 Table 对象 第一个 参数 创建 SQL 表格 名字 ， 第二个 表格 bind MetaData 对象 ， 简单 理解 表格 对象 存入 MetaData 对象 代表 database 中 。 调用   db . create _ ( )   ， bind db 上 表格 都 创建 。 还   users . create ( )   单独 创建 表格 。     sqlalchemy   import   *     sqlalchemy _ utils   import   database _ exists   ,   create _ database   def   init _ sqlalchemy   (   dburl   ,   echo   =   True   ) :   engine   =   create _ engine   (   dburl   ,   echo   =   echo   )       database _ exists   (   engine   .   url   ) :   ### 确保 目标 数据库 。   create _ database   (   engine   .   url   )   metadata   =   MetaData   (   bind   =   engine   )   return   metadata   db   =   init _ sqlalchemy   (   ' sqlite : / / / test . db '   )   users   =   Table   (   ' users '   ,   db   ,   Column   (   ' user _ id '   ,   Integer   ,   primary _ key   =   True   ) ,   Column   (   ' '   ,   String   (   40   ) ) ,   Column   (   ' age '   ,   Integer   ) ,   Column   (   ' password '   ,   String   ) ,   )   db   .   create _   ( )   利用 已 Table   数据库 Table ， 创建 一个 Table 对象 ， 只 做 Table 对象 :   users   =   Table ( ' users ' , db , autoload = True )     autoload   设置 True 即可 。 db metadata ， bind metadata 对象 ， 还 未 bind ， 还 加上 autoload _ 参数 。   数据库 中 创建表格   metadata 对象 ， 调用   create _   方法 创建 表格 （   checkfirst   参数 。 ） :   db . create _ ( )   Table 对象 调用   create   方法 来自 创建 。 推荐 加上   checkfirst = True   设置 ， 就算 数据库 中该 表格 报错 。 所示 :   users . create ( checkfirst = True )   类似 用法 用于 安装 删除 表格 ， 表格 不 报错 :   users . drop ( checkfirst = True )   代码 改成 样子 :     :   users   =   Table   (   ' users '   ,   db   ,   autoload   =   True   )     sqlalchemy   .   exc   .   NoSuchTableError   :   users   =   Table   (   ' users '   ,   db   ,   Column   (   ' user _ id '   ,   Integer   ,   primary _ key   =   True   ) ,   Column   (   ' '   ,   String   (   40   ) ) ,   Column   (   ' age '   ,   Integer   ) ,   Column   (   ' password '   ,   String   ) ,   )     NoSuchTableError   ，   autoload = True   获取 Table 对象 数据库 中 不 ， 抛出 异常 。   列 属性 设置   创建表格 对象 一系列 参数 列 Column 对象 ， 第一个 参数 列 名字 ， 第二个 参数 该列 存储 值 类型 ， 还 可选项 属性 进一步 修饰 。 所示 :   primary _ key :   设置 列为 主键 列 称之为 主键 约束   unique :   该列 加上 唯一 约束 ， 列 值 重复 。 主键 约束 一种 唯一 约束 。   nullable :   该列 为空   default :   该列 默认值 设置   index :   该列 索引   auto _ increment :   Integer 列 数值 自动 递增   ForeignKey ( ' brand . id ' ) :   设置 外键 约束   CheckConstraint ( ' amount   >   0 ' ) :   设置 Check 约束   onupdate :   最 常见 用法 :   onupdate = datetime . utcnow   update 调用 callable 对象 。   列 数据类型 声明   列 存储 值 类型 描述 详细 介绍 ， 更 信息 请 参看 文档 查看 。   Class     Python   Type   SQL   Type   (   SQLitedriver )   Arguments   String   string   TEXT     VARCHAR   length   Integer   int   INTEGER     SmallInteger   int   SMALLINT     Numeric   float , Decimal   NUMERIC   precision = 10 ,   length = 2   Float   float   NUMERIC   precision = 10   DateTime   datetime . datetime   TIMESTAMP     time   datetime . time   TIME     Date   datetime . date   DATE     Binary   byte   string   BLOB   length   Boolean   bool   BOOLEAN     Unicode   unicode   TEXT     VARCHAR   length   大致 ， sqlalchemy 类名 大致 等同 ， 一个 上 名字 。   FLOAT :   等同于   Numeric   TEXT :   等同于   String   DECIMAL :   等同于   Numeric   INT :   等同于   Integer   INTEGER :   等同于   Integer   TIMESTAMP :   等同于   DateTime   DATETIME :   等同于   DateTime   CLOB :   等同于   String   VARCHAR :   等同于   String   CHAR :   等同于   String   NCHAR :   等同于   Unicode   BLOB :   等同于   Binary   BOOLEAN :   等同于   Boolean   mysql 方言 额外 类型   Class     Python   type   SQL   type   Arguments   MSEnum   string   ENUM   values   MSTinyInteger   int   TINYINT   length   MSBigInteger   int   BIGINT   length   MSDouble   float   DOUBLE   length = 10 , precision = 2   MSTinyText   string   TINYTEXT     MSMediumText   string   MEDIUMTEXT     MSLongText   string   LONGTEXT     MSNVarChar   unicode   NATIONAL   VARCHAR   length   MSTinyBlob   byte   string   TINYBLOB     MSMediumBlob   byte   string   MEDIUMBLOB     MSLongBlob   byte   string   LONGBLOB     MSBinary   byte   string   BINARY   length   MSVarBinary   byte   string   VARBINARY   length   MSSet   set   SET   set   values   MSYear   int   YEAR   length   MSBit   long   BIT   length   postgresql 额外 类型   Class     Python   type   SQL   type   Arguments   PGArray     TypeEngine   type   engine [ ]   TypeEngine   PGBigInteger   int , long   BIGINT     PGInet     INET     PGInterval     INTERVAL     Oracle 额外 类型   Class     Python   type   SQL   type   Arguments   Oracle   byte   string   RAW   length   JSON 支持   特别 值得 提 ， 主流 数据库 都 支持 JSON 数据 。 sqlalchemy JSON 字 段 类型 ， postgresql 很 早就 支持 ， mysql 版本   >   5.7 . 5   支持 ， 估计 大多 超过 版本 。   很 好 ， 强烈推荐 读者 去 下 ：   json _ data _ field   =   Column ( JSON )   insert 语句   谈及 Table 对象 调用   insert   方法 即可 一个 临时 表达 语句 对象 （ 大概 类似 东西 ， 词是 杜撰 。 ） ， 执行   i   =   users . insert ( )   :   > > >   type ( i )   < class   ' sqlalchemy . sql . dml . Insert ' >   > > >   str ( i )   ' INSERT   INTO   users   ( user _ id ,   ,   age ,   password )   VALUES   ( ,   ,   ,   ) '   > > >   i 临时 表达 语句 对象   execute   方法 ， 接受 参数 ， 所示 :   i   =   users . insert ( )   i . execute ( = ' Mary ' ,   age = 30 ,   password = ' secret ' )   语句 执行 ， 数据 插入 进 数据库 。 还 execute 方法 插入 多个 值 ， 所示 :   i . execute ( { ' ' :   ' John ' ,   ' age ' :   42 } ,   { ' ' :   ' Susan ' ,   ' age ' :   57 } ,   { ' ' :   ' Carl ' ,   ' age ' :   33 } )     insert   ignore   语句 ， :   i   =   users . insert ( ) . prefix _ ( '   ignore ' )   ' INSERT     ignore   INTO   users   ( user _ id ,   ,   age ,   password )   VALUES   ( ,   ,   ,   ) '   > > >   例子 sqlite 情况 ， mysql 写成   . prefix _ ( ' ignore ' )   形式 。   额外 值得一提的是 :   重复 刷 ， primary _ key ，   user _ id   指定 ， ignore 逻辑 基于 主键 列 不 重复 。   delete 语句   delete 语句 类似 insert 语句 谈及 ， SQL   delete 语句 情况 ， 其为 第一个 选 参数 过滤 字句 ， 所示 :   d   =   users . delete ( users . c . password   = =   None )   > > >   str ( d )   ' DELETE   FROM   users   WHERE   users . password   IS   NULL '     users . c . password   用法 ， 细节 再 讨论 ， 大体 users 表格 password 一列 其值 等于 None （ NULL ） ， python 中     None   写法 试 不行 。   delete 语句 users 表格 中 password 为空 行 都 删除 ， 构建 delete 语句 时 ， 不填 语句 ， 表格 记录 都 删除 。   d   =   users . delete ( )   update 语句   update 语句 ， 更新 几个 user password 。   update   语句 参数设置 :   update ( whereclause = None ,   values = None ,   inline = False ,   * * kwargs )   第一个 选 参数 delete   whereclause   过滤 字句 ， 第二个 values 一个 字典 值 ， 用来 设置 值 。 演示 构建 update 语句 风格 ， 风格   insert   ,   update   ,   select   语句 构建 。   u1   =   users . update ( )   u2   =   u1 . ( users . c .   = =   ' John ' ) . values ( password = ' 123456 ' )   > > >   str ( u1 )   ' UPDATE   users   SET   user _ id = ,   = ,   age = ,   password = '   > > >   str ( u2 )   ' UPDATE   users   SET   password =   WHERE   users .   =   '   str 显示 参数 打进去 ，   u2 . execute ( )   执行 会 实际效果 。   select 语句   select 语句 谈论   insert   语句 构建 过程 类似 ， SQL 中 select 语句 情况 较为 ， select 语句 还 查询 返回值 ， 东西 很多 。   看 函数 :   def   show _ squery   (   squery   ) :   res   =   squery   .   execute   ( )     r     res   :   print   (   r   )   select 语句 执行 返回   ResultProxy   对象 ， 语句 迭代 。 不带 参数 select 语句 返回 Table 行 :   > > >   show _ squery ( users . select ( ) )   ( 1 ,   ' Mary ' ,   30 ,   ' secret ' )   ( 2 ,   ' John ' ,   42 ,   ' 123456 ' )   ( 3 ,   ' Susan ' ,   57 ,   None )   ( 4 ,   ' Carl ' ,   33 ,   None )   :   > > >   show _ squery ( users . select ( users . c . = = ' John ' ) )   ( 2 ,   ' John ' ,   42 ,   ' 123456 ' )   这是   _     &   用法 :   > > >   show _ squery ( users . select ( _ ( users . c . age   <   40   ,   users . c .   ! =   ' Mary ' ) ) )   ( 4 ,   ' Carl ' ,   33 ,   None )   > > >   show _ squery ( users . select ( ( users . c . age   <   40 )   &   ( users . c .   ! =   ' Mary ' ) ) )   ( 4 ,   ' Carl ' ,   33 ,   None )   类似   _     |   做 逻辑   ;     _     \" ~ \"   做 逻辑 非 。     startswith   ,     ,   endswith   users . select ( users . c . . startswith ( ' M ' ) )       ,   _   :   users . select ( users . c . age . ( 30 , 39 ) )   users . select ( users . c . . _ ( ' Mary ' ,   ' Susan ' ) )   ResultProxy 对象   select 语句 执行 后 返回 ResultProxy 对象 迭代 外 方法 。   fetchone :   取 一行 ，   RowProxy   对象 ， 可用 api 会 描述 。   fetchmany :   取 多行 ， 返回 一个 列表 ， 其内 装着   RowProxy   对象 。   fetchall :   取 行 ， fetchmany 不 指定 size 等同于 取 行 ， 返回 一个 列表 ， 其内 装着   RowProxy   对象 。   scalar :   keys :   rowcount :   close :   RowProxy 对象   ResultProxy 对象 迭代 ， fetchone ， fetchmany ， fetchall 方法 ， RowProxy 对象 ， 数据库 一行 记录 。 对象 api 操作 很 灵活 ， 操作 一个 字典 操作 ， 类似 操作 namedtuple 般的 操作 ， 还 如同 列表   [ 0 ]   索引 方法 提取 一列 ， 所示 :   s   =   users . select ( )   rs   =   s . execute ( )   row   =   rs . fetchone ( )   > > >   row [ 0 ]   1   > > >   row .   ' Mary '   > > >   row [ ' password ' ]   ' secret '   多表 连接   代码 情况 所示 :   import   sqlalchemy     sqlalchemy   import   *     sqlalchemy _ utils   import   database _ exists   ,   create _ database   def   init _ sqlalchemy   (   dburl   ,   echo   =   True   ) :   engine   =   create _ engine   (   dburl   ,   echo   =   echo   )       database _ exists   (   engine   .   url   ) :   ### 确保 目标 数据库 。   create _ database   (   engine   .   url   )   metadata   =   MetaData   (   bind   =   engine   )   return   engine   ,   metadata   engine   ,   db   =   init _ sqlalchemy   (   ' sqlite : / / / test . db '   )     :   users   =   Table   (   ' users '   ,   db   ,   autoload   =   True   )     sqlalchemy   .   exc   .   NoSuchTableError   :   users   =   Table   (   ' users '   ,   db   ,   Column   (   ' id '   ,   Integer   ,   primary _ key   =   True   ) ,   Column   (   ' '   ,   String   (   40   ) ) ,   Column   (   ' age '   ,   Integer   ) ,   Column   (   ' password '   ,   String   ) ,   )   users   .   create   (   checkfirst   =   True   )   insert _ query   =   users   .   insert   ( )   .   prefix _   (   '   ignore '   )   insert _ query   .   execute   (   id   =   1   ,     =   ' Mary '   ,   age   =   30   ,   password   =   ' secret '   )   insert _ query   .   execute   ( {   ' id '   :   2   ,   ' '   :   ' John '   ,   ' age '   :   42   } ,   {   ' id '   :   3   ,   ' '   :   ' Susan '   ,   ' age '   :   57   } ,   {   ' id '   :   4   ,   ' '   :   ' Carl '   ,   ' age '   :   33   } )   delete _ query   =   users   .   delete   ( )   update _ query   =   users   .   update   ( )   update _ query   =   update _ query   .     (   users   .   c   .     = =   ' John '   )   .   values   (   password   =   ' 123456 '   )   update _ query   .   execute   ( )   def   run   (   query   ) :   query   .   execute   ( )   def   show _ squery   (   squery   ) :   res   =   squery   .   execute   ( )     r     res   :   print   (   r   )     :   emails   =   Table   (   ' emails '   ,   db   ,   autoload   =   True   )     sqlalchemy   .   exc   .   NoSuchTableError   :   emails   =   Table   (   ' emails '   ,   db   ,   Column   (   ' id '   ,   Integer   ,   primary _ key   =   True   ) ,   Column   (   ' address '   ,   String   ) ,   Column   (   ' user _ id '   ,   Integer   ,   ForeignKey   (   ' users . id '   ) ) ,   )   emails   .   create   (   checkfirst   =   True   )   insert _ query   =   emails   .   insert   ( )   .   prefix _   (   '   ignore '   )   insert _ query   .   execute   (   {   ' address '   :   ' mary @ . '   ,   ' user _ id '   :   1   } ,   {   ' address '   :   ' john @ . net '   ,   ' user _ id '   :   2   } ,   {   ' address '   :   ' john @ . org '   ,   ' user _ id '   :   2   } ,   {   ' address '   :   ' carl @ nospam . net '   ,   ' user _ id '   :   4   } ,   )   交叉 连接 笛卡尔 积   交叉 连接 情况 :   > > >   show _ squery ( select ( [ users , emails ] ) )   2015 - 10 - 28   20 : 27 : 21 , 721   INFO   sqlalchemy . engine . base . Engine   SELECT   users . id ,   users . ,   users . age ,   users . password ,   emails . id ,   emails . address ,   emails . user _ id   FROM   users ,   emails   2015 - 10 - 28   20 : 27 : 21 , 721   INFO   sqlalchemy . engine . base . Engine   ( )   ( 1 ,   ' Mary ' ,   30 ,   ' secret ' ,   1 ,   ' mary @ . ' ,   1 )   ( 1 ,   ' Mary ' ,   30 ,   ' secret ' ,   2 ,   ' john @ . net ' ,   2 )   ( 1 ,   ' Mary ' ,   30 ,   ' secret ' ,   3 ,   ' john @ . org ' ,   2 )   ( 1 ,   ' Mary ' ,   30 ,   ' secret ' ,   4 ,   ' carl @ nospam . net ' ,   4 )   ( 2 ,   ' John ' ,   42 ,   ' 123456 ' ,   1 ,   ' mary @ . ' ,   1 )   ( 2 ,   ' John ' ,   42 ,   ' 123456 ' ,   2 ,   ' john @ . net ' ,   2 )   ( 2 ,   ' John ' ,   42 ,   ' 123456 ' ,   3 ,   ' john @ . org ' ,   2 )   ( 2 ,   ' John ' ,   42 ,   ' 123456 ' ,   4 ,   ' carl @ nospam . net ' ,   4 )   ( 3 ,   ' Susan ' ,   57 ,   None ,   1 ,   ' mary @ . ' ,   1 )   ( 3 ,   ' Susan ' ,   57 ,   None ,   2 ,   ' john @ . net ' ,   2 )   ( 3 ,   ' Susan ' ,   57 ,   None ,   3 ,   ' john @ . org ' ,   2 )   ( 3 ,   ' Susan ' ,   57 ,   None ,   4 ,   ' carl @ nospam . net ' ,   4 )   ( 4 ,   ' Carl ' ,   33 ,   None ,   1 ,   ' mary @ . ' ,   1 )   ( 4 ,   ' Carl ' ,   33 ,   None ,   2 ,   ' john @ . net ' ,   2 )   ( 4 ,   ' Carl ' ,   33 ,   None ,   3 ,   ' john @ . org ' ,   2 )   ( 4 ,   ' Carl ' ,   33 ,   None ,   4 ,   ' carl @ nospam . net ' ,   4 )   内 连接   内 连接 情况 :   > > >   show _ squery ( select ( [ users , emails ] , users . c . id   = =   emails . c . user _ id ) )   2015 - 10 - 28   20 : 39 : 09 , 173   INFO   sqlalchemy . engine . base . Engine   SELECT   users . id ,   users . ,   users . age ,   users . password ,   emails . id ,   emails . address ,   emails . user _ id   FROM   users ,   emails   WHERE   users . id   =   emails . user _ id   2015 - 10 - 28   20 : 39 : 09 , 173   INFO   sqlalchemy . engine . base . Engine   ( )   ( 1 ,   ' Mary ' ,   30 ,   ' secret ' ,   1 ,   ' mary @ . ' ,   1 )   ( 2 ,   ' John ' ,   42 ,   ' 123456 ' ,   2 ,   ' john @ . net ' ,   2 )   ( 2 ,   ' John ' ,   42 ,   ' 123456 ' ,   3 ,   ' john @ . org ' ,   2 )   ( 4 ,   ' Carl ' ,   33 ,   None ,   4 ,   ' carl @ nospam . net ' ,   4 )   sqlalchemy 一种 更 智能 内 连接 用法 :   > > >   show _ squery ( join ( users ,   emails ) . select ( ) )   2015 - 10 - 28   20 : 40 : 17 , 502   INFO   sqlalchemy . engine . base . Engine   SELECT   users . id ,   users . ,   users . age ,   users . password ,   emails . id ,   emails . address ,   emails . user _ id   FROM   users   JOIN   emails   ON   users . id   =   emails . user _ id   2015 - 10 - 28   20 : 40 : 17 , 502   INFO   sqlalchemy . engine . base . Engine   ( )   ( 1 ,   ' Mary ' ,   30 ,   ' secret ' ,   1 ,   ' mary @ . ' ,   1 )   ( 2 ,   ' John ' ,   42 ,   ' 123456 ' ,   2 ,   ' john @ . net ' ,   2 )   ( 2 ,   ' John ' ,   42 ,   ' 123456 ' ,   3 ,   ' john @ . org ' ,   2 )   ( 4 ,   ' Carl ' ,   33 ,   None ,   4 ,   ' carl @ nospam . net ' ,   4 )   外 连接   外 连接 所示 ， 写入 顺序 。 第一个 连接 第二个 ， 过滤 条件 data 收进来 ， NULL 填充 。   > > >   show _ squery ( outerjoin ( users ,   emails ) . select ( ) )   2015 - 10 - 28   20 : 41 : 16 , 610   INFO   sqlalchemy . engine . base . Engine   SELECT   users . id ,   users . ,   users . age ,   users . password ,   emails . id ,   emails . address ,   emails . user _ id   FROM   users   LEFT   OUTER   JOIN   emails   ON   users . id   =   emails . user _ id   2015 - 10 - 28   20 : 41 : 16 , 610   INFO   sqlalchemy . engine . base . Engine   ( )   ( 1 ,   ' Mary ' ,   30 ,   ' secret ' ,   1 ,   ' mary @ . ' ,   1 )   ( 2 ,   ' John ' ,   42 ,   ' 123456 ' ,   3 ,   ' john @ . org ' ,   2 )   ( 2 ,   ' John ' ,   42 ,   ' 123456 ' ,   2 ,   ' john @ . net ' ,   2 )   ( 3 ,   ' Susan ' ,   57 ,   None ,   None ,   None ,   None )   ( 4 ,   ' Carl ' ,   33 ,   None ,   4 ,   ' carl @ nospam . net ' ,   4 )   > > >   show _ squery ( outerjoin ( emails ,   users ) . select ( ) )   2015 - 10 - 28   20 : 43 : 56 , 590   INFO   sqlalchemy . engine . base . Engine   SELECT   emails . id ,   emails . address ,   emails . user _ id ,   users . id ,   users . ,   users . age ,   users . password   FROM   emails   LEFT   OUTER   JOIN   users   ON   users . id   =   emails . user _ id   2015 - 10 - 28   20 : 43 : 56 , 590   INFO   sqlalchemy . engine . base . Engine   ( )   ( 1 ,   ' mary @ . ' ,   1 ,   1 ,   ' Mary ' ,   30 ,   ' secret ' )   ( 2 ,   ' john @ . net ' ,   2 ,   2 ,   ' John ' ,   42 ,   ' 123456 ' )   ( 3 ,   ' john @ . org ' ,   2 ,   2 ,   ' John ' ,   42 ,   ' 123456 ' )   ( 4 ,   ' carl @ nospam . net ' ,   4 ,   4 ,   ' Carl ' ,   33 ,   None )   ORM 风格   sqlalchemy 模块 面向对象 封装 改动 较大 ， 参考资料 1 2 内容 很多 都 过时 ， 没 办法 只好 看嚼 官方 文档 。   段 代码 :   import   sqlalchemy     sqlalchemy   import   *     sqlalchemy _ utils   import   database _ exists   ,   create _ database     sqlalchemy . ext . declarative   import   declarative _ base   engine   =   create _ engine   (   ' sqlite : / / / : memory : '   ,   echo   =   True   )       database _ exists   (   engine   .   url   ) :   ### 确保 目标 数据库 。   create _ database   (   engine   .   url   )   metadata   =   MetaData   (   bind   =   engine   )   Base   =   declarative _ base   (   bind   =   engine   )   class   User   (   Base   ) :   __ tablename __   =   ' users '   id   =   Column   (   Integer   ,   primary _ key   =   True   )     =   Column   (   String   )   fullname   =   Column   (   String   )   password   =   Column   (   String   )   def   __ init __   (     ,     ,   fullname   ,   password   ) :     .     =       .   fullname   =   fullname     .   password   =   password   def   __ repr __   (     ) :   return   ' < User   { }   > '   .   format   (     .     )   调用   User   类   __ table __   ， 其实质 - orm 风格 提及 Table 对象 。   > > >   User .__ table __   Table ( ' users ' ,   MetaData ( bind = Engine ( sqlite : / / / : memory : ) ) ,   Column ( ' id ' ,   Integer ( ) ,   table = < users > ,   primary _ key = True ,   nullable = False ) ,   Column ( ' ' ,   String ( ) ,   table = < users > ) ,   Column ( ' fullname ' ,   String ( ) ,   table = < users > ) ,   Column ( ' password ' ,   String ( ) ,   table = < users > ) ,   schema = None )   > > >   ORM 层 Session 对象 数据库 会话 :     sqlalchemy . orm   import   *   Session   =   sessionmaker   (   bind   =   engine   )   session   =   Session   ( )   先 session 数据库 CRUD （ CREATE   RETRIEVE   UPDATE   DELETE ） 操作 :   orm 层 创建 数据库   引入 orm 对象 ， 调用   __ table __   Table 对象 ， 调用   create   方法 即可 。   UserInfo .__ table __. create ( bind   = engine )   Warning :   单表 创建 外键 关系 ， 会 失败 。   官方 教程 推荐 ：   Base . metadata . create _ ( engine )   增加 记录   表格 增加 一条 记录 :   admin   =   User ( ' admin ' , ' administor ' , ' admin ' )   session . add ( admin )   #     add _   方法 一次性 添加 多个 orm 对象   session . commit ( )   session   add   一条 记录 ， 更改 称之为 - fly 更改 ， 谈及 基于 python 对象 操作 记录 属性 更改 ， 都 - fly 模式 。 执行   session . commit ( )   ， 更改 才 会 刷入 数据库 ， 更改 刷入 数据库 ， 代码 查询 操作 都 基于 改动 新 （ 看作 某种 形式 基于 内存 ） 数据库 。   SQL transaction 概念 ， SQL 数据库 transaction 数据 提交 保障 — — transaction 提交 失败 ， 将会 rollback 回滚 ， 保证 SQL 数据库 mess   。 session   rollback   方法 主动 回滚 ， - fly commit transaction 都 会 丢弃 。 session   commit   ， 这次 transaction 成功 提交 ， 下次 一个 新 transaction 。   查询 记录   谈及 - orm 风格 中 提到 select 语句 查询 ， orm 风格 查询 语句 精简 ， 脱离 select 语句 查询 本质 ， 熟悉 SQL select 语句 更好 学习 查询 语句 。   查询 起步 :   session . query ( User )   返回 orm 子 模块 Query 对象 。 User 查询 类 （ 表格 ） 。 简单 理解   query   方法 看作 select 操作   select   *     User   。   Query 对象 迭代 对象 ， 迭代 过程 中 返回   User   对象 。   写成 形式 :   session . query ( User . ,   User . fullname )   大致   select   , fullname     User   。   所示 :   > > >     i     session . query ( User ) :   ...   print ( i )   ...   < User   admin >   > > >   guest   =   User ( ' guest ' , ' guest ' , ' 123456 ' )   > > >   session . add ( guest )   > > >     , fullname     session . query ( User . , User . fullname ) :   ...   print ( , fullname )   ...   admin   administor   guest   guest   学习 SQL select 语句 学到   select         语句 还 跟上 字句 ， order   字句 。 sqlalchemy orm 封装 支持 额外 操作 ， query 语句 基础 上 进一步 操作 。 额外 操作 返回 Query 对象 ， 写 上   session . query ( User ) . filter _ ( ) . filter ( ) . order _ ( )   。 看上去 长 语句 ， 熟悉 SQL 语句 ， 做些 ， 。   过滤 排序 操作   filter 方法 :   filter 方法 select 语句 字句 。 官方 文档 例子 ， 复制到 熟悉 即可 ， 大多 含义 都 :   query . filter ( User .   = =   ' ed ' )   query . filter ( User .   ! =   ' ed ' )   query . filter ( User . . ( ' % ed% ' ) )   query . filter ( User . . _ ( [ ' ed ' ,   ' wendy ' ,   ' jack ' ] ) )   query . filter ( ~ User . . _ ( [ ' ed ' ,   ' wendy ' ,   ' jack ' ] ) ) #     query . filter ( User .   = =   None )   query . filter ( User .   ! =   None )   query . filter ( _ ( User .   = =   ' ed ' ,   User . fullname   = =   ' Ed   Jones ' ) )   query . filter ( _ ( User .   = =   ' ed ' ,   User .   = =   ' wendy ' ) )   filter _ 方法 :   filter _ 方法 类似 filter 方法 ， User . 写成 ， 引用 表格 列名 。   query . filter _ (   =   ' ed ' )   order _ 方法 :   select 语句 order   字句 。   order _ ( User . id ) [ 1 : 3 ]   还 揭示   Query   对象 很 一个 特性 ， 支持 python 切片 操作 。   返回   Query 对象 还 方法 还 返回 :   ( ) :   返回 一个 列表 ， 包含 。   ( ) :   返回 第一个 。 返回 None 。   ( ) :   一个 ， 多个 ， 抛出   MultipleResultsFound   异常 ， ， 抛出   NoResultFound   异常 。   scalar ( ) :   参考   网页 第五条   ， 执行 查询 ， 多条 记录 命中 ， 抛出 MultipleResultsFound   异常 ， 命中 ， 返回 None ， 命中 数为 一条 记录 ， 返回 记录   第一列   值 。   count ( ) :   返回 命中 记录 数 。   更 查询 例子   session . query ( Game ) . filter ( Game . release _ date   > =   ' 1999 - 01 - 01 ' )   text 函数   text 函数 用于 支持   filter     order _   方法 支持 原生 SQL 语句 表达 。 大致 所示 ， 下 即可 :     sqlalchemy   import   text   session . query ( User ) . filter ( text ( \" id < 224 \" ) ) . order _ ( text ( \" id \" ) )   更改 记录   更改 记录 ORM 封装 变得 很 简单 ， 查询 python 对象 ， 修改 即可 。   game   =   session . query ( Game ) . ( 1 )   game .   =   ' Super   Mario   Brothers '   session . commit ( )   删除 记录   session . delete ( jack )   批量 修改 删除   session . query ( Game ) . filter _ ( category = \" RPG \" ) . update ( { \" category \" :   \" ARPG \" } )   session . query ( Game ) . filter _ ( category = \" ARPG \" ) . delete ( )   ORM 层 关系   SQL 表格 四种 关系 ， - - ,   - - ,   - - ,   - - ， 实际上 都 基于 SQL 外键 约束 join 查询 。 - - - - 最 关系 模型 ， 之上 - - ， 三个 SQL 表格 搭建 关系 模型 很 好 理解 。 推荐 读者 阅读   篇文章   更好 理解 SQL 表格 四种 关系 模型 。 - - 实际上 - - 情形 ， - - 实际上 - - 模型 反向 ， 重点 - - 模型 。   - - 模型   sqlalchemy orm 层 - - 关系 高度 封装 ， 不 SQL join 连接 语法 细节 ， 只 声明 好 外键 约束 关系 约束 （ 看作 sqlalchemy 新 关系 约束 ） ， 神奇 SQL 表格 - - 特性 。   ORM 层 join 方法 暂时 SQL 表格 relationship 建立 细节 ， 再 讨论 更 实用 ORM 层 relationship 建立 写法 。   这是 示例 代码 :   import   sqlalchemy     sqlalchemy   import   *     sqlalchemy _ utils   import   database _ exists   ,   create _ database     sqlalchemy . ext . declarative   import   declarative _ base   engine   =   create _ engine   (   ' sqlite : / / / test . db '   ,   echo   =   True   )       database _ exists   (   engine   .   url   ) :   print   (   ' create     database '   )   create _ database   (   engine   .   url   )   metadata   =   MetaData   (   bind   =   engine   )   Base   =   declarative _ base   (   bind   =   engine   )   class   User   (   Base   ) :   __ tablename __   =   ' users '   id   =   Column   (   Integer   ,   primary _ key   =   True   )     =   Column   (   String   )   password   =   Column   (   String   )   def   __ init __   (     ,     ,   password   ) :     .     =       .   password   =   password   def   __ repr __   (     ) :   return   ' < User   { }   > '   .   format   (     .     )   class   Email   (   Base   ) :   __ tablename __   =   ' emails '   id   =   Column   (   Integer   ,   primary _ key   =   True   )   email   =   Column   (   String   )   user   =   Column   (   Integer   ,   ForeignKey   (   ' users . id '   ) )   def   __ init __   (     ,   email   ,   user   ) :     .   email   =   email     .   user   =   user   def   __ repr __   (     ) :   return   ' < Email   { }   > '   .   format   (     .   email   )   Base   .   metadata   .   create _   (   checkfirst   =   True   )   ###   create   table     sqlalchemy . orm   import   *   Session   =   sessionmaker   (   bind   =   engine   )   session   =   Session   ( )   admin   =   User   (   ' admin '   ,   ' admin '   )   session   .   add   (   admin   )   session   .   add _   ( [   User   (   ' Mary '   ,   ' secret '   ) ,   User   (   ' John '   ,   ' 123456 '   ) ,   User   (   ' Susan '   ,   ' 123456 '   ) ,   User   (   ' Carl '   ,   ' 123456 '   ) ] )   session   .   add _   ( [   Email   (   ' mary @ . '   ,   2   ) ,   Email   (   ' john @ . net '   ,   3   ) ,   Email   (   ' john @ . org '   ,   3   ) ,   Email   (   ' carl @ nospam . net '   ,   4   ) ] )   session   .   commit   ( )   sqliteman 观察 数据库 情况 :   session . query ( User , Email )   返回 笛卡尔 积 形式 :   > > >   session . query ( User , Email ) . ( )   [ ( < User   admin > ,   < Email   mary @ . > ) ,   ( < User   admin > ,   < Email   john @ . net > ) ,   ( < User   admin > ,   < Email   john @ . org > ) ,   ( < User   admin > ,   < Email   carl @ nospam . net > ) ,   ( < User   Mary > ,   < Email   mary @ . > ) ,   ( < User   Mary > ,   < Email   john @ . net > ) ,   ( < User   Mary > ,   < Email   john @ . org > ) ,   ( < User   Mary > ,   < Email   carl @ nospam . net > ) ,   ( < User   John > ,   < Email   mary @ . > ) ,   ( < User   John > ,   < Email   john @ . net > ) ,   ( < User   John > ,   < Email   john @ . org > ) ,   ( < User   John > ,   < Email   carl @ nospam . net > ) ,   ( < User   Susan > ,   < Email   mary @ . > ) ,   ( < User   Susan > ,   < Email   john @ . net > ) ,   ( < User   Susan > ,   < Email   john @ . org > ) ,   ( < User   Susan > ,   < Email   carl @ nospam . net > ) ,   ( < User   Carl > ,   < Email   mary @ . > ) ,   ( < User   Carl > ,   < Email   john @ . net > ) ,   ( < User   Carl > ,   < Email   john @ . org > ) ,   ( < User   Carl > ,   < Email   carl @ nospam . net > ) ]   调用 Query 对象   join   方法 执行 内 连接 :   > > >   session . query ( User , Email ) . join ( Email ) . ( )   [ ( < User   Mary > ,   < Email   mary @ . > ) ,   ( < User   John > ,   < Email   john @ . net > ) ,   ( < User   John > ,   < Email   john @ . org > ) ,   ( < User   Susan > ,   < Email   carl @ nospam . net > ) ]   > > >   一点 - - 影子 ， John 两个 Email 对象 。   稍加 过滤 条件 :   > > >   session . query ( User , Email ) . join ( Email ) . filter ( User .   = =   ' John ' ) . ( )   [ ( < User   John > ,   < Email   john @ . net > ) ,   ( < User   John > ,   < Email   john @ . org > ) ]   更 查询 email :   > > >   session . query ( User , Email . email ) . join ( Email ) . filter ( User .   = =   ' John ' ) . ( )   [ ( < User   John > ,   ' john @ . net ' ) ,   ( < User   John > ,   ' john @ . org ' ) ]   形式 :   > > >   session . query ( Email , User ) . join ( User ) . ( )   [ ( < Email   mary @ . > ,   < User   Mary > ) ,   ( < Email   john @ . net > ,   < User   John > ) ,   ( < Email   john @ . org > ,   < User   John > ) ,   ( < Email   carl @ nospam . net > ,   < User   Susan > ) ]   > > >   session . query ( Email , User ) . join ( User ) . filter ( User .   = =   ' John ' ) . ( )   [ ( < Email   john @ . net > ,   < User   John > ) ,   ( < Email   john @ . org > ,   < User   John > ) ]   内 连接 输出 一行 输出 内容   select     ， 行数 内容 描述 上 实际上 回事 。 一种 内 连接 顺序 。 利用 反向 查询 邮箱 User ， - - 数据模型 。   Query 对象   outerjoin   方法 ， 描述 关系 模型 ， 略过 。 介绍 ORM 层 更 实用 关系 定义方法 :   import   sqlalchemy     sqlalchemy   import   *     sqlalchemy . orm   import   *     sqlalchemy _ utils   import   database _ exists   ,   create _ database     sqlalchemy . ext . declarative   import   declarative _ base   engine   =   create _ engine   (   ' sqlite : / / / test . db '   ,   echo   =   True   )       database _ exists   (   engine   .   url   ) :   print   (   ' create     database '   )   create _ database   (   engine   .   url   )   metadata   =   MetaData   (   bind   =   engine   )   Base   =   declarative _ base   (   bind   =   engine   )   class   User   (   Base   ) :   __ tablename __   =   ' users '   id   =   Column   (   Integer   ,   primary _ key   =   True   )     =   Column   (   String   )   password   =   Column   (   String   )   email   =   relationship   (   \" Email \"   ,   backref   =   backref   (   ' user '   ) )   def   __ init __   (     ,     ,   password   ) :     .     =       .   password   =   password   def   __ repr __   (     ) :   return   ' & lt ; User   { }   & gt ; '   .   format   (     .     )   class   Email   (   Base   ) :   __ tablename __   =   ' emails '   id   =   Column   (   Integer   ,   primary _ key   =   True   )   email   =   Column   (   String   )   user _ id   =   Column   (   Integer   ,   ForeignKey   (   ' users . id '   ) )   def   __ init __   (     ,   email   ,   user _ id   ) :     .   email   =   email     .   user _ id   =   user _ id   def   __ repr __   (     ) :   return   ' & lt ; Email   { }   & gt ; '   .   format   (     .   email   )   Base   .   metadata   .   create _   (   checkfirst   =   True   )   ###   create   table   Session   =   sessionmaker   (   bind   =   engine   )   session   =   Session   ( )   admin   =   User   (   ' admin '   ,   ' admin '   )   session   .   add   (   admin   )   session   .   add _   ( [   User   (   ' Mary '   ,   ' secret '   ) ,   User   (   ' John '   ,   ' 123456 '   ) ,   User   (   ' Susan '   ,   ' 123456 '   ) ,   User   (   ' Carl '   ,   ' 123456 '   ) ] )   session   .   add _   ( [   Email   (   ' mary @ . '   ,   2   ) ,   Email   (   ' john @ . net '   ,   3   ) ,   Email   (   ' john @ . org '   ,   3   ) ,   Email   (   ' carl @ nospam . net '   ,   4   ) ] )   john   =   session   .   query   (   User   )   .   filter   (   User   .     = =   ' John '   )   .     ( )   e1   =   session   .   query   (   Email   )   .   filter   (   Email   .   email   = =   ' john @ . org '   )   .     ( )   :   > > >   john . email   [ < Email   john @ . net > ,   < Email   john @ . org > ]   > > >   e1 . user   < User   John >   确实 很 好 ， 模型 （ user ） （ email ） - - 模型 。   重点 介绍   relationship   一行 干 些 :   email   =   relationship ( \" Email \" , backref = backref ( ' user ' ) )   User   email 属性 ， 如上   john . email   调用 。   指定 Email （ ） 端 （ 理解 针对 Email 执行 内 连接 操作 ， sqlalchemy 内部 细节 还 不 ， 差不多 过程 。 ） ， 这样的话 User . email 值 某种 机制 大概 所示   > > >   session . query ( User , Email ) . join ( Email ) . filter ( User .   = =   ' John ' ) . ( )   > > >   [ ( < User   John > ,   < Email   john @ . net > ) ,   ( < User   John > ,   < Email   john @ . org > ) ]   User   John 回应 几个 Email 对象 。 过程 不 ， 但用 语句 理解 八九不离十 。   - - 模型   - - 模型 - - 模型 特例 ， 先 讲 ， 区别 很小 。   class   User ( Base ) :   __ tablename __   =   ' users '   id   =   Column ( Integer , primary _ key = True )     =   Column ( String )   password   =   Column ( String )   email   =   relationship ( \" Email \" , backref = backref ( ' user ' ) , uselist = False )   def   __ init __ ( , , password ) :   .   =     . password   =   password   def   __ repr __ ( ) :   return   ' < User   { } > ' . format ( . )   class   Email ( Base ) :   __ tablename __   =   ' emails '   id   =   Column ( Integer , primary _ key = True )   email   =   Column ( String )   user _ id   =   Column ( Integer , ForeignKey ( ' users . id ' ) )   def   __ init __ ( , email , user _ id ) :   . email   =   email   . user _ id   =   user _ id   def   __ repr __ ( ) :   return   ' < Email   { } > ' . format ( . email )   加上   uselist = False )   一句 ， 返回 Email 对象 。   - - 模型   - - 模型 实际上 - - 模型 回事 ， 如同   backref   设置 好 ， 针对 多个 Email 对象 实际上 找到 User 对象 ， 简单 见 ， - - 模型 理解 。   - - 模型   - - 模型 难于 理解 ， 是因为 还 一个 额外 Table 管理 原 两个 表格 之间 元素 映射 关系 ， 幸好 sqlalchemy 官方 文档 小节 做出 。 描述 一个 场景 一篇 博文 多个 标签 ， 一个 标签 多篇 博文 （ 简单 构建 出 一个 功能 ， 单击 一个 标签 按钮 ， 弹 出 标签 文章 ） 。 一个 博文 多个 标签 很 简单 ， 一个 - - 模型 解决 ， 大概   blog . tags   ， 弹出 一个 list ， 装着 标签 对象 。 关键性 出   tag . blogs   ， 弹出 一个 list ， 装着 博文 对象 。   篇文章   这幅 图片 中 :   情况 ， blog   - - ，   一个 表格 ， tag   - - ， 一个 表格 。 一方 存储 外键 约束 值 ， 表格 两列 ， 左列 外键 引用 blog ， 右列 外键 引用 tag ， 一个 映射 关系 都 写 一条 记录 。 不管怎么 说 ， 看 例子 :   # ! / usr / bin / env   python3   #   - * -   coding :   utf - 8   - * -   import   sqlalchemy     sqlalchemy   import   *     sqlalchemy . orm   import   *     sqlalchemy _ utils   import   database _ exists   ,   create _ database     sqlalchemy . ext . declarative   import   declarative _ base   engine   =   create _ engine   (   ' sqlite : / / / test2 . db '   ,   echo   =   True   )       database _ exists   (   engine   .   url   ) :   print   (   ' create     database '   )   create _ database   (   engine   .   url   )   metadata   =   MetaData   (   bind   =   engine   )   Base   =   declarative _ base   (   bind   =   engine   )   blog _ tags   =   Table   (   ' blog _ tags '   ,   Base   .   metadata   ,   Column   (   ' blog _ id '   ,   Integer   ,   ForeignKey   (   ' blogs . id '   ) ) ,   Column   (   ' tag _ id '   ,   Integer   ,   ForeignKey   (   ' tags . id '   ) ) )   class   Blog   (   Base   ) :   __ tablename __   =   ' blogs '   id   =   Column   (   Integer   ,   primary _ key   =   True   )   title   =   Column   (   String   )   body   =   Column   (   String   )   tags   =   relationship   (   \" Tag \"   ,   secondary   =   blog _ tags   ,   backref   =   backref   (   ' blogs '   ) )   def   __ init __   (     ,   title   ,   body   ) :     .   title   =   title     .   body   =   body   def   __ repr __   (     ) :   return   ' < BLog   { }   > '   .   format   (     .   title   )   class   Tag   (   Base   ) :   __ tablename __   =   ' tags '   id   =   Column   (   Integer   ,   primary _ key   =   True   )   tag   =   Column   (   String   )   def   __ init __   (     ,   tag   ) :     .   tag   =   tag   def   __ repr __   (     ) :   return   ' < Tag   { }   > '   .   format   (     .   tag   )   Base   .   metadata   .   create _   (   checkfirst   =   True   )   ###   create   table   Session   =   sessionmaker   (   bind   =   engine   )   session   =   Session   ( )   blog1   =   Blog   (   ' learning   mysql '   ,   '     learning   mysql '   )   tag1   =   Tag   (   ' python '   )   blog2   =   Blog   (   ' learning   sqlalchemy '   ,   '     learning   sqlalchemy '   )   tag2   =   Tag   (   ' sql '   )   tag3   =   Tag   (   ' sqlalchemy '   )   tag4   =   Tag   (   ' mysql '   )   blog1   .   tags   .   append   (   tag2   )   blog1   .   tags   .   append   (   tag4   )   blog2   .   tags   .   append   (   tag1   )   blog2   .   tags   .   append   (   tag2   )   blog2   .   tags   .   append   (   tag3   )   session   .   add _   ( [   blog1   ,   blog2   ,   tag1   ,   tag2   ,   tag3   ,   tag4   ] )   session   .   commit   ( )   生成 表格 所示 :   执行 :   > > >   blog1   < BLog   learning   mysql >   > > >   blog1 . tags   [ < Tag   sql > ,   < Tag   mysql > ]   > > >   blog2   < BLog   learning   sqlalchemy >   > > >   blog2 . tags   [ < Tag   python > ,   < Tag   sql > ,   < Tag   sqlalchemy > ]   > > >   tag1   < Tag   python >   > > >   tag1 . blogs   [ < BLog   learning   sqlalchemy > ]   > > >   tag2 . blogs   [ < BLog   learning   mysql > ,   < BLog   learning   sqlalchemy > ]   关键 建立 一个 表格 :   blog _ tags   =   Table ( ' blog _ tags ' , Base . metadata ,   Column ( ' blog _ id ' , Integer , ForeignKey ( ' blogs . id ' ) ) ,   Column ( ' tag _ id ' , Integer , ForeignKey ( ' tags . id ' ) ) )   建立 一个 relationship :   tags   =   relationship ( \" Tag \" , secondary = blog _ tags , backref = backref ( ' blogs ' ) )     secondary   参数 指定 新建 表格 ， 表格 数据 都 不 操心 ， 只 上   blog1 . tags   属性 （ 一个 列表 ） 操作 就行了 。   利用 ORM 层来 很 简单 ， 不敢想像 sqlalchemy 底层 到底 做 工作 ， 不得不 承认 ， sqlalchemy   Great 地方 。 值得一提 地方 两个 表格 都 外键 约束 ， 说 关系 连接 工作 抽象 一个 表格 。   ， 类似 - - ， 管理 方 表格 ， 回引 backref 方 对象 属性 ， 定义 一个 表格 就行了 。 - - 数据模型 很 有用 。   删除 动作   manytomany 例子 append 一个 元素 ， 删除 一个 元素 ， 调用 remove 方法 即可 ：   blog . tags . remove ( _ tag _ object )   高级 议题   cascade   定义 基于 关系 删除   items   =   relationship ( \" Item \" ,   cascade = \" ,   delete - orphan \" )   默认值   save - update   merge   save - update   指 一个 对象   Session . add ( )   ， 对象 都 应 加进去 。   merge   Session . merge   最       delete - orphan     指   save - update   merge   refresh - expire   expunge   delete   delete   Session . delete ， 默认 没加 delete ， 子 对象 parent _ id 赋 空值 ， 加 子 对象 删除 。   delete - orphan   增加 delete   删除 ， 子 对象 删除 ， 子 对象 执行 Session   delete 标记 ， 子子 对象 删除 delete 配合 。   自我 引用 表达 树状 结构   一个 SQL 表格 表达 出 树状 层级 结构 （ 很大 程度 上 弥补 python 语言 树状 结构 应付 能力 ） :   root   - - + - - - >   child1   + - - - >   child2   - - + - - >   subchild1   |   + - - >   subchild2   + - - - >   child3   写法 所示 :   class   Folder   (   db   .   Model   ) :   __ tablename __   =   ' folders '   id   =   db   .   Column   (   db   .   Integer   ,   primary _ key   =   True   )     =   db   .   Column   (   db   .   String   (   400   ) ,   nullable   =   False   )   description   =   db   .   Column   (   db   .   String   (   800   ) )   parent _ id   =   db   .   Column   (   db   .   Integer   ,   db   .   ForeignKey   (   ' folders . id '   ) )   children   =   db   .   relationship   (   \" Folder \"   ,   backref   =   db   .   backref   (   ' parent '   ,   remote _ side   =   [   id   ] ) )     parent _ id   NULL 最高级 节点 ， 一个 子 节点 都 描述   parent _ id   。 children 引用 ， 大体 类似   - -   写法 ， 一个 节点 多个 子 节点 ， 。 唯一 区别 设置   remote _ side = [ id ]   ， 写法   remote _ side = id   ， parent _ id 本地 local 端的 ， id 列是 remote 端的 。 更 信息 请 参看   官方 文档   。   面向 ORM 内省 机制   原 数据库 表格 ， 提及 :   users   =   Table ( ' users ' , db , autoload = True )   自动 内省 表格 ， 面向 ORM 写法 中 ， 。 请 参看   官方 文档   。 最 核心 代码 :   engine   =   create _ engine ( ' sqlite : / / / session . db ' )     sqlalchemy . ext . automap   import   automap _ base   AutoBase   =   automap _ base ( bind   =   engine )   class   OldTable ( AutoBase ) :   __ tablename __   =   NewTable .__ tablename __   schema 任意 改动 ， 扩展 SQL 数据库 ， 搭建 关系 ， 实在 改动 schema ， 推荐 采用 migrate 机制 。 写 一个 简单 migrate 脚本 :   # ! / usr / bin / env   python3   #   - * -   coding :   utf - 8   - * -     __ future __   import   print _ function     __ future __   import   unicode _ literals   import   sqlalchemy     sqlalchemy   import   *     sqlalchemy . orm   import   *     sqlalchemy _ utils   import   database _ exists   ,   create _ database     sqlalchemy . ext . automap   import   automap _ base     sqlalchemy . ext . declarative   import   declarative _ base   _ engine   =   create _ engine   (   ' sqlite : / / / _ session . db '   )   Base   =   declarative _ base   (   bind   =   _ engine   )   _ engine   =   create _ engine   (   ' sqlite : / / / session . db '   )   class   User   (   Base   ) :   __ tablename __   =   ' user '   id   =   Column   (   Integer   ,   primary _ key   =   True   )   username   =   Column   (   String   (   80   ) ,   unique   =   True   )   password   =   Column   (   String   (   80   ) )   def   __ init __   (     ,   username   ,   password   ,   * *   kwargs   ) :   ' ' ' kwargs 用于 收集 废 参数 ' ' '     .   username   =   username     .   password   =   password   def   __ repr __   (     ) :   return   ' & lt ; User   { }   & gt ; '   .   format   (     .   username   )   def   migrate _ database   (   NewTable   ,   fromdb   ,   todb   ) :       database _ exists   (   fromdb   .   url   ) :   raise   Exception     :   NewTable   .   __ table __   .   create   (   checkfirst   =   True   )   ###   create   table   AutoBase   =   automap _ base   (   bind   =   fromdb   )   class   OldTable   (   AutoBase   ) :   __ tablename __   =   NewTable   .   __ tablename __   AutoBase   .   prepare   (   fromdb   ,   reflect   =   True   )   Session   =   sessionmaker   (   bind   =   fromdb   )   _ session   =   Session   ( )   Session   =   sessionmaker   (   bind   =   todb   )   _ session   =   Session   ( )     q     _ session   .   query   (   OldTable   )   .     ( ) :   add _   =   NewTable   (   * *   q   .   __ dict __   )   _ session   .   add   (   add _   )   _ session   .   commit   ( )   print   (   ' '   )     __ __   = =   ' __ main __ '   :   migrate _ database   (   User   ,   _ engine   ,   _ engine   )   多个 表格 加上 关系 情况 变得 更 ， 脚本   AutoBase . prepare ( fromdb ,   reflect = True )   建立 内省 模型 关系 ， 多个 表格 ， 这句 话 再 放到 些 。 添加 新 数据 sqlalchemy 自动 相关 关系 对象 功能 ， 倒 不 大 ， 会 。 模块 迁移 数据库 ， 绝不 一件 轻松 事 。 SQL 表格 尽量 设计 好 可扩展性 好 ， 太 精力 花 很 浪费 。   面向 ORM 数据 继承 机制   时间 补 上 。   额外 属性 支持   额外 属性 基于 SQL 表格 一列 属性 ， ORM 之上 建立 额外 属性 ， 基于 SQL 表格 一列 列 ， ORM 封装 之上 提供 便利 属性 接口 。   class   EmailAddress   (   Base   ) :   __ tablename __   =   ' email _ address '   id   =   Column   (   Integer   ,   primary _ key   =   True   )   _ email   =   Column   (   \" email \"   ,   String   )   @ hybrid _ property   def   email   (     ) :   \" \" \" Return         _ email           twelve   characters . \" \" \"   return     .   _ email   [ :   -   12   ]   @ email   .   setter   def   email   (     ,   email   ) :   \" \" \" Set         _ email ,   tacking       twelve   character     @ . . \" \" \"     .   _ email   =   email   +   \" @ . \"   一列 额外 别名   一列 额外 别名 指 创建 额外 列 ， ORM 层 针对 一列 额外 别名 做 类似 操作 。     sqlalchemy . ext . declarative   import   synonym _   class   MyClass   (   Base   ) :   __ tablename __   =   ' _ table '   id   =   Column   (   Integer   ,   primary _ key   =   True   )   status   =   Column   (   String   (   50   ) )   @ synonym _   (   \" status \"   )   @ property   def   job _ status   (     ) :   return   \" Status :   \"   +     .   status   等于 :   class   MyClass   (   Base   ) :   __ tablename __   =   ' _ table '   id   =   Column   (   Integer   ,   primary _ key   =   True   )   status   =   Column   (   String   (   50   ) )   @ property   def   job _ status   (     ) :   return   \" Status :   \"   +     .   status   job _ status   =   synonym   (   \" status \"   ,   descriptor   =   job _ status   )   该列 ORM 层   status     job _ status   操作 。 参考     。   多列 组合 唯一性 约束   请 参看   网页   。   ORM 层 ， :   class   Location ( Base ) :   __ tablename __   =   ' locations '   id   =   Column ( Integer ,   primary _ key   =   True )   customer _ id   =   Column ( Integer ,   ForeignKey ( ' customers . customer _ id ' ) ,   nullable = False )   location _ code   =   Column ( Unicode ( 10 ) ,   nullable = False )   __ table _ args __   =   ( UniqueConstraint ( ' customer _ id ' ,   ' location _ code ' ,   = ' _ customer _ location _ uc ' ) ,   )   flask _ sqlalchemy   db . UniqueConstraint   。   :   __ table _ args __   =   (   db . UniqueConstraint ( \" main _ directory \" ,   \" _ directory \" , \" filename \" ,   \" filext \" ) ,   )   Core 层 ， :   mytable   =   Table ( ' mytable ' ,   meta ,   #   ...   Column ( ' customer _ id ' ,   Integer ,   ForeignKey ( ' customers . customer _ id ' ) ) ,   Column ( ' location _ code ' ,   Unicode ( 10 ) ) ,   UniqueConstraint ( ' customer _ id ' ,   ' location _ code ' ,   = ' uix _ 1 ' )   )   ORM 层 内省   Table 层 利用 数据库 表格   reflect   概念 ， ORM 层多 很多 额外 东西 ， 最 关键   relationship   概念 ， sqlalchemy Automap 一章 解决 ORM 层 内省 。 更 详细 讨论 请 参看   官方 文档   。   最   建立 一个   automap _ base   对象 :     sqlalchemy . ext . automap   import   automap _ base   Base   =   automap _ base ( )   运行   prepare   方法 内省 :   Base . prepare ( engine ,   reflect = True )   sqlalchemy   ORM 层 类 :   User   =   Base . classes . user   #   Base . classes . ( ' user ' )   属性 引用 ， 这是 。 relationship ， 预先 定义 属性 ，   prepare   ， 预先 定义 东西 覆盖 自动 reflect 定义 ， 起到 矫正 作用 。 预先 定义 类 类 ，   Base . classes .   风格 再 获取 。   分表 策略   表格 数据 量过大 ， 建立 分表 策略 ， 值取 模来 表名 ， 先看 例子 ， 例子 参考   网页   。   class   NovelChapter   (   object   ) :   _ mapper   =   { }   @ staticmethod   def   model   (   book _ id   ) :   table _ index   =   book _ id   %   100   class _   =   ' NovelChapter _   { 0 }   '   .   format   (   table _ index   )   ModelClass   =   NovelChapter   .   _ mapper   .     (   class _   ,   None   )     ModelClass     None   :   ModelClass   =   type   (   class _   ,   (   Base   , ) ,   {   ' __ module __ '   :   __ __   ,   ' __ __ '   :   class _   ,   ' __ tablename __ '   :   ' bh _ _ chapter _   { 0 }   '   .   format   (   table _ index   ) ,   ' id '   :   Column   (   Integer   ,   primary _ key   =   True   ) ,   #   填写 目标 Model 字 段 定义   } )   NovelChapter   .   _ mapper   [   class _   ]   =   ModelClass   return   ModelClass   提供   . model   方法 ， 核心 利用 type 函数 生成 一个 类 ， 说 元类 编程 ， 参数 ：   class   =   type ( classname ,   superclasses ,   attributedict )     _ mapper   对象 一个 类 对象 缓存 ， 免得 重复 创建 。   例子 中 最 关键   __ tablename __   差异化 定制 。   附录   datetime 数据类型   sqlalchemy 中 DateTime   数据类型 默认值 跟着   datetime . datetime . utcnow   所示 :   created _ date   =   Column ( DateTime ,   default = datetime . datetime . utcnow )   参考 网页   测试   参考 网页   参考资料   essential   sqlalchemy   ;   author :   Rick   copeland   ; press : O ' REILLY   a   step     step   sqlalchemy   tutorial   sqlalchemy - essential - tutorial - - techniques   面向 django   orm 用户 sqlalchemy 教程",
            "tags":"python_companion",
            "url":"articles/sqlalchemy-module.html"
        },
        {
            "title":"requests模块",
            "text":"urllib . request 内置 模块   urllib . request 模块 稍微 ， 介绍   requests   模块 。   urlopen 函数   urlopen 函数 urllib 模块 request 子 模块 ， 提供 简单 获取 目标 url 网页内容 接口 。 一个 简单 例子 所示 ：     urllib . request   import   urlopen   import   socket   socket   .   setdefaulttimeout   (   10   )   urls   =   [   ' https : / / www . google . . cn '   ,   ' https : / / www . google . '   ,   ' http : / / www . google . . cn '   ]     url     urls   :     :   response   =   urlopen   (   url   )   html   =   response   .   read   ( )   .   decode   (   ' utf - 8 '   )   print   (   html   )     socket   .   timeout     error   :   print   (   error   )     OSError     error   :   print   (   error   )   刚 一个 稍显 例子 演示 ， ， 天朝 网络 特色 。 百度 url   http : / / www . baidu .   ， 大部分 情况 下 都 不用 操心 ， 处在 天朝 网络 大 背景 下 ， 早点 介绍 。 例子 返回 error 种类 间接 GFW 工作 原理 。   google . . cn https 连接 还 工作 （ 暂时 。 。 ） ， 会 慢 ， http 连接 会 返回 404 错误 ， 这是 天朝 网络 常见 网络 错误 ， 分析 GFW dns 投毒 。 google . 连接 http https 连接 都 会 返回 OSError 错误 ， 说 ： Network     unreachable ， GFW 后缀 google . url 硬件 级别 网络 掐断 。   urlopen 函数 第一个 参数 url 连接 不用 说 ， 很多 可选项 ， 很 参数   timeout   参数 ， socket 套 接字 工作 模式 相关 。 不 加上 timeout 参数 ， 墙 网站 会 尝试 程序 陷入 卡死 状态 。 会 介绍   urlretrieve   函数 ， urllib . request 模块 ， 函数 用于 网络 下载 东西 ， 内置 timeout 参数 ， 设置 全局 网络 socket timeout （ socket 模块 setdefaulttimeout 函数 ） ， 全局 timeout 设置 稍微 大 一点 。   套 接字 socket timeout 参数 控制 阻塞 时间 ， 网络 数据 不 传递 完 ， 好比 下载 过程 时间 ， timeout 控制 下载 时间 ， 超过 时间 返回 错误 。 有个 ， 程序 默认 全局 socket timeout 都 设置 10 秒 ， 会 urlretrieve 函数 下载 东西 ， 本身 超过 10 秒 ？ 参看 requests 文档     ， timeout 很 好 解释 ， 说 timeout 仅 连接 过程 ， 响应 体 下载 无关 。   网络 上 情况 比较复杂 ， 网络 异常 回避 话题 。 一个 简单 读取 网页 程序 跟上 异常 捕捉 ， 偏执 追求 程序 健壮 ， 做 工作 。   返回   urlopen 函数 返回 urllib . response 模块 Response 对象 ， 提供 简单 文件 风格 操作 接口 ，   read ( )   方法 ，   readline ( )   方法 ， 记住 read 返回   bytes 流   。   Response 对象   geturl ( )   方法 ， 返回 url 字符串 ，   info ( )   方法 ， 返回 一个 字典 值 ， 网页 信息 。 请 读者 试验 。   HTTPError URLError 异常     urllib . error   import   HTTPError   HTTPError URLError 子类 ， URLError OSError 子类 ， OSError 加载 模块 引用 ， 简单 OSError 捕捉 。   ContentTooShortError 异常     urllib . error   import   ContentTooShortError     urlretrieve   函数 下载 数据量 少于 预期 数据量 时 返回 错误 。   访问 网页 401   error   路由器 为例   192.168 . 1.1     192.168 . 0.1   ， 小 脚本 稍作 修改 ：     urllib . request   import   urlopen     urllib . error   import   HTTPError   import   socket   socket   .   setdefaulttimeout   (   10   )   url   =   ' http : / / 192.168 . 1.1 '     :   response   =   urlopen   (   url   )   html   =   response   .   read   ( )   .   decode   (   ' utf - 8 '   )   print   (   html   )     socket   .   timeout     error   :   print   (   url   ,   error   )     HTTPError     error   :     error   .   code   = =   401   :   print   (   url   ,   '     password ,     401   error '   )     :   print   (   url   ,   error   )     OSError     error   :   print   (   url   ,   error   )   运行 会 返回 ：   http : / / 192.168 . 1.1     password ,     401   error   返回 401 异常 ， 网页 网页 认证 才能 访问 。 一个 简单 小 脚本 附带 网页 认证 功能 ：     urllib . request   import   build _ opener   ,   HTTPBasicAuthHandler   ,   urlopen   import   urllib     urllib . error   import   HTTPError   import   getpass   import   socket   socket   .   setdefaulttimeout   (   10   )   url   =   ' http : / / 192.168 . 1.1 '     True   :   username   =   input   (   \" Username : \"   )   .   rstrip   ( )   password   =   getpass   .   getpass   ( )   .   rstrip   ( )   print   (   ' ... '   ,   username   ,   password   )   auth _ handler   =   HTTPBasicAuthHandler   ( )   auth _ handler   .   add _ password   (   realm   =   ' '   ,   uri   =   ' '   ,   user   =   username   ,   passwd   =   password   )     :   opener   =   build _ opener   (   auth _ handler   )   urllib   .   request   .   install _ opener   (   opener   )   ### install     gloably     urlopen         response   =   urlopen   (   url   )   print   (   ' I   found   '   ,   username   ,   password   )   break     socket   .   timeout     error   :   print   (   url   ,   error   )     HTTPError     error   :     error   .   code   = =   401   :   print   (   url   ,   '     password ,     401   error '   )     :   print   (   url   ,   error   )     OSError     error   :   print   (   url   ,   error   )   getpass 内置 模块 getpass 函数 提供 终端 输入 密码 不 显示 功能 。   build _ opener ( )   函数 ， 接受 一系列 handler ，   HTTPBasicAuthHandler   创建 一个 handler 实例 ，   add _ password   方法 用户名 密码 属性 ， realm uri 还 不 。 认证 网页 head 。   调用 urllib 子 模块 request   install _ opener   函数 ， 全局性 安装 openr ， urlopen 函数 会 opener 。 不 做 ， opener . open 单独 打开 一个 response ， 不 推荐 。   加上 代理 功能 翻墙   修改 最初 第一个 例子 ， 代理 功能 ， 理论 上 写 ， 效果 ， GFW 很 强大 。 。     urllib . request   import   urlopen   ,   build _ opener   import   urllib   import   socket   socket   .   setdefaulttimeout   (   10   )   urls   =   [   ' https : / / www . google . . cn '   ,   ' https : / / www . google . '   ,   ' http : / / www . google . . cn '   ]   proxy _ handler   =   urllib   .   request   .   ProxyHandler   ( {   ' http '   :   ' http : / / 127.0 . 0.1 : 8580 / '   } )   opener   =   urllib   .   request   .   build _ opener   (   proxy _ handler   )   urllib   .   request   .   install _ opener   (   opener   )     url     urls   :     :   response   =   urlopen   (   url   )   html   =   response   .   read   ( )   .   decode   (   ' utf - 8 '   )   print   (   html   )     socket   .   timeout     error   :   print   (   error   )     OSError     error   :   print   (   error   )   修改 url GET 数据   对接 搜索引擎 。     urllib . request   import   urlopen   import   urllib   import   socket   socket   .   setdefaulttimeout   (   10   )   # search _ engine   =   ' http : / / www . baidu . / '   # search _ engine   =   ' http : / / www . zhihu . / '   search _ engine   =   ' http : / / stackoverflow . / '   def   addGETdata   (   url   ,   string   ) :   p   =   urllib   .   parse   .   urlparse   (   url   )     p   .   netloc   = =   ' www . baidu . '   :   return   url   +   ' s '   +   urllib   .   parse   .   urlencode   ( {   ' wd '   :   string   } )   elif   p   .   netloc     [   ' www . zhihu . '   ,   ' stackoverflow . '   ] :   return   url   +   ' search '   +   urllib   .   parse   .   urlencode   ( {   ' q '   :   string   } )   url   =   addGETdata   (   search _ engine   ,   ' python   urllib '   )   print   (   url   )   pyout   =   open   (   ' test . html '   ,   ' w '   )     :   response   =   urlopen   (   url   )   html   =   response   .   read   ( )   .   decode   (   ' utf - 8 '   )   print   (   html   ,   file   =   pyout   )     socket   .   timeout     error   :   print   (   error   )     OSError     error   :   print   (   error   )   讲 addGETdata 函数 ， 修改 url 目标 形式 ， 都 ， 目标 搜索引擎 网站 。   POST 方法 获取数据   不太 灵活 ， baidu zhihu 两个 并不相同 ， 采用 POST 方法 ， 默认 中缀 search ， 不太 适合 ， 采用 POST 方法 伪装 头部 ， 网站 会 禁止 。 方法 略过 。 修改 url GET 很 简单 。   requests 模块 基础   网络 编程 推荐 requests 模块 ， 这是 requests   官网   ， 这是 中文 文档   链接   。 更 信息 请 参看 官方 文档 。   安装   安装 推荐 pip pip3 命令 简便 安装 。   HTTP 协议 支持   几个 函数 一看 名字 HTTP GET ， POST ， PUT DELETE 方法 ， HTTP 冷门 方法 HEAD OPTIONS   requests 模块 类似 head 函数 options 函数 。   函数   这是 第一个 例子 改写 ：   import   requests   urls   =   [   ' https : / / www . google . . cn '   ,   ' https : / / www . google . '   ,   ' http : / / www . google . . cn '   ]     url     urls   :     :   response   =   requests   .     (   url   ,   timeout   =   10   )   html   =   response   .   text   print   (   html   )     requests   .   exceptions   .   Timeout     error   :   print   (   url   ,   error   )     requests   .   exceptions   .   RequestException     error   :   print   (   url   ,   error   )   函数 HTTP GET 方法 获取 网页 内容 ，   socket 全局 设置 timeout   ， 设置 一个 timeout 参数 。 提取 文本 内容 简单 调用 text 属性 即可 ， 错误 捕捉 ， 不 赘述 。   params 参数   params 参数 url 关键词 值 ， 带点 提及 urlencode 函数 功能 ， 语句 简洁 。 类似 例子 演示 ：   import   requests   import   urllib   ###     urlparse   search _ engines   =   (   ' http : / / www . baidu . / s '   ,   ' http : / / www . zhihu . / search '   ,   ' http : / / stackoverflow . / search '   ,   ' http : / / www . . / web '   ,   ' http : / / search . yahoo . / search '   ,   ' http : / / cn . bing . / search '   ,   ' https : / / www . google . / # '   ,   ' https : / / zh . wikipedia . org / w / index . php '   ,   ' https : / / en . wikipedia . org / wiki / '   ,   )   def   addGETparams   (   url   ,   search _ string   ) :   p   =   urllib   .   parse   .   urlparse   (   url   )     p   .   netloc   = =   ' www . baidu . '   :   return   {   ' wd '   :   search _ string   }   elif   p   .   netloc     [   ' www . zhihu . '   ,   ' stackoverflow . '   ,   ' cn . bing . '   ,   ' www . . '   ,   ' www . google . '   ] :   return   {   ' q '   :   search _ string   }   elif   p   .   netloc     [   ' search . yahoo . '   ] :   return   {   ' p '   :   search _ string   }   elif   p   .   netloc     [   ' zh . wikipedia . org '   ,   ' en . wikipedia . org '   ] :   return   {   ' search '   :   search _ string   }   search _ engine   =   search _ engines   [   2   ]   params   =   addGETparams   (   search _ engine   ,   ' python '   )   pyout   =   open   (   ' test . html '   ,   ' w '   )     :   response   =   requests   .     (   search _ engine   ,   timeout   =   10   ,   params   =   params   )   print   (   response   .   url   )   html   =   response   .   text   print   (   html   ,   file   =   pyout   )     requests   .   exceptions   .   Timeout     error   :   print   (   url   ,   error   )     requests   .   exceptions   .   RequestException     error   :   print   (   url   ,   error   )   pyout   .   close   ( )   search _ engin 原始 url 做 修改 ， 语法 简洁 。   post 函数   函数 ：   response   =   requests . put ( \" http : / / httpbin . org / put \" )   data 参数   data 参数 ， POST 方法 传输 数据 ， 字符串 ， 字典 值 ， json 数据 （ json 模块 dumps 函数 ） 。   > > >   payload   =   { ' key1 ' :   ' value1 ' ,   ' key2 ' :   ' value2 ' }   > > >   r   =   requests . post ( \" http : / / httpbin . org / post \" ,   data = payload )   headers 属性   接受 一个 字典 值 ， 用于 定制 POST 方法 HTTP 请求 头 。   put 函数   暂时 略过 。   delete 函数   暂时 略过 。   返回 reponse 响应 对象   函数 返回 reponse 对象   url 属性   返回 响应 url   text 属性   返回 响应 文本 内容   encoding 属性   返回 响应 encoding 。   content 属性   返回 响应 二进制 形式 。 利用 属性 下载 文件 。   download _ file   函数 参考   网页   。     stream   =   True   参数设置 ，   def   download _ file   (   url   ,   filefold   =   ' download '   ) :   ' ' ' 简单 url 下载 文件 函数 ， filefold 下载 文件 存放 下 一级 文件夹 名 ' ' '     :   os   .   mkdir   (   filefold   )     FileExistsError   :   pass   filename   =   ' . / '   +   filefold   +   ' / '   +   url   .   split   (   ' / '   ) [   -   1   ]   #   NOTE     stream = True   parameter   response   =   requests   .     (   url   ,   stream   =   True   )     open   (   filename   ,   ' wb '   )     f   :     chunk     response   .   iter _ content   (   chunk _ size   =   1024   ) :     chunk   :   #   filter     - alive     chunks   f   .   write   (   chunk   )   f   .   flush   ( )   return   filename   json 方法   响应 json 文件 ， 调用 方法 自动 json 文件 解码 （ 相当于 json 模块 loads ） 。   status _ code 属性   响应 状态 码 ， 404 。   headers 方法   服务器 响应 HTTP 头 信息 。   _ redirects   GET   OPTIONS   POST   PUT   PATCH   DELETE   方法 重定向 默认 打开   True   HEAD 方法 默认 重定向 关闭 。   timeout 参数   timeout 参数 控制 ， 超时 抛出   requests . exceptions . Timeout   异常 。   异常   异常 下 ：   网络 （ ： DNS 查询 失败 、 拒绝 连接 ） 时 ， Requests 会 抛出 一个   ConnectionError   异常 。   罕见 无效 HTTP 响应 时 ， Requests 会 抛出 一个   HTTPError   异常 。   请求 超时 ， 抛出 一个   Timeout   异常 。   请求 超过 设定 重定向 次数 ， 会 抛出 一个   TooManyRedirects   异常 。   Requests 显式 抛出 异常 都 继承   requests . exceptions . RequestException   。   requests 模块 高级 篇   会话   会话 对象 跨 多个 requests 请求 对象 参数设置 ， cookies 。   Session 对象 requests   API 方法 ， ， post 。 会话 对象 设置 参数 都 会 保留 ， 调用 方法 还 加上 额外 参数设置 ， 所示 :   s   =   requests . Session ( )   s . auth   =   ( ' user ' ,   ' pass ' )   s . headers . update ( { ' x - test ' :   ' true ' } )   #     ' x - test '     ' x - test2 '       s . ( ' http : / / httpbin . org / headers ' ,   headers = { ' x - test2 ' :   ' true ' } )   SSL 验证   加上   verify = True   目标 主机 SSL 验证 。   响应 体 content   响应 体 含有 content 却 内容 情况 ，   Stream = True   推迟 content 下载 ， 只 获取 header 信息 。   response . content   才 下载 content 。     Response . iter _ content     Response . iter _ lines   方法 控制 工作 流 ，   Response . raw   底层 urllib3 读取 响应 对象 。   response . iter _ content   iter _ content ( chunk _ size = 1 ,   decode _ unicode = False )   迭代 读取 响应 体 content 内容 ， 设置 读取   chunk _ size   。   response . iter _ lines   iter _ lines ( chunk _ size = 512 ,   decode _ unicode = None )   迭代 读取 响应 体 content 内容 ， 读 一行 。 行 内容 小于 chunk _ size ， 不 设置 即可 。   身份验证   > > >     requests . auth   import   HTTPBasicAuth   > > >   requests . ( ' https : / / api . github . / user ' ,   auth = HTTPBasicAuth ( ' user ' ,   ' pass ' ) )   < Response   [ 200 ] >   > > >   requests . ( ' https : / / api . github . / user ' ,   auth = ( ' user ' ,   ' pass ' ) )   < Response   [ 200 ] >   代理   import   requests   proxies   =   {   \" http \" :   \" http : / / 10.10 . 1.10 : 3128 \" ,   \" https \" :   \" http : / / 10.10 . 1.10 : 1080 \" ,   }   requests . ( \" http : / / . org \" ,   proxies = proxies )   附录   HTTP 补充 理论知识   HTTP 协议 支持 四种 方法 ：   GET :   web   service   提取 信息   POST :   web   service   发送信息   PUT :   web   service   更新 信息   DELETE :   web   service   删除 信息   GET POST 区别   参考   网页   。 谈及 修改 网页 url 获取 资源 ， 实质 HTTP GET 方法 ， GET 方法 信息 放在 url 上 ， web   service 服务器 会 分析 url ， 客户机 回应 方式 。 POST 方法 不 修改 url ， web   service 服务器 接受 url 上 额外 信息 ， POST 方法 会 传输 一个 信息 包 。 GET 方法 服务器 互动 采用 GET 方法 ， url 局限性 ， GET 方法 不 ， 服务器 支持 POST 方法 互动 。 PUT DELETE 方法 少用 ， 服务器 不 支持 冷门 方法 。   HTTP 返回 错误码 含义   100 :   ( ' Continue ' ,   ' Request   received ,     continue ' ) ,   101 :   ( ' Switching   Protocols ' ,   ' Switching       protocol ;   obey   Upgrade   header ' ) ,   200 :   ( ' OK ' ,   ' Request   fulfilled ,   document   ' ) ,   201 :   ( ' Created ' ,   ' Document   created ,   URL   ' ) ,   202 :   ( ' Accepted ' ,   ' Request   accepted ,   processing   continues   - line ' ) ,   203 :   ( ' Non - Authoritative   Information ' ,   ' Request   fulfilled     cache ' ) ,   204 :   ( ' No   Content ' ,   ' Request   fulfilled ,     ' ) ,   205 :   ( ' Reset   Content ' ,   ' Clear   input   form       input . ' ) ,   206 :   ( ' Partial   Content ' ,   ' Partial   content   . ' ) ,   300 :   ( ' Multiple   Choices ' ,   ' Object       resources   - -     URI   list ' ) ,   301 :   ( ' Moved   Permanently ' ,   ' Object   moved   permanently   - -     URI   list ' ) ,   302 :   ( ' Found ' ,   ' Object   moved   temporarily   - -     URI   list ' ) ,   303 :   ( ' See   Other ' ,   ' Object   moved   - -     Method     URL   list ' ) ,   304 :   ( ' Not   Modified ' ,   ' Document       changed       time ' ) ,   305 :   ( ' Use   Proxy ' ,   ' You       proxy       Location     access     '   ' resource . ' ) ,   307 :   ( ' Temporary   Redirect ' ,   ' Object   moved   temporarily   - -     URI   list ' ) ,   400 :   ( ' Bad   Request ' ,   ' Bad   request   syntax     unsupported   method ' ) ,   401 :   ( ' Unauthorized ' ,   ' No   permission   - -     authorization   schemes ' ) ,   402 :   ( ' Payment   Required ' ,   ' No   payment   - -     charging   schemes ' ) ,   403 :   ( ' Forbidden ' ,   ' Request   forbidden   - -   authorization       ' ) ,   404 :   ( ' Not   Found ' ,   ' Nothing   matches       URI ' ) ,   405 :   ( ' Method   Not   Allowed ' ,   ' Specified   method     invalid       server . ' ) ,   406 :   ( ' Not   Acceptable ' ,   ' URI         preferred   format . ' ) ,   407 :   ( ' Proxy   Authentication   Required ' ,   ' You     authenticate     '   '   proxy     proceeding . ' ) ,   408 :   ( ' Request   Timeout ' ,   ' Request   timed   ;       . ' ) ,   409 :   ( ' Conflict ' ,   ' Request   conflict . ' ) ,   410 :   ( ' Gone ' ,   ' URI     longer   exists         permanently   removed . ' ) ,   411 :   ( ' Length   Required ' ,   ' Client       Content - Length . ' ) ,   412 :   ( ' Precondition   Failed ' ,   ' Precondition     headers     false . ' ) ,   413 :   ( ' Request   Entity   Too   Large ' ,   ' Entity       large . ' ) ,   414 :   ( ' Request - URI   Too   Long ' ,   ' URI       long . ' ) ,   415 :   ( ' Unsupported   Media   Type ' ,   ' Entity   body     unsupported   format . ' ) ,   416 :   ( ' Requested   Range   Not   Satisfiable ' ,   ' Cannot   satisfy   request   range . ' ) ,   417 :   ( ' Expectation   Failed ' ,   ' Expect   condition         satisfied . ' ) ,   500 :   ( ' Internal   Server   Error ' ,   ' Server         trouble ' ) ,   501 :   ( ' Not   Implemented ' ,   ' Server       support     operation ' ) ,   502 :   ( ' Bad   Gateway ' ,   ' Invalid   responses       server / proxy . ' ) ,   503 :   ( ' Service   Unavailable ' ,   ' The   server     process     request   due     a   high   load ' ) ,   504 :   ( ' Gateway   Timeout ' ,   ' The   gateway   server       receive   a   timely   response ' ) ,   505 :   ( ' HTTP   Version   Not   Supported ' ,   ' Cannot   fulfill   request . ' ) ,   参考资料   Foundations     Python   Network   Programming   ， python 网络 编程 基础 ， [ 美 ]   John   Goerzen   著 ， 莫迟 译   。   计算机网络   [ 美 ]   特南 鲍姆   diveintopython3   web   services   一章   这是   中文 网页   。",
            "tags":"python_companion",
            "url":"articles/requests-module.html"
        },
        {
            "title":"pytest模块",
            "text":"unittest 模块   编写 python 测试代码 ， 学习 pytest 模块 ， 先 学习 python 官方 模块   unitest   。 上 例子 ：   import   unittest   import   math   class   TooBigError   (   Exception   ) :   pass   def     (   n   ) :     n   >   2   :   raise   TooBigError   (   '   big   input   error '   )     :   print   (   ' '   *   n   )   class   FirstTest   (   unittest   .   TestCase   ) :   def   setUp   (     ) :   \" \" \" setUp 函数 测试 单元 执行 前 执行 ， 用于 预先 配置   测试 单元 会 用到 参数 \" \" \"   pass   def   tearDown   (     ) :   \" \" \" tearDown 函数 测试 单元 执行 再 执行 。 \" \" \"   pass   def   test _ bool   (     ) :   \" \" \" 测试 单元 ， 名字 test 字符 \" \" \"     .   assertTrue   (   True   )     .   assertFalse   (   False   )   def   test _ equal   (     ) :     .   assertEqual   (   1   ,   1   )     .   assertNotEqual   (   1   ,   2   )     .   assertAlmostEqual   (   math   .   pi   ,   3.1416   ,   4   )     .   assertNotAlmostEqual   (   math   .   pi   ,   3.1415   ,   4   )   def   test _ raises   (     ) :     .   assertRaises   (   TooBigError   ,     ,   3   )     __ __   = =   ' __ main __ '   :   unittest   .   main   ( )   unittest 模块 main 函数 执行 测试 单元 类 ， 测试 单元 类 继承 unittest TestCase 类 。 继承 TestCase 类 中 ，   setUp   函数   tearDown   函数 用途 ， 见 代码 。 定义 函数 test 字符串 开头 都 测试 单元 ， 逐个 执行 。   TestCase 很多 方法 ，   assertTrue   ，   assertFalse   用于 断言 bool 值 真 假 ，   assertEqual   用来 断言 两个 值 ( = = ) ， 类似   assertNotEqual   用来 断言 两个 值 不 。 值得一提   assertAlmostEqual   方法 用来 断言 两个 float 值 小数位 上 大致 ， 例子 ，   \\ ( \\ pi \\ )   值 小数点 4 位是 3.1416 。 方法 还 额外 接受 一个 提示 字符串 参数 （ Msg 参数 ） ， 用来 断言 成功 时 补充 信息 。   assertRaises   方法 用来 断言 函数 接受 参数 返回 异常 。 方法 第一个 参数 期望 捕捉到 异常 ， 第二个 参数 调用 函数 ， 参数 送给 函数 ， 谈及 Msg 参数 。   更 信息 请 参看 模块   官方 文档   ， 大概 简单 下 unittest 模块 即可 ， 实践 中 推荐 pytest 模块 。   pytest 模块   pytest 模块 站 unittest 基础 上 ，   unittest   写 测试 案例 ， 都 不用 更改 照样 有用 ， 接下来 写 一个 新 测试 ， 不 再 新建 一个   unittest . TestCase   类 （ 希望 多个 测试 一个 类 ， 新建 一个 类 即可 ， 类 不 继承 类 。 ） ， 写 测试函数 ， 不 确认 最 简单   assert   确认 返回   True   即可 。   def   test _ prime   ( ) :   assert   prime   (   4   )   = =   7   确实 简单 不少 。 讨论 编写 单元测试 代码 中 知识 。   mock   写 单元测试 时 ， 涉及 网络 ， 套 接字 编程 ， 需求 ， 希望 伪造 数据 ， 拦截 函数 或类 返回值 ， 测试 大型软件 框架 中 抽离 ， mock 模块 。 mock 模块 unittest 模块 子 模块 ， 上 pytest ， mock 子 模块 很 有用 。     unittest   import   mock   mock 模块 最 关键性 理解 mock 做 。 mock 模块 最 核心 概念   Mock   类   ， 官方 文档 例子 ：     unittest   import   mock   class   Test ( ) :   pass   t   =   Test ( )   t . method   =   Mock ( return _ = 3 )   t . method   =   mock . Mock ( return _ = 3 )   t . method ( )   3   t . method ( 1 , 2 , 3 )   3   简单 伪造 一个 python 对象 ， 定制 特别 属性 方法 单元测试 代码 中 想要 python 对象 。 在实践中 推荐   MagicMock   ， MagicMock 继承 Mock ， 很多 python 对象 magic   method 【 一大堆   __ __   方法 】 。   fixture   mock 类 模拟 python 对象 ， 仿真 数据 ， 希望 仿真 数据 参数 测试函数 中 。   import   pytest   @ pytest   .   fixture   def   sample _ config   ( ) :   return   {   ' a '   :   1   }   def   test _ config _ read   (   sample _ config   ) :   assert   sample _ config   [   ' a '   ]   = =   1     tests   文件夹 新建 一个   conftest . py   文件 ， 定义 pytest fixture 全局 共享 。   确认 抛出 异常   官方 例子 copy ， 看 懂 。   import   pytest   def   f   ( ) :   raise   SystemExit   (   1   )   def   test _ mytest   ( ) :     pytest   .   raises   (   SystemExit   ) :   f   ( )   测试 下次 不 测试   希望 测试函数 测试 ， 不用 测试 ， 函数 加上 装饰器 。   @ pytest . mark . skip ( reason = \" i     test   \" )   写 python 模块 pytest 集成   推荐 安装 ：   pytest     pytest - runner   。 新建   setup . cfg   文件 ， 内容 ：   [ aliases ]   test = pytest   测试 输入 ：   python   setup . py   test   做 好处 ， 其是 利用 本地 修改 源码 ， 修改 源码 实时 测试 。   写 记得 pytest 传递 参数 加上   - - addopts =   选项 ， 打印 更 信息 ：   python   setup . py   test   - - addopts = \" - v \"   每次 写   - - addopts = \" - v \"   麻烦 ，   setup . cfg   上 加上 一句 ：   [ tool : pytest ]   addopts   =   - - verbose   好 ， ：   python   setup . py   test   专心 测试 写 代码 。   自动 发现 测试 文件   pytest 支持 自动 发现 测试 文件 ，   test _ * . py     * _ test . py   文件 都 测试 文件 。   还 更 新建 一个   pytest . ini   文件 ， 内容 ：   [ pytest ]   testpaths   =   tests   pytest 只 tests 文件夹 下 测试 文件 。   情况 希望 测试 文件 代码 文件 【 请 做 ， 毕竟 测试代码 模块 源码 放在 很 不美观 】 ， 没 ， 写 上 ， pytest 会 自动 发现 。 记得   pytest . ini   文件   testpaths   配置 删除 掉 算了 。   patch   编码 中 需求 ， Mock 对象 很 ， 贴近 真实 对象 ， 做 修改 ， patch ：   @ mock   .   patch   (   ' users . views . WXAPPAPI . jscode2session '   ,   \\   return _   =   {   \" openid \"   :   \" o1ZL90Ble54545ylei7sBhjkjhtG7PLM \"   ,   \" session _ key \"   :   \" 4XXDVTc0e4nuDjgjghhfCIcOg = = \"   ,   \" expires _ \"   :   7200   } )   def   test _ login   (     ,   mock _ jscode2session   ) :   data   =   {   ' js _ code '   :   ' 003xXUd30hnknF15454ua5e30xXUdr '   }   response   =     .   client   .     (   reverse   (   ' mini - login '   ) ,   data   )   #       testcase     .   _ session _ key   =   response   .   data   .     (   ' _ session _ key '   )     .   assertEqual   (   response   .   status _ code   ,   status   .   HTTP _ 200 _ OK   )   理解 代码 ？ 这段 测试代码 运行 ， 变量 名字 空间 patch 污染 ，   users . views . WXAPPAPI . jscode2session   函数 ， 污染 一个   Mock   对象 ， Mock 对象 传递 函数 第二个 参数 （ 额外 参数 不用 写 上 ）   mock _ jscode2session   。   代码 运行   jscode2session   总会 返回 给出 值 ， 不用 数据库 ， 网络 情况 。 小 技巧 django 框架 相关 ，   . client . ( reverse ( ' mini - login ' ) ,   data )   利用 django ， 请求 url 响应 ， django 相关 ， 不 说 。     ( ! document . getElementById ( ' mathjaxscript _ pelican _#% @ # $ @ # ' ) )   {   var   align   =   \" center \" ,   indent   =   \" 0em \" ,   linebreak   =   \" false \" ;     ( false )   {   align   =   ( screen . width   <   768 )     \" left \"   :   align ;   indent   =   ( screen . width   <   768 )     \" 0em \"   :   indent ;   linebreak   =   ( screen . width   <   768 )     ' true '   :   linebreak ;   }   var   mathjaxscript   =   document . createElement ( ' script ' ) ;   mathjaxscript . id   =   ' mathjaxscript _ pelican _#% @ # $ @ # ' ;   mathjaxscript . type   =   ' text / javascript ' ;   mathjaxscript . src   =   ' / theme / js / mathjax / MathJax . js ' ;   mathjaxscript [ ( window . opera     \" innerHTML \"   :   \" text \" ) ]   =   \" MathJax . Hub . Config ( { \"   +   \"   config :   [ ' MMLorHTML . js ' ] , \"   +   \"   TeX :   {   extensions :   [ ' AMSmath . js ' , ' AMSsymbols . js ' , ' noErrors . js ' , ' noUndefined . js ' , ' mhchem . js ' ] ,   equationNumbers :   {   autoNumber :   ' AMS '   }   } , \"   +   \"   jax :   [ ' input / TeX ' , ' input / MathML ' , ' output / HTML - CSS ' ] , \"   +   \"   extensions :   [ ' tex2jax . js ' , ' mml2jax . js ' , ' MathMenu . js ' , ' MathZoom . js ' ] , \"   +   \"   displayAlign :   ' \" +   align   + \" ' , \"   +   \"   displayIndent :   ' \" +   indent   + \" ' , \"   +   \"   showMathMenu :   true , \"   +   \"   messageStyle :   ' normal ' , \"   +   \"   tex2jax :   {   \"   +   \"   inlineMath :   [   [ ' \\ \\ \\ \\ ( ' , ' \\ \\ \\ \\ ) ' ]   ] ,   \"   +   \"   displayMath :   [   [ ' $ $ ' , ' $ $ ' ]   ] , \"   +   \"   processEscapes :   true , \"   +   \"   preview :   ' TeX ' , \"   +   \"   } ,   \"   +   \"   ' HTML - CSS ' :   {   \"   +   \"   styles :   {   ' . MathJax _ Display ,   . MathJax   . mo ,   . MathJax   . mi ,   . MathJax   . mn ' :   { color :   ' inherit   !   important ' }   } , \"   +   \"   linebreaks :   {   automatic :   \" +   linebreak   + \" ,   width :   ' 90%   container '   } , \"   +   \"   } ,   \"   +   \" } ) ;   \"   +   \"   ( ' default '   ! = =   ' default ' )   { \"   +   \" MathJax . Hub . Register . StartupHook ( ' HTML - CSS   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax [ ' HTML - CSS ' ] . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" MathJax . Hub . Register . StartupHook ( ' SVG   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax . SVG . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" } \" ;   ( document . body   | |   document . getElementsByTagName ( ' head ' ) [ 0 ] ) . appendChild ( mathjaxscript ) ;   }",
            "tags":"python_companion",
            "url":"articles/pytestmo-kuai.html"
        },
        {
            "title":"pelican模块",
            "text":"简介   pelican 一个 静态 网站 生成 工具 ， python 编写 ， pythoner 来说 显得 格外 亲切 。   官方 quickstart 简单 刷 一遍 ， 作出 讨论 。   项目   python 虚拟环境 控制 不 说 ， 讨论   pelicanconf . py     publishconf . py     Makefile   文件 作出 ， 项目 文档 结构 相关 作出 。   下   publishconf . py     pelicanconf . py   区别 ，   publishconf . py   文件 一句 话 ：   import   os   import   sys   sys   .   path   .   append   (   os   .   curdir   )     pelicanconf   import   *   继承 来自   pelicanconf . py   配置 参量 ，   publishconf . py   针对 发布 远程 服务器 上 ，   pelicanconf . py   配置 用于 机 调试 。     pelicanconf . py     SITEURL   变量 空值 ，   publishconf . py   赋 一个 值 ， 该值 模板 用法 ，   { {   SITEURL   } }   调用 。   发布 远程 机器 还会 额外 东西 ，   DISQUS _ SITENAME   值 ， 很多 模板 会 值来 开启 disqus javascript 引用 ， DISQUS 系统 本机 调试 意义 ， 会 不 设置 值 自动 关闭 。   publishconf . py   也许 ， 略过 ，   pelicanconf . py   配置 。     Makefile   文件 ， 脚本 很 好 ， 命令 很 用到 ：   make   html   make   serve   make   github   ...   make   github 会 output 内容 刷到 github   pages 项目 ， 依赖于 生成 目标   publish   ， make   publish make   html 惟一 区别 讨论 调用 配置文件 。   不用 Makefile   读者 windows 环境 下 ， Makefile 不怎么 好用 ， 说到底 提供 快捷 命令行 支持 ， 写 一个 python 脚本 。   # ! / usr / bin / env   python   #   - * - coding : utf - 8 - * -   \" \" \"   run . bat   windows 下 运行 点     build   命令   \" \" \"   import   click   import   subprocess   import   os   import   shutil     pathlib   import   Path   import   threading   PROJECT   =   ' myblog '   BASEDIR   =   os   .   getcwd   ( )   INPUTDIR   =   os   .   path   .   join   (   BASEDIR   ,   ' content '   )   OUTPUTDIR   =   os   .   path   .   join   (   BASEDIR   ,   ' dev _ output '   )   PUBLISHDIR   =   os   .   path   .   join   (   BASEDIR   ,   ' output '   )   CONFFILE   =   os   .   path   .   join   (   BASEDIR   ,   ' pelicanconf . py '   )   PUBLISHCONF   =   os   .   path   .   join   (   BASEDIR   ,   ' publishconf . py '   )   PORT   =   9000   @ click   .   group   ( )   def   main   ( ) :   pass   @ main   .   command   ( )   def   devserve   ( ) :   \" \" \"   devbuild     pelican   project   \" \" \"   click   .   echo   (   \" start   devbuild     pelican   project ... \"   )   def   devbuild   ( ) :   cmd   =   \" pelican   - - debug   - r   { INPUTDIR }   - o   { OUTPUTDIR }   - s   { CONFFILE }   \"   .   format   (   INPUTDIR   =   INPUTDIR   ,   OUTPUTDIR   =   OUTPUTDIR   ,   CONFFILE   =   CONFFILE   )   click   .   echo   (   ' start   run   cmd :   { 0 }   '   .   format   (   cmd   ) )   subprocess   .   call   (   cmd   ,   shell   =   True   )   def   serve   ( ) :       os   .   path   .   exists   (   OUTPUTDIR   ) :   import   time   time   .   sleep   (   1   )   os   .   chdir   (   OUTPUTDIR   )   serve _ cmd   =   ' python   - m   http . server   { PORT }   '   .   format   (   PORT   =   PORT   )   click   .   echo   (   ' start   run   cmd :   { 0 }   '   .   format   (   serve _ cmd   ) )   subprocess   .   call   (   serve _ cmd   ,   shell   =   True   )   t0   =   threading   .   Thread   (   target   =   devbuild   )   t0   .   start   ( )   t   =   threading   .   Thread   (   target   =   serve   )   t   .   start   ( )   threads   =   [ ]   threads   .   append   (   t0   )   threads   .   append   (   t   )     t     threads   :     :   t   .   join   ( )     KeyboardInterrupt     e   :   print   (   ' 用户 取消 '   )   @ main   .   command   ( )   def   build   ( ) :   \" \" \"   build     pelican   project   \" \" \"   click   .   echo   (   \" start   build     pelican   project ... \"   )   cmd   =   \" pelican   - - debug   { INPUTDIR }   - o   { PUBLISHDIR }   - s   { PUBLISHCONF }   \"   .   format   (   INPUTDIR   =   INPUTDIR   ,   PUBLISHCONF   =   PUBLISHCONF   ,   PUBLISHDIR   =   PUBLISHDIR   )   click   .   echo   (   ' start   run   cmd :   { 0 }   '   .   format   (   cmd   ) )   ret   =   subprocess   .   call   (   cmd   ,   shell   =   True   )   click   .   echo   (   ' running   result   :   { 0 }   '   .   format   (   ret   ) )   @ main   .   command   ( )   def   devclean   ( ) :   \" \" \"   clean     dev   output   \" \" \"   click   .   echo   (   \" start   clean     output   folder ... \"   )   rm   (   OUTPUTDIR   ,   recursive   =   True   )   def   normalized _ path _ obj   (   path   =   ' . '   ) :   \" \" \"   默认 支持   ~   符号   返回   Path   对象   : param   path :   : return :   \" \" \"     isinstance   (   path   ,   Path   ) :   return   path   .   expanduser   ( )   elif   isinstance   (   path   ,   str   ) :     path   .   startswith   (   ' ~ '   ) :   path   =   os   .   path   .   expanduser   (   path   )   return   Path   (   path   )     :   raise   TypeError   def   rm   (   path   ,   recursive   =   False   ) :   \" \" \"     function     remove   file     empty   directory ( default ) .     ` shutil . rmtree `     remove     - empty   directory ,     add   ` recursive = True `   \" \" \"   path   =   normalized _ path _ obj   (   path   )     recursive   :   shutil   .   rmtree   (   path   )     :     path   .   _ file   ( ) :   path   .   unlink   ( )     :   path   .   rmdir   ( )     __ __   = =   ' __ main __ '   :   main   ( )     run . py   基础 上 ， 创建 两个 脚本 ：   start _ server . bat   脚本 用于 本地 调试   start   / b   python   run . py   devserve   build . bat   脚本 用于 编译 输出   start   / b   python   run . py   build   官方 quickstart 文档 内容 本文 再 赘述 ， 值得一提 地方 做出 。   写文章   引用 博客 内部 文章   引用 博客 内部 文章 不 文章 slug 细节 ， 引用 ：   { filename } path / / . md   相对路径 支持   ..   表达 。   引用 静态 资源   markdown 引入 图片 所示 ：   ! [   img   ] (   { static } / images / chemistry / Naphthalene . png   )   { static }   引用 文件 路径 。 content 文件夹 images 文件夹 ， 文件夹 默认 copy output 输出 文件夹 根目录 去 。   网站 favicon . ico   参考   网页   ， 配置 ， 其会 extra 文件夹 favicon . ico 文件 copy output 文件夹 。   EXTRA _ PATH _ METADATA   =   {   ' extra / favicon . ico ' :   { ' path ' :   ' favicon . ico ' }   }   常用 配置 参考   Category 参数 控制   配置 ：   DEFAULT _ CATEGORY   =   ' '   pelican 项目 默认 Category 参数值 。   配置 ：   USE _ FOLDER _ AS _ CATEGORY   =   True     Category   参数 省略 ， pelican 会 文章 所在 上 一级 文件夹 名字 文章 Category 。   文件夹 结构 变得复杂 ， 默认 Category 方法 不再 满意 ， 设置 关闭 ：   USE _ FOLDER _ AS _ CATEGORY   =   False   目标 文章 头 参数 配置   Category :     静态 资源管理   images pdfs data extra 文件夹 名字 都 随意 ， 写 ， pdfs 放 pdf ， images 放 图片 。 几个 文件夹 都 静态 资源 文件夹 ， 下 生成 output 文件夹 ， 内容 都 放 送入 output 文件夹 去 。 设置 ：   STATIC _ PATHS   =   [ ' images ' ,   ' pdfs ' ,   ' data ' ,   ' extra ' , ]   html 文件 额外 说 ， 原 网页 body 内容 都 会 完整 传 ， 原 html 网页 head meta 标签 title 标签 之外 ， 多余 内容 传 不 。 css js 设置 怎么弄 ， 请 参看 相关 讨论 ， 到时候 设置 好 相关 meta 标签 即可 。   output 输出 控制   ARTICLE _ URL   =   ' { category } / { slug } . html '   ARTICLE _ SAVE _ AS   =   ARTICLE _ URL   PAGE _ URL   =   ' { slug } . html '   PAGE _ SAVE _ AS   =   PAGE _ URL   CATEGORY _ URL   =   ' { slug } / index . html '   CATEGORY _ SAVE _ AS   =   CATEGORY _ URL   TAG _ URL   =   ' tag / { slug } . html '   TAG _ SAVE _ AS   =   TAG _ URL   ARTICLE _ URL   定义 文章 URL 显示 ， slug 文件 头 属性 自定义 。   ARTICLE _ SAVE _ AS   定义 文件 output 文件夹 存储 路径   类似 控制   CATEGORY   TAG   PAGE   页面 URL 网页 output 文件夹 存储 路径 。   theme 相关   theme   没 pelican 推荐 theme 都 下载 ， 找 一个 喜欢 theme ， 复制到 pelican 项目 根目录 下 ， 配置   _ theme _   等于 复制 主题 文件夹 名字 ：   THEME   =   ' _ theme _ '   theme 内部 static 文件夹 下 内容 会 copy output 文件夹 下 ，   static / css     theme / css   。   templates 文件夹 都 jinja2 模板 文件 ， 讨论 theme 相关 jinja2 模板 定制 知识 。   Markdown 相关   ：   pip   install   markdown   pelican     markdown 支持 。 模块 官方 文档     。 不 太 模块 ， 稍微 定制 需求 ， 插件 ， 都 模块 功能 关联 。   来看 最 常用 两个 功能 ， 一个 语法 高亮 功能 ， 一个 自动 目录 生成 功能 。   pelican 相关 MARKDOWN 配置 原始 参数 ：   MARKDOWN   =   {   ' extension _ configs ' :   {   ' markdown . extensions . codehilite ' :   { ' css _ class ' :   ' highlight ' } ,   ' markdown . extensions . extra ' :   { } ,   ' markdown . extensions . meta ' :   { } ,   } ,   ' output _ format ' :   ' html5 ' ,   }   参数 实际上 传递 提到   markdown   模块 ， pelican 这块 。   extension _ config   官方 文档     信息 ， 很多 官方 插件 ， markdown 模块 安装 一并 安装 进来 。   codehilite   插件 提供 一种 代码 块 语法 高亮 方案 ， 代码 块 采用 格式 ：   # ! / usr / bin / python   #   Code       ...   几种 格式 不 赘述 ， 提到   fenced _ code   插件 实际上 站   CodeHilite   之上 ， 支持 常见 gfm 代码 块 表达 。 两个 插件 都 依赖   pygments   模块 。   css _ class   配置 最 外面 div 区块 class 名字   guess _ lang   不 版本 ， 参数 默认 True ， 带来 困扰 ， 它会 pygments 去 猜 代码 块 里 语言 ， 猜 不 准确 ， 喜欢 关掉 ， 默认 text 不 染色 ， 用户 习惯 ， 不 指定 语言 暗含 语种 不 text 。   几个 参数 选择 读者 参看 插件 文档 。   linenums   人会 喜欢 。   fenced _ code   上 描述 。   toc   markdown   文档 写 上 ：   [ TOC ]   其会 自动 转成 ：   < div   class = \" toc \" >   .....   < / div >   顺便 提到   extract _ toc   plugin   ， 插件 利用   beautifulsoup4   模块 刷 toc   div ， pelican 模板 中   article   变量 ，   article . toc   属性 ， 具体内容 提及 自动 生成 toc 内容 。   出于 好奇 看 extract _ toc   相关 代码 ：     toc   :   toc   .   extract   ( )   content   .   _ content   =   soup   .   decode   ( )   content   .   toc   =   toc   .   decode   ( )     content   .   toc   .   startswith   (   ' < html > '   ) :   content   .   toc   =   content   .   toc   [   12   :   -   14   ]     toc . extract ( )     toc   插件 生成 目录 删去 ， toc 赋值 content ， content   article   【 pelican page page 】 。   pelican 里 ， 查看 theme ， toc 显示 ， 类似 jinja2 代码 ：   { %     article . toc   % }   < div   class = \" col - md - 2   table - - content \" >   < nav >   ....   { {   article . toc   } }   < / nav >   < / div >   讨论 MARKDOWN   变量 ：   MARKDOWN   =   {   ' extension _ configs ' :   {   ' markdown . extensions . codehilite ' :   { ' css _ class ' :   ' highlight ' ,   ' guess _ lang ' :   False } ,   ' markdown . extensions . toc ' :   { } ,   ' markdown . extensions . fenced _ code ' :   { } ,   ' markdown . extensions . extra ' :   { } ,   ' markdown . extensions . meta ' :   { } ,   } ,   ' output _ format ' :   ' html5 ' ,   }   plugin 相关   plugin 安装   配置 安装 plugin ， 文件夹 操作 pelican 项目 根目录 下有   myplugins   文件夹 ， 编写 plugin 作者 写 plugin   copy 。   PLUGIN _ PATHS   =   [ ' myplugins ' ]   PLUGINS   =   [ ' pelican _ javascript ' ,   ' extract _ toc ' ,   ' pelican _ ipynb ' ,   ' tipue _ search ' ,   ' render _ math ' ]   pelican _ javascript   plugin   项目   github 地址   。   js css 静态 资源 ， 有所不同 ， 提及 html 源文件 head css 引用 语句 ， 都 会 丢失 。 加上 meta 标签 语句 ：   <   meta     =   \" javascripts \"   content   =   \" 周易 之摇卦 . js \"   / >   还 安装 pelican - plugins   pelican _ javascript   所示 ：   PLUGIN _ PATHS   =   [ ' pelican - plugins ' ]   PLUGINS   =   [ ' pelican _ javascript ' ,   ' tipue _ search ' ,   ' extract _ toc ' ]   配置 参考     pelicanconf . py   文件 配置 提到 很多 ， 再 配置 做出 。",
            "tags":"python_companion",
            "url":"articles/pelican-module.html"
        },
        {
            "title":"click模块",
            "text":"简介   click 模块 一个 类似 getopt argparse python 第三方 模块 ， 简单 ， 简直 python 快速 创建 命令行 工具 类似 requests 之于 urllib ， writed   human - friendly 。 click 官方 文档     ， 就让 学习 好 一个 模块 。   官方 文档 第一个 例子 :   import   click   @ click   .   command   ( )   @ click   .   option   (   ' - - count '   ,   default   =   1   ,     =   ' Number     . '   )   @ click   .   option   (   ' - - '   ,   prompt   =   ' Your   '   ,     =   ' The   person     greet . '   )   def     (   count   ,     ) :   \" \" \" Simple   program     greets   NAME     a   total     COUNT   times . \" \" \"     x     range   (   count   ) :   click   .   echo   (   ' Hello   % s   ! '   %     )     __ __   = =   ' __ main __ '   :     ( )   一切都是 很 直观 明 ，   @ click . command ( )   用来 装饰 一个 函数 ，   @ click . option   添加 命令行 选项 。 第一个 命令行 选项 名字 ，     ，   default   意义 （ 类似   type   控制 数据类型 ） 。 选项 请求 输入 值 。   click . echo   打印 操作 （ print 函数 更好 python2 3 兼容性 ， 随意 ， print 函数 ） 。   脚本 运行 情况 所示 :   wanze @ wanze - ubuntu : ~ / 桌面 $   python3   test2 . py   - -   Usage :   test2 . py   [ OPTIONS ]   Simple   program     greets   NAME     a   total     COUNT   times .   Options :   - - count   INTEGER   Number     .   - -   TEXT   The   person     greet .   - -   Show     message     exit .   函数   __ doc __   文档 成 命令行 描述性 文档 。   更棒   prompt   机制 命令行 输入 参数 兼容 :   wanze @ wanze - ubuntu : ~ / 桌面 $   python3   test2 . py   - - count = 3   - - = wanze   Hello   wanze !   Hello   wanze !   Hello   wanze !   必填 参数 ， 文件 操作 测试   必填 参数   @ click . argument ( )   装饰 添加 ， 所示 :   import   click   @ click   .   command   ( )   @ click   .   argument   (   ' input '   ,   type   =   click   .   File   (   ' rb '   ) )   @ click   .   argument   (   ' output '   ,   type   =   click   .   File   (   ' wb '   ) )   def   inout   (   input   ,   output   ) :     True   :   chunk   =   input   .   read   (   1024   )       chunk   :   break   output   .   write   (   chunk   )     __ __   = =   ' __ main __ '   :   inout   ( )     click . File ( )   接受 一个 文件名 ， 打开 ， 函数 一个 文件 对象 。 文件 推荐 click 模块 类型 ， Unicode bytes 好 ， 优化 。   click . Path   类型 ， 函数 相当于 一个 优化 Path 文件名 ， 提供 Unicode bytes 兼容 支持 。   @ click   .   command   ( )   @ click   .   argument   (   ' f '   ,   type   =   click   .   Path   (   exists   =   True   ) )   def   touch   (   f   ) :   click   .   echo   (   click   .   format _ filename   (   f   ) )   例子 中 脚本 写 上 :     __ __   = =   ' __ main __ ' :   inout ( )   脚本 测试 :   bash > > >   python3   test5 . py   test . py   output . txt   更好 做法 测试 式 开发 风格 :   import   click     click . testing   import   CliRunner   def   test _ inout   ( ) :   @ click   .   command   ( )   @ click   .   argument   (   ' input '   ,   type   =   click   .   File   (   ' rb '   ) )   @ click   .   argument   (   ' output '   ,   type   =   click   .   File   (   ' wb '   ) )   def   inout   (   input   ,   output   ) :     True   :   chunk   =   input   .   read   (   1024   )       chunk   :   break   output   .   write   (   chunk   )   runner   =   CliRunner   ( )     runner   .   isolated _ filesystem   ( ) :   string   =   ' Hello   World ! '     open   (   ' . txt '   ,   ' w '   )     f   :   f   .   write   (   string   )   result   =   runner   .   invoke   (   inout   ,   [   ' . txt '   ,   ' hello2 . txt '   ] )   assert   result   .   exit _ code   = =   0     open   (   ' hello2 . txt '   ,   ' r '   )     f   :   s   =   f   .   read   ( )   assert   s   = =   string     __ __   = =   ' __ main __ '   :   test _ inout   ( )   新建 一个   CliRunner   对象 ， 调用   invoke   方法 执行 命令 ，   Result   对象   exit _ code     output   属性 。   result . output   屏幕 回显 文字 。   runner 调用   isolated _ filesystem ( )   方法 ， 暂停 程序 会 发现   / tmp   文件夹 会 一个 临时 文件夹 ， 文件 操作 都 ， 完 会 删除 。   标准 输入 标准 输出   值得一提的是 标准 输入 标准 输出   ' - '   简单 。 例子 :   bash > > >   python3   test4 . py   -   output . txt   test   test   bash > > >   python3   test4 . py   test . py   -   标准 输入 例子 按下   Ctrl - D   结束 文件 流 。   分组 多个 子 命令   click 模块 分组 建立 多个 子 命令 功能 上 设计 很 简洁 :   import   click   @ click   .   group   ( )   def   cli   ( ) :   pass   @ cli   .   command   ( )   def   initdb   ( ) :   click   .   echo   (   ' Initialized     database '   )   @ cli   .   command   ( )   def   dropdb   ( ) :   click   .   echo   (   ' Dropped     database '   )     __ __   = =   ' __ main __ '   :   cli   ( )     @ click . group   定义 命令 组 ， 命令 组 函数 command 方法   @ cli . command ( )   添加 子 命令 。   命令行 选项 详解   click 模块 必填 参数   argument ( )   引入 ， 选 参数   option ( )   引入 ， 值得一提的是 两个 函数 参数 不 ， 比如说 option   prompt   当该 可选 参数 输入 ， 请求 输入 ； argument 无此 概念 。 更 细节 请 参看 请求 输入 小节 。   default   设置 默认值 ， argument 必填 参数 无此 概念 。   type   控制 数据类型 ， 都 。   接受 多个 输入   nargs   设置 大于 等于 1 值 ， 命令行 中要 刷入 多值 ， argparse 模块 类似 ， 不定量 多个 值 情况   nargs = - 1   ， 相当于 内置 模块 argparse   *   。 argparse   +   一个 值 情况 ， 额外 加上   required = True   控制 。   count   option ， 某种 情景 下 很 有用 。   @ click . command ( )   @ click . option ( ' - v ' ,   ' - - verbose ' ,   count = True )   def   log ( verbose ) :   click . echo ( ' Verbosity :   % s '   %   verbose )   $   log   - vvv   Verbosity :   3   布尔值   默认   default = True   设置 ， 默认 存储 布尔值 ， 实际上 暗含 加上   _ flag = True   。 设置 default ，   _ flag   控制 存储 布尔值 。   短名 选项 长名 选项 布尔值   import   sys   @ click . command ( )   @ click . option ( ' - - shout / - - - shout ' ,   '   / - S ' ,   default = False )   def   info ( shout ) :   rv   =   sys . platform     shout :   rv   =   rv . upper ( )   +   ' ! ! ! ! 111 '   click . echo ( rv )   bash > > >   python3   test . py   linux   bash > > >   python3   test . py   - - shout   LINUX ! ! ! ! 111   bash > > >   python3   test . py   - S   linux     /   分割 语句 创建 多个 flag 布尔值 控制 ，   /   左边 True ， 右边 False ， 短名 选项 跟着 写入 。     例子 短名 情况 空格 少 。   想要 效果 ， 不 输入 flag flag 值 False ， 输入 True 。 ：   import   click   @ click   .   command   ( )   @ click   .   option   (   ' - - break '   ,   _ flag   =   True   )   def   main   (   break   ) :     break   :   print   (   ' break '   )   多个 choice 选项 用法   @ click   .   command   ( )   @ click   .   option   (   ' - - hash - type '   ,   type   =   click   .   Choice   ( [   ' md5 '   ,   ' sha1 '   ] ) )   def   digest   (   hash _ type   ) :   click   .   echo   (   hash _ type   )   请求 输入 prompt 控制   option 才 概念 。 最 简单 情况 所示 :   @ click   .   command   ( )   @ click   .   option   (   ' - - '   ,   prompt   =   ' Your     '   )   def     (     ) :   click   .   echo   (   ' Hello   % s   ! '   %     )   弹 出 提示 输入   - - =   给出 值时 才 会 。   请求 输入 密码   所示 :   @ click   .   command   ( )   @ click   .   option   (   ' - - password '   ,   prompt   =   True   ,   hide _ input   =   True   ,   confirmation _ prompt   =   True   )   def   encrypt   (   password   ) :   click   .   echo   (   ' Encrypting   password     % s   '   %   password   .   encode   (   ' rot13 '   ) )   额外 加上 两个 选项 控制 :   hide _ input = True     confirmation _ prompt = True   。 组合 简单 写为 :   @ click   .   command   ( )   @ click   .   password _ option   ( )   def   encrypt   (   password   ) :   click   .   echo   (   ' Encrypting   password     % s   '   %   password   .   encode   (   ' rot13 '   ) )   请求 默认值 控制   请求 prompt   default   设置 默认值 ， 那种 情况 下 按下 Enter 相当于 输入 默认值 。 还 获取 系统 环境 下 值 默认值 。   @ click   .   command   ( )   @ click   .   option   (   ' - - username '   ,   prompt   =   True   ,   default   =   lambda   :   os   .   environ   .     (   ' USER '   ,   ' '   ) )   def     (   username   ) :   print   (   \" Hello , \"   ,   username   )   click 模块 还 提供 prompt 快捷 请求 输入 命令 。     =   click . prompt ( ' Please   enter   a   valid   integer ' ,   type = int )     confirm   函数 很 有用 :     click . confirm ( ' Do         continue ' ) :   click . echo ( ' Well   ! ' )   Press     Key     continue   终端 显示 稍微 停留 一会 ， 显示   Press     Key     continue   ， 随便 按个键 再 退出 ， 好 用户 终端 显示 信息 。 click 很 简单 效果 ：   import   click   click . pause ( )   命令行 选项 控制 动作   所示 ，   _ eager = True   选项 优先级 高于 选项 。   expose _ = False   输入 选项 ， 不 影响 原 命令 执行 流 。   callback   跳转 函数 上 。   def   print _ version   (   ctx   ,   param   ,     ) :           ctx   .   resilient _ parsing   :   return   click   .   echo   (   ' Version   1.0 '   )   ctx   .   exit   ( )   @ click   .   command   ( )   @ click   .   option   (   ' - - version '   ,   _ flag   =   True   ,   callback   =   print _ version   ,   expose _   =   False   ,   _ eager   =   True   )   def     ( ) :   click   .   echo   (   ' Hello   World ! '   )   最 关键性 理解   ctx   param       几个 参数 。   带 颜色 终端 回显   click 借助 python 模块   colorama   力量 终端 显示 带 颜色 字体 功能 ， 确认   colorama   :   pip   install   colorama   简单 :   import   click   click . secho ( ' Hello   World ! ' ,   fg = ' green ' )   click . secho ( ' Some     text ' ,   bg = ' white ' ,   fg = ' black ' )   click . secho ( ' ATTENTION ' ,   blink = True ,   bold = True )   fg 前景 颜色 ， 说 字体 颜色 ， 颜色 选项 :   Fore :   BLACK ,   RED ,   GREEN ,   YELLOW ,   BLUE ,   MAGENTA ,   CYAN ,   WHITE .   bg 背景 颜色 :   Back :   BLACK ,   RED ,   GREEN ,   YELLOW ,   BLUE ,   MAGENTA ,   CYAN ,   WHITE .   style :   dim = True   bold = True   blink = True   underline = True   reverse = True   dim 淡化 ， bold 加粗 ， blink 闪烁 ， 没 效果 。 underline 下划线 ， reverse 前景色 背景色 翻转 。",
            "tags":"python_companion",
            "url":"articles/click-module.html"
        },
        {
            "title":"jinja2模板引擎",
            "text":"前言   jinja2 模板 引擎 flask pelican 中 都 ， django 框架 中 ， 模版 语法 大体 类似 ， jinja2 模板 引擎 很 值得 一学 。   jinja2 模板 引擎 python 模块 简单 所示 ：     jinja2   import   Template   template   =   Template   (   template _ content   )   content   =   template   .   render   (   link _ data   =   link _ data   )   render 函数 参数 变量 渲染 进去 ， 目标 文本 内容 。   本文 接下来 简要 讨论 下 flask pelican 中 编写 模板 文件 ， 更 详细 内容 请 参见   官方 文档 模板 设计者 文档 一章   。   注释   注释 写法 所示 ， 放在 最 是因为 模板 引擎 注释 很 有用 ， 很 不同于 编程语言 注释 写法 。   { #       a   comment   # }   变量   所示 ， 包含 变量 ， jinja2 渲染 模板 会 解析 变量 。   { {   variable _   } }     object . a   dot 法 引用 ，   object [ ' a ' ]   写法 ， 调用 实例 方法   object . func ( )   ， 方法 返回 字符串 。   debug 变量 上将 变量值 显示 。   语句   条件 分支 用于 条件 显示 内容 。   { %     user   % }   Hello ,   { {   user   } } !   { %     % }   Hello   ,   stranger !   { %   endif   % }   elif 语句 支持 ：   { %     kenny . sick   % }   Kenny     sick .   { %   elif   kenny . dead   % }   You   killed   Kenny !   You   bastard ! ! !   { %     % }   Kenny       - - -       { %   endif   % }   语句   语句 结构 所示 :   < ul >   { %     user     users   % }   < li > { {   user . username   } } < / li >   { %   endfor   % }   < / ul >   < dl >   { %     key ,       _ dict . iteritems ( )   % }   < dt > { {   key | e   } } < / dt >   < dd > { {   | e   } } < / dd >   { %   endfor   % }   < / dl >   循环 区块 中 还 变量 ：   loop . index   循环 记数 ， 1   loop . index0   循环 记数 ， 0   loop .   是否是 第一次 迭代   loop .   是否是 迭代   不 赘述 ， 请 参看 官方 文档 For 语句 。   过滤器   变量 进一步 加上 过滤器 进一步 。 过滤器 类似 linux 系统 管道 作业 风格 ， 多个 过滤器 叠加 ， ：   { {   var   |   striptags   |   title   } }   。   列出 过滤器 功能 ， 更 过滤器 参见 官方 文档 内置 过滤器 清单 小节 。   safe   渲染 值 不 转义   capitalize   值 首字母 大写   字母 小写   lower   字母 都 小写   upper   字母 都 大写   title   值 单词 首字母 大写   trim   值 首尾 空格 去除   striptags   渲染 HTML 标签 去掉   safe 过滤器 请 参看 讨论 特殊符号 。   html 特殊符号   变量 html 特殊符号 :   <   >   &   \"   jinja2 模板 系统 默认 不 做 ， ：   > > >     jinja2   import   Template   > > >   t   =   Template ( ' test   { {   x   } } ' )   > > >   t . render ( x   =   ' < h1 > abc < / h1 > ' )   ' test   < h1 > abc < / h1 > '   上 输出 html 中是 html 效果 ，   escape   过滤器 转义 特殊符号 :   > > >   t   =   Template ( ' test   { {   x | escape   } } ' )   > > >   t . render ( x   =   ' < h1 > abc < / h1 > ' )   ' test   & lt ; h1 & gt ; abc & lt ; / h1 & gt ; '   转义 输出 html 中 单纯 显示   <   >   符号 ， 不 html 效果 。   flask 设置 全局 auto   escape   ， 需求 。 确实 html 标签 希望 html 标签 形式 显示 ， 不 escape ， 采用   safe   过滤器   1   。   > > >   t   =   Template ( ' test   { {   x | safe   } } ' )   > > >   t . render ( x   =   ' < h1 > abc < / h1 > ' )   ' test   < h1 > abc < / h1 > '   escape   过滤器 模板 作者 会 更 喜欢 别名 缩写 ， 一个 小写字母   e   。   模板 文件 继承 机制   jinja2 模板 文件 一种 继承 机制 ， 基于 模板 文件 建构 出 一个 模板 文件 。 父 模板 （ 模板 文件 模板 文件 ） 构建 block 区块 ， 所示 :   < title > { %   block   title   % }   { %   endblock   % } < / title >   构建 一个 title 区块 。   子 模板 继承 父 模板 内容 :   { %   extends   \" base . html \"   % }   定制 ， 比如说 title ， 做成 block ， 子 模板 文件 定义 title   block :   { %   extends   \" base . html \"   % }   { %   block   title   % }   awesome   title { %   endblock   % }   子 模块 block 重载 ， 还   { {   super ( )   } }   加载 父 模块 block 中 定义 。   模板 块 还 重复 打印 ：   { {   . title ( )   } }   宏   宏 python 函数 类似 ， 即将 展开 。   { %   macro   render _ comment ( comment )   % }   < li > { {   comment   } } < / li >   { %   endmacro   % }   < ul >   { %     comment     comments   % }   { {   render _ comment ( comment )   } }   { %   endfor   % }   < / ul >   外部 宏 文件   引入   { %   import   ' macros . html '     macros   % }   < ul >   { %     comment     comments   % }   { {   macros . render _ comment ( comment )   } }   { %   endfor   % }   < / ul >   import   模板 传递 上下文 ， 上下文 传递 引入 进来 模板 ：   { %     ' forms . html '   import   input     context   % }   include   宏 文件 推荐 import ， 模板 文件 继承 机制 ， include 语句 ？   模板 代码 片段 反复 推荐 include 语句 ， 模板 代码 片段 默认 访问 外围 上下文 ：   { %   include   ' common . html '   % }   明确要求 包含 上下文 不 包含 上下文 都 ：   { %   include   ' header . html '     context   % }   { %   include   ' header . html '     context   % }   技巧   列表 排序   参考   网页   ：   { %     movie     movie _ list | sort ( attribute = ' rating ' )   % }   { %     movie     movie _ list | sort ( attribute = ' rating ' ,   reverse   =   True )   % }   移除 块 空白   空白 指   空格 ， 制表符 ， 换行符 ， jinja2 这块 全局 配置 选项 。 手工 配置 ， 大体 加上   -   跟上 一个   trim _ blocks   操作 。   { %     item     seq   - % }   { {   item   } }   { % -   endfor   % }   Footnotes :   1   参考   网页   。",
            "tags":"python_companion",
            "url":"articles/jinja2-template-engine.html"
        },
        {
            "title":"beautifulsoup模块",
            "text":"简介   BeautifulSoup 模块 python 网页 分析 一块 很 有名 一个 模块 ， 确实 网页 分析 变得 轻松 easy 。 本文 bs4 模块 简单 介绍 ， 更 细节 请 参看   官方 文档   。   安装   安装 简单 pip 命令 安装 :   sudo   pip   install   beautifulsoup   第一个 例子   上 python2 python3 urllib 相关 改动 很大 ， 加上 urllib 上 很 友好 ， 强烈推荐 requests 模块 相关 操作 。 beautifulsoup 引入 语句 所示 :     bs4   import   BeautifulSoup   最 简单 requests 组合 所示 :   import   requests     bs4   import   BeautifulSoup   res   =   requests   .     (   \" http : / / www . pythonscraping . / exercises / exercise1 . html \"   )   soup   =   BeautifulSoup   (   res   .   text   )   print   (   soup   .   title   )   soup . title 返回 一个 标签 对象 。 标签 对象 标签 点 号 索引 标签 :   > > >   soup . body . h1   < h1 > An   Interesting   Title < / h1 >   读者 想 ， 文档 p 标签 很多 ， soup 会 返回 ？   import   requests     bs4   import   BeautifulSoup   res   =   requests   .     (   \" http : / / www . crummy . / software / BeautifulSoup / bs4 / doc / \"   )   soup   =   BeautifulSoup   (   res   .   text   )   print   (   soup   .   p   )   soup 返回 第一个 p 标签 ， 看作 讲 find 方法 简化 css 索引 形式 。   find 方法   所示 最 简单 find 定位 实际上 类似   soup . p   用法 。 find 方法 更 内容 。   > > >   soup . find ( ' p ' )   < p > < a   class = \" reference   external \"   href = \" http : / / www . crummy . / software / BeautifulSoup / \" > Beautiful   Soup < / a >     a   Python   library     pulling   data       HTML     XML   files .   It   works       favorite   parser     provide   idiomatic   ways     navigating ,   searching ,     modifying     parse   tree .   It   commonly   saves   programmers   hours     days     work . < / p >   find 方法 找 不到 返回 None ， 找到 返回 目标 标签 元素 。   > > >   soup . test     None   True   过滤器   find 方法 最 常用 形式 接受 一个 参数 ， 参数 过滤器 参数 。 过滤器 字符串 正则表达式 列表 ， 列表 元素 基于 谈及 字符串 正则表达式 ， 逻辑 ， 符合 一个 匹配 条件 匹配 。   第一个 参量 参量 针对 tag 操作 ， 简单 字符串 够用 ， 正则表达式 ，   . compile ( \" &# 94 ; b \" )   形式 ， 其内 正则表达式   match   方法 （ 稍作 测试 ， . search 。 ） 。   额外 一提 过滤器   True   ， 其会 匹配 值 ， 比如说   id = True   ， 将会 匹配 id 属性 标签 。   class _ 参量     class _ =   过滤 标签 class 属性 ， python class 关键词 区分 ， 加上 一个 下划线 ， 接受 一个 过滤器 。   id 参量     id =   定位 网页 中 id ， 接受 一个 过滤器 。   text 参量   网页 标签 内 字符串 过滤 操作 ， 提及 过滤器 都 ， 字符串 精确 匹配 估计 用得会 少 。 尽可能 地用 正则表达式 。 单独 text 参量   soup . find _ ( text = . compile ( ' ' ) )   标签 字符串 会 搜索 ， 返回 不 标准 标签 元素 对象 ， 很 不好 。 推荐 采用 形式 :   soup . find _ ( True , text = . compile ( ' ' ) )   返回 必定 标签 元素 ， text 必定 只 搜索 标签 text 字符串 内容 ， 更 易于 理解 。   搜索 完 定位 小 标签 ，   < b >   ， 目标 标签 元素   . parent   ， 返回 更高 一级 标签 元素 ， 会 很 有用 :   soup . find _ ( True , text = . compile ( ' ' ) ) [ - 1 ] . parent   keywords   标签 属性 都 类似 关键词 加上 过滤器 搜索 。   oup . find _ ( href = . compile ( \" elsie \" ) )   recursive 参量   recursive 默认 True ， 检索 tag 子孙 节点 ， 只想 搜索 tag 第一级 子 节点 ，   recursive = False   。   limit 参量   只 find _ 才 意义 ， 返回 几个 元素 。   find _ 方法   find _ find 方法 API 类似 ， find _ 返回 一系列 匹配 标签 元素 列表 。 顺便 提 ， find 方法 find _ 方法 接受 多个 参数 限定 ， 限定 条件 看作 逻辑 关系 。   标签 元素 对象   标签 元素 见 例子 :   > > >   import     > > >   soup . find ( True , text = . compile ( \" sister \" ) )   < span   class = \" s \" > < p   class = \" story \" > Once     a   time           sisters ;       names   < / span >   > > >   thetag   =   soup . find ( True , text = . compile ( \" sister \" ) )   > > >   thetag .   ' span '   > > >   thetag . text   ' < p   class = \" story \" > Once     a   time           sisters ;       names   '   > > >   thetag . string   ' < p   class = \" story \" > Once     a   time           sisters ;       names   '   > > >   type ( thetag . string )   < class   ' bs4 . element . NavigableString ' >   > > >   type ( thetag . text )   < class   ' str ' >   > > >   thetag [ ' class ' ]   [ ' s ' ]   :   标签 对象 标签 名字   string :   返回 NavigableString 对象 ， 暂时 先 略过 讨论 。   text :   返回 标签 包含 文本 对象 。   _ text ( ) :   最新 bs4 文档 来看 ， 官方 文档 推荐 tag 获取 其内 文本 内容 都   _ text   方法 ，   thetag . text   形式 。   [ ' class ' ] :   属性 值 索引 ， \" class \" 属性 返回 一个 列表 ， 多值 属性 。   基于 标签 附加 查找     find     find _   找到 标签 对象 ， bs4 还给 标签 对象 加上 辅助 查找 方法 ， 基于 标签 对象 进一步 查找 ， 返回 标签 对象 。   平行 级别 标签   平行 级别 标签 指如 例子 :   < html >   < body >   < a >   < b > text1 < / b >   < c > text2 < / c >   < / a >   < d > test3 < / d >   < / body >   < / html >   标签   标签 一个 html 文档 缩进 深度 ， 一个 层次 平行 标签 。     平行 标签 ，     。   平行 级别 下 标签   find _ _ sibling ( ,   attrs ,   string ,   * * kwargs )   才 外 返回 标签 对象 （ find _ 方法 ） 方法 :   find _ _ siblings ( ,   attrs ,   string ,   limit ,   * * kwargs )   例子 :   > > >   [   i     i     soup . a . _ siblings ]   [ ' \\ n ' ,   < d > test3 < / d > ,   ' \\ n ' ]   > > >   [   i     i     soup . b . _ siblings ]   [ ' \\ n ' ,   < c > text2 < / c > ,   ' \\ n ' ]   > > >   方法 用法 谈及   find     find _   类似 ， 令人 沮丧 ， beautifulsoup 换行符 干扰 ，   这篇 网页   中 提到 预处理 网页 换行符 都 换成 空格 ， 标签 之间 空格符 号 都 删除 解决方案 ， 很 完美 ， 解决 接受 ， 网络 抓取 实际上 进来 网页 简化 预处理 做 一步 工作 。   平行 级别 上 标签   平行 级别 上 标签 类似 描述 ， 往上走 ， 不 赘述 。   find _ previous _ sibling ( ,   attrs ,   string ,   * * kwargs )   返回 标签 对象 （ find _ 方法 ） 方法 :   find _ previous _ siblings ( ,   attrs ,   string ,   limit ,   * * kwargs )   非 平行 级别 标签   find _ parents ( ,   attrs ,   string ,   limit ,   * * kwargs )   find _ parent ( ,   attrs ,   string ,   * * kwargs )   find _ _ ( ,   attrs ,   string ,   limit ,   * * kwargs )   find _ ( ,   attrs ,   string ,   * * kwargs )   find _ _ previous ( ,   attrs ,   string ,   limit ,   * * kwargs )   find _ previous ( ,   attrs ,   string ,   * * kwargs )   . contents     . children   select 方法   select 方法 CSS 选择器 标签 元素 选择 。 原则上 谈论 方法 大部分 需求 ， 再 加上 针对 网站 网页 css 布局 抓取 ， 抓取 方法 很 不 灵活 很 局限性 ， select 方法 用户 备选 方案 。   移除 标签   s   =   soup . find ( ' ' )   s . extract ( )   解析 文档 提升 效率   请 函数 ， 用途 webpage a 连接 href 属性 链接 收集 。   def   _ webpage _ links   (   html   ,   baseurl   ) :   ' ' '   刷 本网页   a 标签     href   属性   links   绝对化 路径   去除 fragment   返回 字典 值去 重   ' ' '   soup   =   BeautifulSoup   (   html   ,   ' lxml '   ,   parse _   =   SoupStrainer   (   ' a '   ) )   links   =   [   link   .     (   ' href '   )     link     soup   .   find _   (   ' a '   ,   href   =   True   ) ]   links   =   [   _ absolute _ url   (   baseurl   ,   link   )     link     links   ]   links   =   [   remove _ url _ fragment   (   link   )     link     links   ]   return   set   (   links   )   :   soup   =   BeautifulSoup ( html ,   ' lxml ' ,   parse _ = SoupStrainer ( ' a ' ) )   parse _   参数 用于 控制 BeautifulSoup 刷 文档 时 创建 标签 元素 对象 ， 只 刷 标签 过滤 操作 ， 节省 工作量 。 参数 创建 一个   SoupStrainer   对象 ， 接受 过滤器 语法 叙述 。",
            "tags":"python_companion",
            "url":"articles/beautifulsoup-module.html"
        },
        {
            "title":"字体反爬虫",
            "text":"爬虫 ， 分析 网页 会 ， 东西 看上去 乱码 ， css 设置 一种 额外 字体 。 破解 内容 ？   目标 字体 下载 ， 字体 各种各样 名字 ， 字体 codepoint 随机 ...   下载 一个 fontcreator 会 字 codepoint ， 爬虫 编码 ， python   fonttools 库来 加载 字体 。   下载 好 字体 ， 保存 好 字体 做好 缓存 工作 。   见 本文 参考资料 2 ， 利用   fonttools   模块 加载 目标 字体 。   font   =   TTFont ( font _ filename )   分析 字体 cmap   tables cmap 数据 ， 字体 情况 ， 分析 ， fonttools 模块 文档 少 ， 加上 字体 知识 不太多 ， 只能 简单 摸索 下 。   font _ mapping   =   font [ ' cmap ' ] . tables [ ] . cmap   找到   font _ mapping   ， 字符   python   ord   函数 下 ， 目标 字符   unicode   code   point ， 说 字体 code   point ，   font _ mapping   会 ， 内容 。   参考资料   https : / / zhuanlan . zhihu . / p / 32087297       find       codepoint     ttf   file",
            "tags":"crawler",
            "url":"articles/zi-ti-fan-pa-chong.html"
        },
        {
            "title":"scrapy模块",
            "text":"简介   Scrapy 模块 Django 模块 上 包括 内容 目录 结构 上 都 很 ， 两个 项目 干 两个 事情 ， 想 相似性 更 描述 类似 GUI 界面 那种 类似 。   尝试 写 一个 小 Spider 网络 爬虫 程序 ， 网络 爬取 大体 过程 都 类似 ， 学习 Scrapy 项目 大体 配置 ， 内部 原理 很 熟悉 ， 本文 地方 赘述 。   scrapy 一个 python 模块 ，   pip   安装 ， 安装 这块 不 说 。   新建 一个 项目   scrapy   startproject   project _   [ path ]   喜欢 创建 python venv 虚拟环境 ， path 设置   .   当前目录 下 。   接下来 编写 爬虫 Spider 脚本 配置 。   第一个 例子   一个 简单 例子 ：   class   MySpider   (   scrapy   .   Spider   ) :   user _ agent   =   _ random _ user _ agent   ( )     =   \" 7yrt \"   start _ urls   =   [   ' http : / / 7yrt . / html / rhrt / '   ]   def   parse   (     ,   response   ) :   url   =   response   .   url   html   =   response   .   text   ##           .   match   (   ' http : / / 7yrt . / html / rhrt / [ \\ d ] + / [ \\ d ] + / [ \\ d _ ] +. html '   ,   url   ) :   images   =   parse _ webpage _ images   (   url   ,   html   ,     =   ' div '   ,   class _   =   ' imgview '   )   title   =   response   .   xpath   (   ' / / h1 / text ( ) '   )   .   extract _   ( )     index   ,   image     enumerate   (   images   ) :   yield   MyItem   (   uuid   =   _ item _ uuid   (   url   ,   str   (   index   ) ) ,   image _ url   =   [   image   ] ,     =   title   )   #####       page   links   =   parse _ webpage _ links   (   url   ,   html   )     _ page     links   :   yield   scrapy   .   Request   (   _ page   ,   callback   =     .   parse   )   user _ agent   属性 改变 爬虫 情况 USER _ AGENT   HTTP 头 ， 设置 ， 爬虫 ban 。     爬虫 名字 ， 下 运行 爬虫 名字   scrapy   crawl   spider _   ， 定义 名字 。   scrapy   list   显示 爬虫 名字 。   start _ urls   爬虫 起始 开爬点 ， 官方 教程 提到   start _ requests   方法 ， 定义   start _ urls   很 简便 。   response 对象   response 对象 获取   response . text   送给 beautifulsoup ，   parse _ webpage _ images     parse _ webpage _ links   做 ， 两个 写 函数 很 简便 ， 没 效率 ， 真的 不在乎 一点 ， 还会 讨论 减缓 爬虫 爬取 速度 。   官方 教程 提到 response 对象 调用   css     xpath   方法 信息提取 工作 ， 简单 下 xpath 语法 ， 很 便捷 。   测试 抓取   scrapy   shell   url   shell ， 有个   response   对象 ， 写 爬虫   parse 函数 response 对象 。 进一步 做 前期 测试 抓取 工作 。   爬取   爬取 爬虫   scrapy   crawl   命令 ：     - a   爬虫 传递 参数 进去   scrapy   crawl   spider _ 51shucheng   - a   book _ = \" xunqinji \"   参数 爬虫 传递   __ init __   ：   def   __ init __ ( ,   book _ = ' ' ,   * * kwargs ) :   推荐 采用 笔者 方式 ， 实践 很 优雅 灵活 ，   - a   传递 极少 参数 ， 爬虫 寻找   . ini   配置文件 所在 ， 加载 配置文件 进一步   start _ url   爬虫 动作 参数 调配 。   xpath 语法   例子 简要 介绍 xpath 语法 ， 参考   阮 一峰 篇文章   菜鸟 教程 xpath 教程 。   东西 简单 下 即可 ， 看 例子 。   /   路径 表达 ， 下个 节点   / /   路径 表达 ， 任意 位置 下个 节点     /   下个 节点 中 匹配 ，   / /   下个 子 节点 匹配 。   / / div [ @ id = ' ' ]   id 定位   / / div [ @ id = ' ' ] / a [ 1 ]   id 定位 后 找 第一个 a 标签   / / div [ @ id = ' ' ] / a [ * ]   id 定位 后 找 a 标签     *   。   / / div [ @ ]   找 属性 div 标签   / / div [ @ = ' ' ]   找 属性 等于 div 标签   / / * [ ( @ class , ' ' ) ]   找 标签 class 属性     NOTICE :   ， 多个 class 属性 匹配   class = \"   _ \"   / / div [ @ class = ' ' ]   目标 标签 class 属性 ， 匹配   class = \" \"   / / * [ @ id = \" list \" ] / / dd [ * ] / a [ @ href     @ title ]   找 id = list 标签 dd 标签 a 标签 ， a 标签 href title 属性 。   / / title [ @ * ]   选择 title ， 随意 属性 ， title 标签 属性   选择 title   / / title   这是 选择 文档 中 任意 位置   title   标签 ，   /   开头 会 选择 根 节点 ， 不太好 。   选择 title 包含 文本   / / title / text ( )   id 选择   / / div [ @ id = ' post - date ' ] / text ( )   例子 选择 一个 div 标签 ， 其有 id 属性   post - date   ， div 改为   *   随便 标签 名字 。   往下选   / / * [ @ id = ' js _ profile _ qrcode ' ] / div / p [ 1 ] / span / text ( )   选择 目标 标签 属性   / / / / * [ @ id = ' js _ profile _ qrcode ' ] / / a / @ href   选择 属性   / / * [ @ id = \" list \" ] / / dd [ * ] / a [ @ href     @ title ] / @ href   选择 文本   / / title / text ( )   string   选择 节点 （ 返回 节点 集   nodeset 只取 第一个 ） ， 节点 （ 包括 子 节点 ） 文本 抽取 合并 。   string ( / / div [ @ class = \" lemma - summary \" ] )   减缓 访问速度   网络 爬取 中 ， ban （ 403 错误 由此而来 ） 大 。 开 代理 换 IP 成本 挺 高 ， 手段 ， 都 settings . py ， 只 去 注释 。 大体 ：   DOWNLOAD _ DELAY   =   3   CONCURRENT _ REQUESTS _ PER _ DOMAIN   =   16   # CONCURRENT _ REQUESTS _ PER _ IP   =   16   #   Disable   cookies   ( enabled     default )   COOKIES _ ENABLED   =   False   设置 下载 访问 停顿 时间 并行 请求 数 禁用 cookies 。 禁用 cookies 之外 ， 几个 设置 不用 ， 请 官方 文档     。     settings . py   文件 些 ， 这是 一种 自动 节流 机制 ， 利用 下载 延迟 并行 数来 自动 调节 DELAY 时间 ，   AUTOTHROTTLE _ ENABLED   =   True   #   The   initial   download   delay   AUTOTHROTTLE _ START _ DELAY   =   5   #   The   maximum   download   delay       set     case     high   latencies   AUTOTHROTTLE _ MAX _ DELAY   =   60   #   The   average   number     requests   Scrapy       sending     parallel     #     remote   server   AUTOTHROTTLE _ TARGET _ CONCURRENCY   =   1.0   要说 自动 节流   DOWNLOAD _ DELAY     CONCURRENT _ REQUESTS _ PER _ DOMAIN   协作关系 。 自动 节流 最小 小过   DOWNLOAD _ DELAY   ， 大过   AUTOTHROTTLE _ MAX _ DELAY   。     AUTOTHROTTLE _ TARGET _ CONCURRENCY   一个 节流 建议 ， 极限 ， 单个 域名 并行 请求 数是   CONCURRENT _ REQUESTS _ PER _ DOMAIN   定义 。   控制 输出   scrapy   crawl   命令 默认   - o   test . json   参数 省略 ， settings . py   控制 输出 格式 文件名 ， 请 参看 scrapy 官方 文档   feed - export   一章 。   配置 默认 输出 jsonlines 格式 ， 爬虫 数据 收集 来说 会 更好 一点 ， 容错 率高 一点 ：   FEED _ URI   =   ' file : / / / output / % ( ) s / % ( time ) s . jl '   FEED _ FORMAT   =   ' jsonlines '   FEED _ EXPORT _ ENCODING   =   ' utf8 '   慎用 scrapy 高级 特性   请 慎用 scrapy 高级 特性 ， PIpeline ， middleware ， 请 慎用 数据库 。 简单 练手 性质 项目 ， 正式 爬虫 项目 ， 够 操心 事 一大堆 ， ， 先 数据 爬 到手 。 弄 高级 特性 数据库 只会 精力 吸走 ， 关注点 爬 取 ， xpath 分析 ， 数据 收集 数据 后处理 上 。   模拟 用户 登录   表单 简单 来说 一个 前端 友好 界面 ， 其实质 发送   一个   POST   请求 。   关键 理解 前端 表单 界面 ， POST 参量 。   < form   method = \" POST \"   action = \" \"   < input   type = ...   = \" firstname \"   ...   >   < input   type   ...   submit   < / form >   input         POST   参量 ， action   POST   目的地 。   类似 表单 很多 元素 ， checkbox ， 都 用户 快速 设置 参量 。   登录 cookies   http 无 状态 ， cookies     session   ， 服务端 数据库 记录 session ， cookies 客户端 。 爬虫 登录 ， 记得 保留 好 登录 成功 cookies 。   请求 ， requests cookies 保存 设置 不好 。 记得 requests session 机制 。   import   requests   session   =   requests . Session ( )   data   =   { ' username ' : ' user ' ,   ' password ' :   ' 123456 '   }   s   =   session . post ( ' login . html ' ,   data )   #####   session 请求 ，   s . ( ' profile . html ' )   import   scrapy   class   LoginSpider   (   scrapy   .   Spider   ) :     =   ' . '   start _ urls   =   [   ' http : / / www . . / users / login . php '   ]   def   parse   (     ,   response   ) :   return   scrapy   .   FormRequest   .   _ response   (   response   ,   formdata   =   {   ' username '   :   ' john '   ,   ' password '   :   ' secret '   } ,   callback   =     .   _ login   )   def   _ login   (     ,   response   ) :   #   check   login   succeed           \" authentication   failed \"     response   .   body   :     .   logger   .   error   (   \" Login   failed \"   )   return   #   continue   scraping     authenticated   session ...   封 策略   设置 随机 user   agent 策略   禁用 cookie   COOKIES _ ENABLED   =   True   设置 下载 停顿   DOWNLOAD _ DELAY   =   n   代理 池   封 首要 策略 尽量 别人 服务器 下 ， 写 爬虫 少 请求 ， 每次 请求 都 核心 请求 获取 最 核心 数据 ， 刷 页面 刷 ajax ， 请求 之间 设置 一个 停顿 时间 。   time . sleep ( 3 )   首要 原则 基础 上 ， 介绍 很多 实战 技巧 ， 都 符合 一个 大 原则 ： 尽可能 爬虫 人 浏览 网页 区别 。   http 请求 头 调整   user - agent   设置 ， 时不时 切换 下 。   还 ， 推测   Referrer   header 场景 下 文章 。     Accept - Language   有用 。   Cookies   情况 下 cookies 获取 javascript 支持 。 cookies 总 原则 第一次 请求 获取 cookies ， 很 请求 都 cookies 即可 。   反 爬虫 cookies 都 会 时间 ， 一个 简单 做法 设置 时间 ， 定时 获取 最新 cookies ， 请求 量 再 获取 一个 新 cookies 。     scrapy - splash   下 。   表单 陷阱   表单 ：   < input   type = \" hidden \"   ...   记住 人 页面 上 点击 ， 显示 字 段 值 会 一并 送 ， 服务器 会 值 加密 值来 判断 请求 人点 爬虫 。   策略 先 表单 内容 爬 ， 收集 好 再 发送 表单 请求 。   情况 ， 一种 情况 ， 页面 表单 发送 特别 ， 表 单字 段 ， 用户 看得见 看不见 ， 都 发送 ， 发送 会 毙掉 。   表单 陷阱 ， css 会 动态 input   hidden 属性 ， 好好 分析 下 。   403   forbidden   这极 爬虫 封 。   高级 议题   JsonPipeline   pipelines . py   文件 定义 写 Pipeline 类 ， JsonPipeline 类 ：   class   JsonPipeline   (   object   ) :   def   __ init __   (     ) :     .   file   =   codecs   .   open   (   ' test . json '   ,   ' w '   ,   encoding   =   ' utf - 8 '   )   def   process _ item   (     ,   item   ,   spider   ) :   line   =   json   .   dumps   (   dict   (   item   ) ,   ensure _ ascii   =   False   ,   indent   =   4   )   +   \"   \\ n   \"     .   file   .   write   (   line   )   return   item   def   spider _ closed   (     ,   spider   ) :     .   file   .   close   ( )   大体 一个 简单 类 ， 特别 方法 特别 用处 。 jsonpipelie 不 实用价值 ， 简单 下 即可 。   ImagesPipeline   想要 自动 下载 图片 ， 没 ， scrapy 内置 功能 ！ 做 收集 好 图片 连接 。 设置 里 加上 一行 ：   ITEM _ PIPELINES   =   {   ' scrapy . pipelines . images . ImagesPipeline ' :   1 ,   }   设置 里 相关 配置 :   IMAGES _ STORE   =   ' / path / / download _ images '   IMAGES _ URLS _ FIELD   =   ' image _ url '   IMAGES _ RESULT _ FIELD   =   ' image '     IMAGES _ URLS _ FIELD   默认值   image _ urls   ， items 对象 加上 这一 属性 ， 其是 一个 列表 值 。   IMAGES _ RESULT _ FIELD   默认值   images   ，   值 ImagesPipeline 会 自动 填充 ， 不 。 改名字 是因为 不 喜欢 很多 图片 混在 ， 做 分开 。   MongoDBPipeline   想要 数据 实时 填入 mongodb 去 ？   MongoDBPipeline   即可 ，   pip   install   scrapy - mongodb   配置 加上   ITEM _ PIPELINES   =   {   ' scrapy _ mongodb . MongoDBPipeline ' :   400 ,   }   数字 执行 优先级 ， 没什么 特别 含义 。   配置 ：   MONGODB _ URI   =   ' mongodb : / / localhost : 27017 '   MONGODB _ DATABASE   =   ' myscrapy '   MONGODB _ UNIQUE _ KEY   =   ' uuid '   插件   MONGODB _ COLLECTION   值 默认   items   死 ， 还 很 满意 。   MONGODB _ UNIQUE _ KEY   还 不 ， 时间 。   settings 传递   爬虫 初始化 后 ，   . settings   ， 调用   settings . py   文件 配置 变量 。 写 pipeline ， ：   def   open _ spider   (     ,   spider   ) :     .   client   =   MongoClient   (     .   mongo _ uri   )     .   mongodb   =     .   client   [     .   mongo _ dbname   ]   spider   .   mongodb   =     .   mongodb   open _ spider   打开 爬虫 后 动作 ， 定义   . mongodb   目标 mongodb   数据库 对象 挂载   pipeline 上 ，   spider . mongodb   变量 挂 爬虫 上 ， 爬虫类 都   . mongodb   调用 目标 变量 ， 说 爬虫类   __ init __   方法 还 不大 。 写 pipeline   crawler . settings   配置 变量 ：   @ classmethod   def   _ crawler   (   cls   ,   crawler   ) :   return   cls   (   mongo _ uri   =   crawler   .   settings   .     (   ' MONGODB _ URI '   ) ,   mongo _ dbname   =   crawler   .   settings   .     (   ' MONGODB _ DATABASE '   )   )",
            "tags":"crawler",
            "url":"articles/scrapy-module.html"
        },
        {
            "title":"bash脚本学习笔记",
            "text":"前言   简单 讲   bash   shell   脚本 知识 ， 点到为止 。 日常 linux 作业 中 很 有用 。 一个 蹩脚 编程语言 【 抱歉 说 】 不 推荐 编写 bash 脚本 代码 ， 这块 需求 ， 工具 。   变量   i = 2   echo   $ i   赋值 上 所示 ， 编程语言 变量 赋值 大体 类似 ，   特别 变量 值 之间 号 相连 ， 空格 隔开   。 变量 符号 字母 数字 ， 加 下划线 。 声明 变量 局部变量 ， shell 中 。 创建 全局变量 export 命令 。   变量 加上   $   符号 ， 变量 字符 字符 组合成 一个 新 字符 ， 用花 括号 变量名 包围起来 。 形式   $ { i }   。 一般来说 变量 都 推荐   $ { }   形式 。   ： 修改 终端 前缀   export   PS1 = \" = > \"   利用 export 命令 变量 变为 全局变量 （ 全局变量 指子 shell 继承 父 shell 变量 。 ） ， shell 脚本 都 通用 。   代码 放入 你家 目录   . bashrc   文件 ， 每次 终端 启动 都 会 自动 加载 文件 。 开启 终端 前缀 都 会   = >   形式 。   节省 点 屏幕 空间 。 pwd 命令 查看 ， 都 影响 。   PS1 终端 一级 前缀 符号 ， PS2 进一步 输入 提示 符号 。 换成 形式 ：   export   PS2 = \" > \"   echo 命令   echo 命令 接触 很多 ， 不 赘述 。 echo 命令 用于 查看 变量 值 输出 一行 字符串 。   unset 命令   取消 bash 变量 赋值 。   read 命令   请求 用户 输入 变量 值   read     ;   echo   ' 输入 ： ' $ { }   bash 特殊符号   分号 bash 编程语言 都 大体 类似 ， 一行 结束 。 bash 很多 特殊符号 ， 讲 ， 特殊符号 搜索 都 不太好 搜索 。   更 信息 请参阅   网页   。   $ 0   命令 名字 ， shell 脚本 成 脚本 名字 。   $ 1   $ 2   ...   命令 接受 参数   $ @   参数 ：   { $ 1 ,   $ 2 ,   $ 3   ... }   ， 其是 一个 array 。   $   上 一个 命令 返回 状态 ， 0 成功 。   $ !   上 一个 命令 运行 进程 号   &&     cmd1   &&   cmd2   前 一个 命令 执行 成功 再 执行 第二个 命令   &   命令   &   结尾 ， 命令 异步 ， 后台 执行 。 （ PS ： ， 远程 连接 服务器 创建 命令 ， 远程 关闭 后台 进程 自动 关闭 。 nohup screen 。 ）   条件 判断   条件 语句 格式 ：     [   test   expression   ]         fi   短小 shell 命令行 ， 写成 一行 格式 ， 分 号 换行 。     [   test   expression   ]   ;         ;   fi   还 值得 提醒 ： 条件 判断 语句 （ test   expression ） 方括号 [ ] 一个 空格 分开 ， （ 上古 神器 都 怪僻 ， 淡定 好 ） 。   ： 确认 文件夹     [   !   - d   workspace   ]   ;     mkdir   workspace   ;   fi   - d   检测 文件夹 ，   !   符号 逻辑 否 操作 。 workspace 不 ， 新建 workspace 文件夹 。   循环   小节 参考   bash     loop   篇文章 ， bash 编程 循环 讲 很 详细 。   循环 语句 格式 ：     var     1   2   3     cmd1   cmd2     ， 写成 一行 样子 ：     var     1   2   3   ;     cmd1   ;   cmd2   ;     ​   加分 号 地方 多行 格式 下 换行 地方 。   ： 小数点 递加 输出 流     animate     $ (   seq   4   . 0   0   . 1   8   . 0   )   ;     echo   $ {   animate   }   ;     seq 命令 简单 说 下 ， 请   - -   查阅 信息 ：   用法 ： seq   [ 选项 ] ...   尾数   ： seq   [ 选项 ] ...   首数   尾数   ： seq   [ 选项 ] ...   首数   增量   尾数   ： 批量 创建 文件   文件夹 输入 命令 ：     ( (   i   =   1   ;   i <   =   10   ;   i ++   ) )   ;     touch   file   $ i   . txt   ;     ： 批量 缩小 图片大小   这是 一个 多行 脚本 ， 用于 批量 缩小 图片 大小 。     [   !   - d   smallsize   ]   ;     mkdir   smallsize   ;   fi   cd   smallsize     i   =   1         $ (   ls   * . png   )     convert   - resize   50   % x50%   $   $ i   -   $     i   =   i + 1   echo   $     smallsized     ： 批量 重命名 文件     i   =   1   &&     f     $ (   ls   * . jpg   )   ;     mv   - vi   $ {   f   }   0000   $ {   i   }   . jpg   &&     i   =   i + 1   ;     调用 子 命令 返回值   几个 例子 中 ， 形式 ：   $ ( cmd )   ， 执行 子 shell 命令 ， 返回 字符串 值 。   array   shell 编程 过多 涉及 编程 内容 ， 很 痛苦 ， 情况 下 array 概念 。 演示 一个 例子 ， 需求 一个 自动 备份 程序 之上 再 加上 自动 删除 逻辑 。   DATE   =   $ (   date   +% F   )   DAYS   =   30   ##         autodump   code ,       output   filename     whatdump _ $ { DATE }   ###     allowed   list   ALLOWED   [   0   ] =   whatdump _   $ {   DATE   }     ( (   i   =   1   ;   i   &   lt   ;   =   $ {   DAYS   }   ;   i ++   ) )     ALLOWED   [   i   ] =   whatdump _   $ (   date   - d   \"   -   $ {   i   }   days \"   +   \" % F \"   )     ###       python   script   ,         hard     write       bash   python   ~ / thepython / scripts / whatdump _ autoremove . py   $ {   ALLOWED   [ @ ]   }   程序 逻辑 创建 一个 名字   whatdump _ DATE   备份文件 （ crontab 控制 好 运行 ） ， 希望 目标 文件 只 保留 三十天 文件 。 逻辑 较为 ， 本来 打算   DATE   参数传递 python 脚本 做 接下来 工作 ， date 命令 强大 人类 友好 日期 时间 表达 功能 （ 请 参考     ） ， 文件名 都 传递 进 python 脚本 中 去 。   兴趣 下 date 命令 - d 选项 灵活 表达 支持 ，   date   - d   \"   - 3days \"   三天 日期 时间 ，   date   - d   \" + 3weeks \"   三周 日期 时间 。 兴趣 下 ， date 命令 - d 选项 真的 好 强大 。   好 详细 讲 array 涉及 语法 。   赋值 引用   =   > array   [   0   ] =   \" \"   =   > array   [   1   ] =   \" world ! \"   =   > echo   $ {   array   [ 0 ]   }   $ {   array   [ 1 ]   }     world !   表达 常见 那种 数组 概念 相近 ， 记得 索引 0 惯例 即可 。 赋值 :   =   > array2   = (   \" \"   \" python \"   )   =   > echo   $ {   array2   [ @ ]   }     python     $ { arrayname [ @ ] }   表达方式 引用 array ，   $ { # arrayname [ @ ] }   表达 返回 array 长度 。   = > echo   $ { # array2 [ @ ] }   2   这句 :   python   ~ / thepython / scripts / whatdump _ autoremove . py   $ { ALLOWED [ @ ] }   收集 文件名 array 传递 进 python 脚本 中去 。 python 脚本 中 一个 粗糙 做法 引用   def   main ( args , path = \" \" ) :   print   args   main ( sys . argv [ 1 : ] )   array 传递 进 args 去 ， 读者 兴趣 试一下 ， args python 中 一个 列表 对象 。 python 更 逻辑 都 很快 写 ， 不 说 。   大概 类似 所示 ， pathlib python3.4 才 会 ， pip 安装 。   # ! / usr / bin / env   python   #   - * -   coding :   utf - 8   - * -     __ future __   import   print _ function   import   sys     datetime   import   datetime   import   os     pathlib   import   Path   import   shutil   def   main   (   args   ,   path   =   \" \"   ) :   allowed   =   args   p   =   Path   (   path   )   pfolds   =   [   p     p     p   .   iterdir   ( )     p   .   _ dir   ( ) ]   print   (   pfolds   )     p     pfolds   :     p   .       allowed   :   print   (   p   .     ,   \" passed \"   )     :   print   (   p   .     ,   \" removed \"   )   ###         remove   thing   shutil   .   rmtree   (   p   .     )     __ __   = =   ' __ main __ '   :   ###   切换 autodump 目录   os   .   chdir   (   os   .   path   .   expanduser   (   \" ~ / autodump \"   ) )   main   (   sys   .   argv   [   1   : ] )   date 命令   date 命令 放在 一章 是因为 date 命令 单独 一个 命令 ， 打印 显示 日期 意义 很大 。 bash 脚本 中 ， 管道 中 ， date 命令 却 变得 有用 。 读者   - -   查看 信息 ， 命令 预想 还要 ， 输出 格式 参数 控制 语法 ， 编程语言 中 有用 （ python time 模块 中 strftime 函数 ） 。   date 返回 日期 字符   date 命令 返回 特定 格式 日期 shell 脚本 中 很 有用 ， 所示 一个 简单 例子 ：   date = $ ( date   + \" % F _% R \" ) ; echo   $ date   date 命令 已 谈到 一点 ， 更 信息 请 参看   篇文章   。 不 赘述 。   xargs 多行 转 一行   sudo   rmdir   - - ignore - fail - - - empty   $ ( ls   - U   |   head   - n   10000   |   xargs )   这是 一个 批量 删除 空 文件夹 命令 ， 假设 空 文件夹 数目 很多 。   ls   - U   单纯 列出来 ， 管道 导向   head   只 打印 最 几行 ， 管道 导向   xargs   命令 ， 多行 转 成 一行 ，   rmdir   参数 。",
            "tags":"linux",
            "url":"articles/bash-learning-notes.html"
        },
        {
            "title":"ansible",
            "text":"ansible 一个 自动化 运维 工具 ， 学习 ， 会 发现 只 写 一个 简单 web   app ， 远程 计算机 环境 很多 配置 ， 后台 脚本 执行 ， nginx 配置 服务 静态 文件 。 都 手工   ssh   端 操作 低效率 ， 繁多 ， 环境 重复 部署 。 ansible 解决 这一 。   第一个 例子 ： 假设 免 密钥 登录 一个 远程 服务器 ，   / / ansible / hosts   文件 服务器 名字 加进去 ， 执行 :   ansible     - m   ping   一切正常 返回   SUCESS   信息 ， 证明 ansible 连通 远程 服务器 。   hosts 文件 配置   讨论   / / ansible / hosts   文件 默认   inventory   文件 ， 默认 inventory 配置文件 之外 ， 还 写 很多 配置文件 。 配置文件 内容 大体 :   [ webservers ]   foo . .   bar . .   [ webservers ]   字 段 定义 主 机组 概念 ， 随便 写上去 主机 没 主 机组 ， 一个 主 机组 还 一个 主 机组 ， 。 主 机组 主机 统一 管理 ， 。   主机 变量 设置   组 变量 情况 请 看 文档 ， 主机 变量 大体 写 上 值 ， 变量 定义 后 playbooks ， playbooks 无疑 重头戏 ， 值得 提 。   [ atlanta ]   host1   http _ port = 80   maxRequestsPerChild = 808   host2   http _ port = 303   maxRequestsPerChild = 909   主机 参数 控制   大多 ssh 连接 配置 ， :   _ host   ansible _ ssh _ port = 2222   ansible _ ssh _ user = manager   ansible _ ssh _ host   没 好 设置 ， 主机名 很长 ， 设置 连接 主机名 。 写   _ host   主机 别名 。 ansible 版本号 大于 2 ， 推荐   ansible _ host   。   ansible _ ssh _ port   端口号 ， 默认 不 配置 。 ansible 版本号 大于 2 ， 推荐   ansible _ port   。   ansible _ ssh _ user   ssh 登录 用户名 ， 默认 电脑 登录 用户名 ， 情况 下 配置 。 ansible 版本号 大于 2 ， 推荐   ansible _ user   。   ansible _ ssh _ pass   登录 密码 ， 免 密钥 登录 不 配置 。 文档 说 不 推荐 。   playbooks 熟悉 yaml   简单 下 yaml 语法 ， 一个 简单 例子 :   - - -   #   一位 职工 记录     :   Example   Developer   job   :   Developer   skill   :   Elite   employed   :   True   foods   :   -   Apple   -   Orange   -   Strawberry   -   Mango   languages   :   ruby   :   Elite   python   :   Elite   dotnet   :   Lame   yaml 文件 都 加上 :   - - -   。   注释   #   缩进 级别   -   开头 一个 列表 ， 键值 字典 ， 大体 。   playbook 入门   最 简单 一个 例子 ， 新建 一个   . yaml   文件 :   - - -   -   hosts   :   work   tasks   :   -     :   ping     pong   ping   :   执行 :   ansible - playbook   . yaml   简单 ping   pong   ， 配置 简单 内容 主机   work   ， 提到   / / ansible / hosts   文件 里 定义 。 主机 执行   tasks   。 这是 一个 列表 清单 ，   描述 ， 文字 随意 。 执行   ping   模块 。   确保 nginx 重启 :   -   :   make     nginx   restarted   service :   = nginx   state = restarted   确保 nginx 服务 运行 :   -   :   make     nginx     running   service :   = nginx   state = running   playbook 最佳 实践   hosts 文件   项目 文件夹 下 新建 一个 hosts 文件 ， 类似 讨论   / / ansible / hosts   文件 ， 本地 语法 引入 ：   ansible - playbook   - i   hosts   site . yml   ​   site . yml   刷 脚本 主 入口   tags 单独 运行 子   roles 文件夹 新建 一个 common 文件夹 ， common 文件夹 新建 一个 tasks 文件夹 ， tasks 文件夹 定义 一个 main . yml ， 文件 内容 大体 :   - - -   -   :   task 名字   command :   ...   site . yml 定义 ：   - - -   -     :   ansible   参数 侦测   hosts   :     remote _ user   :   root   roles   :   -   {   role   :   common   ,   tags   :   [   ' common '   ] }   只 运行 子 利用 tags 。   ansible - playbook   - i   hosts   site . yml   - - tags = common   ​   临时 加上   tags     -     :   create   odoo   superuser   shell   :   su   -   postgres   - c   \" createuser   - s   { {   user   } } \"   tags   :   -   psql _ user   role 全局 参数   全局 参数 放在   group _ vars   文件夹     文件 ， 一个 简单 yaml 文件 。   role 里 局部参数   参数 推荐 site . yml 文件 role 定义 ， 所示 定义 一个   folder _   变量   ：   roles   :   -   {   role   :   update - sdsomweb   ,   folder _   :   \" resource / install _ venv \"   ,   tags   :   [   ' update - sdsomweb '   ] }   ansible - playbook 最 配置 编写 很 简单 ， 关键 具体任务 熟悉 好 特定 模块 。   playbook 模块   官方 模块 很多 ， 内容 很 ， 不 赘述 ， 请 参看 官方 文档 。   本地 安装   hosts 添加 一行 ：   localhost   ansible _ connection = local   本地 安装 不 提供 ssh 用户名 密码 ， 不 上传 ssh   key ， 上传 操作 加上 一行 ：   :   ansible _ connection   ! =   \" local \"   ​   压缩包 解压包 远程 机器 目标 点   值得一提 unarchive 模块 才 支持   remote _ src   模式 ， 推荐 采用 本地 压缩包 源 解压 方式 。   -     :   解压   apr   unarchive   :   src   :   \" { { folder _ } } / apr - 1.5 . 2 . tar . gz \"   dest   :   / root   rsync 风格 文件夹 复制   不 利用 copy 模块 ， scp 文件夹 结构 稍微 点 会 很慢 ， 推荐   synchronize   模块 ：   -   :   上传 源   synchronize :   src = resource / winstore   dest = / root   mode = push   值得一提的是 ， rsync 远程 机器 免 密码 ssh 连接 ， 输入 密码 ， 推荐 playbook pub 密钥 传 ， rsync 功能 远程 机装 libselinux - python   rsync   两个 软件包 。   -   :   上传 ssh   key   authorized _ key :   user = root   key = \" { {   lookup ( ' file ' ,   ' / home / / . ssh / id _ rsa . pub ' )   } } \"   user 登录 远程 机器 用户名 。   远程 机器 更 参数信息   ansible   setup   模块 远程 机器 很多 有用 信息 ， 远程 机器运行 虚拟机 软件 。 更 信息 ， 远程 机器 默认 python 版本 ， 方式 ：   -   :     python   version   command :   python   - c   ' import   sys ; print ( \" { 0 } . { 1 } \" . format ( sys . version _ info . major , sys . version _ info . minor ) ) '   register :   python _ version _ check   register 注册 执行 命令 command 返回 ， ansible 运行 时里 都 ， 还   python _ version _ check . stdout   方式 。   command   shell 区别   command shell 很多 情况 下 都 区别 ， shell 意义 上 来讲 类似 shell 中 执行 命令 ， bash 环境变量 ， 没事 会 优先 shell 模块 。   pip 虚拟环境 下 工作   参考   网页   ， 所示 目标 虚拟环境 文件夹 下 requirements . txt 文件夹 描述 安装 目标 python 模块 虚拟环境 中 。   -     :   Install   requirements   pip   :   requirements   :   / _ app / requirements . txt   virtualenv   :   / user / home / venvs / myenv   virtualenv _ python   :   python3.4   安装 本地 rpm 包   兴趣 看 ansible   yum   模块 ， 免 网络 利用 本地下载 rpm 包来 安装 模块 很 好 ， 很 好 模块 之间 依赖 。 推荐 调用 shell 模块 ， 所示 ：   -   :   install   rpms   shell :   yum   localinstall   - yC   - - disablerepo = *   ` ls   / path / / rpms / * . rpm `   rpm 包 base ， 推荐 ：   yum   install   yum - utils   yum   install   - - downloadonly   - - downloaddir = .   _ rpm _   下载 。 来自 epel ， 推荐   pkgs . org   搜 名字 ，   网站   下载 。   删除 文件 文件夹   删除 文件 文件夹 推荐   file   模块 调用 rm 命令 ， 所示 ：   -   :   确保 目标 venv 文件夹 不   file :   path = / opt / sdsom / venv   state = absent   微调 配置文件   配置文件 远程 机器 上 有个 原样 ， 几行 修改 ， lineinfile 模块 微调 配置 很 适宜 。   -     :   调配 apache   httpd . conf   lineinfile   :   dest   :   / / apache / conf / httpd . conf   regexp   :   \" { { item . regexp } } \"   insertafter   :   \" { { item . insertafter } } \"   line   :   \" { { item . line } } \"   _ items   :   -   {   regexp   :   \" &# 94 ; Listen   \"   ,   insertafter   :   \" &# 94 ; # Listen   \"   ,   line   :   \" Listen   8880 \"   }   -   {   regexp   :   \" &# 94 ; User   \"   ,   insertafter   :   \" &# 94 ; # User   \"   ,   line   :   \" User   sdsadmin \"   }   -   {   regexp   :   \" &# 94 ; Group   \"   ,   insertafter   :   \" &# 94 ; # Group   \"   ,   line   :   \" Group   sdsadmin \"   }   -   {   regexp   :   \" &# 94 ; ServerName   \"   ,   insertafter   :   \" &# 94 ; # ServerName   \"   ,   line   :   \" ServerName   { { server _ } } \"   }   例子   regexp   匹配 目标 行 ，   替换 内容   line   。 insertafter 匹配 ， line 插入 该行 。   例子 插入 一行   line ：   -     :   Load   config   files       config   directory   conf . d / * . conf   lineinfile   :   dest   :   / / apache / conf / httpd . conf   line   :   \" { { item . line } } \"   _ items   :   -   {   line   :   \" Include   conf . d / * . conf \"   }   template 模块 利用 本地 模板 文件 （ jinja2 模块 系统 ） 生成 一个 配置文件 。   只 版本 操作系统 下才 执行 动作       语句 表达 ， 只 远程 机器 操作系统 CentOS 版本号 7.2 时才 执行 动作 （ 参考   网页   。   -   :       centos7.2       tweak   command :   ...   :   ansible _ distribution   = =   ' CentOS '     ansible _ distribution _ version . startswith ( ' 7.2 ' )   ansible _ distribution   还   Ubuntu   ， Debian   ，   Red   Hat   Enterprise   Linux   。   register 用法   比如说 写 上 一个 简单   test . yml   文件 ， 内容 ：   - - -   -   hosts   :   localhost   tasks   :   -     :   test   shell   :   date   register   :   test   -     :   debug   debug   :   msg = \" { {   test [ ' stdout ' ]   } } \"   运行 ：   ansible - playbook   - i   \" localhost , \"   - c   local   test . yml   运行 显示 运行 date 命令 注册 ansible 全局变量 池 去 ， 名字 register 赋值 ， jinja2 模板 系统 中 都 调用 。   _ items 用法   请 参看 官方 文档     。   换行 写 一行 写   小 细节 ， 官方 文档 看 会 两种 形式 ， 不多 说 。   lookup 用法   lookup 上传 ssh   key 用到 ，   ansible 一个 高级 。   command   模块 skip 判断   加上   creates   参数 command 跳过 判断 标准 ， 文件 command 执行 会 跳 。   local _ action   local _ action     delegate _ :   127.0 . 0.1   缩写 ， 简单 来说 只 本机 说 操作 机上 执行 动作 。 顺便 提   delegate _   含义 ， 指定 主机 执行 动作 ， 脱离 ansible 默认 inventory 输出 几个 hosts ，   delegate _   主机 默认 几个 hosts 中 一个 ， 主机 。   tasks   :   -     :         load   balancer   pool   local _ action   :   command   / usr / bin / _ _ _ pool   { {   inventory _ hostname   } }   handlers   -     :   template   configuration   file   template   :   src = template . j2   dest = / / foo . conf   notify   :   -   restart   memcached   -   restart   apache   handlers   :   -     :   restart   memcached   #   The   service   module     ,             module     wanted   service   :   = memcached   state = restarted   -     :   restart   apache   service   :   = apache   state = restarted   会 playbook role hanlders 文件夹 ， 简单 来说 执行 （ 跳过 不算 ， 执行 changed   state 返回 ） ， 执行 notify :   定义 hanlders 。   参考资料   ansible 官方 文档   ， 有个 翻译   中文 ansible 官方 文档   。   - - - ansible   篇文章 写 ansible 东西 写 挺 好 。",
            "tags":"linux",
            "url":"articles/ansible.html"
        },
        {
            "title":"html5学习教程二css篇",
            "text":"css 基础   谈到 inline   css 肯定 作用 于本 标签 ， 写法 简化 ， style 引入 属性 即可 。 谈到 外部 css ， 写法 都 所示 :   p   {   text - indent   :   2   em   ;   / * 段落 缩进 * /   line - height   :   180   %   ;   / * 行间距 * /   }   第一个 元素 简单 称之为 css 选择器 ， 网络 抓取 中 类似 概念 。 花 括号 类似   inline   css   格式 ， 用分 号 隔开 ， 换行 不 换行 都 无所谓 ， 美观 都 一个 属性 占 一行 。   css 选择器   html5 为例 ， html5 内置 标签 都 引用 ， body ， article ， video ， table ， figure 。 css 中 引用 section ， 文档 section 标签 元素 选中 。   html5 中   class   属性 元素 归于 一类 ， 假设 :   <   p   class   =   \" emph \"   >     < /   p   >     p . emph   选中 p 标签 class 属性 emph 标签 。   css 中 形式 ：   . hightlight   完整 形式   * . hightlight   ， class 属性 hightlight 元素 都 选中 。   id 属性 可用 定义 标签 唯一 id ，   # idname   选中 标签 即可 。   子 选择器   h1   >   strong   ， 只 选择 h1 标签 下   第一个   strong 标签 ， 下 意义 上 父子 标签 包含 关系 下 ， strong 标签 em 标签 ， em 标签 h1 标签 ， strong 元素 逐级 选择 选中 。   后代 选择器   figure   p   选择 figure 标签 元素     p 标签 元素 。 谈及 标签 元素 方法 都 ，   # footer   . emph   选择 id footer 标签 class 属性 emph 标签 。   更 css 选择 信息 请 参看 w3school   css 元素 选择 详解   ， 一块 弄 太 。 实际上 选择 逻辑 弄 越 css 代码 维护 越 困难 ， 实践   class     id   管理 css 属性 。   带上 属性 选择   href 属性 a 标签 才 样式 :   a [ href ]   { color : red ; }   href 属性 title 属性 a 标签 才 样式 :   a [ href ] [ title ]   { color : red ; }   属性 值 指定 :   a [ href = \" http : / / www . w3school . . cn / _ . asp \" ]   { color :   red ; }   伪类 选定   带个 : 冒号 跟着 标签 伪类 ， 值 标签 某种 状态 ， 最 常见 a 标签 状态 ， 所示 :   a : link   { color :   # FF0000 }   / *   未 访问 链接   * /   a : visited   { color :   # 00FF00 }   / *   已 访问 链接   * /   a : hover   { color :   # FF00FF }   / *   鼠标 链接 上   * /   a : active   { color :   # 0000FF }   / *   选定 链接   * /   - child 伪类   p : - child   {   color :   red ;   }   父 标签 第一个 子 标签 元素 才 会 选定 。   nth - child 伪类   p : nth - child ( 2 )   {   color :   red ;   }   父 标签 第几个 子 标签 元素 才 会 选定 。   css 选择权 值   标签 多个 css 语句 选定 ， 权值 ：   标签 权值 1   子 选择器 后代 选择器 两个 标签 1 + 1 = 2   类 选择器 权值 10   id 选择器 权值 100   css 样式 层叠 优先级   内联 样式   >   嵌入 样式   >   外部 样式   ! important   用法   css 设置 不可避免 会 发生 样式 重叠 覆盖 ， 尽可能 统一 css 设置 ， 嫌 麻烦 懒得 弄 ，   ! important   手工 提高 css 设置 优先级 ( 参考   网页   。 ) 。 所示 ：   table   ,     ,   td   {   margin   :   0   auto   ;   min - width   :   2   em   ;   text - align   :   center   ! important   ;   padding   :   5   px   ;   }   严格控制 表格 各项 都 居中 对齐 。   css 长度 单位   css 很多 长度 单位 ， 单位 熟悉   ( \\ LaTeX )   会 单位 很 眼熟 。 长度 单位 ： 1in   =   2.54 cm   =   25.4 mm   =   72pt   =   6pc   ， 不 推荐 。   这篇 网页   推荐   px   ，   em     %   长度 单位 。 \" px \" \" % \" css 特有 ， 其会 显示屏 变动 ， 1em 字体 M 宽度 （ TeX 情况 ） 。 px 值得 ， 其会 显示 设备 很 好 调整 ， 更 信息 请 参看 提到 参考 网页 。   css 盒子 模型   html 显示 布局   ( TeX )   显示 布局 采用 浮动 盒子 模型 ， 从上到下 ， 从左到右 ， 一个个 盒子 排下来 ，   ( TeX )   更 ， 一个 分页 算法 。 简言之 一个 标签 元素 都 一个 盒子 ( 还 不 太 一个个 字 一个 盒子 ，   ( TeX )   一个个 字 都 一个 盒子 。 )   。   图片 来自   网页   。   篇文章   讲解 很 好 ， 简要 介绍 ， 放在 短 代码 环境 都 用作 css 属性 。 盒子 最 中心 content 区域 ， 盒子   box - sizing   默认值 ，   width   控制 content 区域 宽度 。   box - sizing   设置   border - box   ，   width   盒子 宽度 。 一点 简单 数学 加减法 把戏 ， 没什么 大不了 。   类似   height   默认 控制 content 区域 高度 ，   min - width   ,   min - height   控制 盒子 content 区域 最小 宽度 最小 高度 ，   max - width   ,   max - height   控制 盒子 content 区域 宽度 高度 ， 类似 几个 属性   box - sizing   设置   border - box   ， 都 盒子 宽度 高度 。   content 区域 外围 padding 区域 ， padding 区域 透明 ， 盒子 设置   background - color     backgroud - image   ， 会 。 padding 区域 属性 控制 左边 右边 长度 :   padding - top   ,   padding - bottom   ,   padding - left   ,   padding -   。   一个 简便 写法   padding   ， 写法 设置 一个 值 控制 四个 量 很 ， 还 接 多个 值 ， 顺序 ， 不太 喜欢 用法 。   padding 区域 外面 border 区域 ， 网页 中 一条条 边框线 ，     border - width   控制 边框线 宽度 。 实际上 一个 简写 ， 类似   padding   ， 四个 值 :   上 ， 右 ， 下 ， 左 :   border - width :   1px   2em   0   4rem ;   三个 值 :   上 ， 右 左 ， 下 :   border - width :   1px   2em   1.5 cm ;   两个 值 :   ， :   border - width :   2px   1.5 em ;   :   border - top - width   上 宽度 ，   border - bottom - width   。   border 区域 外面 margin 边距 区域 。 其有 属性 ， 含义 一看 明白 :   margin - top   ,   margin - bottom   ,   margin - left   ,   margin -   ,   margin   。   border 属性   border 属性 跟上 三个 值 ， :   border - width   border - style   border - color   img   {   border :   1px   solid   # 4682b4   }   border - style 情况 ， 常见   solid   实线   dashed   虚线   double   双线   dotted   点线 ， 更 请 参看   网页   。   css 布局   网站 介绍   css 布局   ， 深入浅出 讲 很 好 ， css 布局 css 很 课题 ， 建立 认真学习 。   display 属性   block   块级 元素 ， 占 满 右边 行 行 空间 。   div 元素 p 默认 block 元素 ， display 属性   block   。   display   :   block   ;   inline   span 元素 默认   inline   。   display   :   inline   ;   占据 宽度 ， 盒子 元素 填满 一行 。   :   li   {   display   :   inline   ;   }   无序 列表 序列表 item 另起 一行 。 默认   display : list - item ;   。   inline - block   inline - block 块 级 元素 块级 元素 ， 几个 块级 元素 对外 排布   inline   模式 排布 ， 这是 css 新 一个 特性 。 块状 元素 设置 display 属性   inline   ， 块状 元素 都 会 内部 尺寸 布局 ， 想要 。     display   :     元素 显示 。   visibility : hidden   区别 本该 显示 空间 保留 。   float 属性   元素 居右 放置   float : ;   clear 属性   两侧 都 浮动 元素   clear : ;   position 属性   css 布局 控制 中 ， positon 一个 很 关键 属性 。 参考   网页     网页   。 position 属性 四个 值 设置 :   static   static 默认值 ， 额外 位置 调整 ， \" positioned \" 。   relative   relative static 类似 ， 属性 设置 。   top   ,     ,   bottom   ,   left   属性 调整 ， 含义 原本 地方 。 调整 留下来 地方 会 保留 ， 后续 动作 。   fixed   fixed 元素 显示 页面 上 ， 比如说 弹窗 广告 。   top   ,     ,   bottom   ,   left   属性 辅助 调整 弹窗 位置 。   absolute   absolute 类似 fixed ， 视窗 固定 ， 页面 固定 。 设置 :     {   margin - left :   - 200px ;   width :   181px ;   position :   absolute ;   background - color : # FDF6E3 ;   }   目录 ， 放在 正文 左边 ， 不用 absolute 布局 ， 右边 空间 释放出来 。 请 参看   网页 nav 标签 元素   。",
            "tags":"html5_tutorial",
            "url":"articles/html5-tutorial-css.html"
        },
        {
            "title":"html5学习教程三bootstrap篇",
            "text":"bootstrap   本文 点到为止 讲解 ， 读者 简单 即可 ， 练手 学习 。   安装   本文 加载 ：   < ! - -   最新 版本   Bootstrap   核心   CSS   文件   - - >   < link   rel = \" stylesheet \"   href = \" https : / / cdn . jsdelivr . net / npm / bootstrap @ 3.3 . 7 / dist / css / bootstrap . min . css \"   integrity = \" sha384 - BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va + PmSTsz / K68vbdEjh4u \"   crossorigin = \" anonymous \" >   < ! - -   可选   Bootstrap   主题 文件 （ 不用 引入 ）   - - >   < link   rel = \" stylesheet \"   href = \" https : / / cdn . jsdelivr . net / npm / bootstrap @ 3.3 . 7 / dist / css / bootstrap - theme . min . css \"   integrity = \" sha384 - rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl / Sp \"   crossorigin = \" anonymous \" >   < ! - -   最新   Bootstrap   核心   JavaScript   文件   - - >   < script   src = \" https : / / cdn . jsdelivr . net / npm / bootstrap @ 3.3 . 7 / dist / js / bootstrap . min . js \"   integrity = \" sha384 - Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa \"   crossorigin = \" anonymous \" > < / script >   viewport 元 数据 声明   确保 绘制 触屏 缩放 ， 加上 viewport 元 数据 声明 :   < meta   = \" viewport \"   content = \" width = device - width ,   initial - scale = 1 ,   shrink - - fit = \" >   container 类   container   class   div   一个 固定 宽度 响应 式 容器 。   < div   class = \" container \"   style = \" background : # FFF0F5 \" >   container 类 。   < / div >   container 类 。   一个   container - fluid   class ， 区别 container 类会 设备 尺寸 自动 调整 大小 。 推荐 页面 都 包围 container 盒子 。   栅格 系统   栅格 系统 bootstrap 框架 很 有用 一个 特性 ， 基本思路 :   一行   row   类 都 放在 谈及   container   类 。   一行 row 类 （ 类 实际上 该类 属性 div 盒子 ） 再 添加 行类 。   行类 很 多种 ， 请 参看   网页   官方 文档     设计 。   <   div   class   =   \" container \"   style   =   \" background : # FFF0F5 \"   >   container 类 。   <   div   class   =   \" row \"   style   =   \" background - color : yellow \"   >   <   div   class   =   \" col - md - 8 \"   style   =   \" background - color : red \"   >   col - md - 8 盒子 ， 黄色 row 盒子 。   < /   div   >   <   div   class   =   \" col - md - 4 \"   style   =   \" background - color : blue \"   >   col - md - 4 盒子 ， 8 + 4 = 12 ， bootstrap 最多 12 列 。   < /   div   >   < /   div   >   < /   div   >   container 类 。   col - md - 8 盒子 ， 黄色 row 盒子 。   col - md - 4 盒子 ， 8 + 4 = 12 ， bootstrap 最多 12 列 。   常规 css 设置   常规 css 设置 比如说 h1 - h6 字体大小 ， 常规 标签 字体大小 颜色 代码 背景 设置 ， 都 浏览器 开发者 工具 查看 css 代码 设置 ， 默认设置 不好 再 弄 css 文件 重载 ， 不 说 。   bootstrap 提供   text - lowercase   ,   text - uppercase   ,   text - capitalize   class :   < p   class = \" text - lowercase \" > HELLO   world < / p >   < p   class = \" text - uppercase \" >   world < / p >   < p   class = \" text - capitalize \" >   world < / p >   HELLO   world     world     world   控制 文本 对齐 方式   作用 p 段落 盒子 属性 支持 :   text - left   ,   text - center   ,   text -   ,   text - justify   ,   text - nowrap   。   css 都 很 简单 :   < pre   class = \" pre - scrollable \" >   . text - left   {   text - align :   left ;   }   . text -   {   text - align :   ;   }   . text - center   {   text - align :   center ;   }   . text - justify   {   text - align :   justify ;   }   . text - nowrap   {   white - space :   nowrap ;   }   < / pre >   lead 盒子   都 约定 ，   lead 盒子   指 class 属性 lead div 标签 ， :   <   div   class   =   \" lead \"   style   =   \" border : 1px   solid \"   >     ， lead 盒子 ， 边框 额外 加上 去 。 用来 特别 。   < /   div   >     ， lead 盒子 ， 边框 额外 加上 去 。 用来 特别 。   jumbotron 盒子   bootstrap 提供 jumbotron 盒子 首页 用于 展示 特别 希望 读者 阅读 信息 。   <   div   class   =   \" jumbotron \"   >   <   p   >   好 ， jumbotron 盒子 。   < /   p   >   < /   div   >   好 ， jumbotron 盒子 。   pull - left pull -   bootstrap class 属性 左 对齐 或右 对齐 标签 元素 。   tabs 制作   利用 bootstrap 制作 tabs ， 建立 一个 ul 无序 列表 ， class 属性 设置   nav   nav - tabs   ， 制作 一个 简单 tabs 。   <   ul   class   =   \" nav   nav - tabs \"   >   <   li   class   =   \" active \"   > <   a   href   =   \" # \"   >   Features   < /   a   > < /   li   >   <   li   > <   a   href   =   \" # \"   >   Details   < /   a   > < /   li   >   < /   ul   >   Features   Details   pill 形状 tabs 制作   <   ul   class   =   \" nav   nav - pills \"   >   <   li   class   =   \" active \"   > <   a   href   =   \" # \"   >   Features   < /   a   > < /   li   >   <   li   > <   a   href   =   \" # \"   >   Details   < /   a   > < /   li   >   < /   ul   >   Features   Details   list - inline   ul ol 加上   list - inline   属性 ， li 列表 元素 水平 inline - block 显示 ， 所示 :   第一个 li   第二个 li   kbd 标签   kbd 标签 用来 显示 按键 组合 :   Ctrl + X   制作 一个   Bootstrap   风格 带 链接 按钮   参看   网页   。   更 喜欢 写法 :   < a   href = \" { {   message [ \" body \" ]   } } \"   target = \" _ blank \"   role = \" button \"   class = \" btn   btn - success   btn - large \" > Click   ! < / a >",
            "tags":"html5_tutorial",
            "url":"articles/html5-tutorial-bootstrap.html"
        },
        {
            "title":"html5学习之cookbook篇",
            "text":"表单 提交 按钮 点击 提交   参考   网页 第一 小节   ， 解决方案 很 简单 ， 。 单 页面 表单 ， 提交 成功 切换 网页 去 ， 很 好 。 情况 下 ， 解决方案 会 令人 不太 满意 ， 提交 按钮 提交 显示 按钮 处于 禁用 状态 。   <   form   method   =   \" POST \"   action   =   \" ... \"   onsubmit   =   \" myButton . disabled   =   true ;   return   true ; \"   >   ...   <   input   type   =   \" submit \"     =   \" myButton \"     =   \" Submit \"   >   < /   form   >",
            "tags":"html5_tutorial",
            "url":"articles/html5-cookbook.html"
        },
        {
            "title":"html5代码规范",
            "text":"html5 代码 规范   本文 参考   篇文章     篇文章     aribnb javascript 规范   。   指出 都 代码 建议 ， 还 大头 开蛋 小头 开蛋 ， 到底 空 四个 空格 两个 空格 ， 分歧 不 写 ， 读者 自行决定 。   总 原则   团队 人数 ， 代码 看起来 好像 一个 人写 。 — — 原则 公认 。   文件名 推荐 小写字母 加 下划线 。 （ 小写字母 加连 字符 ， 不 推荐 带上 空格 ）   html   缩进 ， 一个 好 编辑器 会 提供 自动 缩进 功能 。   属性 名 小写 ，   -   隔开 。   属性 定义   双引号   包围起来 。   < hr >   < img   src = ... >   不用 加个   /   号 。   关闭 标签 省略   < li > ... < / li >   这是 疑问 。   开头 格式 都 ：   < ! DOCTYPE   html >   语言 指定 遵循 规范   ，   < html   lang = \" zh - cn \" >   字符 编码 推荐 指定 utf8 ，   < meta   charset = \" utf - 8 \" >   IE 兼容 模式 ， 推荐 加上 一行 ：   <   meta   http - equiv   =   \" X - UA - Compatible \"   content   =   \" IE = Edge \"   >   引用 css javascript ， 所示 （ 再 加上 杂七杂八 东西 ， 尽可能 代码 简洁 。 ） ：   < ! - -   External   CSS   - - >   <   link   rel   =   \" stylesheet \"   href   =   \" code _ guide . css \"   >   < ! - -   In - document   CSS   - - >   <   style   >   ...   < /   style   >   < ! - -   External   JS   - - >   <   script   src   =   \" code _ guide . js \"   > < /   script   >   < ! - -   In - document   JS   - - >   <   script   >   ...   < /   script   >   属性 顺序 ：   1 )   class   2 )   id     3 )   data -   4 )   src     type   href     5 )   title   alt   6 )   role   aria -   布尔 属性 ， html 规范 原文 ：   The   values   \" true \"     \" false \"       allowed     boolean   attributes .   To   represent   a   false   ,     attribute         omitted   altogether .   布尔 属性 true ， 不 取值 false 。   <   input   type   =   \" text \"   disabled   >   <   input   type   =   \" checkbox \"     =   \" 1 \"   checked   >   <   select   >   <   option     =   \" 1 \"   selected   >   1   < /   option   >   < /   select   >   代码 简洁 简洁 ， 尽可能减少 标签 数量 。 这是 疑问 。   css   css 代码 规范 兴趣 请 参看 提到 参考 文章 ， 不 太 感兴趣 ， 老实 说 css 本来 可读性 偏低 ， 代码 规范 做 。   javascript   javascript 好几种 代码 风格 写法 规范 ， 推荐 读者 安装   eslint   插件 ， 学习   aribnb   javascript 规范 ， 接下来 javascript 基础 篇 内容 按此 修订 重写 。",
            "tags":"html5_tutorial",
            "url":"articles/html5-style-guide.html"
        },
        {
            "title":"C语言学习笔记",
            "text":"前言   教程 参考   github 样例 项目   阅读 更 。   C语言 开发 环境   windows 下 推荐 visual   studio ， C++ 开发 环境 ， C++ C语言 超集 ， 支持 。 选择 新建 空 C++ 项目 ， 添加 项 记得 默认 后缀   . cpp   改为   . c   。   不想 visual   studio ， 老实 说 初学者 真的 不 推荐 立刻 入手 visual   studio ， mingw 官网 下载 mingw ， 提供 gcc windows 移植版 。   本来 打算 一块 再 讨论 ， gcc   编译   链接 知识 ， 经常出现 ， 越 积累 越多 。 假设 读者 安装 mingw ， 设置 好   PATH   系统 变量 。 读者 cmd powershell 输入 gcc 。   一个 简单 helloworld 程序 一般来说 稍微 熟悉 下 gcc 出 ：   gcc   helloword . c   - o   helloworld   本文 讨论会 提到 编写 头文件   myhead . h     myhead . c   ， 这块 会 讨论 ， 最 简单 程序 ：   # include   < stdio . h >   # include   \" myhead . h \"   int   main   (   void   )   {   print _ name2   ( ) ;   return   0   ;   }   gcc 编译 报错 找 不到   print _ name2   函数 。   myhead . h   myhead . c   都 文件夹 下 ， 道理 gcc 编译器 include 没出 ， 报错 说 ld 链接 出 。   一个 C 程序 源码 编译 机器码 ， 机器码 文件 链接 可执行文件 。 简单 来说 一个 C 程序 编译 链接 两个 过程 才能 一个 可执行文件 。 visual   studio 不 做 调配 ， 它会 自动   myhead . c   编译 进去 ， gcc 不行 。 ：   gcc   helloword . c   myhead . c   - o   helloworld   编译 成功 ， 太 丑陋 。 官方 内置   stdio include 一个 头文件 ， c 文件 不 编译 ？ 操作系统 内置 库 c 源文件 都 编译成 库 ， 有的是 静态 库 ， 有的是 动态 库 ， 讨论 中 重点 。 静态 库 举例 ， 过程 ：   ar   rcs   libmyhead . a   myhead . o   ar 命令 时间 再 ， 简单 理解 一个 打包 程序 ， c 源码 文件 编译成 o 机器码 文件 ， ar 命令 o 机器码 文件 打包 一个 静态 库 文件 。 静态 库 文件 名字   libwhat . a     lib     . a   都 固定   ， 下 链接 静态 文件 就要 gcc 上 加上 选项 ：   - l   myhead   。 实际上 gcc 本来 支持 多种 来源 混合输入 ：   gcc   helloword . c   myhead . o   - o   helloworld   gcc 编译 命令 ：   gcc   helloword . c   - o   helloworld   - L   .   - l   myhead   选项 都 写 ， 纠结 好久 ， 才 发现 选项 写 gcc 刷 参数 正确 。 ， 讨论 。   - L   .   这是 告诉 gcc 新 库 搜索 路径 ， 当前工作 路径 。   stdio . h 正确 工作 ， 库 本来 默认 搜索 路径 上 ，   - l   库 加载 默认 会 自动 去 加载 ， 动态 库 。   做 修改 ， 模仿 mingw 文件夹 结构 ， 定义 头文件 放入   include   文件夹 下 ， 生成 静态 文件 放入   lib   文件夹 下 ， 编译 命令 成 【   - I   选项 告诉 gcc 额外 include 搜索 路径 。 】 ：   gcc   . c   - o     - I   include   - L   lib   - l   myhead   code 编辑器 ， 希望 一种 效果 ， 随便 写 一个   helloworld . c   文件 ， 编译 运行 。 默认   cpp 插件   调配 执行 编译 动作 ， 更 细节 请 参看 插件 官方 文档 ， 推荐   code   runner   插件 ， 说到底 希望 一行 命令 更 快捷 生成 执行 ， 默认 cpp 插件 麻烦 。 c 大概 做 修改 ：   \" code - runner . executorMap \" :   {   ......   \" c \" :   \" cd   $ dir   &&   gcc   $ fileName   - o   $ fileNameWithoutExt   - I   include   - L   lib   - l   myhead   &&   $ dir $ fileNameWithoutExt \"   } ,   右键 run   code 菜单项 。   ， 会 编写 很多 c 源码 文件 h 头文件 ， 源码 h 头文件 include 进去 ， 实际上 编译 阶段 头文件 include 进去 指示 头文件 找到 ， 基本上 做 事情 内容 copy 进来 ， 编译 动作 很少 ， 头文件 预处理 相关 声明 。 预期 程序 中 包含 进来 c 源码 文件   gcc   - c   编译成 o 文件 ， 说 动作 很多 库 早就 做 。   下 一步 链接 ， 收集整理 o 文件 ld 链接 ， 提及 库 也许 gcc ， 链接 进来 ， 链接 进来 程序 预期 内容 会 缺失 。   这段 叙述 完 改 主意 ， 学习 C语言 都 先 过程 详细 。   helloworld   最 简单 最 简单 版本 ：   # include   < stdio . h >   int   main   (   void   ) {   printf   (   \"   world .   \\ n   \"   ) ;   }   定义 一个 函数 ， 函数 名 ，   main   ， 默认 程序 入口 函数 名 。 利用 printf 函数 打印 一个 字符串 ， printf 函数 引入 stdio 包 。   版本 稍微 做 修改 ： 相 helloworld 程序 system 函数 ， 屏幕 暂停 ， 屏幕 会 一闪而过 ， 会 看不清 打印 字 。   # include   < stdio . h >   # include   < stdlib . h >   int   main   (   void   )   {   printf   (   \"   world !   \\ n   \"   ) ;   system   (   \" pause \"   ) ;   return   0   ;   }   C11 标准 推荐 main 函数 采用 写法 ：   int   main   (   void   ) {   }   头文件   C语言 源码 可执行程序   操作系统 平台 上 细节 各有不同 ， 总会 分为 编译 阶段 【 C语言 代码 转 成 汇编语言 代码 】   链接 阶段 【 汇编语言 代码 汇总 】 ， 关注 编译 阶段 即可 。   编译 阶段 C语言 编译器 写 C语言 源码 过程 ， 过程 中 ， C语言 编译器 会 很多 工作 ， 推荐 C语言 编译器 相关 工作 代码 汇总 写入 头文件 中 。     #   开头 命令 都 C语言 编译器 预处理 过程 相关 命令 ，   # include   。   定义 宏   # define   命令 定义 一个 宏 ， 一个 简单 C语言 编译器 预处理 阶段 文本 替换 操作 ， ：   # define   PI   3.14   提醒 一点 ， PI C语言 中 讨论 常量 变量 ， 一个 文本 替换 操作 ， ：   printf   (   \" The   PI     % f   \\ n   \"   ,   PI   ) ;   实际上 源码 预处理 ：   printf   (   \" The   PI     % f   \\ n   \"   ,   3.14   ) ;   python 这类 动态 语言 很大 。   编写 头文件   新建 一个   myhead . h   头文件 ， 内容 ：   # include   < stdio . h >   # include   < stdlib . h >   # define   PI   3.14   两个 包 反正 ， 先 一并 包含 进来 。   主程序   main . c   ：   # include   \" myhead . h \"   int   main   (   void   )   {   printf   (   \" The   PI     % f   \\ n   \"   ,   PI   ) ;   system   (   \" pause \"   ) ;   return   0   ;   }   读者   # include   写法 上 差异 ， 简单 来说 尖括号 包围 标准 库 系统 标准 目录 找到 ； 双引号 包围 先 当前目录 寻找 ， 找 不到 再 标准 系统目录 下 找 ， 操作系统 标准 目录 定义 略过 讨论 。   定义 函数   helloworld 程序 包含 很多 信息 ， 至少 刚 接触 C语言 读者 来说 。 看 完 helloworld 程序 ， 读者 C语言 函数 写法 ：   return _ type   function _   (   function _ parameters   ) {   / /       a   comment .   / *         a   comment . * /   return   0   ;   }   更 细节 再 慢慢 讨论 ， C语言 一个 很 简单 语言 。   C90 新增 函数 原型 概念 ， ：   int   add   (   int   a   ,   int   b   )   {   return   a   +   b   ;   }   函数 原型 ：   int   add   (   int   a   ,   int   b   ) ;   函数 原型 函数 声明 ， 告诉 编译器 函数 ， 函数 声明 语句 放在 头文件 中 。   头文件 函数 原型   描述 ，   myhead . h   文件 加上 ：   int   add   (   int   a   ,   int   b   ) ;   新建 一个   myhead . c   文件 ， 函数 定义 ：   int   add   (   int   a   ,   int   b   )   {   return   a   +   b   ;   }   main . c   定义 add 函数 即可 。   数据类型       printf 输出   int   整型   % d   float   浮点 型   % f   【 % e 指数 】   char   单 字符 型   % c   long   长 整型   % ld   double   双 浮点 型   % f   【 % e 指数 】   _ Bool   布尔 型   % d   C语言 char 单 字符 型 单引号 ：   char   a   =   ' a '   ;   C99 新增 _ Bool 布尔 型 ， 实际上 一种 整数型 ， 0 false ； 1 true 。   自动 类型转换   C语言 数据类型 运算 ， 会 发生 自动 类型转换 情况   char   - >   int   int   - >   double   ， 包括   char   - >   double   。   强制 类型转换   ( int ) ( 3.14 )   强制 类型转换 不 影响 原 变量 ， 运算 时 截取 操作 ， 四舍五入 。   计算 最大公约数   除法 求 余数   演示 下 除法 求 余数 ， 加法 减法 乘法 很 直白 。   float   x   =   12.2 ;   float   y   =   2 ;   float   z   =   x   /   y ;   / /   除法   printf ( \" z   :   % f . \\ n \" ,   z ) ;   int   w   =   13   %   2 ;   / /   求 余数   printf ( \" w   :   % d . \\ n \" ,   w ) ;   取 余数 ：   a   %   b     b   %   a   返回   a b 两个 数中 最小 更 小 数 ， 假设 a b 大 ，   a   %   b   相当于   a   -   b   一个 正数 ，     b   %   a   返回   最小   b 。   欧几里得 算法   小节 参考 维基百科   欧几里得 算法 ， 程序 很 ， 关键 理解 算法 思想 。 欧几里得 算法 最 核心 思想 ：   两个 数 最大公约数 等于 小 数 两个 数 差 最大公约数 。   简要 证明 ：   a   =   mk   b   =   nk   a b 最大公约数 k ， m n 互质   ：   a - b   =   ( m - n ) k   b   =   nk   证明 m - n   n 互质 ， 反证 ， 假设   m - n     n   互质 ， ：   m - n   =   ix   n   =   iy   ：   m   =   n +   ix   =   i ( x   +   y )     m     n   i 整除 ， m n 互质 假设 违背 ，     m - n     n 互质 ， 进一步 :   a - b     b 最大公约数   k 。   过程 记 作 ：   gcd ( a ,   b )   =   gcd ( b ,   ( a - b ) )     b 小 ，   a - b   小 ， 过程 会 两个 数 越来越 小 。   举例 ：   36   ~   9   = >   27   ~ 9   = >   18   ~   9   = >   9 ~ 9   = >   0   递归 写法 最 直观 写法 ， 基本上 定义 程序实现 ：   int   gcd   (   int   a   ,   int   b   )   {     (   b   = =   0   )   {   return   a   ;   }     {   return   gcd   (   b   ,   a   %   b   ) ;   }   }     a   %   b   取余 保证 最小 更 小 数 ， 这是 。   辗转 相 除法 ， 网上 ：   int   gcd2   (   int   a   ,   int   b   )   {   int   t   ;   / /   一个 临时 变量 , 记录 最小值     (   b   )   {   / /   b 最小值 零 返回 a   t   =   a   %   b   ;   / /   t 记录 取余后 最小值   a   =   b   ;   / /   a 记录 最大值   b   =   t   ;   / /   b 记录 最小值   } ;   return   a   ;   }   基础知识   加减乘除 不 说 ， 语言 各有不同 ， 简单 下 即可 。   sizeof 函数   sizeof ( int )   返回 目标 对象 bytes 大小 ， 返回   size _ t   类型 ， 实际上   unsigned   int   类型 ：   typedef   unsigned   int   size _ t   ;   布尔值   推荐 stdbool 包 ， bool 称为 _ Bool 别名 ， 还 true false 。 再 0 1 布尔值 。   int   _ input _ integer   (   void   )   {   int   input _ len   ;   char   input   [   100   ] ;   bool   input _ _ good   =   true   ;   printf   (   \" Please   enter     integer :   \"   ) ;   scanf   (   \" % s \"   ,   input   ) ;   input _ len   =   strlen   (   input   ) ;     (   int   i   =   0   ;   i   <   input _ len   ;   i   ++   )   {   char   test _ char   ;   test _ char   =   input   [   i   ] ;     (   !   isdigit   (   test _ char   ) )   {   input _ _ good   =   false   ;   }   }   return   input _ _ good   ;   }   # include   \" myhead . h \"   int   main   (   void   )   {   bool   res   ;   res   =   _ input _ integer   ( ) ;     (   res   )   {   printf   (   \"       a   integer \"   ) ;   }     {   printf   (   \"         a   integer \"   ) ;   }   return   0   ;   }   fabs 函数   fabs 函数   math . h   库 ， 接受 一个 浮点数 ， 返回 浮点数 绝对值 。   规范 循环 语句   python 语言 引入 迭代 对象 概念 循环 语句 简单 ， 常规 语言 语句 都 建议 写法 上 遵循 规范 ：     (   int   i   =   0   ;   i   <   obj _ length   ;   i   ++   ) {   }   目标 对象 索引 计数 规范 都 是从 0   终止 判断 小于 目标 对象 索引 长度   标准 写法 ， 一个 目标 对象 索引 0 一位 循环 。   getchar 函数 putchar 函数   两个 函数 来自   stdio . h   库 ， 一个 接受 一个 字符 ； 一个 打印 一个 字符 ， 相当于 scanf printf 针对 字符 精简 mini 版本 。   ch   =   getchar   ( ) ;   putchar   (   ch   ) ;   ctypes . h 库   ctypes . h   库 提供 单个 字符 测试 函数 ：   isalnum   是否是 字母 数字   isalpha   是否是 字母   isblank   是否是 空白 字符 【 空格   水平 制表符   换行符 本地化 空白 字符 】   isdigit   是否是 数字   islower   是否是 小写   isupper   是否是 大写   isspace   是否是 空白 字符 【 空格   换行符   换页 符   回车符   垂直 制表符   水平 制表符 本地化 空白 字符 】   isprint   是否是 打印 字符   ispunct   是否是 标点符号   转换 字符 函数 ：   tolower   转 成 小写字母   toupper   转 成 大写字母   字符串 数据类型   字符串 确切 来说 一个 字符 型 数组 ，   ' \\ 0 '   结束 ，   \" sam \"   存储 值 所示 ：   void   print _   (   void   )   {   char     [   4   ] ;     [   0   ]   =   ' s '   ;     [   1   ]   =   ' a '   ;     [   2   ]   =   ' m '   ;     [   3   ]   =   ' \\ 0 '   ;   printf   (   \"     % s   \\ n   \"   ,     ) ;   }   C语言 数组 初始化 支持 形式 写法 ：   void   print _ name2   (   void   )   {   char     [   4   ]   =   {   ' s '   ,   ' a '   ,   ' m '   ,   ' \\ 0 '   } ;   printf   (   \"     % s   \\ n   \"   ,     ) ;   }   C语言 数组 初始化 支持 自动 计算 数组 大小 ， 代码 还 简化 ：   void   print _ name3   (   void   )   {   char     [ ]   =   {   ' s '   ,   ' a '   ,   ' m '   ,   ' \\ 0 '   } ;   printf   (   \"     % s   \\ n   \"   ,     ) ;   }   双引号 括 内容   字符串 常量     字符串 字面 量   ， 编译器 会 自动 加上   \\ 0   字符 。 字符串 常量 用法 ：   void   print _ name4   (   void   )   {   char     [ ]   =   \" sam \"   ;   printf   (   \"     % s   \\ n   \"   ,     ) ;   }   编译器 字符串 常量 会 存入 内存 ， 只存 ， 存储 静态 存储 区 。 程序 代码 ， 会 新建 一个 数组 ， 才 静态 存储 区 字符串 常量 数据 拷贝 。 C语言 一种 利用 指针 方法 ：   void   print _ name5   (   void   )   {   char   *     =   \" sam \"   ;   printf   (   \"     % s   \\ n   \"   ,     ) ;   }   字符串 常量 地址 拷贝 指针 ， 内存 两个 拷贝 。   分析 看 数组 数组 ， 指针 指针 ， 好 纠结 ， 总 喜欢 讨论 数组名 指针 ， 上 ， 最 简单 回答 ， 数组名 存放 地址 固定 ， 指针 存放 地址 随意 变动 。 没什么 好 纠结 。   两种 表达 选择 ， 参考资料 1 给出 建议 字符串 修改 操作 ， 数组 表达方式 。   strlen 函数   strlen 函数   < string . h >   包 提供 ， 它会 返回 字符串 长度 ， 所说 长度 不 包括   \\ 0   字符 。   printf 函数   转换   % d   整型   % ld   long 长 整型   % o   八进制 整数   % x   十六进制 整数   % f   浮点 型   十进制   % e   浮点 型   e 记数法   % c   单 字符   % s   字符串   % p   指针   %%   打印 一个 百分号   printf 函数 格式 字符串 类似 python format ， 内容 挺 ， 再 慢慢 。 列出 几个 简单 实用 例子 ：   \" % 3.1 f \"   打印 一个 浮点数 ， 字符串 宽度 3 ， 小数点 后 有效位数 1 位 。   \" % 10d \"   打印 一个 整数 ， 字符串 宽度 10 ， 左侧 空白 。   \" % 010d \"   打印 一个 整数 ， 字符串 宽度 10 ， 左侧 填充 0 。   scanf 函数   visual   studio scanf 会 抛出 错误 ：   C4996   '   scanf   '   :   This   function     variable       unsafe   .   Consider     scanf _ s     .   To   disable   deprecation   ,     _ CRT _ SECURE _ NO _ WARNINGS   .   See   online       details   .     myhead . h   加上 一行   ：   # define   _ CRT _ SECURE _ NO _ WARNINGS   scanf 函数 两条 ：   读取 变量 类型 值 ， 变量名 加上   &   读取 字符串 字符 数组 ，   &   ， 数组名 即可 。   char     [   40   ] ;   scanf   (   \" % s \"   ,     ) ;   scanf 函数 接受 多个 输入 ， 空白 分隔 ， 读取 指定 数目 为止 。   % c   会 空白 字符 读取 进来 。   转换   % c   字符 型   % d   整型   % e   % f   都 会 转成 浮点 型   % p   指针   % s   字符串   scanf 函数 类似 printf 支持 格式 修饰符 ， scanf 函数 特别 ， 实践 中 推荐   getchar     fgets   两个 函数 。   返回值   scanf 函数 返回值 ：   成功 读取 ， 返回 读取 项数 【 请求 输入 一个 % d ， 返回 1 】   读取 项 用户 输入 不 合乎 规范 返回 0 ,   scranf 检测 EOF 文件 结尾 ， 返回 EOF 【 - 1 】   指针   指针 一个 存储 内存地址 变量 。 int 类型 存储 整数 ， pointer 类型 存储 内存地址 。 指针 声明 ：   int   *   p ;   * 变量 指针 ， int 指针 指向 地址 上 值 一个 int 值 。   相关 运算符   &   运算符 用于 变量 内存地址 ；   *   运算符 用于 内存地址 指针 名来 指针 指向 地址 上 值 。   swap 函数   swap 函数 接受 两个 变量 值 ， 交换 两个 变量 值 ， 函数 C语言 用到 指针 。   void   swap _ int   (   int   *   p1   ,   int   *   p2   )   {   / /   swap     int     int   temp   ;   temp   =   *   p1   ;   *   p1   =   *   p2   ;   *   p2   =   temp   ;   }   # include   \" myhead . h \"   int   main   (   void   )   {   int   x   =   2   ;   int   y   =   3   ;   swap _ int   (   &   x   ,   &   y   ) ;   printf   (   \" % d   % d \"   ,   x   ,   y   ) ;   return   0   ;   }   函数 值 不 指针 参数 ， 目标 函数 改变 外围 调用 环境 中 变量 值 ， 采用 指针 参数 形式 。   C   Primer   Plus 这段 说 好 ：   变量 值 量 ， 地址   &   运算符 派生 量 ； 指针 地址 量 ， 值   *   运算符 派生 量 。   假设 p1 指针 指向 变量 x ， ：   x   =   1 ;     * p1   =   1 ;   看做 等价 ， 说 指针 指向 变量 ， 暗含   * p   名字   x   一个 别名 。   数组   多维 数组   C语言 支持 形式   matrix [ 3 ] [ 4 ]   多维 数组 ， 值得 。   c   int   x [ 3 ] [ 2 ]   =   {   { 1 , 2 } ,   { 1 , 2 } ,   { 1 , 2 }   } ;   本来 打算 编写 一个 简单 函数 先 打印 二维 数组 ， 竟 发现 还 很 。 一维 数组 情况 都行 ， 数组名 就可以看 做 一个 指针 ：   void   print _ int _ array   (   int   *   arr   ,   int   length   )   {     (   int   i   =   0   ;   i   <   length   ;   i   ++   )   {   printf   (   \" % d   \"   ,   arr   [   i   ] ) ;   }   }   int   sum _ int _ array   (   int   *   arr   ,   int   length   )   {   int   res   =   0   ;     (   int   i   =   0   ;   i   <   length   ;   i   ++   )   {   res   + =   arr   [   i   ] ;   }   return   res   ;   }   二维 数组 不 数组名 指针 无缝 转换 ， 建立 一种 二维 指针 数组 ， 过程 引入 太 复杂度 ， 实在 一个 明智 选项 ； 就算 建立 函数 ， 二维 数组 列数 写 死 。   变 长 数组   概念 ，   变 长 数组   visual   studio   不 支持 ， 支持 计划 ， 特性 最新 C语言 标准 打算 废弃 。     网页   一种   malloc   函数   自动 分配 二维 指针 数组 内存 方法 ， 其内 本质 二维 指针 数组 过于 东西 ， 不 喜欢 ， 玩法 还 引入   int   * *   p   东西 ， C语言 指针 很 厌倦 ， 还 弄 两个 指针 ， 玩法 过于 不 推荐 。   一个 解决方案 ， 方案 利用 C语言 struct 结构 ， 优美 解决方案 【 也许 一维 表达 很丑 ， 实际上 计算机 内存 存储 一维 表达 结构 】 。 方案 抛弃 C语言   x [ 3 ] [ 2 ]   表达 ， 回归 一维 数组 本源 ， 扩展 支持 方法 进一步 表达 分组 分行 内部 属性 。   typedef   struct   {   int   rows   ;   int   cols   ;   int   data   [   0   ] ;   }   Matrix2D   ;   void   print _ 2d   (   Matrix2D   *   m   )   {   printf   (   \" [   \\ n   \"   ) ;     (   int   i   =   0   ;   i   <   m   - >   rows   ;   ++   i   )   {   printf   (   \"   [ \"   ) ;     (   int   j   =   0   ;   j   <   m   - >   cols   ;   ++   j   )   {   printf   (   \" % 3d   \"   ,   m   - >   data   [   i   *   m   - >   cols   +   j   ] ) ;     (   !   (   j   = =   (   m   - >   cols   -   1   ) ) )   {   printf   (   \" , \"   ) ;   }     {   printf   (   \" ] \"   ) ;   }   }   printf   (   \"   \\ n   \"   ) ;   }   printf   (   \" ]   \\ n   \"   ) ;   }   # include   \" myhead . h \"   int   main   (   void   )   {   Matrix2D   x   =   {   .   rows   =   3   ,   .   cols   =   4   ,   .   data   =   {   1   ,   2   ,   3   ,   4   ,   5   ,   6   ,   7   ,   8   ,   9   ,   10   ,   11   ,   12   }   } ;   print _ 2d   (   &   x   ) ;   return   0   ;   }   结构 体在 函数 中是 传递 地址 ， 数组名 数组 首 元素 地址 ， 一维 数组 传递 数组名 对象 指向 指针 没 。 结构 体 看做 一种 内部 长度 一维 数组 形式 ， 理解 做 可行 。 结构 体 指针 引用 内部 对象 采用   m - > cols   写法 。 二维 数组 不行 是因为 计算机 只 传递 首 元素 地址 内部 数据类型 ， 几行 几列 信息 丢失 。   Flexible   array   member     structure   小节 参看   篇文章   。 结构 体   int   data [ 0 ]   C99 引入 新 特性 ， Flexible   array   member ， 一个 结构 体 ， 结构 体 一个 成员 。 结构 体 lexible   array   member 之外 还 成员 。   NOTICE :   声明   int   data [ ]   写法 visual   studio ， gcc 默认 gnu11 我试 只能   int   data [ 0 ]   写法 才行 。   再谈 指针   谈论 ， 数组名 数组 首 元素 地址 ， 编程 中 很多 指针 操作 都 作用 数组名 ， 说 数组名 指针 来说 存储 内存地址 不 变动 。 指针 操作 包括 ：   指针 加一   内存地址 偏移 值 增加 一个 存储单元 【 一个 数据 对象 】 ， int 加 4 字节 ， double 加 8 字节 【 讨论 数值 一个 假设 】 。 指针 声明 包含 类型 声明 ， 指针 偏移 计算 我要 偏移 。 假设 一个 结构 体 指针 加一 ， 偏移 值 会 大 ， 偏移 一个 结构 体 数据 。   指针 减一 类似 指针 加一 讨论 ， 不 赘述 。   利用 数组名 编程 中 指针 偏移 操作 很 ， 指针 数组 中 两个 指向 指针 ， 相减 差 绝对值 数组 中 两个 数据 之间 索引 差 。   C语言 代码 编写 指针 滥用 ， 数组名 操作 ， 上 讨论 情况 ， 尽情 。     arr [ 1 ]     * ( arr + 1 )   一个 ，   arr [ 0 ]     * arr   一个 ， 就行了 。   计算 数组 长度   C语言 涉及 数组 操作 传递 一个 额外 长度 参数 ， 利用 宏来 第二个 参数 计算 工作 丢 程序 。   # define   SIZEOF ( ARRAY )   ( sizeof ( ARRAY ) / sizeof ( * ARRAY ) )   一个 带 参数 宏 ， ：   res   =   sum _ int _ array   (   y   ,   SIZEOF   (   y   ) ) ;   替换 ：   res   =   sum _ int _ array   (   y   ,   (   sizeof   (   y   )   /   sizeof   (   *   y   ) ) ) ;   这是 ， y 改为 结构 体 数组 不行 ， sizeof 函数 。   Matrix2D   不 大 ，   rows * cols   即可 。   const 保护 数组 中 数据   数组 函数 中 传递 指针 ， 数组 修改 动作 修改 原 数组 ， 新建 一个 数组 副本 。 保护 数组 数据 不 修改 ， 修饰符   const   。   int   sum _ int _ array   (   const   int   *   arr   ,   int   length   )   字符串 操作   puts   _ s 函数   scanf 字符串 空格 会 停止 ， 函数 用于 读取 整行 字符串 输入 ， 不 再 函数 ， 用户 输入 行 字符串 【 未知 】 超过 程序 中 声明 存储 目的地 声明 长度 ， 会 导致 缓冲区 溢出 错误 。 _ s 函数 相当于 版本 函数 ， 一个 简单 演示 例子 ：   # define   LINE _ MAX _ LENGTH   100   int   echo _ line   (   void   )   {   char   words   [   LINE _ MAX _ LENGTH   ] ;   puts   (   \"   input   a   line . \"   ) ;   _ s   (   words   ,   LINE _ MAX _ LENGTH   ) ;   puts   (   words   ) ;   return   0   ;   }   参考资料 1   谈到 行 输入 过长 ， 利用 fgets 函数 一个 函数 ， fgets 更 针对 文件 io 读取 操作 ， 谈论 行 输入 大材小用 ， 利用 getchar 函数 一个 函数 ：   void   empty _ string   (   char   *   st   ,   int   length   )   {   / /   make   target   string   fill     \\ 0   / /   size       target   string   char   array   length     (   int   i   =   0   ;   i   <   length   ;   i   ++   )   {   st   [   i   ]   =   ' \\ 0 '   ;   }   }   char   *   line _   (   char   *   st   ,   int   num   )   {   / /     num       max   character   number     include     \\ n   char   ch   ;   int   i   =   0   ;   / /   make   st     a   empty   string   notice       + 1   empty _ string   (   st   ,   num   +   1   ) ;   ch   =   getchar   ( ) ;     (   ch   ! =   ' \\ n '   )   {     (   i   <   num   )   {   st   [   i   ]   =   ch   ;   }     {   puts   (   \"   input   line       long ,     input     . \"   ) ;   / /   empty     previous   user   input   buffer     (   getchar   ( )   ! =   ' \\ n '   )   {   continue   ;   }   return   line _   (   st   ,   num   ) ;   }   i   ++   ;   ch   =   getchar   ( ) ;   }   return   st   ;   }   # include   \" myhead . h \"   int   main   (   void   )   {   char   words   [   5   ] ;   puts   (   \"   input   a   line . \"   ) ;   line _   (   words   ,   4   ) ;   puts   (   words   ) ;   return   0   ;   }   num 含义 字符 不 包括   \\ n   长度 ， 用户 角度 理解 看做 字符 数 。   strcat 函数   接受 两个 字符串 参数 ， 后 一个 字符串 附加 前 一个 字符串 上 ， 返回 前 一个 字符串 指针 ， 附加 动作 超过 前 一个 字符串 容纳 空间 。   strcmp 函数   两个 字符串 内容 ， 多余   \\ 0   会 容忍 ， 内容 返回 0 ， 返回 非 0 。   strcpy 函数   接受 两个 字符串 参数 ， 后 一个 字符串 内容 拷贝到 前 一个 字符串 上 ， 执行 拷贝 动作 内容 超过 前 一个 字符串 容纳 空间 。   字符串 排序   一个   strsort 函数 ， 接受 一个 字符串 数组 参数 数组 长度 ， 内部 动作 将会 字符串 数组 排序 。   void   swap _ pointer   (   void   *   p _ 1   ,   void   *   p _ 2   )   {   / /   swap     pointer     int   *   p1   =   (   int   *   )   p _ 1   ;   int   *   p2   =   (   int   *   )   p _ 2   ;   int   *   temp   =   NULL   ;   temp   =   *   p1   ;   *   p1   =   *   p2   ;   *   p2   =   temp   ;   }   void   strsort   (   char   *   strings   [ ] ,   int   num   )   {     (   int   i   =   0   ;   i   <   num   ;   i   ++   )   {     (   int   j   =   i   +   1   ;   j   <   num   ;   j   ++   )   {     (   strcmp   (   strings   [   i   ] ,   strings   [   j   ] )   >   0   )   {   swap _ pointer   (   &   strings   [   i   ] ,   &   strings   [   j   ] ) ;   }   }   }   }   # include   \" myhead . h \"   int   main   (   void   )   {   char   st   [ ]   =   \" abcf \"   ;   char   st2   [ ]   =   \" abcd \"   ;   char   st3   [ ]   =   \" zzzz \"   ;   char   st4   [ ]   =   \" eeee \"   ;   char   *   strings   [ ]   =   {   st   ,   st2   ,   st3   ,   st4   } ;   strsort   (   strings   ,   SIZEOF   (   strings   ) ) ;     (   int   i   =   0   ;   i   <   SIZEOF   (   strings   ) ;   i   ++   )   {   puts   (   strings   [   i   ] ) ;   }   return   0   ;   }   strcmp 函数 返回 大于 0 值 第一个 字符串 机器 排序 【 字母 顺序 排序 】 后 一个 字符串 。 一个 临时 排序 方案 ， 重点 。 排序 算法 选择 排序 ， 基本上 一轮 轮 找 序列 最 值 ， 放置 。   特别 值得一提 一点   char   *   strings [ ]   叫法 字符串 指针 数组 ， 实际上 C语言 字符串 数组 说法 ， 字符串 长度 不一是 不 C语言 数组 。 字符串 指针 数组 实际上 存储 一系列 指针 ， 正是 ， 上 面试 一种 通用 交换 两个 指针 值得 swap _ pointer   函数 。 空 指针 操作 值得 特别 。   例子 swap _ int ， 不 规范 ， 恰好 int 型 存储 指针 。 写   strings [ i ]   ， 不 规范 ， 打印 字符串 显示 ， 感到 奇怪的是 字符串 字符 数组 指针 指向 修改 ，   char   *   st     char   st [ ]   还 真的 没 区别 ， 程序员 自我 约束 下 ， 例子 来说 逻辑 清晰 角度 出发 ， 传递 指向 字符串 指针 地址 进去 。   空 指针   int   *   temp   =   NULL   ;   一行 声明 一个 指针 ， 值 0 【 0 指针 内存 存储 位置 ， 程序 分配 】 。   C语言 编写 函数 如同 声明   void   *   void 类型 指针 ：   void   swap _ pointer   (   void   *   p _ 1   ,   void   *   p _ 2   )   接受 随便 指向 类型 指针 。 函数 ， 接下来 针对 空 类型 指针 强制 类型转换 ， ：   int   *   p1   =   (   int   *   )   p _ 1   ;   int   *   p2   =   (   int   *   )   p _ 2   ;     swap _ pointer   函数 例子 来说 ，   int   *   随便 选 ， 操作 都 针对 指针 存储 值 ， 指针 映射 值 。   进制 转换 例子   字符串 转 成 数字 推荐   stdlib . h     strtol   函数 【 转成 long 类型 】 ，   strtoul   函数 【 转成 unsigned   long 类型 】 ，   strtod   函数 【 转成 double 类型 】 。 函数 相比 原   atoi   函数 ， 函数 还 指定 进制 位数 。   例子 引入 一个 ， 函数 返回 字符串 。 C语言 字符串 操作 来说 ， 如同 strsort 函数 演示 ， 字符串 指针 传递 进来 ， 所示 ， 方案 最 简单 ， 方案 。   void   number _ radix _ conversion   (   char   *   number   ,   char   *   result   ,   int   input _ radix   ,   int   output _ radix   )   {   char   *   end   ;   unsigned   long     ;     =   strtoul   (   number   ,   &   end   ,   input _ radix   ) ;     (   output _ radix   = =   2   )   {   _ itoa   (     ,   result   ,   2   ) ;   }     (   output _ radix   = =   8   )   {   sprintf   (   result   ,   \" % o \"   ,     ) ;   }       (   output _ radix   = =   10   )   {   sprintf   (   result   ,   \" % u \"   ,     ) ;   }       (   output _ radix   = =   16   )   {   sprintf   (   result   ,   \" % x \"   ,     ) ;   }   return   result   ;   }   一种 方法 ， 函数 内部 新 定义 字符串 ， 带来 一个 ， 函数 内部 块 声明 字符串 定义 ， 出 函数 不 访问 ， 返回 字符串 指针 ， C语言 默认 变量 自动 变量 ， 访问 权限 熟悉 编程语言 那种 块 作用域 ， 伴随 块 作用域 随之而来 内存 管理 上 ， 变量 自动 分配 释放 ， 简言之 ， 熟悉 那种 局部变量 概念 。 函数 内部 声明 字符串 ， 出 函数 字符串 内存 清洗 掉 ， 指针 访问 一个 内存 莫名 数据 。   看 函数 第二个 版本 ：   char   *   number _ radix _ conversion   (   char   *   number   ,   int   input _ radix   ,   int   output _ radix   )   {   char   *   end   ;   unsigned   long     ;   static   char   result   [   100   ] ;     =   strtoul   (   number   ,   &   end   ,   input _ radix   ) ;     (   output _ radix   = =   2   )   {   _ itoa   (     ,   result   ,   2   ) ;   }     (   output _ radix   = =   8   )   {   sprintf   (   result   ,   \" % o \"   ,     ) ;   }       (   output _ radix   = =   10   )   {   sprintf   (   result   ,   \" % u \"   ,     ) ;   }       (   output _ radix   = =   16   )   {   sprintf   (   result   ,   \" % x \"   ,     ) ;   }   return   result   ;   }   函数 版本 真的 返回 字符串 ， 字符串 函数 内部 声明 ， 出 函数 字符串 内存 没 清洗 掉 ， 是因为 加上   static   关键词 ， result 变量 成   静态 变量   。 静态 变量 程序运行 时 内在 内存 保留 。   静态 变量 ， C语言 跳出 变量 声明 传统 语法 ， 指定 内存 我要 空间 。 内存 控制 浅 深 C语言 威力 所在 一把 双刃剑 ， 真的 明白 做 ， 做 更好 方法 ， 才 做 ， 默认 自动 变量 工作 ， 不 纯粹 炫技 编写 那种 代码 。   文件 作用域   讨论 ， 函数 内部 声明 局部变量 来说 【 C语言 说法 块 作用域 ， 写 上 一个 花 括号 块 ， 声明 一个 变量 ， 变量 作用域 都 只 局限 块 ， 讨论 简单 ， 简单 说 函数 内部 声明 局部变量 。 】 ， 程序员 变量 访问 域 规则 都 很 熟悉 。 一块 编程语言 差别 不 大 。   C语言 链接 过程 上 差异 ， 两个 变量 声明 ：   int   giants   =   5   ;   static   int   dodgers   =   3   ;   int   main   ( ) {   ...   }   两个 变量 都 文件 作用域 ，   giants   文件 都 访问 ， 简单 称作 全局变量 。   dodgers   文件 作用域 静态 变量 ， 一个 专业 称呼 内部 链接 ， 只 文件 函数 访问 ， 文件 内部 私有 。   一点 值得一提 ，   dodgers   文件 声明 ：   extern   int   dodgers   ;   变量 成 外部 链接 变量 ，   extern   声明 告诉 编译器 变量 地方 声明 ， 程序 链接 过程 中 会 。   dodgers   文件 中 访问 。   提到 全局变量 情况 文件 ， 做法 推荐 加上   extern   关键词 ， 增加 程序 清晰性 。   寄存器 变量   register   int   c   ;   寄存器 变量 声明 告诉 C 编译器 变量 会 频繁 用到 ， 放入 寄存器 ， 仅仅只是 加速 ， 变量 属性 等同于   int   c   。   malloc free   malloc 函数 手工 声明 一个 内存空间 ， 记得 free 内存空间 。 本文 暂时 略过 ， ， 那种 确实 不得不 malloc 函数 情况 才 。   命令行 参数   int   main   (   int   argc   ,   char   *   argv   [ ] ) {   }   编写 程序 上 编写 接受命令 行 参数 ， argc 接受 参数 个数 ， argv 参数 字符串 指针 数组 ， argv [ 0 ]   程序 名字 ， 参数 。 命令行 参数 写法 对接 都 熟悉 通用 接口 ，   Github 项目   给出 一个 版本 。 做 简化 。   简化 getopt 逻辑 挺 ， 刷 参数 接口 。   初看 项目 代码 基本知识 补充 ， 头文件 ：   # ifdef     ...   #   ...   # endif   这是 C语言 预处理 条件 编译 语句 。   # ifndef   _ WINGETOPT _ H _   # define   _ WINGETOPT _ H _   ...   # endif   这是 一种 常用 本宏包 只 加载 手段 。   extern   \" C \"   {   ...   }   声明 C++ C 风格 声明 。   统计 文件 字数 程序   getopt 刷 参数 函数 编写 一个 简单 模仿 linux 系统 wc 命令行 工具 ， 提供 三个 参数 选项 ：   - c   打印 字符 数   - l   打印 行数   - w   打印 词数 ，   - f   指定 输入 文件 。   例子 附带 介绍 C语言 文件 操作 ， 很多 文件 操作 函数 ，   fprintf   函数 提到   fgets     fputs   函数 ， 简单 即可 。   # include   \" myhead . h \"   # include   \" wingetopt . h \"   int   main   (   int   argc   ,   char   *   argv   [ ] )   {   char   c   ;   char   ch   ;   unsigned   long   char _ count   =   0   ;   unsigned   long   line _ count   =   0   ;   unsigned   long   word _ count   =   0   ;   extern   char   *   optarg   ;   bool   char _ turn _   =   false   ;   bool   line _ turn _   =   false   ;   bool   word _ turn _   =   false   ;   char   *   filename   [   100   ]   =   { [   0   ]   =   ' \\ 0 '   } ;   FILE   *   fp   ;     ( (   c   =   getopt   (   argc   ,   argv   ,   \" hclwf : \"   ) )   ! =   -   1   )   {   switch   (   c   )   {   case   ' h '   :   printf   (   \" Useage :   wc   [ - clw ]   - f   filename   \\ n   \"   ) ;   exit   (   EXIT _ FAILURE   ) ;   case   ' c '   :   char _ turn _   =   true   ;   break   ;   case   ' l '   :   line _ turn _   =   true   ;   break   ;   case   ' w '   :   word _ turn _   =   true   ;   break   ;   case   ' f '   :     (   optarg   = =   NULL   )   {   exit   (   EXIT _ FAILURE   ) ;   }     {   strcpy   (   filename   ,   optarg   ) ;   break   ;   }   case   ' '   :   printf   (   \" unknown   option :   0% o   \\ n   \"   ,   c   ) ;   break   ;   default   :   exit   (   EXIT _ FAILURE   ) ;   }   }     (   strlen   (   filename   )   = =   0   )   {   printf   (   \" Need   filename   \\ n   \"   ) ;   exit   (   EXIT _ FAILURE   ) ;   }     ( (   fp   =   fopen   (   filename   ,   \" r \"   ) )   = =   NULL   )   {   printf   (   \" Can ' t   open   % s   \\ n   \"   ,   filename   ) ;   exit   (   EXIT _ FAILURE   ) ;   }   bool   inword   =   false   ;   char   prev   ;     ( (   ch   =   getc   (   fp   ) )   ! =   EOF   )   {   / /   putc ( ch , stdout   ) ;     (   char _ turn _   )   {   char _ count   ++   ;   }     (   line _ turn _   &&   ch   = =   ' \\ n '   )   {   line _ count   ++   ;   }     (   word _ turn _   &&   !   isspace   (   ch   )   &&   !   inword   )   {   inword   =   true   ;   word _ count   ++   ;   }     (   word _ turn _   &&   isspace   (   ch   )   &&   inword   )   {   inword   =   false   ;   }   prev   =   ch   ;   }     (   prev   ! =   ' \\ n '   )   {   line _ count   ++   ;   }     (   char _ turn _   )   {   printf   (   \" % s     % ld   characters   \\ n   \"   ,   filename   ,   char _ count   ) ;   }     (   line _ turn _   )   {   printf   (   \" % s     % ld   lines   \\ n   \"   ,   filename   ,   line _ count   ) ;   }     (   word _ turn _   )   {   printf   (   \" % s     % ld   words   \\ n   \"   ,   filename   ,   word _ count   ) ;   }   return   0   ;   }   结构 体   结构 体   结构 体 声明 才能 ：   struct   book   {   char   title   [   100   ] ;   char   author   [   50   ] ;   } ;   声明 ，   struct   book   类似   int   声明 变量 ：   int   x   ;   struct   book   y   ;   结构 体 变量 初始化 所示 ：   struct   book   library   =   {   \"     a   title \"   ,   \" author \"   ,   } ;   C99 C11 还 提供 初始化 语法 ：   struct   book   library   =   {   .   title   =   \"     a   title \"   ,   .   author   =   \" author \"   ,   } ;   访问 结构 体 成员 变量 采用   .   运算符 ：   library . title   library . author   函数参数 上 传递 结构 体 传递 结构 体 指针 ， 传递 结构 体 指针 采用 语法 访问 结构 体 成员 变量 ：   library - > title   library - > author   typedef   typedef   类型 声明 一个 别名 ， ：   typedef   unsigned   char   BYTE   ;   BYTE   x   ;   typedef 定义 结构 体 类型 会 很 好 ：   typedef   struct   {   int   rows   ;   int   cols   ;   int   data   [ ] ;   }   Matrix2D   ;   Matrix2D   x   ;   链表   LISP 语言 中 常见 链表 数据结构 ， 小节 参考   参考资料 4   。 结构 定义 写法 很 清晰 ：   struct   node   {   int   data   ;   struct   node   *     ;   } ;   基础 上 ， 参考资料 4 做 灵活性 拓展 ， 做 修改   list . h   文件 ：   # ifndef   LIST _ H _   # define   LIST _ H _   # include   < stdbool . h >   # define   ItemType   int   # define   DefNode ( NodeType ,   ListType )   \\   typedef   struct   node   {   \\   ItemType   item ;   \\   struct   node   *   ;   \\   } NodeType ;   \\   typedef   NodeType *   ListType ; \\   DefNode   (   Node   ,   List   ) ;   List   init _ list   ( ) ;   List   make _ list   (   ItemType   x   ) ;   void   print _ list   (   List   list   ) ;   void   free _ list   (   List   *   plist   ) ;   bool   insert _ list   (   ItemType   x   ,   List   *   plist   ) ;   bool   _ list _ empty   (   const   List   *   plist   ) ;   unsigned   int   list _ length   (   List   list   ) ;   # endif   参数   # define   宏 介绍   SIZEOF   提到 。   list . c   文件 所示 ：   # include   \" list . h \"   # include   < stdio . h >   List   make _ list   (   ItemType   x   )   {   / /   init _ list       item   List   _ list   ;   _ list   =   (   List   )   malloc   (   sizeof   (   Node   ) ) ;   _ list   - >   item   =   x   ;   _ list   - >     =   NULL   ;   return   _ list   ;   }   List   init _ list   ( )   {   / /   init _ list       item   return   NULL   ;   }   void   print _ list   (   List   list   )   {   printf   (   \"   \\ n   [   \"   ) ;     (   list   ! =   NULL   )   {   printf   (   \" % d ,   \"   ,   list   - >   item   ) ;   list   =   list   - >     ;   }   printf   (   \"   ] \"   ) ;   }   bool   insert _ list   (   ItemType   x   ,   List   *   plist   )   {     ( (   *   plist   )   = =   NULL   )   {   (   *   plist   )   =   (   List   )   malloc   (   sizeof   (   Node   ) ) ;     (   *   plist   = =   NULL   )   {   / /   malloc   failed .   return   false   ;   }   (   *   plist   )   - >   item   =   x   ;   (   *   plist   )   - >     =   NULL   ;   return   true   ;   }     {   insert _ list   (   x   ,   &   ( (   *   plist   )   - >     ) ) ;   }   }   bool   _ list _ empty   (   const   List   *   plist   )   {     (   *   plist   = =   NULL   )   {   return   true   ;   }     {   return   false   ;   }   }   unsigned   int   list _ length   (   List   list   )   {   unsigned   int   count   =   0   ;     (   list   ! =   NULL   )   {   count   ++   ;   list   =   list   - >     ;   }   return   count   ;   }   void   free _ list   (   List   *   plist   )   {   / *   NOTICE :   assume     list     create     malloc           a   bug .   * /   Node   *   psave   ;     ( (   *   plist   )   ! =   NULL   )   {   psave   =   (   *   plist   )   - >     ;   free   (   *   plist   ) ;   *   plist   =   psave   ;   }   }   运行 文件 ：   # include   \" myhead . h \"   # include   \" list . h \"   int   main   (   void   )   {   List   list1   =   make _ list   (   1   ) ;   print _ list   (   list1   ) ;   insert _ list   (   2   ,   &   list1   ) ;   print _ list   (   list1   ) ;   List   list2   =   init _ list   ( ) ;   insert _ list   (   3   ,   &   list2   ) ;   print _ list   (   list2   ) ;   assert   (   list _ length   (   list1   )   = =   2   ) ;   free _ list   (   &   list1   ) ;   free _ list   (   &   list2   ) ;   return   0   ;   }   链表 操作 动作 函数 ， 后续 时间 补 上 。 定义 一个 数据结构 ， 一般来说 针对 数据结构 排序 查找 相关 动作 都 配套 函数 跟上 。 面向对象编程 风格 优点 缺点 。 优点 基础 配套 函数 写 好 操作 接口 会 很 简单 ， 缺点 引入 一个 新 对象 数据结构 ， 会 带来 一系列 代码 量 工作量 ， 提升 项目 复杂度 。     enum   union   联合   一种 数据类型 ， 其能 内存空间 中 存储 数据类型 ， ：   union   hold   {   int   digit ;   double   bigfl ;   }   联合 数据类型 存储 一个 int 类型 一个 double 数据类型 。 分配内存 空间 占用 空间 数据类型 。   更 声明   指向 函数 指针   参考资料   C   Primer   Plus   第六版 中文版   Practical   C   programming   Steve   Oualline   菜鸟 教程   计算机科学 基础   Alfred   V .   Aho   Jeffrey   D .   Ullman",
            "tags":"c_language",
            "url":"articles/c-language-learning-notes.html"
        },
        {
            "title":"pyside2学习笔记",
            "text":"更新   原 pyqt5 学习 笔记 基础 上 更新 调整 pyside2 学习 笔记 ， 推荐 pyside2 。 本文 推荐 参看   样例 项目   阅读 风味 更佳 。   安装 配置   利用 pip   安装 ：   pip   install   pyside2   第一个 例子   窗口   【 beginning - first01 】   import   sys     PySide2 . QtWidgets   import   QApplication   ,   QWidget   class   MyWidget   (   QWidget   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )     .   setGeometry   (   0   ,   0   ,   800   ,   600   )   #   坐标 0   0   大小 800   600     .   setWindowTitle   (   ' myapp '   )     __ __   = =   ' __ main __ '   :   myapp   =   QApplication   (   sys   .   argv   )   mywidget   =   MyWidget   ( )   mywidget   .   show   ( )   sys   .   exit   (   myapp   .   exec _   ( ) )   导入 sys 宏包 ， 这是 接受 sys . argv 参数 。   接下来 定义 MyWidget 类 ， 继承 QWidget 类 。 QWidget 类   setGeometry   方法 调整 窗口 左 顶点 坐标 位置 窗口 大小 。     setWindowTitle   方法 设置 窗口 程序 标题 ， 简单 设置 \" myapp \" 。   窗口 程序 都 创建 一个 QApplication 类 实例 ， myapp 。 接下来 创建 QWidget 类 实例 mywidget ， 调用 mywidget 方法   show   显示 窗体 。   系统 退出 调用 myapp 实例   exec _   方法 。   加上 图标   【 beginning - first02 】   import   sys     PySide2 . QtGui   import   QIcon     PySide2 . QtWidgets   import   QWidget   ,   QApplication   class   MyWidget   (   QWidget   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )     .   resize   (   800   ,   600   )     .   setWindowTitle   (   ' myapp '   )     .   setWindowIcon   (   QIcon   (   ' icons / myapp . ico '   ) )     __ __   = =   ' __ main __ '   :   myapp   =   QApplication   (   sys   .   argv   )   mywidget   =   MyWidget   ( )   mywidget   .   show   ( )   sys   .   exit   (   myapp   .   exec _   ( ) )   程序 程序 增加 一个   setWindowIcon   方法 ， 方法 调用   QtGui . QIcon   方法 ， 图标 存放 路径 ， 相对路径 。 运行 例子 ， 请 随便 弄个 图标 文件 。   简单 见 程序 QWidget 类   resize   方法 设置 窗体 大小 。   弹 出 提示信息   【 beginning - first03 】   import   sys     PySide2 . QtGui   import   QIcon   ,   QFont     PySide2 . QtWidgets   import   QWidget   ,   QApplication   ,   QToolTip   class   MyWidget   (   QWidget   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )     .   resize   (   800   ,   600   )     .   setWindowTitle   (   ' myapp '   )     .   setWindowIcon   (   QIcon   (   ' icons / myapp . ico '   ) )     .   setToolTip   (   ' 看 看 &# 94 ; _&# 94 ; '   )   QToolTip   .   setFont   (   QFont   (   ' 微软 雅黑 '   ,   12   ) )     __ __   = =   ' __ main __ '   :   myapp   =   QApplication   (   sys   .   argv   )   mywidget   =   MyWidget   ( )   mywidget   .   show   ( )   sys   .   exit   (   myapp   .   exec _   ( ) )   段 代码 代码 在于 MyWidget 类 初始 函数 新 两条 命令 。   setToolTip   方法 设置 显示 弹出 提示 文本 内容 ， 调用 QToolTip 类   setFont   方法 设置 字体 字号 ， 不 太 随便 设置 系统 字体 微软 雅黑 。   鼠标 停放 窗口 上 一会儿 会弹 出 一小 段 提示 文字 。   关闭 窗体 时 询问   【 beginning - first04 】   import   sys     PySide2 . QtGui   import   QIcon   ,   QFont     PySide2 . QtWidgets   import   QWidget   ,   QApplication   ,   QToolTip   ,   QMessageBox   class   MyWidget   (   QWidget   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )     .   resize   (   800   ,   600   )     .   setWindowTitle   (   ' myapp '   )     .   setWindowIcon   (   QIcon   (   ' icons / myapp . ico '   ) )     .   setToolTip   (   ' 看 看 &# 94 ; _&# 94 ; '   )   QToolTip   .   setFont   (   QFont   (   ' 微软 雅黑 '   ,   12   ) )   def   closeEvent   (     ,   event   ) :   #   定义 colseEvent   reply   =   QMessageBox   .   question   (     ,   ' 信息 '   ,   \" 退出 ？ \"   ,   QMessageBox   .   Yes   ,   QMessageBox   .   No   )     reply   = =   QMessageBox   .   Yes   :   event   .   accept   ( )     :   event   .   ignore   ( )     __ __   = =   ' __ main __ '   :   myapp   =   QApplication   (   sys   .   argv   )   mywidget   =   MyWidget   ( )   mywidget   .   show   ( )   sys   .   exit   (   myapp   .   exec _   ( ) )   段 代码 代码 定义   colseEvent   事件 。 段 代码 核心 QMessageBox 类 question 方法 ， 方法 将会弹 出 一个 询问 窗体 。 方法 接受 四个 参数 ： 第一个 参数 窗体 所属 母体 ， 实例 mywidget ； 第二个 参数 弹出 窗体 标题 ； 第三个 参数 一个 标准 button ； 第四个 参数 一个 标准 button ， 默认 （ enter 选定 ） button 。 方法 返回 点击 标准 button 标识符 ， 标准   QMessageBox . Yes   ， 执行 event accept 方法 。   屏幕 居中 显示 窗体   【 beginning - first05 】   import   sys     PySide2 . QtGui   import   QIcon   ,   QFont     PySide2 . QtWidgets   import   QWidget   ,   QApplication   ,   QToolTip   ,   QMessageBox   class   MyWidget   (   QWidget   ) :   def   __ init __   (     ,   app   ) :   super   ( )   .   __ init __   ( )     .   app   =   app     .   resize   (   800   ,   600   )     .   center   ( )     .   setWindowTitle   (   ' myapp '   )     .   setWindowIcon   (   QIcon   (   ' icons / myapp . ico '   ) )     .   setToolTip   (   ' 看 看 &# 94 ; _&# 94 ; '   )   QToolTip   .   setFont   (   QFont   (   ' 微软 雅黑 '   ,   12   ) )   def   closeEvent   (     ,   event   ) :   #   定义 colseEvent   reply   =   QMessageBox   .   question   (     ,   ' 信息 '   ,   \" 退出 ？ \"   ,   QMessageBox   .   Yes   ,   QMessageBox   .   No   )     reply   = =   QMessageBox   .   Yes   :   event   .   accept   ( )     :   event   .   ignore   ( )   #   center   method   def   center   (     ) :   screen   =     .   app   .   screens   ( ) [   0   ]   screen _ size   =   screen   .   size   ( )   size   =     .   geometry   ( )     .   move   ( (   screen _ size   .   width   ( )   -   size   .   width   ( ) )   /   2   ,   \\   (   screen _ size   .   height   ( )   -   size   .   height   ( ) )   /   2   )     __ __   = =   ' __ main __ '   :   myapp   =   QApplication   (   sys   .   argv   )   mywidget   =   MyWidget   (   myapp   )   mywidget   .   show   ( )   sys   .   exit   (   myapp   .   exec _   ( ) )   例子 相比 改动 新建 一个   center   方法 ， 接受 一个 实例 ， mywidget 。 实例 窗口 具体位置 做 调整 。   新建 QApplication 对象 传递 进来 ， 其有 一个   screens   方法 ， 获取 电脑设备 QScreen 对象 列表 ， 多个 屏幕 有用 ， 简单 选定 第一个 屏幕 。 QScreen 对象   size   方法 获取 屏幕 大小 尺寸 ， 返回 QSize 对象 。   QWidget 类   geometry   方法 返回 一个 量 ， 量 width 窗体 宽度 ， 量 height 属性 窗体 高度 。   调用 QWidget 类 move 方法 ， mywidget 实例 作用 。 move 方法 X ， Y 是从 屏幕 坐标 原点   ( 0 , 0 )   计算 。 第一个 参数 X 右 宽度 ， Y 向下 高度 。   函数 作用 效果 窗体 居中 显示 。   QMainWindow 类   QMainWindow 类 提供 应用程序 主 窗口 ， 创建 一个 经典 拥有 状态栏 、 工具栏 菜单栏 应用程序 骨架 。 （ QWidget 类 ， 换成 QMainWindow 类 。 ）   第一个 例子 都 QWidget 类 创建 一个 窗体 。 QWidget QMainWindow 两个 类 区别   网站   结论 ： QWdget 类 Qt 中是 可画类 基础 （ 窗体 基础 。 ）   基于 QWidget 类 都 独立 窗体 显示 不 母体 （ parent ） 。   QMainWindow 类 针对 主 窗体 需求 设计 ， 预定 义 菜单栏 状态栏 widget （ 窗口 小 部件 ）   。 继承 QWidget ， 谈及 属性 修改 都 。 代码 中 QWidget 类 换成 QMainWindow 类 ， 加上 一个 状态栏 提示信息 。   【 beginning - first06 】   import   sys     PySide2 . QtGui   import   QIcon   ,   QFont     PySide2 . QtWidgets   import   QMainWindow   ,   QApplication   ,   QToolTip   ,   QMessageBox   class   MyWindow   (   QMainWindow   ) :   def   __ init __   (     ,   app   ) :   super   ( )   .   __ init __   ( )     .   app   =   app     .   resize   (   800   ,   600   )     .   center   ( )     .   setWindowTitle   (   ' myapp '   )     .   setWindowIcon   (   QIcon   (   ' icons / myapp . ico '   ) )     .   setToolTip   (   ' 看 看 &# 94 ; _&# 94 ; '   )   QToolTip   .   setFont   (   QFont   (   ' 微软 雅黑 '   ,   12   ) )   def   closeEvent   (     ,   event   ) :   #   定义 colseEvent   reply   =   QMessageBox   .   question   (     ,   ' 信息 '   ,   \" 退出 ？ \"   ,   QMessageBox   .   Yes   ,   QMessageBox   .   No   )     reply   = =   QMessageBox   .   Yes   :   event   .   accept   ( )     :   event   .   ignore   ( )   #   center   method   def   center   (     ) :   screen   =     .   app   .   screens   ( ) [   0   ]   screen _ size   =   screen   .   size   ( )   size   =     .   geometry   ( )     .   move   ( (   screen _ size   .   width   ( )   -   size   .   width   ( ) )   /   2   ,   \\   (   screen _ size   .   height   ( )   -   size   .   height   ( ) )   /   2   )     __ __   = =   ' __ main __ '   :   myapp   =   QApplication   (   sys   .   argv   )   mywindow   =   MyWindow   (   myapp   )   mywindow   .   show   ( )   mywindow   .   statusBar   ( )   .   showMessage   (   ' 程序 已 就绪 ... '   )   sys   .   exit   (   myapp   .   exec _   ( ) )   加上 菜单栏   【 beginning - first07 】   import   sys     PySide2 . QtGui   import   QIcon   ,   QFont     PySide2 . QtWidgets   import   QMainWindow   ,   QApplication   ,   QToolTip   ,   QMessageBox   class   MyWindow   (   QMainWindow   ) :   def   __ init __   (     ,   app   ) :   super   ( )   .   __ init __   ( )     .   app   =   app     .   initUI   ( )   def   initUI   (     ) :     .   resize   (   800   ,   600   )     .   center   ( )     .   setWindowTitle   (   ' myapp '   )     .   setWindowIcon   (   QIcon   (   ' icons / myapp . ico '   ) )     .   setToolTip   (   ' 看 看 &# 94 ; _&# 94 ; '   )   QToolTip   .   setFont   (   QFont   (   ' 微软 雅黑 '   ,   12   ) )   #   菜单栏   menu _ control   =     .   menuBar   ( )   .   addMenu   (   ' Contorl '   )   act _ quit   =   menu _ control   .   addAction   (   ' quit '   )   act _ quit   .   triggered   .   connect   (     .   close   )   menu _   =     .   menuBar   ( )   .   addMenu   (   ' Help '   )   act _   =   menu _   .   addAction   (   ' ... '   )   act _   .   triggered   .   connect   (     .     )   act _ aboutqt   =   menu _   .   addAction   (   ' aboutqt '   )   act _ aboutqt   .   triggered   .   connect   (     .   aboutqt   )   #   状态栏     .   statusBar   ( )   .   showMessage   (   ' 程序 已 就绪 ... '   )     .   show   ( )   def   closeEvent   (     ,   event   ) :   #   定义 colseEvent   reply   =   QMessageBox   .   question   (     ,   ' 信息 '   ,   \" 退出 ？ \"   ,   QMessageBox   .   Yes   ,   QMessageBox   .   No   )     reply   = =   QMessageBox   .   Yes   :   event   .   accept   ( )     :   event   .   ignore   ( )   def     (     ) :   QMessageBox   .     (     ,   \"     software \"   ,   \" wise   system \"   )   def   aboutqt   (     ) :   QMessageBox   .   aboutQt   (     )   #   center   method   def   center   (     ) :   screen   =     .   app   .   screens   ( ) [   0   ]   screen _ size   =   screen   .   size   ( )   size   =     .   geometry   ( )     .   move   ( (   screen _ size   .   width   ( )   -   size   .   width   ( ) )   /   2   ,   \\   (   screen _ size   .   height   ( )   -   size   .   height   ( ) )   /   2   )     __ __   = =   ' __ main __ '   :   myapp   =   QApplication   (   sys   .   argv   )   mywindow   =   MyWindow   (   myapp   )   sys   .   exit   (   myapp   .   exec _   ( ) )   讨论 加上 状态栏 类似 ， QMainWindow 类   menuBar   方法 一个 菜单栏 对象 。 菜单栏 对象   addMenu   方法 创建 一个 新 菜单 对象 （ QMenu 类 ） ， addMenu 方法 内容 新建 菜单 显示 文本 。   菜单 对象 加上 动作 ， 调用 菜单 对象   addAction   方法 ， menuBar 创建 一个 菜单栏 对象 ， addMenu 方法 创建 一个 菜单 ， 返回 一个 菜单 对象 ， 菜单 对象 addAction 方法 ， 方法 菜单 添加 一个 动作 ， 或者说 一个 item 一个 内容 ， addAction 返回 一个 动作 对象 ， 动作 对象 信号 － 槽 机制 连接 ， 一个 函数 连接起来 。   动作 对象 ， 菜单 下 拉 选项 ， 鼠标 点击 ， 将会 触发   triggered   信号 ， connect 方法 连接 槽 上 （ 定义 函数 ） ， 将会 触发 函数 执行 。 信号 － 槽 机制 详细 。   信号 － 槽 机制   GUI 程序 都 引入 一种 事件 信号 机制 ， ， 简单 来说 一个 循环 程序 ， 循环 程序 等到 时刻 程序 会 自动 做 事情 刷新 程序界面 ， 扫描 键盘 鼠标 ， 用户 点击 鼠标 键盘 ， 它会 接受 信号 做出 。   猜到 ，   close   函数 退出 循环 程序 。 调用 主程序   exec _   方法 ， 开启 循环 程序 。   新 信号 - 槽 语法 所示 ：   act _ exit   .   triggered   .   connect   (     .   close   )   新 信号 － 槽 机制 语句 变得 更 精简 更 易懂 。 过程 所述 ， 对象 发出 信号 ， connect 信号 槽 （ 定义 函数 ） 连接起来 一个 反射弧 。   槽 主 窗口 实例 close 方法 ， 主 窗口 自带 函数 。   aboutqt 函数 。 读者 不 懂 请 翻阅 QMessageBox 类 静态方法       aboutqt   。   再 随便 画 点   再 随便 画 点 ， QMainWindow 中心 面板   setCentralWidget   ， 随便 新 自定义 面板 设置 垂直 布局 ， 简单 加上 一个 按钮 。 按钮 点击 会 执行 print     world 动作 。 更 详细 请 参看 信号 - 槽 详解 小节 布局 管理 小节 。   import   sys     PySide2 . QtGui   import   QIcon   ,   QFont     PySide2 . QtCore   import   Slot     PySide2 . QtWidgets   import   QMainWindow   ,   QApplication   ,   QToolTip   ,   QMessageBox   ,   \\   QPushButton   ,   QWidget   ,   QVBoxLayout   class   MyWidget   (   QWidget   ) :   def   __ init __   (     ) :   super   (   MyWidget   ,     )   .   __ init __   ( )   layout   =   QVBoxLayout   ( )   mybutton   =   QPushButton   (   \"   world ! \"   )   layout   .   addWidget   (   mybutton   )     .   setLayout   (   layout   )   mybutton   .   clicked   .   connect   (     .     )   @ Slot   ( )   def     (     ) :   print   (   '   world ! '   )   class   MyWindow   (   QMainWindow   ) :   def   __ init __   (     ,   app   ) :   super   ( )   .   __ init __   ( )     .   app   =   app     .   initUI   ( )   def   initUI   (     ) :     .   resize   (   800   ,   600   )     .   center   ( )     .   setWindowTitle   (   ' myapp '   )     .   setWindowIcon   (   QIcon   (   ' icons / myapp . ico '   ) )     .   setToolTip   (   ' 看 看 &# 94 ; _&# 94 ; '   )   QToolTip   .   setFont   (   QFont   (   ' 微软 雅黑 '   ,   12   ) )   #   菜单栏   menu _ control   =     .   menuBar   ( )   .   addMenu   (   ' Contorl '   )   act _ quit   =   menu _ control   .   addAction   (   ' quit '   )   act _ quit   .   triggered   .   connect   (     .   close   )   menu _   =     .   menuBar   ( )   .   addMenu   (   ' Help '   )   act _   =   menu _   .   addAction   (   ' ... '   )   act _   .   triggered   .   connect   (     .     )   act _ aboutqt   =   menu _   .   addAction   (   ' aboutqt '   )   act _ aboutqt   .   triggered   .   connect   (     .   aboutqt   )   #   绘制 点   mywidget   =   MyWidget   ( )     .   setCentralWidget   (   mywidget   )   #   状态栏     .   statusBar   ( )   .   showMessage   (   ' 程序 已 就绪 ... '   )     .   show   ( )   def   closeEvent   (     ,   event   ) :   #   定义 colseEvent   reply   =   QMessageBox   .   question   (     ,   ' 信息 '   ,   \" 退出 ？ \"   ,   QMessageBox   .   Yes   ,   QMessageBox   .   No   )     reply   = =   QMessageBox   .   Yes   :   event   .   accept   ( )     :   event   .   ignore   ( )   def     (     ) :   QMessageBox   .     (     ,   \"     software \"   ,   \" wise   system \"   )   def   aboutqt   (     ) :   QMessageBox   .   aboutQt   (     )   #   center   method   def   center   (     ) :   screen   =     .   app   .   screens   ( ) [   0   ]   screen _ size   =   screen   .   size   ( )   size   =     .   geometry   ( )     .   move   ( (   screen _ size   .   width   ( )   -   size   .   width   ( ) )   /   2   ,   \\   (   screen _ size   .   height   ( )   -   size   .   height   ( ) )   /   2   )     __ __   = =   ' __ main __ '   :   myapp   =   QApplication   (   sys   .   argv   )   mywindow   =   MyWindow   (   myapp   )   sys   .   exit   (   myapp   .   exec _   ( ) )   信号 － 槽 详解   信号 ( singal ) 连接 无数 多个 槽 ( slot ) ， 连接 槽 ， 信号 连接 信号 。 所述 ， 连接 语句 形式 ：   . singal . connect ( slot )   。 比如说 按钮 最 常见 内置 信号   triggered   ， 槽 实际上 函数 ， 主 窗体   . close   方法 。   信号   QObject   一个 属性 ， pyqt 窗体 很多 内置 信号 ， 定义 信号 ， 再 提及 。 信号 还 没 槽 连接起来 一个 属性 ，   connect   方法 连接起来 ， 信号 － 槽 机制 建立 。 类似 信号   disconnect   方法   emit   方法 。 disconnect 断开 信号 － 槽 机制 ， emit 激活 信号 。   定义 信号 槽 . singal . connect ( slot ) 简洁 形式 工作 感到 困惑 。 先 简要地 介绍 。   信号 都 类 一个 属性 ， 新 信号 继承 QObject ，   PySide2 . QtCore . Singal   方法 创建 ， 方法 接受 参数 中 最 types 类型 ， int ， bool ， 这是 信号 传递 参数 类型 ， 传递 参数值 emit 方法 。 槽 实际上 封装 函数 ， 函数 接受 参数 不 接受 参数 ， 参数 值 传 进来 emit 方法 执行 ， 隐藏 一个 细节 emit 方法 。 比如说 定义 一个 新 信号 ， 点击 屏幕 x , y 坐标 发送 ， 内置 信号 － 槽 机制 都 ， 定义 信号 槽 ，   Singal ( int , int )   ， 发送给 func ( x , y ) ， x y 值 emit ( x , y ) 发送 。   请 看 例子 ：   【 singal - slot / age 】   import   sys     PySide2 . QtWidgets   import   QHBoxLayout   ,   QSlider   ,   QSpinBox   ,   QApplication   ,   \\   QWidget     PySide2 . QtCore   import   Qt   app   =   QApplication   (   sys   .   argv   )   window   =   QWidget   ( )   window   .   setWindowTitle   (   \" enter     age \"   )   spinBox   =   QSpinBox   ( )   slider   =   QSlider   (   Qt   .   Horizontal   )   spinBox   .   setRange   (   0   ,   130   )   slider   .   setRange   (   0   ,   130   )   spinBox   .   valueChanged   .   connect   (   slider   .   setValue   )   slider   .   valueChanged   .   connect   (   spinBox   .   setValue   )   spinBox   .   setValue   (   35   )   layout   =   QHBoxLayout   ( )   layout   .   addWidget   (   spinBox   )   layout   .   addWidget   (   slider   )   window   .   setLayout   (   layout   )   window   .   show   ( )   sys   .   exit   (   app   .   exec _   ( ) )   spinBox . valueChanged . connect ( slider . setValue )   spinBox   valueChanged   信号 slider   setValue   槽 连接起来 ， QSpinBox 内置   valueChanged   信号 发射 自带 一个 参数 改变 后 值 ， 值 传递 QSlider 内置 槽   setValue   ， slider 值 设置 新值 。 ， slider 值 发生 改变 ， 会 发送 valueChanged 信号 ， 传递 spinBox ， 执行 内置 槽 setValue ， 值 原值 ， spinBox 内 值 发生 改变 ， 程序 陷入 死循环 。   自定义 信号   创建 一个 定义 信号 ：     PySide2 . QtCore   import   Signal   closed   =   Signal   ( )   自定义 槽   python 格式 定义 函数 自定义 槽 。 推荐 Pyside2 槽 装饰器 定义 槽 。     PySide2 . QtCore   import   Slot   @ Slot   ( )   def   foo   (     ) :   pass   @ Slot   (   int   ,   str   )   def   foo   (     ,   arg1   ,   arg2   ) :   pass   第一个 例子 定义 名叫 foo 一个 槽 ， 不 接受 参数 。 第二个 槽 接受 一个 int 类型 值 str 类型 值 。   发射 信号   信号 对象 emit 方法 用来 发射 信号 ， 信号 对象 disconnect 方法 断开 信号 槽 连接 。   一个 信号 连接 多个 槽 ， 多个 信号 连接 同一个 槽 ， 一个 信号 一个 信号 相连接 。   一个 例子 详解 建 信号 自建槽 建立 发射 机制 情况 。   【 singal - slot / FindDialog 】     PySide2 . QtWidgets   import   QDialog   ,   QLabel   ,   QLineEdit   ,   QCheckBox   ,   \\   QPushButton   ,   QHBoxLayout   ,   QVBoxLayout   ,   QApplication     PySide2 . QtCore   import   Qt   ,   Signal   ,   Slot   class   FindDialog   (   QDialog   ) :   findNext   =   Signal   (   str   ,   Qt   .   CaseSensitivity   )   findPrevious   =   Signal   (   str   ,   Qt   .   CaseSensitivity   )   def   __ init __   (     ,   parent   =   None   ) :   super   ( )   .   __ init __   (   parent   )   label   =   QLabel   (   \" Find   & : \"   )     .   lineEdit   =   QLineEdit   ( )   label   .   setBuddy   (     .   lineEdit   )     .   caseCheckBox   =   QCheckBox   (   \" Match   & case \"   )     .   backwardCheckBox   =   QCheckBox   (   \" Search   & backward \"   )     .   findButton   =   QPushButton   (   \" & Find \"   )     .   findButton   .   setDefault   (   True   )     .   findButton   .   setEnabled   (   False   )   closeButton   =   QPushButton   (   \" Close \"   )     .   lineEdit   .   textChanged   .   connect   (     .   enableFindButton   )     .   findButton   .   clicked   .   connect   (     .   findClicked   )   closeButton   .   clicked   .   connect   (     .   close   )   topLeftLayout   =   QHBoxLayout   ( )   topLeftLayout   .   addWidget   (   label   )   topLeftLayout   .   addWidget   (     .   lineEdit   )   leftLayout   =   QVBoxLayout   ( )   leftLayout   .   addLayout   (   topLeftLayout   )   leftLayout   .   addWidget   (     .   caseCheckBox   )   leftLayout   .   addWidget   (     .   backwardCheckBox   )   rightLayout   =   QVBoxLayout   ( )   rightLayout   .   addWidget   (     .   findButton   )   rightLayout   .   addWidget   (   closeButton   )   rightLayout   .   addStretch   ( )   mainLayout   =   QHBoxLayout   ( )   mainLayout   .   addLayout   (   leftLayout   )   mainLayout   .   addLayout   (   rightLayout   )     .   setLayout   (   mainLayout   )     .   setWindowTitle   (   \" Find \"   )     .   setFixedHeight   (     .   sizeHint   ( )   .   height   ( ) )   def   enableFindButton   (     ,   text   ) :     .   findButton   .   setEnabled   (   bool   (   text   ) )   @ Slot   ( )   def   findClicked   (     ) :   text   =     .   lineEdit   .   text   ( )       .   caseCheckBox   .   isChecked   ( ) :   cs   =   Qt   .   CaseSensitive     :   cs   =   Qt   .   CaseInsensitive       .   backwardCheckBox   .   isChecked   ( ) :     .   findPrevious   .   emit   (   text   ,   cs   )     :     .   findNext   .   emit   (   text   ,   cs   )     __ __   = =   ' __ main __ '   :   import   sys   app   =   QApplication   (   sys   .   argv   )   findDialog   =   FindDialog   ( )   def   find   (   text   ,   cs   ) :   print   (   ' find : '   ,   text   ,   ' cs '   ,   cs   )   def   findp   (   text   ,   cs   ) :   print   (   ' findp : '   ,   text   ,   ' cs '   ,   cs   )   findDialog   .   findNext   .   connect   (   find   )   findDialog   .   findPrevious   .   connect   (   findp   )   findDialog   .   show   ( )   sys   .   exit   (   app   .   exec _   ( ) )   自建 信号 类 属性 ， 类 QObject 子类 ， 面板 都 继承 QObject ， 倒 不用 担心 。   findNext   =   Signal   (   str   ,   Qt   .   CaseSensitivity   )   findPrevious   =   Signal   (   str   ,   Qt   .   CaseSensitivity   )   两行 自定义 信号 ， 信号 两个 参数 ， 一个 str 字符 变量 ， 一个 Qt . CaseSensitivity 枚举 值 。 假设 输入 文字 ， 点击 Find 按钮 ， 请 ：     .   findButton   .   clicked   .   connect   (     .   findClicked   )   点击 执行 findClicked 槽 ， 按钮 clicked 信号 不带 参数 。 定义 findClicked 槽 参数 。   findClicked 函数 QLineEdit text 值 cs 大小写 检查 状态 。 向前 后 勾选来 接下来 发送 信号 。 findNext 信号 调用 emit 方法 ， 两个 参数 传递 。 findNext 正是 自定义 信号 ， 正是 两个 参数 类型 。   def   find   (   text   ,   cs   ) :   print   (   ' find : '   ,   text   ,   ' cs '   ,   cs   )   def   findp   (   text   ,   cs   ) :   print   (   ' findp : '   ,   text   ,   ' cs '   ,   cs   )   findDialog   .   findNext   .   connect   (   find   )   findDialog   .   findPrevious   .   connect   (   findp   )   简单 定义 两个 函数 术语 来说 称之为 槽 ， emit 方法 发送 findNext 信号 参数 ， findNext 信号 find 槽 连接起来 ， 信号 槽 之间 参数 匹配 ， find 接受 两个 参数 。   引用 信号 发射 对象   sender   方法 来自 GObject ， Qt 里 窗体 对象 都 。 用法 槽 ， 调用   . sender ( )   ， 返回 一个 发射 信号 对象 。   布局 管理   最   QHBoxLayout     QVBoxLayout   ， 一个 水平 布局 ， 一个 垂直 布局 。   QBoxLayout   QHBoxLayout     QVBoxLayout   一个 横向 排布 ， 一个 竖向 排布 。 方法 所示 ：   mainLayout   =   QHBoxLayout   ( )   mainLayout   .   addWidget   (   button1   )   mainLayout   .   addWidget   (   button2   )     .   setLayout   (   mainLayout   )   Layout 对象 好像 一个 封装 器 ， Layout 还 Layout ， 窗体 子 单元 ， 都   addWidget   方法 确立 封装 关系 。 主母 窗口 接受 一个 Layout 对象 ，   setLayout   方法 。   【 layout / 】     PySide2 . QtWidgets   import   QApplication   ,   QWidget   ,   QLabel   ,   QVBoxLayout   ,   \\   QPushButton   ,   QLineEdit   ,   QMessageBox   class   Form   (   QWidget   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )   nameLabel   =   QLabel   (   \" Name : \"   )     .   nameLine   =   QLineEdit   ( )     .   submitButton   =   QPushButton   (   \" Submit \"   )   bodyLayout   =   QVBoxLayout   ( )   bodyLayout   .   addWidget   (   nameLabel   )   bodyLayout   .   addWidget   (     .   nameLine   )   bodyLayout   .   addWidget   (     .   submitButton   )     .   submitButton   .   clicked   .   connect   (     .   submit   )     .   setLayout   (   bodyLayout   )     .   setWindowTitle   (   \" Hello   Qt \"   )     .   show   ( )   def   submit   (     ) :     =     .   nameLine   .   text   ( )       = =   \" \"   :   QMessageBox   .   information   (     ,   \" Empty   Field \"   ,   \" Please   enter   a   . \"   )   return     :   QMessageBox   .   information   (     ,   \" Success ! \"   ,   \" Hello   % s   ! \"   %     )     __ __   = =   ' __ main __ '   :   import   sys   app   =   QApplication   (   sys   .   argv   )   screen   =   Form   ( )   sys   .   exit   (   app   .   exec _   ( ) )   addStretch 方法   插入 一个 分隔符 ， 设计 器 弹簧 。   QGridLayout   QGridLayout 网格 布局 。 QGridLayout 用法 QBoxLayout 类似 ，   addWidget   方法 还 接受 两个 额外 参数 几行 几列 。   请 例子 。 例子 很 好 演示 QGridLayout 。   ( i - 1 ) / / 3   该数 3 取商 ， 本来 1   2   3   4   5   6 … 0   0   0   1   1   1   2   2   2 … 正好 网格 中 几行 ，   ( i - 1 ) % 3   该数 3 取余 ， 本来 1   2   3   4   5   6 … 0   1   2   0   1   2   0   1   2 … 正好 网格 中 几列 概念 。   【 layout / gridlayout 】     PySide2 . QtWidgets   import   QApplication   ,   QWidget   ,   QPushButton   ,   QGridLayout   class   Form   (   QWidget   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )   bodyLayout   =   QGridLayout   ( )     i     range   (   1   ,   10   ) :   button   =   QPushButton   (   str   (   i   ) )   bodyLayout   .   addWidget   (   button   ,   (   i   -   1   )   / /   3   ,   (   i   -   1   )   %   3   )   print   (   i   ,   (   i   -   1   )   / /   3   ,   (   i   -   1   )   %   3   )     .   setLayout   (   bodyLayout   )     .   setWindowTitle   (   \"   grid   layout \"   )     .   show   ( )     __ __   = =   ' __ main __ '   :   import   sys   app   =   QApplication   (   sys   .   argv   )   screen   =   Form   ( )   sys   .   exit   (   app   .   exec _   ( ) )   QFormLayout   QFormLayout ， 表单 布局 ， 常用 提交 配置 信息 表单 。   请 例子 。 例子 来自 pyqt5 源码 examples 文件夹 layouts 文件夹 basiclayouts . py 文件 ， 做 简化 用于 演示 表单 布局 。   【 layout / basiclayouts 】     PySide2 . QtWidgets   import   (   QApplication   ,   QDialog   ,   QDialogButtonBox   ,   QFormLayout   ,   QGroupBox   ,   QLabel   ,   QLineEdit   ,   QSpinBox   ,   QVBoxLayout   ,   QTextEdit   )   class   Dialog   (   QDialog   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )     .   createFormGroupBox   ( )   buttonBox   =   QDialogButtonBox   (   QDialogButtonBox   .   Ok   |   QDialogButtonBox   .   Cancel   )   buttonBox   .   accepted   .   connect   (     .   accept   )   buttonBox   .   rejected   .   connect   (     .   reject   )   mainLayout   =   QVBoxLayout   ( )   mainLayout   .   addWidget   (     .   formGroupBox   )   mainLayout   .   addWidget   (   buttonBox   )     .   setLayout   (   mainLayout   )     .   setWindowTitle   (   \" user   info \"   )   def   createFormGroupBox   (     ) :     .   formGroupBox   =   QGroupBox   (   \"   infomation \"   )   layout   =   QFormLayout   ( )   layout   .   addRow   (   QLabel   (   \" : \"   ) ,   QLineEdit   ( ) )   layout   .   addRow   (   \" age : \"   ,   QSpinBox   ( ) )   layout   .   addRow   (   QLabel   (   \"   infomation : \"   ) ,   QTextEdit   ( ) )     .   formGroupBox   .   setLayout   (   layout   )     __ __   = =   ' __ main __ '   :   import   sys   app   =   QApplication   (   sys   .   argv   )   dialog   =   Dialog   ( )   sys   .   exit   (   dialog   .   exec _   ( ) )     QDialog   类   QDialogButtonBox   类 不 去 ， QDialog 类 accept reject 方法 ， QDialogButtonBox 最 两个 按钮 绑定 喜好 accepted rejected 。   创建 表单 函数 ，   QGroupBox   一个 窗体 类型 ， 带有 标题 。 接下来 QFormLayout 表单 布局 核心 代码 ：   layout   =   QFormLayout   ( )   layout   .   addRow   (   QLabel   (   \" : \"   ) ,   QLineEdit   ( ) )   layout   .   addRow   (   QLabel   (   \" age : \"   ) ,   QSpinBox   ( ) )   layout   .   addRow   (   QLabel   (   \"   infomation : \"   ) ,   QTextEdit   ( ) )     .   formGroupBox   .   setLayout   (   layout   )   layout 创建 母 窗体 layout   setLayout   方法 两个 布局 都 类似 ， 表单 布局 一行行 ， 方法 addWidget ，   addRow   ， addRow 方法 意义 上 接受 两个 窗体 类型 （ 包括 layout 类型 ） ，   第一个 参数 还 字符串 ， 显示 文字   。   资源 文件 管理   【 funnyclock 】   资源 文件 ， 图片 文件 ， 翻译 文件 ， 推荐 转成 python 资源 文件 ， python 代码 中 import 即可 。 编写 一个 qrc 文件 ， qrc 文件 编写 格式 ：   < ! DOCTYPE   RCC >   < RCC   version =   \" 1.0 \"   >   < qresource >   < file >   icons / clock . png   < / file >   < / qresource >   < / RCC >   qrc 编写 很 简单 ， 手工 编写 。 代码 第三行   icons / clock . png   qrc 文件 所在 目录 下 icons 文件夹 ， clock . png 文件 。   qrc 文件 编写 好 运行 命令   pyside2 - rcc . exe   funnyclock . qrc   - o   funnyclock _ rc . py   pyside2 - rcc   安装 pyside2 会 自动 ， 安装 虚拟环境 系统 python 环境 下 Script 文件夹 下 。 资源 ，   import   funnyclock _ rc   引用 路径   : / icons / clock . png   ， 图标 文件 。   推荐 一个 项目 资源 文件 都 一个 qrc 文件 管理 。   国际化 支持   小节 参考资料 官方 文档 之外   网站   。   指 软件 国际化 支持 指 i18n ， 两种 语言 ， 英语 本土 语言 。 软件 字符串 都 英语 ，   . tr ( )   封装 。   项目 里 新建 一个 translations 文件夹 ， 新建 一个 小 文件   wise . pro   ， wise 模块 名字 ， 随意 修改 。 文件 内容 简要 ：   SOURCES   + =   timer . py   TRANSLATIONS   + =   timer _ zh _ CN . ts   SOURCES   希望 扫描 py 文件 ， 文件 所说 翻译 封装 ， 字符串   pyside2 - lupdate   工具 扫描 。 支持 路径 表达 。 不 支持 glob 语法 。   第二个 变量 TRANSLATIONS 希望 生成 目标 翻译 ts 文件 文件名 ， 格式 ：   { PROJECT _ NAME } _ { QLocale . system ( ) . ( ) } . ts   PROJECT _ NAME 项目 名字 ， QLocale . system ( ) . ( ) 机器 所用 目标语言 简写 ， 查看 下 ：   > > >     PySide2 . QtCore   import   QLocale   > > >   QLocale . system ( ) . ( )   ' zh _ CN '     pyside2 - lupdate   小 工具 pro 文件 【 小 工具 安装 pyside2 自动 安装 】 ：   pyside2 - lupdate . exe   timer . pro   生成   timer _ zh _ CH . ts   文件 。   编辑 ts 文件   下载 qtlinguist 工具 编辑 ts 文件 生成 qm 文件 。 推荐   项目   上 下载 。   翻译 文件   翻译 文件 ， qm 文件   #   先 自动 加载 最佳 语言 方案   default _ translator   =   QTranslator   ( )   default _ translator   .   load   (   f   ' : translations / timer _ { QLocale . system ( ) . ( ) } '   )   app   .   installTranslator   (   default _ translator   )   构建 一个 QTranslator 对象 ， 调用 对象 方法 load ， 第一个 参数 load qm 文件名 ， 第二个 参数 qm 文件 路径 ， 谈及 qrc 引用 路径 。   主母 窗口 myapp installTranslator 方法 QTranslator 对象 加进去 即可 。   动态 切换 翻译 方案   请 参看 演示 样例   【 timer 】   def   change _ lang _ chinese   (     ) :     .   app   .   removeTranslator   (   default _ translator   )   translator   =   QTranslator   ( )   translator   .   load   (   ' : translations / timer _ zh _ CN '   )     .   app   .   installTranslator   (   translator   )     .   retranslateUi   ( )     .   lang   =   ' zh '   def   change _ lang _ english   (     ) :     .   app   .   removeTranslator   (   default _ translator   )   translator   =   QTranslator   ( )   translator   .   load   (   ' '   )     .   app   .   installTranslator   (   translator   )     .   retranslateUi   ( )     .   lang   =   ' '   多线程 初步   请 参看 演示 样例   【 timer 】   class   MakeSoundThread   (   QThread   ) :   def   run   (     ) :     True   :   gfun _ beep   (   500   ,   3   )     .   sleep   (   10   )       .   isInterruptionRequested   ( ) :   return   start   线程   requestInterruption     isInterruptionRequested   ， 用于 长时 线程 退出 。   最小化 托盘   请 参看 演示 样例   【 timer 】   class   MySystemTrayIcon   (   QSystemTrayIcon   ) :   def   __ init __   (     ,   parent   =   None   ) :   super   (   MySystemTrayIcon   ,     )   .   __ init __   (   parent   )     .   parent   =   parent     .   setIcon   (   QIcon   (   ' : images / myapp . png '   ) )     .   activated   .   connect   (     .   onTrayIconActivated   )   def   onTrayIconActivated   (     ,   reason   ) :     reason   = =   QSystemTrayIcon   .   ActivationReason   .   Trigger   :     .   parent   .   reopen   ( )   .....     .   mysystemTrayIcon   =   MySystemTrayIcon   (     )   menu1   =   QMenu   (     )   menu _ systemTrayIcon _ open   =   menu1   .   addAction   (   ' open '   )   menu _ systemTrayIcon _ open   .   triggered   .   connect   (     .   reopen   )   menu1   .   addSeparator   ( )   menu _ systemTrayIcon _ exit   =   menu1   .   addAction   (   \" exit \"   )   menu _ systemTrayIcon _ exit   .   triggered   .   connect   (     .   menu _ exit   )     .   mysystemTrayIcon   .   setContextMenu   (   menu1   )     .   mysystemTrayIcon   .   show   ( )   exe 制作 安装程序 制作   exe 制作   exe 制作 写 python 程序 freeze ， 目标 机器 上 用户 安装 python 依赖 都 运行 程序 。   推荐 pyinstaller 。   pyinstaller 官网     。 安装 pip   安装 即可 。   推荐 项目 根目录 下 创建 一个 简单 启动 脚本 ， 平时 测试 ， pyinstaller 程序 入口 。   NOTICE :   脚本 名字 程序 模块 名字 ， 安装 后 闪退 脚本 名字 没取 好 。   很 简单 ：   pyinstaller   _ entry _ point . py   一切顺利 ，   dist   文件夹 下 运行 目标程序 exe 运行 ， 都 OK ， 出 ， 请 钻研 官方 文档 。   安装程序 制作     advanceintaller     nsis   工具 制作 程序 安装文件 。   qt   designer   安装 pyside2 实际上 安装 qt   designer ：   pyside2 - designer . exe   设计 器 快速 设计 图形界面 ， 转成 python 代码 文件 ：   pyside2 - uic . exe   test . ui   >   test . py   输出 python 文件 基础 上 进一步 代码 修改 完善 工作 。 不 推荐 python 代码 中 加载 ui 文件 风格 ， 这会 项目 代码 一种 分裂 感 。   生成 代码 很 满意 ， 权 作 参考 。   配置文件 管理   QtCore 模块 里 提供   QSettings   类来 管理软件 配置文件 。   QSettings 构造函数   先 推荐 OrganizationName ApplicationName 设置 好 。   app   .   setOrganizationName   (   \" Wise \"   )   app   .   setApplicationName   (   \" wise \"   )   接下来 构建 一个 QSettings 对象 。   QSettings   (   parent   )   设置 好 组织 名 软件 名 ， 上 简单   QSettings ( )   创建 一个 配置文件 对象 ， 不带 参数 ， parent 取 默认值 ， format 取 默认值   QSettings . NativeFormat   ， scope 取 默认值   QSettings . UserScope   。 scope QSettings . SystemScope ， 软件 配置文件 权限 ， 先 略过 ， 默认 UserScope 。   fromat 取 默认 NativeFormat 软件 配置文件 安装 目录 ：   linux 系统 ， 例子 配置文件 ：   / home / wanze / . config / Wise / wise . conf   windows 系统 ， 例子 ：   HKEY _ CURRENT _ USER \\ Software \\ Wise \\ wise   windows 下 配置 放在 注册表 。   IniFormat   希望 配置文件 都 ini 形式 存储 ， 格式 初始化 配置文件 对象 ：   . settings   =   QSettings ( QSettings . IniFormat , QSettings . UserScope , \" Wise \" , \" wise \" )   配置文件 ：   / home / wanze / . config / Wise / wise . ini   。 linux 系统 情况 ， windows 系统 官方 文档 给出 ：   % APPDATA% \\ Wise \\ wise . ini   ，   % APPDATA%     C : \\ Documents     Settings \\ * User   Name * \\ Application   Data   调用   . settings . fileName ( )   查看 配置文件 对象 路径 所在 。   推荐 配置文件 mainwindow 实例 属性 如上 . settings ， 子 窗体 都 调用 配置文件 对象 。   ini 文件 存放 DIY   希望 ini 文件 放在 喜欢 地方 ， 配置文件 构造函数 第三种 形式 ：   QSettings ( \" wise . ini \" , QSettings . IniFormat )   第一个 参数 配置 文件名 ， 第二个 参数 format 。 上 相对路径 是从 软件 运行 时 文件夹 算 。   ini 文件 注意事项   ini 文件 大小写 不 敏感 ， 尽量避免 两个 变量名 相近 大小写 。     \\     /   。 windows 里   \\   会 转换成   /   ，   /   用来 配置文件 中 分组 关系 。   存值 读值   配置文件 对象 建立 很 存放 值 读 取值 。 存值   setValue   方法 ， 取值     方法 。 所示 ：   settings   .   setValue   (   \" editor / wrapMargin \"   ,   68   )   margin   =     .   settings   .     (   \" editor / wrapMargin \"   )   setValue 键 配置文件 对象 中 ， 更新 值 ， 修改 生效 ，   sync   方法 ， sync 方法 不 接受 参数 ， 同步 配置文件 中 更新 。     方法 第一个 参数 \" 键 \" ， 第二个 参数 选值 ， 没 找到 键 ， 将会 返回 值 。 写 上 ， 配置文件 不 ， 会 发生 读取 错误 。   方法 ：   :   接受 一个 \" 键 \" ， 字符串 对象 ， 返回 bool 值 ， 键 。   remove :   接受 一个 \" 键 \" ， 移除 该键 。   allkeys :   不 接受 参数 ， 返回 \" 键 \" 。   clear :   不 接受 参数 ， 清除 \" 键 \" 。   群组 管理   settings   .   setValue   (   \" editor / wrapMargin \"   ,   68   )   上 例子 所示   /   数据结构 中 分组 ， 很多 值 都 前缀 ， 同属 一组 ， beginGroup 方法 endGroup 方法 管理 。 所示 ：   settings   .   beginGroup   (   \" editor \"   )   settings   .   setValue   (   \" wrapMargin \"   ,   68   )   settings   .   engGroup   ( )   快捷键 Tab 键 管理   伙伴关系   QLabel setBuddy 方法 关联 输入 窗体 。 QLabel 一个 快捷键 ， 下 快捷键 ， 输入 焦点 就会 转到 QLabel 伙伴 输入 窗体 上 。   快捷键   QShortcut 类   QKeySequence   QKeySequence   类 快捷键 解决方案 。 引用   QKeySequence . Open   快捷键 Ctrl + O 。 可用 构造函数 所示 ：   QKeySequence   (   QKeySequence   .   Print   )   QKeySequence   (   tr   (   \" Ctrl + P \"   ) )   QKeySequence   (   tr   (   \" Ctrl + p \"   ) )   QKeySequence   (   Qt   .   CTRL   +   Qt   .   Key _ P   )   字母 按键 类似   Qt . Key _ W   形式 ， Shift 按键 Qt . SHIFT ， Meta 按键 Qt . META ， CTRL 按键   Qt . CTRL   ， ALT 按键   Qt . ALT   。",
            "tags":"gui",
            "url":"articles/pyside2-learning-notes.html"
        },
        {
            "title":"贪婪算法",
            "text":"总 暴力 穷举 算法 求解 ， 组合 数 情况 太多 ， ， 快速 算法 ， NP 。 试着 近似算法 快速 找到 一个 近似 解 。 贪婪 算法 一个 近似 解 。   贪婪 算法 某种 算法 ， 更 像是 写 算法 时 一种 思路 参考 。 解决问题 ， 分解 多个 步骤 ， 寻找 每步 局部 最优 解 ，   近似   目标 全局 最优 解 。 （ 贪婪 算法 不 保证 解 全局 最优 解 ， 解是 很 靠近 全局 最优 解了 。 ）   一个 ， 贪婪 算法 ， 贪婪 算法 解决 算法 。   背包   class   Knapsack   (   object   ) :   def   __ init __   (     ,   capacity   ,   items   =   None   ) :     .   capacity   =   capacity     .   items   =   [ ]     items     None     items     .   freespace   =     .   capacity   def   add _ item   (     ,   item   ) :       .   freespace   -   item   .   weight   > =   0   :     .   freespace   - =   item   .   weight     .   items   .   append   (   item   )   return   True     :   return   False   def   _ items _   (     ) :     =   0     item       .   items   :     + =   item   .     return     def   __ repr __   (     ) :   return   ' < Knapsack :   { 0 }   > '   .   format   (     .   items   )   class   Item   (   object   ) :   def   __ init __   (     ,     ,     ,   weight   ) :     .     =       .   weight   =   weight     .     =     def   __ repr __   (     ) :   return   ' < Item :   { 0 }   > '   .   format   (     .     )   def   __ eq __   (     ,     ) :       .     = =     .         .     = =     .         .   weight   = =     .   weight   :   return   True     :   return   False   def   greedy _ algorithm   (   knapsack   ,   items   ) :   \" \" \"   贪婪 法 求解   : return :   \" \" \"   items _ copy   =   items   .   copy   ( )   found   =   True     found   :   max _   =   0   choosed _ item   =   None     item     items _ copy   :     item   .     >   max _   :   choosed _ item   =   item   max _   =   choosed _ item   .       knapsack   .   add _ item   (   choosed _ item   ) :   found   =   True   items _ copy   .   remove   (   choosed _ item   )     :   found   =   False   return   knapsack   版本 还 扩展 出 函数 最小 重量 价值 / 重量 ， 理解 贪婪 算法 思想 即可 。   参考资料   算法 图解   Aditya   Bhargava   著",
            "tags":"algorithm",
            "url":"articles/tan-lan-suan-fa.html"
        },
        {
            "title":"选择排序",
            "text":"前言   选择 排序 基本思路 直观 ， 遍历 序列 ， 找到 最小 ， 放在 第一位 ， 剩下 找 最小 。 排序 算法 第二 梯队 ， 第一 梯队 指 快速 排序 变种 ， 冒泡排序 显得 故弄玄虚 。 特别 大型 序列 来说 ， 实际上 选择 排序 不错 算法 。   C语言 版本   void   select _ sort   (   int   array   [ ] ,   int   num   )   {   int   temp   ;     (   int   i   =   0   ;   i   <   num   ;   i   ++   )   {     (   int   j   =   i   +   1   ;   j   <   num   ;   j   ++   )   {     (   array   [   i   ]   >   array   [   j   ] )   {   temp   =   array   [   i   ] ;   array   [   i   ]   =   array   [   j   ] ;   array   [   j   ]   =   temp   ;   }   }   }   }   python 语言 版本   def   selection _ sort   (   seq   ) :   res   =   list   (   seq   .   copy   ( ) )     i     range   (   0   ,   len   (   res   ) ) :   minimum   =   i     j     range   (   i   +   1   ,   len   (   res   ) ) :     res   [   j   ]   <   res   [   minimum   ] :   minimum   =   j   res   [   i   ] ,   res   [   minimum   ]   =   res   [   minimum   ] ,   res   [   i   ]   return   res   过程 都 大同小异 ， 利用 两个 遍历 动作 A , B ， 再 。 python 语言 版本 额外 动作 是因为 希望 返回 序列 序列 ， 原 序列 必变 ， C语言 版本 原 数组 修改 。   算法 复杂度   选择 排序 计算 复杂度 粗略 估计 长度   \\ ( O ( n &# 94 ; 2 ) \\ )   ， 核心 占用 时间 动作 循环 套 循环 。   顺便 说 下 快速 排序 ， python 语言 版本 ， 10000 随机数 列表 排序 用时 ：   10000   随机数 列表 排序 ：   select _ sort     time   3.0919713973999023   quick   sort     time   0.024930477142333984   快速 排序 相比 选择 排序 确实 快 太 。     ( ! document . getElementById ( ' mathjaxscript _ pelican _#% @ # $ @ # ' ) )   {   var   align   =   \" center \" ,   indent   =   \" 0em \" ,   linebreak   =   \" false \" ;     ( false )   {   align   =   ( screen . width   <   768 )     \" left \"   :   align ;   indent   =   ( screen . width   <   768 )     \" 0em \"   :   indent ;   linebreak   =   ( screen . width   <   768 )     ' true '   :   linebreak ;   }   var   mathjaxscript   =   document . createElement ( ' script ' ) ;   mathjaxscript . id   =   ' mathjaxscript _ pelican _#% @ # $ @ # ' ;   mathjaxscript . type   =   ' text / javascript ' ;   mathjaxscript . src   =   ' / theme / js / mathjax / MathJax . js ' ;   mathjaxscript [ ( window . opera     \" innerHTML \"   :   \" text \" ) ]   =   \" MathJax . Hub . Config ( { \"   +   \"   config :   [ ' MMLorHTML . js ' ] , \"   +   \"   TeX :   {   extensions :   [ ' AMSmath . js ' , ' AMSsymbols . js ' , ' noErrors . js ' , ' noUndefined . js ' , ' mhchem . js ' ] ,   equationNumbers :   {   autoNumber :   ' AMS '   }   } , \"   +   \"   jax :   [ ' input / TeX ' , ' input / MathML ' , ' output / HTML - CSS ' ] , \"   +   \"   extensions :   [ ' tex2jax . js ' , ' mml2jax . js ' , ' MathMenu . js ' , ' MathZoom . js ' ] , \"   +   \"   displayAlign :   ' \" +   align   + \" ' , \"   +   \"   displayIndent :   ' \" +   indent   + \" ' , \"   +   \"   showMathMenu :   true , \"   +   \"   messageStyle :   ' normal ' , \"   +   \"   tex2jax :   {   \"   +   \"   inlineMath :   [   [ ' \\ \\ \\ \\ ( ' , ' \\ \\ \\ \\ ) ' ]   ] ,   \"   +   \"   displayMath :   [   [ ' $ $ ' , ' $ $ ' ]   ] , \"   +   \"   processEscapes :   true , \"   +   \"   preview :   ' TeX ' , \"   +   \"   } ,   \"   +   \"   ' HTML - CSS ' :   {   \"   +   \"   styles :   {   ' . MathJax _ Display ,   . MathJax   . mo ,   . MathJax   . mi ,   . MathJax   . mn ' :   { color :   ' inherit   !   important ' }   } , \"   +   \"   linebreaks :   {   automatic :   \" +   linebreak   + \" ,   width :   ' 90%   container '   } , \"   +   \"   } ,   \"   +   \" } ) ;   \"   +   \"   ( ' default '   ! = =   ' default ' )   { \"   +   \" MathJax . Hub . Register . StartupHook ( ' HTML - CSS   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax [ ' HTML - CSS ' ] . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" MathJax . Hub . Register . StartupHook ( ' SVG   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax . SVG . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" } \" ;   ( document . body   | |   document . getElementsByTagName ( ' head ' ) [ 0 ] ) . appendChild ( mathjaxscript ) ;   }",
            "tags":"algorithm",
            "url":"articles/xuan-ze-pai-xu.html"
        },
        {
            "title":"蒙特卡罗模拟",
            "text":"前言   蒙特卡罗 模拟 蒙特卡罗 一个 赌 运气 游戏 名字 ， 蒙特卡罗 模拟 计算机 发展 背景 下 ， 思想 越来越 。 简单 来说 试图 一个 转 成 某种 随机 过程 ， 计算机 模拟 随机 过程 解答 。 自然界 ， 本身 暗含 随机性 ， 过程 建立 基于 随机性 模型 很 直观 ， 还 ， 计算   \\ ( \\ pi \\ )   值 ， 随机性 很 相关 ， 随机 过程 ， 计算 出   \\ ( \\ pi \\ )   值 ， 典型 蒙特卡罗 模拟 ， 蒙特卡罗 方法 。   常见 随机 游走 ， 建模 一个 蒙特卡罗 模拟 过程 。   本文 讨论 随机 游走 随机 过程 ， 还会 涉及 线性 拟合 ， 最小 二 乘法 ， 线性回归 相关 绘图 内容 。   建模 代码 所示 ， 参考 MIT python 编程 导论 一书 ：   import   random     math   import   sqrt   class   Location   (   object   ) :   def   __ init __   (     ,   x   ,   y   ) :     .   x   =   x     .   y   =   y   def   move   (     ,   dx   ,   dy   ) :   return   Location   (     .   x   +   dx   ,     .   y   +   dy   )   def   _ x   (     ) :   return     .   x   def   _ y   (     ) :   return     .   y   def   distance   (     ,     ) :   ox   ,   oy   =     .   x   ,     .   y   distance   =   sqrt   ( (     .   x   -   ox   )   * *   2   +   (     .   y   -   oy   )   * *   2   )   return   distance   def   __ str __   (     ) :   return   f   ' < Location   (   { . x }   ,   { . y }   ) > '   class   Drunk   (   object   ) :   def   __ init __   (     ,     =   None   ) :     .     =     def   __ str __   (     ) :       .         None   :   return     .       :   return   ' Anonymous '   class   UsualDrunk   (   Drunk   ) :   def   _ step   (     ) :   step _ choices   =   [ (   0   ,   1   ) ,   (   0   ,   -   1   ) ,   (   1   ,   0   ) ,   (   -   1   ,   0   ) ]   return   random   .   choice   (   step _ choices   )   class   Field   (   object   ) :   def   __ init __   (     ) :     .   drunks   =   { }   def   add _ drunk   (     ,   drunk   ,   loc   ) :     isinstance   (   loc   ,   (   tuple   ,   list   ) ) :   assert   len   (   loc   )   = =   2   loc   =   Location   (   loc   [   0   ] ,   loc   [   1   ] )     drunk       .   drunks   :   raise   ValueError   (   ' Duplicate   drunk '   )     :     .   drunks   [   drunk   ]   =   loc   def   move _ drunk   (     ,   drunk   ) :     drunk         .   drunks   :   raise   ValueError   (   ' Drunk       field '   )   dx   ,   dy   =   drunk   .   _ step   ( )   current _ loc   =     .   drunks   [   drunk   ]     .   drunks   [   drunk   ]   =   current _ loc   .   move   (   dx   ,   dy   )   def   _ loc   (     ,   drunk   ) :     drunk         .   drunks   :   raise   ValueError   (   ' Drunk       field '   )   return     .   drunks   [   drunk   ]   def   walk   (   f   ,   d   ,   num _ steps   ) :   start   =   f   .   _ loc   (   d   )     s     range   (   num _ steps   ) :   f   .   move _ drunk   (   d   )   return   start   .   distance   (   f   .   _ loc   (   d   ) )   def   bulk _ walk   (   num _ steps   ,   num _ bulk   ,   dClass   ) :   \" \" \"   : param   num _ steps :   随机 行走 步   : param   num _ bulk :   批次 次 实验   : param   dClass :   醉汉 类型   : return :   distances   批次 每次 开图 总共 行走 距离 列表   \" \" \"   drunk   =   dClass   ( )   origin   =   Location   (   0   ,   0   )   distances   =   [ ]     i     range   (   num _ bulk   ) :   f   =   Field   ( )   f   .   add _ drunk   (   drunk   ,   origin   )   distances   .   append   (   round   (   walk   (   f   ,   drunk   ,   num _ steps   ) ,   1   ) )   return   distances   def   drunk _ test   (   num _ steps _ batch   ,   num _ bulk   ,   dClass   ) :   \" \" \"   : param   num _ steps _ batch :   随机 行走 步 填入 批次   : param   num _ bulk :   批次 次 实验   : param   dClass :   醉汉 类型   : return :   \" \" \"   _ distance _ list   =   [ ]     num _ steps     num _ steps _ batch   :   distances   =   bulk _ walk   (   num _ steps   ,   num _ bulk   ,   dClass   )   print   (   f   '   { dClass .__ __ }   random   walk     { num _ steps }   steps '   )   _ distance   =   round   (   sum   (   distances   )   /   len   (   distances   ) ,   4   )   _ distance _ list   .   append   (   _ distance   )   print   (   f   ' Mean   =   { _ distance }   '   )   print   (   f   ' Max   =   { max ( distances ) }   Min   =   { min ( distances ) } '   )   return   _ distance _ list     __ __   = =   ' __ main __ '   :   num _ steps _ batch   =   list   (   range   (   100   ,   3000   ,   100   ) )   data   =   drunk _ test   (   num _ steps _ batch   ,   100   ,   UsualDrunk   )   代码 都 很 简单 直观 代码 。 定义   绘图 函数 ：   def   polyfit _ plot   (   ax   ,   x   ,   y   ,   deg   =   1   ,   xlabel   =   ' '   ,   ylabel   =   ' '   ,   title   =   ' '   ,   * *   kwargs   ) :   \" \" \"   多项式 拟合 绘图   : return :   \" \" \"     xlabel   :   ax   .   set _ xlabel   (   xlabel   )     ylabel   :   ax   .   set _ ylabel   (   ylabel   )     title   :   ax   .   set _ title   (   title   )   predict _ func   =   np   .   poly1d   (   np   .   polyfit   (   x   ,   y   ,   deg   ) )     =   ax   .   plot   (   x   ,   y   ,   ' . '   ,   x   ,   predict _ func   (   x   ) ,   ' - '   ,   * *   kwargs   )   return     绘制 简单 线性 拟合 线 ， 想到 很多 东西 ， 热门 机器学习 ， 随机 过程 模拟 ， 统计 过程 分析 ， 作图 演示 概念 都 密不可分 。   比如说 简单 一元函数 拟合 ， numpy 提供 polyfit 函数 ， 本身 支持 ， 做 多项式 曲线拟合 。 拟合 过程 方法   最小 二 乘法   ， 其内 构建 一个   函数 ： 函数 值 最小 ：   $ $   \\ sum   ( y   -   y _ { predict } ) &# 94 ; 2   $ $   函数 还 误差 函数 。 机器学习 平方 损失 函数 ， 机器学习 会 接触 更 损失 函数 ， 梯度 下降 算法 扮演 角色 等同于 最小 二 乘法 ， 目标 损失 函数 值 最小 ， 参数 。 参数 扔进 多项式 ， 成 模型 。   实际上 线性回归   多项式 回归 过程 差不多 ， 还 提供 predict 操作 ， 思路 换成 机器学习 那种 建模 说法 。   机器学习 中 线性回归 会 引入 更 数据 更 特征 变量 ， 建模 会 ， 大体 过程 类似 谈及 。   说 一句 题外话 ， 很多 人 深度学习 都 抱 一种 统计学 轻蔑 态度 ， ， 正 量变 质变 ， 东西 做 原本 简单 回归 大相径庭 ， 不 单单 指 厉害 任意 曲线 拟合 能力 ， 更 质变 ， 学习 角度 慢慢 去 理解 没 。   随机 游走 深究 ， 解决 计算   \\ ( \\ pi \\ )   之外 ， 再 更 概率 统计 知识 理解 之外 ， 再 介绍 更 函数 拟合 绘图 ， 差不多 顺理成章 转 机器学习 那块 去 ， 去 建立 更 机器学习 模型 ， 解决 更 。 或者说 更 牛 掰 ， 模拟 计算 世界 。     ( ! document . getElementById ( ' mathjaxscript _ pelican _#% @ # $ @ # ' ) )   {   var   align   =   \" center \" ,   indent   =   \" 0em \" ,   linebreak   =   \" false \" ;     ( false )   {   align   =   ( screen . width   <   768 )     \" left \"   :   align ;   indent   =   ( screen . width   <   768 )     \" 0em \"   :   indent ;   linebreak   =   ( screen . width   <   768 )     ' true '   :   linebreak ;   }   var   mathjaxscript   =   document . createElement ( ' script ' ) ;   mathjaxscript . id   =   ' mathjaxscript _ pelican _#% @ # $ @ # ' ;   mathjaxscript . type   =   ' text / javascript ' ;   mathjaxscript . src   =   ' / theme / js / mathjax / MathJax . js ' ;   mathjaxscript [ ( window . opera     \" innerHTML \"   :   \" text \" ) ]   =   \" MathJax . Hub . Config ( { \"   +   \"   config :   [ ' MMLorHTML . js ' ] , \"   +   \"   TeX :   {   extensions :   [ ' AMSmath . js ' , ' AMSsymbols . js ' , ' noErrors . js ' , ' noUndefined . js ' , ' mhchem . js ' ] ,   equationNumbers :   {   autoNumber :   ' AMS '   }   } , \"   +   \"   jax :   [ ' input / TeX ' , ' input / MathML ' , ' output / HTML - CSS ' ] , \"   +   \"   extensions :   [ ' tex2jax . js ' , ' mml2jax . js ' , ' MathMenu . js ' , ' MathZoom . js ' ] , \"   +   \"   displayAlign :   ' \" +   align   + \" ' , \"   +   \"   displayIndent :   ' \" +   indent   + \" ' , \"   +   \"   showMathMenu :   true , \"   +   \"   messageStyle :   ' normal ' , \"   +   \"   tex2jax :   {   \"   +   \"   inlineMath :   [   [ ' \\ \\ \\ \\ ( ' , ' \\ \\ \\ \\ ) ' ]   ] ,   \"   +   \"   displayMath :   [   [ ' $ $ ' , ' $ $ ' ]   ] , \"   +   \"   processEscapes :   true , \"   +   \"   preview :   ' TeX ' , \"   +   \"   } ,   \"   +   \"   ' HTML - CSS ' :   {   \"   +   \"   styles :   {   ' . MathJax _ Display ,   . MathJax   . mo ,   . MathJax   . mi ,   . MathJax   . mn ' :   { color :   ' inherit   !   important ' }   } , \"   +   \"   linebreaks :   {   automatic :   \" +   linebreak   + \" ,   width :   ' 90%   container '   } , \"   +   \"   } ,   \"   +   \" } ) ;   \"   +   \"   ( ' default '   ! = =   ' default ' )   { \"   +   \" MathJax . Hub . Register . StartupHook ( ' HTML - CSS   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax [ ' HTML - CSS ' ] . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" MathJax . Hub . Register . StartupHook ( ' SVG   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax . SVG . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" } \" ;   ( document . body   | |   document . getElementsByTagName ( ' head ' ) [ 0 ] ) . appendChild ( mathjaxscript ) ;   }",
            "tags":"algorithm",
            "url":"articles/meng-te-qia-luo-mo-ni.html"
        },
        {
            "title":"算法复杂度",
            "text":"讨论 算法 复杂度 关注 算法 时间 复杂度 ， 真到 思考 算法 时间 复杂度 ， 目标 算法 应对 一个 输入 规模 n 很大 情况 。 常说 大 O 表示法 细枝末节 东西 都 省略 ， 输入 规模 n 很大 ， 还 关心 那多 几步 意义 。   更 专注 算法 中 循环 ， 循环 ， 循环 次数 输入 规模 无关 ， 记为 O ( 1 )   常数 运行 时间 。   循环 ：     i     range   (   n   ) :   print   (   i   )   循环 输入 规模 n 相关 ， 记 作   O ( n )   线性 运行 时间 。   假设 一个 算法 提到 O ( 1 )   ， O ( n )   ， O ( 1 )   项 去掉 ：   运行 时间 一个 多项式 ， 保留 增长速度 最快 项 ， 去掉 各项   提到 算法 复杂度 简单 记   O ( n )   。   假设 有个 算法 ， 两个 循环 ：     i     range   (   n   ) :   print   (   i   )     i     range   (   n   ) :   print   (   i   )   道理 算法 复杂度   2n   ， 大 O 表示法 规则 ：   项是 一个 乘积 ， 去掉 常数   算法 复杂度   O ( 2n )   简化   O ( n )   ， 算法 线性 运行 时间 。   两个 循环 嵌套 情况 ：     i     range   (   n   ) :     j     range   (   n   ) :   print   (   i   ,   j   )   运行 n * n 次 ， 算法 复杂度 记   \\ ( O ( n &# 94 ; 2 ) \\ )   ， 二次 多项式 运行 时间 。 会 情况 ， 第二层 循环 会多 运行 几次 少 运行 几次 ， 都 细枝末节 ， 说 第一条 规则 ： 展开 加减 增长速度 较慢 项 去除 ， 只 剩下   \\ ( O ( n &# 94 ; 2 ) \\ )   。   递归 情况   阶乘 函数 为例 ， 递归函数 计算 复杂度 递归函数 展开 ：   $ $   fac ( n )   *   fac ( n - 1 )   ...   fac ( 1 )   $ $   展开 序列 长度 递归 次数 计算 复杂度   O ( n )   。   对数 复杂度   考量 对数 复杂度 不 关心 对数 底数 ， 提及 第二条 规则 乘积 常数 项 忽略 。     n   >   0   :   print   (   1   )   n   =   n   / /   10   例子 读者 看 循环 次数 输入 规模 n 数次 ，   O ( logn )   。   二分 查找 算法 计算 复杂度 对数 复杂度 ， 大致 2 底数 压缩 查找 空间 。   对数 线性 复杂度   O ( nlog ( n ) )   快速 排序 算法 计算 复杂度 对数 线性 复杂度 。   def   quick _ sort   (   seq   ) :   \" \" \"   10000   随机数 列表 排序 ：   select _ sort     time   3.0919713973999023   quick   sort     time   0.024930477142333984   : param   seq :   : return :   \" \" \"     len   (   seq   )   <   2   :   return   seq     :   pivot   =   seq   [   0   ]   _ part   =   [   i     i     seq   [   1   : ]     i   < =   pivot   ]   greater _ part   =   [   i     i     seq   [   1   : ]     i   >   pivot   ]   return   quick _ sort   (   _ part   )   +   [   pivot   ]   +   quick _ sort   (   greater _ part   )   def   selection _ sort   (   seq   ) :   \" \" \"   两种 写法 速度 都 差不多 ， 优先 写 直白 点 。   : param   seq :   : return :   \" \" \"   def   find _ smallest _ index   (   seq   ) :   smallest   =   seq   [   0   ]   smallest _ index   =   0     i     range   (   1   ,   len   (   seq   ) ) :   target   =   seq   [   i   ]     target   <   smallest   :   smallest   =   target   smallest _ index   =   i   return   smallest _ index   res   =   [ ]   seq _ copy   =   seq   .   copy   ( )     i     range   (   0   ,   len   (   seq   ) ) :   smallest _ index   =   find _ smallest _ index   (   seq _ copy   )   res   .   append   (   seq _ copy   .   pop   (   smallest _ index   ) )   return   res   选择 排序 计算 复杂度 粗略 估计 长度   \\ ( O ( n &# 94 ; 2 ) \\ )   ， 直观 算法 有个 循环 套 循环 。   选择 排序 快速 排序 说 直观 计算 复杂度 等级 ， 运算 效率 提升 。 测试 ：   10000   随机数 列表 排序 ：   select _ sort     time   3.0919713973999023   quick   sort     time   0.024930477142333984   ， 速度 提升 100 倍 。   快速 排序 计算 复杂度 估算 两 ：   小 大部分 合计 约 n 判断 操作   递归 层级 展开 ， 大小 2 类似 二分 查找 分割 ， 一层 8 4 ， 递归 层级   \\ ( log _ 2n \\ )   相乘 快速 排序 计算 复杂度   \\ ( O ( n \\ log ( n ) ) \\ )   。   python 语言 排序 算法   蒂姆 · 彼得斯 不满 python 排序 算法 （ 估计 类似 快速 排序 ） ， 2002 年 发明 timsort 算法 ， 基本思路 类似 快速 排序 ， 利用 数据 集 数据 有序 情况 ， 优化 。   python list . sort sorted 函数 timsort 算法 。   字典   字典 查找 key 计算 复杂度 O ( 1 ) ， 字典 长度 无关 ， 内部 散 列表 算法 。   python 字典 基于 红黑树 二叉 搜索 树 ， 理解 错 。 python 中 字典 基于 hash   table   散 列表 ，   查   插入   删除   计算 复杂度 都   O ( 1 )   ， 引入 一个 散列 函数 ， 一个 大规模 输入 空间 映射 一个 小 输出 空间 ， 数量 key 转换 数量 较少 整数 索引 。     ( ! document . getElementById ( ' mathjaxscript _ pelican _#% @ # $ @ # ' ) )   {   var   align   =   \" center \" ,   indent   =   \" 0em \" ,   linebreak   =   \" false \" ;     ( false )   {   align   =   ( screen . width   <   768 )     \" left \"   :   align ;   indent   =   ( screen . width   <   768 )     \" 0em \"   :   indent ;   linebreak   =   ( screen . width   <   768 )     ' true '   :   linebreak ;   }   var   mathjaxscript   =   document . createElement ( ' script ' ) ;   mathjaxscript . id   =   ' mathjaxscript _ pelican _#% @ # $ @ # ' ;   mathjaxscript . type   =   ' text / javascript ' ;   mathjaxscript . src   =   ' / theme / js / mathjax / MathJax . js ' ;   mathjaxscript [ ( window . opera     \" innerHTML \"   :   \" text \" ) ]   =   \" MathJax . Hub . Config ( { \"   +   \"   config :   [ ' MMLorHTML . js ' ] , \"   +   \"   TeX :   {   extensions :   [ ' AMSmath . js ' , ' AMSsymbols . js ' , ' noErrors . js ' , ' noUndefined . js ' , ' mhchem . js ' ] ,   equationNumbers :   {   autoNumber :   ' AMS '   }   } , \"   +   \"   jax :   [ ' input / TeX ' , ' input / MathML ' , ' output / HTML - CSS ' ] , \"   +   \"   extensions :   [ ' tex2jax . js ' , ' mml2jax . js ' , ' MathMenu . js ' , ' MathZoom . js ' ] , \"   +   \"   displayAlign :   ' \" +   align   + \" ' , \"   +   \"   displayIndent :   ' \" +   indent   + \" ' , \"   +   \"   showMathMenu :   true , \"   +   \"   messageStyle :   ' normal ' , \"   +   \"   tex2jax :   {   \"   +   \"   inlineMath :   [   [ ' \\ \\ \\ \\ ( ' , ' \\ \\ \\ \\ ) ' ]   ] ,   \"   +   \"   displayMath :   [   [ ' $ $ ' , ' $ $ ' ]   ] , \"   +   \"   processEscapes :   true , \"   +   \"   preview :   ' TeX ' , \"   +   \"   } ,   \"   +   \"   ' HTML - CSS ' :   {   \"   +   \"   styles :   {   ' . MathJax _ Display ,   . MathJax   . mo ,   . MathJax   . mi ,   . MathJax   . mn ' :   { color :   ' inherit   !   important ' }   } , \"   +   \"   linebreaks :   {   automatic :   \" +   linebreak   + \" ,   width :   ' 90%   container '   } , \"   +   \"   } ,   \"   +   \" } ) ;   \"   +   \"   ( ' default '   ! = =   ' default ' )   { \"   +   \" MathJax . Hub . Register . StartupHook ( ' HTML - CSS   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax [ ' HTML - CSS ' ] . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" MathJax . Hub . Register . StartupHook ( ' SVG   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax . SVG . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" } \" ;   ( document . body   | |   document . getElementsByTagName ( ' head ' ) [ 0 ] ) . appendChild ( mathjaxscript ) ;   }",
            "tags":"algorithm",
            "url":"articles/suan-fa-fu-za-du.html"
        },
        {
            "title":"动态规划",
            "text":"动态规划 算法 感觉 名字 取 很 唬人 ， 类似 贪婪 算法 ， 采用 分治 思想 ， 大 分解 小 。 贪婪 算法 小 求解 局部 最优 即可 ， 动态规划 朴素 解法 ， 试着 尝试 组合 情况 ， 采用 记忆 策略 ， 类似 子 一并 解决 。 动态规划 算法 名字 感人 ， 第一 ， 子 某种 类似性 ； 第二 ， 一种 记忆 策略 。   算法 图解 动态规划 算法 采用 一种 网格 思路 ， 最长 公共 子 序列 很 适合 ， MIT python 编程 导论 解决 背包 提出 一种 决策树 思路 。 思考 很 空间 排列组合 特性 ， 采用 类似 解决 最长 公共 子 序列 网格 思路 ； 很 时间 决策 展开 性 ， 选用 决策树 。   背包   构建 决策树 ：   class   BinaryDecisionTree   (   object   ) :   \" \" \"   二叉 决策树   决策函数   data   decisions   =   [ ( ' a ' , True ) ,   ( ' b ' , False ) ]   决策树 中 节点 决策树 中 位置   \" \" \"   def   __ init __   (     ,   data   =   None   ,   decisions   =   None   ,   parent   =   None   ) :     .   left   =   None     .     =   None     .   data   =   data     decisions     None   :   decisions   =   [ ]     .   decisions   =   decisions     .   parent   =   parent   def   __ repr __   (     ) :   return   ' < BinaryDecisionTree   { 0 }   { 1 }   > '   .   format   (     .   decisions   ,     .   data   )   def   append   (     ,   child _ data   ,   _ decision   ) :   \" \" \"   节点 附加   : param   child _ data :   : param   _ decision :   : return :   \" \" \"   bool _ key   ,   bool _   =   _ decision     bool _   :   decisions   =     .   decisions   +   [   _ decision   ]     .   left   =   BinaryDecisionTree   (   child _ data   ,   decisions   =   decisions   ,   parent   =     )   return     .   left     :   decisions   =     .   decisions   +   [   _ decision   ]     .     =   BinaryDecisionTree   (   child _ data   ,   decisions   =   decisions   ,   parent   =     )   return     .     def   insert   (     ,   child _ data   ,   decisions   ,   auto _ create   =   False   ) :   \" \" \"   插 节点 上   : param   bool _ key :   : param   child _ data :   : return :   \" \" \"     len   (   decisions   )   = =   1   :   target   =     .   find   ( )   _ decision   =   decisions     :   target   =     .   find   (   decisions   [ :   -   1   ] ,   auto _ create   =   auto _ create   )   _ decision   =   decisions   [   -   1   ]   _ node   =   target   .   append   (   child _ data   ,   _ decision   =   _ decision   )   return   _ node   def   find   (     ,   decisions   =   None   ,   auto _ create   =   False   ) :     decisions     None   :   assert     .   parent     None   return     res   =   None     target       .   introspection   ( ) :     target   .   decisions   = =   decisions   :   res   =   target   return   res     res     None   :     auto _ create   :     i     range   (   1   ,   len   (   decisions   )   +   1   ) :   decisions _ small   =   decisions   [ :   i   ]         .   find   (   decisions _ small   ) :     .   insert   (   child _ data   =   None   ,   decisions   =   decisions _ small   )     :   return   None   def   set _ data   (     ,   data   ) :     .   data   =   data   def   introspection   (     ) :   stack   =   [ ]   node   =       stack     node   :     node   :   stack   .   append   (   node   )   node   =   node   .   left     :   node   =   stack   .   pop   ( )   yield   node   node   =   node   .     return   stack   def   children _ count   (     ) :   \" \" \" Return     number     children   @ returns   number     children :   0 ,   1 ,   2   \" \" \"   cnt   =   0       .   left   :   cnt   + =   1       .     :   cnt   + =   1   return   cnt   发现 很 好 动态规划 ， 开销 节省 构建 决策树 ， 只好 一种 类似 贪婪 算法 东西 ， 尽量 节省 node 生成 。   动态规划 算法 算不上 很 神奇 东西 ， 到此为止 。   item _ a   =   Item   (   ' a '   ,   6   ,   3   )   item _ b   =   Item   (   ' b '   ,   7   ,   3   )   item _ c   =   Item   (   ' c '   ,   8   ,   2   )   item _ d   =   Item   (   ' d '   ,   9   ,   5   )   items   =   [   item _ a   ,   item _ b   ,   item _ c   ,   item _ d   ]   import   heapq   class   PriorityQueue   :   def   __ init __   (     ) :     .   _ queue   =   [ ]     .   _ index   =   0   def   push   (     ,   item   ,   priority   ) :   heapq   .   heappush   (     .   _ queue   ,   (   -   priority   ,     .   _ index   ,   item   ) )     .   _ index   + =   1   def   pop   (     ) :   return   heapq   .   heappop   (     .   _ queue   ) [   -   1   ]   def   dynamic _ programming2   (   items   ,   max _ node   =   None   ) :   \" \" \"   利用 决策树 动态规划   引入 优先级 队列 减少 决策树 构建 成本   : param   knapsack :   : param   items :   : return :   \" \" \"   tree   =   BinaryDecisionTree   (   data   =   {   ' pre '   :   [ ] ,   ' post '   :   items   ,   ' '   :   0   ,   ' freespace '   :   5   } )   q   =   PriorityQueue   ( )   q   .   push   (   tree   ,   0   )   node _ num   =   1     q   .   _ queue   :     max _ node     node _ num   >   max _ node   :   break   target   =   q   .   pop   ( )   import   copy   data   =   copy   .   deepcopy   (   target   .   data   )   data _ pre   =   data   [   ' pre '   ]   data _ post   =   data   [   ' post '   ]   data _   =   data   [   ' '   ]   data _ freespace   =   data   [   ' freespace '   ]     :   item   =   data _ post   .   pop   (   0   )   data   =   {   ' pre '   :   data _ pre   ,   ' post '   :   data _ post   ,   ' '   :   data _   ,   ' freespace '   :   data _ freespace   }   node   =   target   .   append   (   data   ,   _ decision   =   (   item   .     ,   False   ) )   node _ num   + =   1   q   .   push   (   node   ,   data _   )   data _ pre   =   data _ pre   +   [   item   ]   data _   + =   item   .     data _ freespace   - =   item   .   weight   data   =   {   ' pre '   :   data _ pre   ,   ' post '   :   data _ post   ,   ' '   :   data _   ,   ' freespace '   :   data _ freespace   }     data _ freespace   <   0   :   pass     :   node   =   target   .   append   (   data   ,   _ decision   =   (   item   .     ,   True   ) )   node _ num   + =   1   q   .   push   (   node   ,   data _   )     IndexError   :   pass   max _   =   0   target _ node   =   None     node     tree   .   introspection   ( ) :     =   node   .   data   [   ' '   ]       >   max _   :   target _ node   =   node   max _   =     return   target _ node   ​   最长 公共 子 序列   \" \" \"   最长 公共 子 序列 区别 递增 。   \" \" \"   import   pandas     pd   def   longest _ increasing _ subsequence   (   seq _   ,   seq _   ) :   df   =   pd   .   DataFrame   (   index   =   [   item     item     seq _   ] ,   columns   =   [   item     item     seq _   ] )     i   ,   c1     enumerate   (   seq _   ) :     j   ,   c2     enumerate   (   seq _   ) :     c1   = =   c2   :     (   i   -   1   <   0   )     (   j   -   1   <   0   ) :   df   .   iloc   [   i   ] [   j   ]   =   1     :   df   .   iloc   [   i   ] [   j   ]   =   df   .   iloc   [   i   -   1   ] [   j   -   1   ]   +   1     :   df   .   iloc   [   i   ] [   j   ]   =   0   print   (   df   )   longest _ increasing _ subsequence   (   ' fish '   ,   ' hish '   )   longest _ increasing _ subsequence   (   ' hish '   ,   ' vista '   )   \" \" \"   动态规划 法解 最长 公共 子 序列 ， 经典 案例 ， 很 实用 。   子 序列 不 递增 ， 更 度   \" \" \"   import   pandas     pd   def   longest _ common _ subsequence   (   seq _   ,   seq _   ) :   df   =   pd   .   DataFrame   (   index   =   [   item     item     seq _   ] ,   columns   =   [   item     item     seq _   ] )   df   =   df   .   fillna   (   0   )     i   ,   c1     enumerate   (   seq _   ) :     j   ,   c2     enumerate   (   seq _   ) :     c1   = =   c2   :     (   i   -   1   <   0   )     (   j   -   1   <   0   ) :   df   .   iloc   [   i   ] [   j   ]   =   1     :   df   .   iloc   [   i   ] [   j   ]   =   df   .   iloc   [   i   -   1   ] [   j   -   1   ]   +   1     :     i   <   1     j   <   1   :   df   .   iloc   [   i   ] [   j   ]   =   0   elif   i   <   1   :   df   .   iloc   [   i   ] [   j   ]   =   max   (   0   ,   df   .   iloc   [   i   ] [   j   -   1   ] )   elif   j   <   1   :   df   .   iloc   [   i   ] [   j   ]   =   max   (   df   .   iloc   [   i   -   1   ] [   j   ] ,   0   )     :   df   .   iloc   [   i   ] [   j   ]   =   max   (   df   .   iloc   [   i   -   1   ] [   j   ] ,   df   .   iloc   [   i   ] [   j   -   1   ] )   print   (   df   )   longest _ common _ subsequence   (   ' fort '   ,   ' fosh '   )   longest _ common _ subsequence   (   ' fish '   ,   ' fosh '   )",
            "tags":"algorithm",
            "url":"articles/dong-tai-gui-hua.html"
        },
        {
            "title":"二叉搜索树",
            "text":"二叉 搜索 树   本文 很大 程度 上 参考   algorithms   项目 ， 谢谢 作者 。   二叉 搜索 树 （ Binary   Search   Tree ） 大概 图 所示 东西 :   一个 节点 都 至多 两个 子 节点 ， 节点 都 三个 条件   左 节点 值 小于 父 节点   右 节点 值 大于 父 节点   节点 值 均 不   二叉 搜索 树 插入 复杂度   O ( log   n )   ， 查找 复杂度 情况   O ( log   n )   ， 最坏 情况   O ( n )   。   图片 二叉树 ， 假设 插入 19 ， 8 ， 大 ， 右 ， 再 10 ， 大则 右 ， 再 14 ， 大则 右 ， 空 插入 。   假设 查找 19 ， 过程 大体 类似 8 ， 大则 右 ， 再 10 ， 大则 右 ， 再 14 ， 大则 右 ， 找到 。 查找 过程 ， 涉及 判断 操作 ， 假设 元素 两边 分 ， 树中 一半 元素 都 跳过去 。 利用 数据结构 加速 查找 存储 数据 好处 显而易见 。   二叉 搜索 树 python   python 二叉树 参考   参考资料 2   ， 有个 伙计 评论 说 不 合并 一个 类 ， 提议 实际上 好 。 这样的话 data ， 节点 存储 数据 ， 都 ， 设计 ， data 大小 采用   hash ( object )   调用   __ hash __   方法 ， 判断 采用   = =   ， 调用   __ eq __   方法 。   结构 插入 查找 操作   值得一提的是 key 大小 判断 采用   hash ( data )   形式 ， 键 唯一 id 一种 方法 ， 这是 。 data 不 sequence 。 大小 ， 不 某种 实际意义 。 :   > > >   hash ( 11 ) >   hash ( \" 22 \" )   True   含义 某种 大小 ， 确保 对象 同一个 类 ， 更 抽象 讨论 ， 同一个 概念 同一个 聚合 类 。   ###   ref   http : / / www . laurentluce . / posts / binary - search - tree - library - - python /   class   BSTree   (   object   ) :   ' ' '   hash ( data )   ,   notice     data         sequence ' ' '   def   __ init __   (     ,   data   =   None   ,   parent   =   None   ) :     .   left   =   None     .     =   None     .   data   =   data     .   parent   =   parent   def   __ repr __   (     ) :   return   ' < BSTree   { }   > '   .   format   (     .   data   )   def   insert   (     ,   data   ) :   ' ' ' insert   data ' ' '     hash   (   data   )   <   hash   (     .   data   ) :       .   left     None   :     .   left   =   BSTree   (   data   ,   parent   =     )     :     .   left   .   insert   (   data   )   elif   hash   (   data   )   >   hash   (     .   data   ) :       .       None   :     .     =   BSTree   (   data   ,   parent   =     )     :     .     .   insert   (   data   )     :     .   data   =   data   def   find   (     ,   data   ) :     hash   (   data   )   <   hash   (     .   data   ) :       .   left     None   :   raise   KeyError     :   return     .   left   .   find   (   data   )   elif   hash   (   data   )   >   hash   (     .   data   ) :       .       None   :   raise   KeyError     :   return     .     .   find   (   data   )     :   return     绘制 图形   很感兴趣 ， 先弄 。 很大 程度 上 依赖 一种 遍历 树 机制 。   def   introspection   (     ) :   ' ' ' walk   a   round ,       information ' ' '   stack   =   [ ]   node   =       stack     node   :     node   :   stack   .   append   (   node   )   node   =   node   .   left     :   node   =   stack   .   pop   ( )   yield   node   node   =   node   .     函数 看 参考资料 ， 稍微 做 改动 ， 返回 data ， node 对象 ， 后续 很多 函数 支持 调用 。 堆 遍历 老实 说 估计 想 不 ， 看 跟着 程序 走 发现 确实 遍历 树 ， 很 巧妙 。   绘图 函数 所示 :   def   _ ymove   (     ) :       .   parent     None   :   return   0   return     .   parent   .   _ ymove   ( )   +   1   def   _ xmove   (     ) :       .   parent     None   :   return   0       = =     .   parent   .   left   :   return     .   parent   .   _ xmove   ( )   -   1   elif     = =     .   parent   .     :   return     .   parent   .   _ xmove   ( )   +   1   def   draw   (     ) :     PIL   import   Image   ,   ImageDraw   ,   ImageFont   font   =   ImageFont   .   truetype   (   \" arial . ttf \"   ,   15   )   w   =   800   h   =   600   image   =   Image   .     (   ' RGB '   , (   w   ,   h   ) , (   255   ,   255   ,   255   ) )   draw   =   ImageDraw   .   Draw   (   image   )   _ x   =   None   _ y   =   None     node       .   introspection   ( ) :   node _ point _ x   =   node   .   _ xmove   ( )   *   50   +   400   node _ point _ y   =   node   .   _ ymove   ( )   *   50   +   50     node   .   parent       None   :   node _ point _ x _ parent   =   node   .   parent   .   _ xmove   ( )   *   50   +   400   node _ point _ y _ parent   =   node   .   parent   .   _ ymove   ( )   *   50   +   50   draw   .   line   ( (   node _ point _ x _ parent   +   15   ,   node _ point _ y _ parent   ,   node _ point _ x   +   15   ,   node _ point _ y   ) ,   fill   =   (   0   ,   0   ,   0   ) )   # del   draw   draw   .   ellipse   ( [ (   node _ point _ x   ,   node _ point _ y   ) , (   node _ point _ x   +   30   ,   node _ point _ y   +   30   ) ] ,   outline   =   (   0   ,   0   ,   0   ) )   draw   .   text   ( (   node _ point _ x   +   15   ,   node _ point _ y   ) ,   str   (   node   .   data   ) ,   fill   =   (   0   ,   0   ,   0   ) ,   font   =   font   )   _ x   =   node _ point _ x   _ y   =   node _ point _ y   image   .   show   ( )   利用 pillow 一个 很 粗糙 绘图 过程 ， 这块 还 不 熟悉 ， 绘图 细节 优化 还 很 值得 商榷 。   删除 操作   删除 操作 稍微 点 ，   def   children _ count   (     ) :   \" \" \" Return     number     children   @ returns   number     children :   0 ,   1 ,   2   \" \" \"   cnt   =   0       .   left   :   cnt   + =   1       .     :   cnt   + =   1   return   cnt   def   delete   (     ,   data   ) :   \" \" \" Delete   node     data   @ param   data   node ' s   content     delete   \" \" \"   #     node     data   node   ,   parent   =     .   lookup   (   data   )     node       None   :   children _ count   =   node   .   children _ count   ( )     children _ count   = =   0   :   #     node       children ,     remove       parent   :     parent   .   left     node   :   parent   .   left   =   None     :   parent   .     =   None     :     .   data   =   None   elif   children _ count   = =   1   :   #     node     1   child   #   replace   node       child     node   .   left   :   n   =   node   .   left     :   n   =   node   .       parent   :     parent   .   left     node   :   parent   .   left   =   n     :   parent   .     =   n     :     .   left   =   n   .   left     .     =   n   .       .   data   =   n   .   data     :   #     node     2   children   #   find     successor   parent   =   node   successor   =   node   .       successor   .   left   :   parent   =   successor   successor   =   successor   .   left   #   replace   node   data       successor   data   node   .   data   =   successor   .   data   #   fix   successor ' s   parent   node   child     parent   .   left   = =   successor   :   parent   .   left   =   successor   .       :   parent   .     =   successor   .     二叉树   def   compare _ trees   (     ,   node   ) :   \" \" \" Compare   2   trees   @ param   node   tree     compare   @ returns   True       tree   passed     identical       tree   \" \" \"     node     None   :   return   False       .   data   ! =   node   .   data   :   return   False   res   =   True       .   left     None   :     node   .   left   :   return   False     :   res   =     .   left   .   compare _ trees   (   node   .   left   )     res     False   :   return   False       .       None   :     node   .     :   return   False     :   res   =     .     .   compare _ trees   (   node   .     )   return   res   小节 参考资料   https : / / github . / qiwsir / algorithm / blob / master / binary _ tree . md   http : / / www . laurentluce . / posts / binary - search - tree - library - - python /   https : / / zh . wikipedia . org / wiki / % E4% BA% 8C% E5% 85% 83% E6% 90% 9C% E5% B0% 8B% E6% A8% B9",
            "tags":"algorithm",
            "url":"articles/er-cha-sou-suo-shu.html"
        },
        {
            "title":"有向无环图",
            "text":"图论 ， 听 挺 高大 上 ， ， 数学家 画 圈圈 画线 线 还 很 乐趣 地方 。   线 方向 ， 无向 图 ， 线有 方向 ， 有向图 。   有向图 中 ， 任意 一个 节点 流向 流着 流着 都 流不回 ， 说 图为   无 环图   ， 英文 缩写   DAG ， （ directied   acyclic   graph ） 。   东西 ？   最先 接触   DAG   术语 ， 找 工作 流 软件 ， 一种 工作 流 通用 方法   DAG   。 ？ 假设 工作 流中 节点 员工 ， workflow 走 ， 闭环 ， 无限 循环 流程 中 ， 那可真 蠢 。   比如说   git   版本控制 ， 内部   无 环图 ， 版本 修改 修改 ， 回到 老 版本 ， 版本控制 失效 。   聪明 朋友 肯定 想到 宇宙 时间 不 可逆 ， 也就是说 模型 宇宙 信息 数据 变动 流 结构 ， 无 环图 。   python     algorithms 项目   有向图 代码 ， 存储 一个 字典 值 ， 再 加上 辅助 方法 ，   key   节点 值 ， 一个 列表 ， 存放 节点 节点 流向地 。 过程 很 好 理解 ， jieba 分词 中 ：   def   _ DAG   (     ,   sentence   ) :     .   check _ initialized   ( )   DAG   =   { }   N   =   len   (   sentence   )     k     xrange   (   N   ) :   tmplist   =   [ ]   i   =   k   frag   =   sentence   [   k   ]     i   <   N     frag       .   FREQ   :       .   FREQ   [   frag   ] :   tmplist   .   append   (   i   )   i   + =   1   frag   =   sentence   [   k   :   i   +   1   ]       tmplist   :   tmplist   .   append   (   k   )   DAG   [   k   ]   =   tmplist   return   DAG   大体 类似 。   实际操作 中 ， 对无环 条件 判断 ， 出乎 意料之外 。 图论 算法 ， 没什么 好 想 ， 图论 拓扑 排序 方法 判断 一个 有向图 是否是 无环 。   wiki 上 伪 代码 ， 下 看 ：   L   ←   Empty   list           sorted   elements   S   ←   Set       nodes       incoming   edge     S     - empty     remove   a   node   n     S   add   n     tail     L       node   m       edge   e     n     m     remove   edge   e       graph     m         incoming   edges     insert   m     S     graph     edges     return   error   ( graph           cycle )     return   L   ( a   topologically   sorted   order )   算法   Kahn   算法 ， 思路 请 读者 假想 目标 研究 有向图 一个 闭环 ， 闭环 节点 都 箭头 ， 不 set   S ， 算法 中 只   m   中 选中 ， 闭环 中 节点 n 中 ， 算法 再 运算 ， 语句 闭环 中 m 来说 都 成立 。   假设 几个 节点 都 入口 ， 顺藤摸瓜 ， 逐个 删除 节点 都 放到 S 去 。   一个 担心 ， 算法 终止 ， 闭环 。 初步 判断 闭环 内 节点 m S ， 节点 慢慢 会 放入 L 。 OK ， 写 代码 ， 再 看 。   代码 参考 提及   algorithm   项目 之外 ，   还 参看   网页   ， 深度 优化 。   # ! / usr / bin / env   python   #   - * -   coding :   utf - 8   - * -     copy   import   deepcopy     collections   import   defaultdict   import   logging   logger   =   logging   .   getLogger   (   __ __   )   class   CyclicError   (   Exception   ) :   pass   class   DAG   ( ) :   def   __ init __   (     ) :     .   _ dag   =   defaultdict   (   list   )     .   _ vertex _ count   =   0     .   _ edge _ count   =   0   @ property   def   data   (     ) :   return     .   _ dag   @ property   def   vertex _ count   (     ) :   \" \" \"   Returns     number     vertices       graph .   Worst   Case   Complexity :   O ( 1 )   \" \" \"   return     .   _ vertex _ count   @ property   def   edge _ count   (     ) :   \" \" \"   Returns     number     edges       graph .   Worst   Case   Complexity :   O ( 1 )   \" \" \"   return     .   _ edge _ count   def   add _ edge   (     ,   src   ,   dest   ) :   \" \" \"   Adds     undirected   edge   ' src ' - ' dest '       graph .   Worst   Case   Complexity   O ( 1 )   \" \" \"   def   _ add _ edge   (     ,   src   ,   dest   ) :     src       .   _ dag   :     dest         .   _ dag   [   src   ] :     .   _ dag   [   src   ]   .   append   (   dest   )     .   _ edge _ count   + =   1     :   logger   .   warning   (   ' src - > dest     exists '   )     :     .   _ dag   [   src   ]   =   [   dest   ]     .   _ vertex _ count   + =   1     .   _ edge _ count   + =   1     dest         .   _ dag   :     .   _ dag   [   dest   ]   =   [ ]     .   _ vertex _ count   + =   1   backup   =   deepcopy   (     )   _ add _ edge   (   backup   ,   src   ,   dest   )       backup   .   sort   ( ) :   raise   CyclicError     :   _ add _ edge   (     ,   src   ,   dest   )   def   remove _ edge   (     ,   src   ,   dest   ) :   \" \" \"   remove   edge   src   - >   dest   \" \" \"     src       .   _ dag   :     dest       .   _ dag   [   src   ] :     .   _ dag   [   src   ]   .   remove   (   dest   )     .   _ edge _ count   - =   1     :   raise   ValueError     :   raise   ValueError   ##   clear   data       .   indegree   (   src   )   = =   0       .   outdegree   (   src   )   = =   0   :     src       .   _ dag   :   del     .   _ dag   [   src   ]     .   _ vertex _ count   - =   1       .   indegree   (   dest   )   = =   0       .   outdegree   (   dest   )   = =   0   :     dest       .   _ dag   :   del     .   _ dag   [   dest   ]     .   _ vertex _ count   - =   1   def   adjacent   (     ,   src   ) :   \" \" \"   Returns     vertices   adjacent     vertex   ' src ' .   Worst   Case   Complexity :   O ( 1 )   \" \" \"   return     .   _ dag   [   src   ]   def   outdegree   (     ,   src   ) :   \" \" \"   Returns     degree       vertex   ' src '   Worst   Case   Complexity :   O ( 1 )   \" \" \"   count   =   0     src       .   _ dag   :   count   =   len   (     .   _ dag   [   src   ] )   return   count   def   indegree   (     ,   src   ) :   \" \" \"   Returns       degree       vertex   ' src '   \" \" \"   count   =   0     k   ,   v       .   _ dag   .   items   ( ) :     src     v   :   count   + =   1   return   count   @ property   def   vertices   (     ) :   \" \" \"   Returns     iterable         vertices       graph .   Worst   Case   Complexity :   O ( V )   \" \" \"   return     .   _ dag   .   keys   ( )   def   __ str __   (     ) :   s   =   [ ]   s   .   append   (   \"   { 0 }   vertices     { 1 }   edges   \\ n   \"   .   format   (     .   vertex _ count   ,     .   edge _ count   ) )     key       .   vertices   :   s   .   append   (   \"   { 0 }   :   \"   .   format   (   key   ) )     val       .   adjacent   (   key   ) :   s   .   append   (   \"   { 0 }   \"   .   format   (   val   ) )   s   .   append   (   \"   \\ n   \"   )   return   \" \"   .   join   (   s   )   def   __ repr __   (     ) :   s   =   [ ]     key       .   vertices   :   s   .   append   (   \"   { 0 }   :   \"   .   format   (   key   ) )     val       .   adjacent   (   key   ) :   s   .   append   (   \"   { 0 }   \"   .   format   (   val   ) )   s   .   append   (   \"   \\ n   \"   )   return   ' '   .   join   (   s   )   def   sort   (     ) :   \" \" \"   L   ←   Empty   list           sorted   elements   S   ←   Set       nodes       incoming   edge     S     - empty     remove   a   node   n     S   add   n     tail     L       node   m       edge   e     n     m     remove   edge   e       graph     m         incoming   edges     insert   m     S     graph     edges     return   error   ( graph           cycle )     return   L   ( a   topologically   sorted   order )   \" \" \"   target   =   deepcopy   (     )   top _ order   =   [ ]     collections   import   deque   queue   =   deque   ( )     k     target   .   vertices   :     target   .   indegree   (   k   )   = =   0   :   queue   .   append   (   k   )   logger   .   debug   (   ' queue   append   { 0 }   '   .   format   (   k   ) )     queue   :   n   =   queue   .   pop   ( )   top _ order   .   append   (   n   )     m       .   adjacent   (   n   ) :   target   .   remove _ edge   (   n   ,   m   )   logger   .   debug   (   ' remove   n - > m   { 0 }   { 1 }   '   .   format   (   n   ,   m   ) )     target   .   indegree   (   m   )   = =   0   :   logger   .   debug   (   ' append   { 0 }   '   .   format   (   m   ) )   queue   .   append   (   m   )     len   (   top _ order   )   ! =   len   (     .   vertices   ) :   return   False     :   return   top _ order",
            "tags":"algorithm",
            "url":"articles/you-xiang-wu-huan-tu.html"
        },
        {
            "title":"二分查找",
            "text":"二分 查找   二分 查找 接触 ， 不怎么 重视 ， 一种 快速 查找 方法 ， 参看   网页   ， python   index   方法 二分 查找 ， 大规模 查询 会 很 吃力 。 python sequence 对象 都 预 排序 ， 说法 可信度 很 高 。 利用 python   bisect   模块 ， 构建 出 一种 预 排序 支持 更 快 查询 接口 ， 内部 二分 查找 。   二分 查找 原理 不 啰嗦 ， 想 说 ， 看 MIT 视频 ， 第三课 讲到 利用 二分 查找 思想 求解 平方根 ， 启发 很大 。 一句 :   计算机 找 不到 好 方法 ， 实际上 都 穷举 ， 穷举 过程 ， 不 一个个 都 试一下 ， 只 集 排序 ， 二分 查找 快速 缩小 集 ， 更快 趋近 理想 。   ， 二分 查找 思想 可不 限于 查找 ， 更 ， 看作 一种 计算机 最 核心 最底层 那种 计算 思想 东西 。 小节 二分 查找 分为 两个 内容 ， 一是 查找 ， 讨论 python   bisect 模块 ； 一是 一种 抽象 思维 描述 二分 查找 思想 。   抽象 二分 查找 思想 讨论   集 函数 f ( x ) 输入 参数 ， 目标 参数 target ， 令 f ( x ) = target 说 找到 目标 x ， 或者说 目标 x 符合 函数 f ( x ) = target 关系 。 假设 考察 对象 f ( x ) 目标 集内 简单 增减 关系 ， 目标 集合 由此 排序 ， 二分 查找 找到 目标 x 。   查找 为例 ， f ( x ) 函数 f ( x ) = x ， 输入 输出 。 x = target ， 说 目标 x 复合 条件 f ( x ) = target ， x 找 目标 x 。   定义   f ( x ) = x * x   ， 找 x 符合条件   x * x = target   ， 求 平方根 过程 。   程序 主体   binary _ search   函数 大体 ， 参考   algorithms 模块   binary _ search . py   文件 ， 稍作 修改 。   def   binary _ search   (   f   ,   seq   ,   target   ) :   low   =   0   high   =   len   (   seq   )   -   1     high   > =   low   :   mid   =   low   +   (   high   -   low   )   / /   2   print   (   low   ,   high   ,   mid   )     f   (   seq   [   mid   ] )   <   target   :   ## higher   area   low   =   mid   +   1   elif   f   (   seq   [   mid   ] )   >   target   :   ## lower   area   high   =   mid   -   1     :   print   (   ' '   )   return   seq   [   mid   ]     :   print   (   ' '   )   return   seq   [   mid   ]   来看 最 简单 查找 匹配 操作 ， :   def   f   (   x   ) :   return   x   :   seq   =   list ( ' abcdefg ' )   res   =   binary _ search ( f , seq , ' e ' )   print ( res )   0   6   3   4   6   5   4   4   4     e   > > >   平方根 ，   x * x = target   过程 ， 定义 函数 简单 改 即可 :   def   f   (   x   ) :   return   x   *   x   利用 numpy   arange   函数 生成 一个 集 。   > > >   import   numpy     np   > > >   np . arange ( 0 , 10 , 0.1 )   array ( [   0 .   ,   0.1 ,   0.2 ,   0.3 ,   0.4 ,   0.5 ,   0.6 ,   0.7 ,   0.8 ,   0.9 ,   1 .   ,   1.1 ,   1.2 ,   1.3 ,   1.4 ,   1.5 ,   1.6 ,   1.7 ,   1.8 ,   1.9 ,   2 .   ,   2.1 ,   2.2 ,   2.3 ,   2.4 ,   2.5 ,   2.6 ,   2.7 ,   2.8 ,   2.9 ,   3 .   ,   3.1 ,   3.2 ,   3.3 ,   3.4 ,   3.5 ,   3.6 ,   3.7 ,   3.8 ,   3.9 ,   4 .   ,   4.1 ,   4.2 ,   4.3 ,   4.4 ,   4.5 ,   4.6 ,   4.7 ,   4.8 ,   4.9 ,   5 .   ,   5.1 ,   5.2 ,   5.3 ,   5.4 ,   5.5 ,   5.6 ,   5.7 ,   5.8 ,   5.9 ,   6 .   ,   6.1 ,   6.2 ,   6.3 ,   6.4 ,   6.5 ,   6.6 ,   6.7 ,   6.8 ,   6.9 ,   7 .   ,   7.1 ,   7.2 ,   7.3 ,   7.4 ,   7.5 ,   7.6 ,   7.7 ,   7.8 ,   7.9 ,   8 .   ,   8.1 ,   8.2 ,   8.3 ,   8.4 ,   8.5 ,   8.6 ,   8.7 ,   8.8 ,   8.9 ,   9 .   ,   9.1 ,   9.2 ,   9.3 ,   9.4 ,   9.5 ,   9.6 ,   9.7 ,   9.8 ,   9.9 ] )   > > >   :   import   numpy     np   seq   =   np . arange ( 0 , 10 , 0.000001 )   res   =   binary _ search ( f , seq , 2 )   print ( res )     1.414214   讲个 题外话 ， 提到 集 ， 想到 多个 函数参数 ( a , b , c ) 形式 ， 多元 函数 ， 排序 ， 大小 ， 增减 性 ？ 只好 回滚 最 原始 穷举 过程 ， 讲 计算 思想 很 核心 一个 思想 穷举 思想 ， 二分 查找 方法 条件 符合 情况 下 加速 穷举 过程 。   比如说 孙子 算经 :   今有 雉 兔 同笼 ， 上 三十五 头 ， 下有 九 十四 足 ， 问雉 兔 几何 ？   穷举 函数 :   def   iter _ search   (   f   ,   seq   ,   target   ) :     item     seq   :     f   (   item   )   = =   target   :   yield   item   很 简单 一个 函数 ， 很 简单 逻辑 ， 实际上 先 迭代 对象 ， 找到 对象 复合 条件 ， 返回 对象 过程 程序 模式 常见 。   笛卡尔 积 生成 集 :   > > >     itertools   import   product   > > >   seq   =   list ( product ( range ( 35 ) , range ( 35 ) ) )   > > >   seq   [ ( 0 ,   0 ) ,   ( 0 ,   1 ) ,   ( 0 ,   2 ) ,   ( 0 ,   3 ) ,   ( 0 ,   4 ) ,   ( 0 ,   5 ) ,   ..............   .............   很 直观 化为 两个 满足条件 集 过滤 操作 :   def   f ( d ) :   x   =   d [ 0 ]   y   =   d [ 1 ]   head   =   x   +   y   return   head   def   g ( d ) :   x   =   d [ 0 ]   y   =   d [ 1 ]   foot   =   2 * x   +   4 * y   return   foot   :   res   =   list ( product ( range ( 35 ) , range ( 35 ) ) )   res   =   iter _ search ( f , res , 35 )   res   =   iter _ search ( g , res , 94 )   print ( list ( res ) )   [ ( 23 ,   12 ) ]   很 简单 函数 ， 过程 很感兴趣 一种 风格 。   bisect 模块   bisect 模块 提供 二分 查找 支持 ， bisect _ left 函数 ：   def   bisect _ left   (   a   ,   x   ,   lo   =   0   ,     =   None   ) :   \" \" \" Return     index       insert   item   x     list   a ,   assuming   a     sorted .   The   return     i           e     a [ : i ]     e   <   x ,       e     a [ i : ]     e   > =   x .   So     x     appears       list ,   a . insert ( x )     insert         leftmost   x     .   Optional   args   lo   ( default   0 )       ( default   len ( a ) )   bound     slice     a       searched .   \" \" \"     lo   <   0   :   raise   ValueError   (   ' lo       - negative '   )         None   :     =   len   (   a   )     lo   <     :   mid   =   (   lo   +     )   / /   2     a   [   mid   ]   <   x   :   lo   =   mid   +   1     :     =   mid   return   lo   底层 c 加速 ， 返回 一个 索引 值 ， 索引 值 ， 执行   a . insert ( x )   ， 目标值 插入 目标 位置 ， x a 中 ， 插入 最 左边 位置 。 ：   def   binary _ search   (   seq   ,   target   ) :   \" \" \"   seq 已 排序 ， 二分 查找   返回 找到 索引 值 找到 返回 - 1   : param   seq :   : param   target :   : return :   \" \" \"   pos   =   bisect _ left   (   seq   ,   target   )   return   (   pos     (   pos   ! =   len   (   seq   )     seq   [   pos   ]   = =   target   )     -   1   )   仔细 体会 python 官方 源码 ， 写 版本 版本 稍微 好 一点 ， 代码 更 精炼 ， 版本 改造 ， 效果 都 差不多 。",
            "tags":"algorithm",
            "url":"articles/er-fen-cha-zhao.html"
        },
        {
            "title":"mindmaptree",
            "text":"思维 导图 ， 设计 一种 数据格式 便捷 后续 csv json 操作 ？   csv 格式 ：   奴隶社会 , 非洲 , 古埃及 文明 , 金字塔   , 亚洲 , 两河 流域 文明 , 汉谟拉 法典   , , 古印度 , 种姓 制度   , , , 佛教 创立   , 欧洲 , 希腊 , 希腊 城邦   , , , 雅典 民主   , , 罗马 , 城邦   , , , 帝国 征服 扩展   , , 希腊 罗马 古典 文化 , 建筑 艺术   , , , 公历   实际上 谈论 二叉 搜索 树 类似 ， 变种 ， 树形 结构 下 不可避免 用到 递归 思维 。 一个 很 粗糙 版本 ， 最 核心 一个点 Node 只 做好 分内 事情 就行了 ， 放到 整体 支持 功能 递归 展开 即可 。   类 设计   import   logging   logger   =   logging   .   getLogger   (   __ __   )   logging   .   basicConfig   (   level   =   logging   .   DEBUG   )   class   MindMapTree   (   object   ) :   def   __ init __   (     ,   data   =   None   ,   parent   =   None   ) :     .   data   =   data     .   parent   =   parent     .   children   =   [ ]   def   introspection   (     ) :   \" \" \"   核心 内省 函数 ， 返回 children 。   \" \" \"   stack   =   [ ]   tree   =       tree   .   data       None   :   logger   .   debug   (   ' intorspection   add   node :   { 0 }   '   .   format   (   tree   ) )   stack   .   append   (   tree   )     child     tree   :   stack   + =   child   .   introspection   ( )   return   stack   def   __ str __   (     ) :       .   children   :   return   ' < MindMapTree :   { 0 }   >     children :   { 1 }   '   .   format   (     .   data   ,     .   children   )     :   return   ' < MindMapTree :   { 0 }   > '   .   format   (     .   data   )   def   __ repr __   (     ) :       .   children   :   return   ' < MindMapTree :   { 0 }   >     children :   { 1 }   '   .   format   (     .   data   ,     .   children   )     :   return   ' < MindMapTree :   { 0 }   > '   .   format   (     .   data   )   def   append   (     ,   child _ data   ) :   child   =   MindMapTree   (   child _ data   ,   parent   =     )     .   children   .   append   (   child   )   def   remove   (     ,   child _ data   ) :   child   =   MindMapTree   (   child _ data   ,   parent   =     )     .   children   .   remove   (   child   )   def   insert   (     ,   parent _ data   ,   child _ data   ) :     target       .   introspection   ( ) :     target   .   data   = =   parent _ data   :   target   .   append   (   child _ data   )   def   find   (     ,   key   ) :     target       .   introspection   ( ) :     target   .   data   = =   key   :   return   target   raise   KeyError   def   set _ nodedata   (     ,   data   ) :     .   data   =   data   def   __ iter __   (     ) :       .   children       None   :     child       .   children   :   yield   child   def   _ json   (     ) :   return   {     .   data   :   [   i   .   _ json   ( )     i       .   children   ] }   def   _ path   (     ) :   res   =   [ ]     True   :   res   .   append   (     .   data   )       .   parent     None   :   break     :     =     .   parent   return   res   [ : :   -   1   ]     __ __   = =   \" __ main __ \"   :   tree   =   MindMapTree   (   \" 奴隶社会 \"   )   tree   .   append   (   \" 非洲 \"   )   tree   .   append   (   \" 亚洲 \"   )   tree   .   insert   (   \" 非洲 \"   ,   \" 古埃及 文明 \"   )   tree   .   insert   (   \" 古埃及 文明 \"   ,   \" 金字塔 \"   )   tree   .   insert   (   \" 亚洲 \"   ,   \" 两河 流域 文明 \"   )   tree   .   insert   (   \" 两河 流域 文明 \"   ,   \" 汉谟拉 法典 \"   )   tree   .   insert   (   \" 亚洲 \"   ,   \" 古印度 \"   )   print   (   tree   )   print   (   ' ###################### '   )   stack   =   tree   .   introspection   ( )   print   (   stack   )   yazhou   =   tree   .   find   (   \" 亚洲 \"   )   print   (   yazhou   .   introspection   ( ) )   print   (   yazhou   .   parent   )   print   (   yazhou   .   children   )   print   (   tree   .   _ json   ( ) )   print   (   tree   .   _ path   ( ) )   csv 读写   import   csv     collections   import   defaultdict   class   MindMapCSV   (   csv   .   Dialect   ) :   delimiter   =   ' , '   #   分隔符   quotechar   =   ' \" '   #   quote 符号   doublequote   =   True   #   双引号 字符 中 情况   skipinitialspace   =   True   #   分隔符 后 空白 忽略   lineterminator   =   '   \\ n   '   #   换行符   quoting   =   csv   .   QUOTE _ MINIMAL   #   最小 quote   csv   .   register _ dialect   (   \" MindMapCSV \"   ,   MindMapCSV   )   import   logging   logger   =   logging   .   getLogger   (   __ __   )   logging   .   basicConfig   (   level   =   logging   .   INFO   )     mindmaptree   import   MindMapTree   class   MindMapReader   ( ) :   def   __ init __   (     ,   f   ,   dialect   =   ' MindMapCSV '   ) :     .   data   =   MindMapTree   ( )   _ stack   =   { }     =   True   #   根 元素 ， 还 只 一个 根 元素 情况     line     csv   .   reader   (   f   ,   dialect   ) :   logger   .   debug   (   '   original   line   data :   { 0 }   '   .   format   (   line   ) )     index   ,   item     enumerate   (   line   ) :     item   :       :   _ stack   [   index   ]   =   item     .   data   .   set _ nodedata   (   item   )     =   False     :     =   _ stack   [   index   -   1   ]   _ stack   [   index   ]   =   item     .   data   .   insert   (     ,   item   )     :   #   \" \"   continue   logger   .   debug   (   ' init   data :   { 0 }   '   .   format   (     .   data   .   introspection   ( ) ) )   def   getdata   (     ) :   return     .   data   class   MindMapWriter   ( ) :   def   __ init __   (     ,   f   ,   dialect   =   ' MindMapCSV '   ) :     .   data   =   MindMapTree   ( )     .   writer   =   csv   .   writer   (   f   ,   dialect   )   def   setdata   (     ,   data   ) :     .   data   =   data   函数 接口   def   read _ csv   (   f   ) :     open   (   f   ,   newline   =   ' '   ,   encoding   =   ' utf8 '   )     f   :   reader   =   MindMapReader   (   f   )   data   =   reader   .   getdata   ( )   return   data   def   csv2json   (   f   ) :     open   (   f   ,   newline   =   ' '   ,   encoding   =   ' utf8 '   )     f   :   reader   =   MindMapReader   (   f   )   data   =   reader   .   getdata   ( )   res   =   data   .   _ json   ( )   import   json   res   =   json   .   dumps   (   res   ,   sort _ keys   =   True   ,   indent   =   2   ,   ensure _ ascii   =   False   )   return   res   def   find   (   mindmaptree   ,   key   ) :     :   target   =   mindmaptree   .   find   (   key   )   return   ' . '   .   join   (   target   .   _ path   ( ) )     KeyError   :   return   ' 找 不到 关键字 ：   { 0 }   '   .   format   (   key   )     __ __   = =   ' __ main __ '   :   data   =   read _ csv   (   ' history . csv '   )   print   (   data   )   json _ data   =   csv2json   (   ' history . csv '   )   print   (   json _ data   )   find _ res   =   find   (   data   ,   \" 汉谟拉 法典 \"   )   print   (   find _ res   )   find _ res   =   find   (   data   ,   \" 美洲 \"   )   print   (   find _ res   )",
            "tags":"algorithm",
            "url":"articles/mindmaptree.html"
        },
        {
            "title":"hash分桶操作",
            "text":"简介   hashlib md5 算法 实践 级别 算法 一个 很大 输出 位数 长度 固定 ， 很 下 一步 输出 再 分桶 操作 ：   import   random   import   string   import   hashlib     operator   import   add     functools   import   reduce     collections   import   defaultdict   def   md5   (   key   ) :   return   hashlib   .   md5   (   key   .   encode   ( ) )   .   hexdigest   ( )   def   mapping   (   hashkey   ,   n   =   10   ) :   return   reduce   (   add   ,   [   ord   (   i   )     i     hashkey   ] )   %   n   个位数 相加 参考   网站   ， 个位数 相加 保证 分桶 均匀 性 ， 老实 说 不大 确切 ， 做 一个 简单 测试 ：   data   =   defaultdict   (   lambda   :   0   )   def   random _ string _ generator   ( ) :   data   =   [ ]   random _ length   =   random   .   randint   (   1   ,   100   )     i     range   (   random _ length   ) :   x   =   random   .   choice   (   string   .   ascii _ lowercase   +   string   .   digits   +   '   '   )   data   .   append   (   x   )   return   ' '   .   join   (   data   )     i     range   (   100000   ) :   s   =   random _ string _ generator   ( )   c   =   mapping   (   md5   (   s   ) )   print   (   f   ' \"   { s }   \"   mapping     bukket   { c }   '   )   data   [   c   ]   + =   1   print   (   data   )   初步 随机 生成 各种各样 字符串 最终 分桶 基本上 均匀 。 md5 算法 保证 位数 上 随机 ， ord 数字 ， 相加 再 取模 ， 保证 均匀 性 ， 只能 说 猜 ， 数学 证明 。",
            "tags":"algorithm",
            "url":"articles/hashfen-tong-cao-zuo.html"
        },
        {
            "title":"numpy模块",
            "text":"前言   本文 numpy 模块 函数 细节 不 做 ， 请 参看 文档 。 本文 numpy 核心 概念 理清 。   numpy 模块 最 核心 概念   ndarray 对象 ， 请 参看     ， 疑问 ， numpy array 函数 ndarray 对象 区别 ， 答案 ： 推荐   numpy . array   创建   ndarray 对象 ，   zeros   ， empty 函数 ， 都 很 好 接口 去 创建 一个   numpy . ndarray   对象 ，   numpy . ndarray   创建 一个 ndarray 对象 ，   numpy 模块 开发人员 推荐 风格 。   numpy   ndarray 对象 python 列表 区别   numpy   ndarray 内部 item 固定 内存 size ， 改变 size 将会 创建 一个 ndarray 。   numpy   ndarray 内部 item data   type ， 固定 内存 size 。   numpy ndarray 有助于 大型 数据 高级 数学 运算 操作 ， python 序列 执行 会 更 有效率 。   很多 科学 数学计算 python 模块 都 基于 numpy ndarray ， 支持 python 序列 类型 输入 ， 都 numpy array 再 相关 计算 ， 输出 numpy ndarray 对象 。   ndarray 对象   numpy 模块 中 很 核心 一个 概念 ndarray 对象 。 ndarray 对象 numpy 官方 手册 绘图 一个 数据结构 ：   ndarray 一个头 header 控制 接下来 存储 数据类型 ( dtype ) ， 存储 数据 都 数据类型 ， 这是 一个 不同于 列表 限定 条件 ， 约定 大大提高 数据处理 效率 。   利用 array 函数 简单 一个 列表 ndarray 对象 ：   > > >   x   =   np   .   array   ( [   1   ,   2   ,   3   ,   4   ,   5   ] )   > > >   x   array   ( [   1   ,   2   ,   3   ,   4   ,   5   ] )   > > >   type   (   x   )   <   class   '   numpy   .   ndarray   ' >   > > >   x   .   dtype   dtype   (   ' int32 '   )   例子 中 ， 一个 ndarray 对象 都 一个 属性 (   dtype   ) ， 存储 讲 ndarray 对象 一连串 数据 数据类型 ， 数据类型 \" int32 \" 。   dtype   基本上 讨论 numpy 资料 都 会 清单 列出来 ， 列出来 。   bool _ :   True     False   int _ :   相当于 C语言 long ， int32 int64 。 整数型 其内 细分 :   intc :   等于 C语言 int ， int32 int64   intp :   整数 用于 索引 ， C语言 ssize _ t ， int32 int64 。   int8 :   Byte （ - 128   ~   127 ）   int16 :   Integer （ - 32769   ~   32767 ）   int32 :   Integer   int64 :   Integer   uint8 :   Unsigned   Integer （ 0   ~   255 ）   uint16 :   Unsigned   Integer （ 0   ~   65535 ）   uint32 :   Unsigned   Integer   uint64 :   Unsigned   Integer   float _ :   float64 。 浮点 型 细分 :   float16 :   半 精度 浮点 型   float32 :   单精度 浮点 型   float64 :   双 精度 浮点 型   complex _ :   complex128 。   复数 型 细分 :   complex64 :   复数 型 ， 32 位 浮点 型   complex128 :   复数形 ， 64 位 浮点 型   声明 :   > > >   t   =   np . array ( [ 1 , 2 , 3 ] , dtype = ' int32 ' )   > > >   type ( t )   < class   ' numpy . ndarray ' >   > > >   t . dtype   dtype ( ' int32 ' )   > > >   ， dtype 指定 int ，   np . int _   > > >   t   =   np . array ( [ 1 , 2 , 3 ] , dtype = ' int ' )   > > >   t . dtype   dtype ( ' int64 ' )   类似   float     np . float _   ;   bool     np . bool _   ;   complex     np . complex _   。   ndarray dtype 变换   还 调用 ndarray   astype   方法 。 方法   非 破坏型   方法 ， 例子 所示 ：   > > >   t   =   np . array ( [ 1 , 2 , 3 ] , dtype = ' int8 ' )   > > >   t . astype ( ' int32 ' )   array ( [ 1 ,   2 ,   3 ] ,   dtype = int32 )   > > >   t   array ( [ 1 ,   2 ,   3 ] ,   dtype = int8 )   dtype 对象 从属关系     np . issubdtype   函数 判断 ndarray dtype 对象 整型 子集 。   > > >   t   array ( [ 1 ,   2 ,   3 ] ,   dtype = int8 )   > > >   t . dtype   dtype ( ' int8 ' )   > > >   np . issubdtype ( t . dtype , ' int ' )   True   > > >   np . issubdtype ( t . dtype , ' float ' )   False   shape 属性   ， 一个 ndarray 对象 都   shape   属性 ， 用于 控制 跟着 数据 维度 。 请 看 例子 ：   > > >   x   array ( [ 1 ,   2 ,   3 ,   4 ,   5 ,   6 ] )   > > >   x . shape   ( 6 , )   > > >   x . shape   =   ( 2 , 3 )   > > >   x   array ( [ [ 1 ,   2 ,   3 ] ,   [ 4 ,   5 ,   6 ] ] )   shape   属性 用来 控制 数据 维度 理解 ， 一个 数字 一维 ， 二个 数字 二维 几行 几列 （ 数学 中 常见 概念 矩阵 ） ， 三个 数字 三维 。 修改 ndarray 对象 shape 属性 影响 程序 对象 数据 理解 ， 更 常用   reshape   方法 ， 不 原地 修改 ndarray 对象 shape ， 返回 一个 修改 shape 属性 新 ndarray 对象 。   reshape   ndarray 调用 reshape 改变 ndarray shape 属性 ， 不 原地 修改 ndarray 对象 shape ， 返回 一个 修改 shape 属性 新 ndarray 对象 。   只 指定 一个 维度 ， 一个 维度 填 上   - 1   ， 改 维度 shape 将会 自动 计算出来 。     4 * 5 矩阵 ， reshape   ( - 1 , 4 )   ， 矩阵 row = 5 。   创建 一个 ndarray 对象   python 数据结构 中 创建   接触   np . array   函数 ， 用来 接受 一个 python   list     tuple   ， 返回 一个 ndarray 对象 。   > > >   x   =   np . array ( [ [ 1 + 2j , 2 + 3j ] , [ 3 + 4j , 4 + 5j ] ] )   > > >   x   array ( [ [   1 .+ 2 . j ,   2 .+ 3 . j ] ,   [   3 .+ 4 . j ,   4 .+ 5 . j ] ] )   > > >   x . dtype   dtype ( ' complex128 ' )   > > >   生成 一系列 随机数   例子 中 ：   np . random . randn ( 2 , 3 )   array ( [ [ - 0.26670745 ,   1.09572856 ,   - 0.38875728 ] ,   [   1.04339429 ,   0.06330302 ,   1.35696512 ] ] )   填充 一个 2 行 3 列 随机数 ， randn n normal ， 正态分布 。   arrange 函数   arange ( start , end , step )   参数 类似 range 函数 。 生成 一个 数据 递增 （ 减 ） ndarray 对象 ：   > > >   x   =   np . arange ( 5 )   > > >   x   array ( [ 0 ,   1 ,   2 ,   3 ,   4 ] )   > > >   x   =   np . arange ( 1 , 10 , 0.5 )   > > >   type ( x )   < class   ' numpy . ndarray ' >   > > >   x   array ( [   1 .   ,   1.5 ,   2 .   ,   2.5 ,   3 .   ,   3.5 ,   4 .   ,   4.5 ,   5 .   ,   5.5 ,   6 .   ,   6.5 ,   7 .   ,   7.5 ,   8 .   ,   8.5 ,   9 .   ,   9.5 ] )   其是 一维 ， reshape 操作 生成 二维 ndarray 对象 ， 接受   dtype   对象 控制 dtype 属性 。   linspace 函数   linspace 函数 看作   arange 函数 补充 ， arange 函数 指定 start stop ， 数值 不 包含 ， 生成 item 不易 知 ， linspace 接受 三个 参数 :   start   end   number   ， start end ndarray 中 包含 ， number 给定 生成 item 。   > > >   np . linspace ( 1 , 10 , 6 )   array ( [   1 .   ,   2.8 ,   4.6 ,   6.4 ,   8.2 ,   10 .   ] )   结束 元素 包不 包含 倒 很 ， 关键 情况 下 控制 生成 item ，   linspace   函数 。   zeros 函数   zeros 函数 用于 快速 创建 一个 ndarray 对象 ， 其内 数据 都 填充   0 .   ， 默认 dtype   float64   。 接受 一个 参数 简单 看作 shape 属性 参数 ， 所示 ：   > > >   np . zeros ( ( 10 , ) )   array ( [   0 . ,   0 . ,   0 . ,   0 . ,   0 . ,   0 . ,   0 . ,   0 . ,   0 . ,   0 . ] )   > > >   np . zeros ( 10 )   array ( [   0 . ,   0 . ,   0 . ,   0 . ,   0 . ,   0 . ,   0 . ,   0 . ,   0 . ,   0 . ] )   > > >   np . zeros ( ( 5 , 5 ) )   array ( [ [   0 . ,   0 . ,   0 . ,   0 . ,   0 . ] ,   [   0 . ,   0 . ,   0 . ,   0 . ,   0 . ] ,   [   0 . ,   0 . ,   0 . ,   0 . ,   0 . ] ,   [   0 . ,   0 . ,   0 . ,   0 . ,   0 . ] ,   [   0 . ,   0 . ,   0 . ,   0 . ,   0 . ] ] )   函数   函数 类似 zeros 函数 ， 填充 数据 1 。 不 做 例子 演示 。   empty 函数   empty 函数 谈论   zeros     函数 类似 ， item 都 原 内存 随机 数值 ， 不 做 修改 。   > > >   np . empty ( ( 2 , 3 ) )   array ( [ [   0.00000000 e + 000 ,   4.99297208 e - 317 ,   4.94026911 e - 317 ] ,   [   6.94094003 e - 310 ,   1.03878549 e - 013 ,   0.00000000 e + 000 ] ] )   > > >   索引 值   ndarray 值 索引 操作 python 中 列表 索引 值 操作 ， 方括号 语法 索引   [ index ]   :   > > >   x   =   np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] )   > > >   x   array ( [ [ 1 ,   2 ,   3 ] ,   [ 4 ,   5 ,   6 ] ,   [ 7 ,   8 ,   9 ] ] )   > > >   x [ 0 ]   array ( [ 1 ,   2 ,   3 ] )   > > >   x [ 0 ] [ 0 ]   1   > > >   y [ 1 ] [ 5 ]   5   还 语法 :   > > >   x   array ( [ [ 1 ,   2 ,   3 ] ,   [ 4 ,   5 ,   6 ] ,   [ 7 ,   8 ,   9 ] ] )   > > >   x [ 0 , 0 ]   1   > > >   x [ 1 , 1 ]   5   > > >   描述 索引 值 语法 修改 ndarray 对象 元素 值 。 numpy 还 提供 一种 语法 ：   [ a , b ]   ， ndarray 对象   [ a ] [ b ]   。 矩阵   不   支持   [ a ] [ b ]   索引 语法 ， 只 支持   [ a , b ]   语法 ， 推荐 矩阵 都 带 逗号 索引 方法 ， 矩阵 a 行 b 列 。   > > >   A   =   np . matrix ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] )   > > >   A [ 0 ]   matrix ( [ [ 1 ,   2 ,   3 ] ] )   > > >   A [ 0 ] [ 0 ] # 索引   matrix ( [ [ 1 ,   2 ,   3 ] ] )   > > >   A [ 0 , 0 ]   1   索引 多个 值 说 view   ndarray 对象 谈及 索引 规则 下   [ start : end : step ]   :   > > >   x   =   np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] )   > > >   x   array ( [ [ 1 ,   2 ,   3 ] ,   [ 4 ,   5 ,   6 ] ,   [ 7 ,   8 ,   9 ] ] )   > > >   x [ : : - 1 ]   array ( [ [ 7 ,   8 ,   9 ] ,   [ 4 ,   5 ,   6 ] ,   [ 1 ,   2 ,   3 ] ] )   > > >   y   =   np . arange ( 10 )   > > >   y   array ( [ 0 ,   1 ,   2 ,   3 ,   4 ,   5 ,   6 ,   7 ,   8 ,   9 ] )   > > >   y [ 0 : : 2 ]   array ( [ 0 ,   2 ,   4 ,   6 ,   8 ] )   支持 索引 多个 值 ， 说 切片 ，   view   视图 。 python list 索引 多个 值 ， 切片 ， 等于 制造 一个 新 列表 ， :   > > >   lst   =   [ 1 , 2 , 3 , 4 , 5 ]   > > >   lst [ 0 : 2 ]   [ 1 ,   2 ]   > > >   x   =   lst [ 0 : 2 ]   > > >   x [ 0 ]   =   12   > > >   x   [ 12 ,   2 ]   > > >   lst   [ 1 ,   2 ,   3 ,   4 ,   5 ]   调用   lst [ 0 : 2 ]   时 ， python 程序 制造 一个 新 子 列表 ， 赋值 x ， 看 ndarray 对象 :   > > >   array   =   np . array ( [ 1 , 2 , 3 , 4 , 5 ] )   > > >   array   array ( [ 1 ,   2 ,   3 ,   4 ,   5 ] )   > > >   x   =   array [ : 2 ]   > > >   x   array ( [ 1 ,   2 ] )   > > >   x [ 0 ]   =   12   > > >   x   array ( [ 12 ,   2 ] )   > > >   array   array ( [ 12 ,   2 ,   3 ,   4 ,   5 ] )   ndarray 对象 索引 多个 值 称之为   视图   原因 ， 返回 指向 原处 片段 ！   索引 多个 值 视图 赋值 操作 ， 元素 都 赋值 值 :   > > >   x [ : ]   =   99   > > >   array   array ( [ 99 ,   99 ,   3 ,   4 ,   5 ] )   多维 切片     [ start : end : step ]   语法 第一个 维度 上 切片 ， numpy 支持 语法 ， 灵活 多个 维度 切片   [ d1 ,   d2 ,   d3 ]   ， d1 第一个 维度 上 索引 值 ， 维度 都 进一步   [ start : end : step ]   进一步 切片 操作 。   import   numpy     np   arr   =   np   .   array   ( [ [ [   5   ,   10   ,   15   ] ,   [   20   ,   25   ,   30   ] ,   [   35   ,   40   ,   45   ] ] ,   [ [   1   ,   2   ,   4   ] ,   [   3   ,   4   ,   2   ] ,   [   1   ,   2   ,   4   ] ] ]   )   arr   Out   [   5   ] :   array   ( [ [ [   5   ,   10   ,   15   ] ,   [   20   ,   25   ,   30   ] ,   [   35   ,   40   ,   45   ] ] ,   [ [   1   ,   2   ,   4   ] ,   [   3   ,   4   ,   2   ] ,   [   1   ,   2   ,   4   ] ] ] )   arr   [   0   , : ]   Out   [   6   ] :   array   ( [ [   5   ,   10   ,   15   ] ,   [   20   ,   25   ,   30   ] ,   [   35   ,   40   ,   45   ] ] )   arr   [   0   ]   Out   [   7   ] :   array   ( [ [   5   ,   10   ,   15   ] ,   [   20   ,   25   ,   30   ] ,   [   35   ,   40   ,   45   ] ] )   arr   [ : ,   0   , : ]   Out   [   8   ] :   array   ( [ [   5   ,   10   ,   15   ] ,   [   1   ,   2   ,   4   ] ] )   看 一个 例子 ， 含义 第一 维度 元素 ， 第二 维度 选择 索引 值 0 ， 第三 维度 元素 。   copy 方法   希望 原 python 那种 索引 多个 值 效果 不 影响 原 ndarray 对象 ， 调用 ndarrary 对象   copy   方法 :   array [ : 2 ] . copy ( )   布尔值 索引   布尔值 索引 基于   ndarray 对象 布尔值 判断 操作 ，   = =   >   <   ， 输出 一个 原 维度 bool 值 ndarray 对象 。 ndarray 对象 送入 array 索引 输入框 中 ， 返回 bool 值为 True 值 。   > > >   array   array ( [ 0 ,   0 ,   3 ,   4 ,   5 ] )   > > >   array   = =   0   array ( [   True ,   True ,   False ,   False ,   False ] ,   dtype = bool )   > > >   array [ array   = =   0 ]   array ( [ 0 ,   0 ] )   > > >   array [ array   = =   0 ]   =   99   > > >   array   array ( [ 99 ,   99 ,   3 ,   4 ,   5 ] )   布尔值 索引 返回   视图   ， 对齐 操作 改变 原 ndarray 对象 。   还   &     |   组合 逻辑 ，         。   一大 用法 利用 item 属性 映射 关系 ， 利用 属性 过滤 data :   > > >   data   =   np . random . randn ( 7 , 3 )   > > >   data   array ( [ [ - 0.82117767 ,   1.02481308 ,   0.50908019 ] ,   [   0.79851282 ,   0.37692996 ,   - 1.0129145   ] ,   [ - 1.30120201 ,   1.71270027 ,   0.2113716   ] ,   [ - 1.33386207 ,   0.02978504 ,   - 0.58061781 ] ,   [   0.72466458 ,   1.94170572 ,   2.09521622 ] ,   [ - 1.24241997 ,   - 1.20557331 ,   - 0.66292731 ] ,   [ - 0.66145326 ,   0.28330579 ,   0.2803069   ] ] )   > > >   names   =   np . array ( [ ' a ' , ' b ' , ' c ' , ' a ' , ' b ' , ' d ' , ' a ' ] )   > > >   data [ names   = =   ' a ' ]   array ( [ [ - 0.82117767 ,   1.02481308 ,   0.50908019 ] ,   [ - 1.33386207 ,   0.02978504 ,   - 0.58061781 ] ,   [ - 0.66145326 ,   0.28330579 ,   0.2803069   ] ] )   索引 一行 ， 其行 ' a ' 值 。   运算   两个 ndarray 对象 之间 数学 运算 ， 两个 ndarray 维度 ， 称之为   vectorization   ， 矢量化 操作 。 大致   加减乘除 幂   具体操作 都   元素 元素 加减乘除 幂 操作   :   > > >   x   =   np . array ( [ [ 4 , 0 , 5 ] , [ - 1 , 3 , 2 ] ] )   > > >   x   array ( [ [   4 ,   0 ,   5 ] ,   [ - 1 ,   3 ,   2 ] ] )   > > >   y   =   np . array ( [ [ 1 , 1 , 1 ] , [ 3 , 5 , 7 ] ] )   > > >   y   array ( [ [ 1 ,   1 ,   1 ] ,   [ 3 ,   5 ,   7 ] ] )   > > >   x   +   y   array ( [ [ 5 ,   1 ,   6 ] ,   [ 2 ,   8 ,   9 ] ] )   > > >   x   -   y   array ( [ [   3 ,   - 1 ,   4 ] ,   [ - 4 ,   - 2 ,   - 5 ] ] )   > > >   x   *   2   array ( [ [   8 ,   0 ,   10 ] ,   [ - 2 ,   6 ,   4 ] ] )   > > >   x   * *   2   array ( [ [ 16 ,   0 ,   25 ] ,   [   1 ,   9 ,   4 ] ] )   两个 ndarray 对象 维度 （ 多维 情况 不 讨论 ） ，   列维 数目 ， ， 不 推荐 。 列维 数目 ， 会 抛出   ValueError   。   > > >   z   =   np . array ( [ 1 , 2 , 3 ] )   > > >   x + z   array ( [ [ 5 ,   2 ,   8 ] ,   [ 0 ,   5 ,   5 ] ] )   z 重复 x 一行 。   ndarray 对象 上 方法   flatten 方法   flatten ， 拉平 。 flatten ndarray 对象 （ 包括 矩阵 ） 一个 方法 ， 变为 一维 形式 ，   非 破坏型   方法 。   flatten 方法 矩阵 是因为 多维 数组 维度 含 元素 数目 （ 类似 矩阵 空间 矩形 排布 感 ） 才 意义 。 矩阵 返回 行 矢量 形式 。   > > >   x   =   np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] )   > > >   x   array ( [ [ 1 ,   2 ,   3 ] ,   [ 4 ,   5 ,   6 ] ,   [ 7 ,   8 ,   9 ] ] )   > > >   x . flatten ( )   array ( [ 1 ,   2 ,   3 ,   4 ,   5 ,   6 ,   7 ,   8 ,   9 ] )   > > >   x   array ( [ [ 1 ,   2 ,   3 ] ,   [ 4 ,   5 ,   6 ] ,   [ 7 ,   8 ,   9 ] ] )   > > >   y   =   np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 , 7 ] ] )   > > >   y   array ( [ [ 1 ,   2 ,   3 ] ,   [ 4 ,   5 ,   6 ,   7 ] ] ,   dtype = object )   > > >   y . flatten ( )   array ( [ [ 1 ,   2 ,   3 ] ,   [ 4 ,   5 ,   6 ,   7 ] ] ,   dtype = object )   > > >   z   matrix ( [ [ 1 ,   2 ,   3 ] ,   [ 4 ,   5 ,   6 ] ] )   > > >   z . flatten ( )   matrix ( [ [ 1 ,   2 ,   3 ,   4 ,   5 ,   6 ] ] )   sort 方法   sort 方法 作用 多维 ， 一维 更显 意义 些 ， 其是 一个   破坏型   方法 。   所示 ， 看 ， 一行 变动 ， 只 行内 一维 情况 下 排序 。   > > >   data   array ( [ [   0.68518059 ,   1.05271585 ,   1.00174264 ] ,   [ - 1.44506879 ,   1.45532422 ,   1.30856608 ] ,   [   0.1121552   ,   - 3.04487041 ,   - 0.03301996 ] ] )   > > >   data . sort ( )   > > >   data   array ( [ [   0.68518059 ,   1.00174264 ,   1.05271585 ] ,   [ - 1.44506879 ,   1.30856608 ,   1.45532422 ] ,   [ - 3.04487041 ,   - 0.03301996 ,   0.1121552   ] ] )   方法   计算 给定 维度 下 元素 值 均值 。   ndarray . ( axis = None ,   dtype = None ,   = None ,   keepdims = False )   难点 在于 理解 维度 扩展 概念 ， 矩阵 ， 竖向 列是 axis = 0 ， 横向 行是 axis = 1 。   numpy . ( axis = 0 )   理解 竖向 列 计算 均值 ， 更好 理解 行 记录 ， 列 特征 ， 第一 维度 样本 维 ， 第二 维度 特征 维 ， axis = 0 ， 官方 文档 axis 解释 维度 轴 计算 ， axis = 0 选择 实际上 样本 维 ， 样本 维 特征 计算 一个 均值 。   std 方法   计算 给定 维度 下 元素 值 标准差 ， 类似 方法 。   通用 函数   讲 通用 函数 ， 大多 numpy 自带 ， 接受 参数 ndarray 对象 ， 改变 目标 ndarray 对象 shape （ 会 稍微 做 改变 ） ， 元素 函数 操作 。   sqrt 函数   开个 平方根   x   =   np . arange ( 10 )   array ( [ 0 ,   1 ,   2 ,   3 ,   4 ,   5 ,   6 ,   7 ,   8 ,   9 ] )   np . sqrt ( x )   array ( [ 0 .   ,   1 .   ,   1.41421356 ,   1.73205081 ,   2 .   ,   2.23606798 ,   2.44948974 ,   2.64575131 ,   2.82842712 ,   3 .   ] )   exp 函数   算个 指数函数   \\ ( e &# 94 ; { x } \\ )   np . exp ( x )   maximum 函数   点对点 返回 最大值   【 会 自动 广播 操作 】   x   =   np . random . randn ( 8 )   y   =   np . random . randn ( 8 )   np . maximum ( x ,   y )   abs 函数   x   =   np . random . randn ( 2 , 3 )   array ( [ [ - 0.11653471 ,   0.72362219 ,   0.93142213 ] ,   [ - 2.03263166 ,   - 0.1941374   ,   1.23463108 ] ] )   np . abs ( x )   array ( [ [ 0.11653471 ,   0.72362219 ,   0.93142213 ] ,   [ 2.03263166 ,   0.1941374   ,   1.23463108 ] ] )   unique 函数   import   numpy     np   list _ dupes   =   [ 1 ,   5 ,   6 ,   2 ,   5 ,   6 ,   8 ,   3 ,   8 ,   3 ,   3 ,   7 ,   9 ]   res   =   np . unique ( list _ dupes )   > > >   [ 1   2   3   5   6   7   8   9 ]   import   numpy     np   list _ dupes   =   [ [ 1 ,   5 ,   6 ,   2 ,   5 ,   6 ,   8 ,   7 ,   9 ] ,   [ 1 ,   1 ,   2 ,   2 ,   3 ,   3 ,   5 ,   6 ,   7 ] ]   res   =   np . unique ( np . array ( list _ dupes ) )   > > >   [ 1   2   3   5   6   7   8   9 ]   返回 给定 数据 集 唯一 元素 集合 。 ndarray 多维 对象 ， 将会 flatten 再 找出 唯一 值 。   tile 函数   np . tile ( A ,   reps )   输入 一个 array ， reps 维度 重复 数据 ：   > > >   a   =   np . array ( [ 0 ,   1 ,   2 ] )   > > >   np . tile ( a ,   2 )   array ( [ 0 ,   1 ,   2 ,   0 ,   1 ,   2 ] )   > > >   np . tile ( a ,   ( 2 ,   2 ) )   array ( [ [ 0 ,   1 ,   2 ,   0 ,   1 ,   2 ] ,   [ 0 ,   1 ,   2 ,   0 ,   1 ,   2 ] ] )   > > >   np . tile ( a ,   ( 2 ,   1 ,   2 ) )   array ( [ [ [ 0 ,   1 ,   2 ,   0 ,   1 ,   2 ] ] ,   [ [ 0 ,   1 ,   2 ,   0 ,   1 ,   2 ] ] ] )   argsort 函数   ndarray 对象 调用 argsort 函数 返回 一个 大小 排序 索引 值 ：   > > >   x   =   np . array ( [ 3 ,   1 ,   2 ] )   > > >   np . argsort ( x )   array ( [ 1 ,   2 ,   0 ] )   含义 排序 后 第一个 值   x [ 1 ]   ， 以此类推 。   np . argpartition 函数   arg 开头 返回 索引 值 。   默认 调用 类似 快速 排序 中 选择 一个点 ， 左边 都 值 小 点 ， 右边 都 值大 点 。 情况 下 ， 指向 topk ， 调用 函数 ， 排序 操作 完 ， 会 很 高效 。   x   =   [ 9 , 8 , 7 , 5 , 4 , 6 , 1 ]   np . argpartition ( x ,   2 )   array ( [ 6 ,   4 ,   3 ,   2 ,   1 ,   5 ,   0 ] ,   dtype = int64 )   例子 ， 输出 分区 点   2   ， 2 内容 中 最小 两个 。 2 数字 5 ， 两个   1   4 ， 剩下 9   8   7   6   都 5 大 。 大概 样子 。   np . allclose   numpy . allclose ( a ,   b ,   rtol = 1e - 05 ,   atol = 1e - 08 ,   equal _ nan = False )   类似 isclose ， 返回 True False   np . isclose   numpy . isclose ( a ,   b ,   rtol = 1e - 05 ,   atol = 1e - 08 ,   equal _ nan = False )   点对点 两个 ndarray 值 ， rtol 容忍度 ， atol 容忍度 ， 这是 一种 近似 数值 相近 判断 操作 。   np . logical _   点对点 逻辑 操作 。   np .   轴 数值 执行 操作 。   ndarray 对象 转置   调用 ndarray 对象   T   属性 ， 更 接近 矩阵 中 转置 操作 （ 一维 ndarray 改变 ） 。 提及   data [ : : - 1 ]   ， 把行 翻转 ， 一维 倒 array 都 翻转 。   > > >   data   =   np . random . randn ( 4 , 3 )   > > >   data   array ( [ [   0.53700477 ,   - 1.30139712 ,   1.12184318 ] ,   [ - 0.91918847 ,   1.52850268 ,   0.73218978 ] ,   [ - 1.14840704 ,   - 0.0413753   ,   0.52820585 ] ,   [   1.84307255 ,   0.21356674 ,   0.23331023 ] ] )   > > >   data . T   array ( [ [   0.53700477 ,   - 0.91918847 ,   - 1.14840704 ,   1.84307255 ] ,   [ - 1.30139712 ,   1.52850268 ,   - 0.0413753   ,   0.21356674 ] ,   [   1.12184318 ,   0.73218978 ,   0.52820585 ,   0.23331023 ] ] )   > > >   data [ : : - 1 ]   array ( [ [   1.84307255 ,   0.21356674 ,   0.23331023 ] ,   [ - 1.14840704 ,   - 0.0413753   ,   0.52820585 ] ,   [ - 0.91918847 ,   1.52850268 ,   0.73218978 ] ,   [   0.53700477 ,   - 1.30139712 ,   1.12184318 ] ] )   广播 ( broadcasting )   广播 一种 操作 ， shape 小 张量 shape 较大 张量 点对点 运算 时 ， shape 小 张量 广播 操作 ， 使 运算 上 shape 兼容 。   广播 具体操作 规则 ：   shape 小 张量 添加 新 维度 两个 张量 维度 数   shape 小 张量 新 维度 中 数据 重复 ， 相当于 原 维度 数据 ， ：   y [ 1 , j ]   =   y [ 2 , j ]   =   y [ 3 , j ]   = ...   y [ j ]   矩阵 对象   矩阵 对象 ndarray 对象 子类 ， 也就是说 ndarray 对象 属性 方法 都 。 行 矢量 列 矢量 矩阵 中 情况 。 矩阵 概念 数学 运算 中 较为 ， 概念 ， 转置 ， 点 ， 矩阵 数学 运算 相关 ， ndarray 对象 做 ， 推荐 矩阵 （ matrix ） 对象 再 ， 理清 概念 。   matrix 函数   numpy matrix 函数 创建 一个 矩阵 对象 :   > > >   data   =   np . random . randn ( 3 , 3 )   > > >   data   array ( [ [ - 0.79589206 ,   - 0.97535141 ,   1.05750453 ] ,   [   0.05051448 ,   0.19753523 ,   0.99618112 ] ,   [   2.09805081 ,   - 0.33623748 ,   0.26033154 ] ] )   > > >   x   =   np . matrix ( data )   > > >   type ( x )   < class   ' numpy . matrixlib . defmatrix . matrix ' >   > > >   x   matrix ( [ [ - 0.79589206 ,   - 0.97535141 ,   1.05750453 ] ,   [   0.05051448 ,   0.19753523 ,   0.99618112 ] ,   [   2.09805081 ,   - 0.33623748 ,   0.26033154 ] ] )   矩阵 转置   transpose   方法 ， 矩阵 转置 。 只 返回 ，   非 破坏型   方法 。   > > >   x   =   np . matrix ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] )   > > >   x   matrix ( [ [ 1 ,   2 ,   3 ] ,   [ 4 ,   5 ,   6 ] ,   [ 7 ,   8 ,   9 ] ] )   > > >   x . transpose ( )   matrix ( [ [ 1 ,   4 ,   7 ] ,   [ 2 ,   5 ,   8 ] ,   [ 3 ,   6 ,   9 ] ] )   行 矢量 列 矢量   行 矢量 列 矢量 矩阵 情况 ， matrix 函数 创建 。 行 矢量 转置 列 矢量 请 看 写法 。   > > >   x   =   np . matrix ( [ 1 , 2 , 3 , 4 , 5 ] )   > > >   x   matrix ( [ [ 1 ,   2 ,   3 ,   4 ,   5 ] ] )   > > >   x . transpose ( )   matrix ( [ [ 1 ] ,   [ 2 ] ,   [ 3 ] ,   [ 4 ] ,   [ 5 ] ] )   矩阵 点   学过 线性代数 印像 最深 矩阵 怪异 乘法 运算 。 numpy 模块 支持 ，   *   执行 两个 矩阵 乘法 ，   np . dot   函数 。   > > >   A   =   np . matrix ( [ [ 1 , 0 , 3 , - 1 ] , [ 2 , 1 , 0 , 2 ] ] )   > > >   B   =   np . matrix ( [ [ 4 , 1 , 0 ] , [ - 1 , 1 , 3 ] , [ 2 , 0 , 1 ] , [ 1 , 3 , 4 ] ] )   > > >   A   *   B   matrix ( [ [   9 ,   - 2 ,   - 1 ] ,   [   9 ,   9 ,   11 ] ] )   > > >   x   =   np . matrix ( [ 1 , 2 , 3 ] )   > > >   y   =   np . matrix ( [ 4 , 5 , 6 ] ) . transpose ( )   > > >   x   *   y   matrix ( [ [ 32 ] ] )   > > >   y   *   x   matrix ( [ [   4 ,   8 ,   12 ] ,   [   5 ,   10 ,   15 ] ,   [   6 ,   12 ,   18 ] ] )   > > >   np . dot ( x , y )   matrix ( [ [ 32 ] ] )   > > >   np . dot ( y , x )   matrix ( [ [   4 ,   8 ,   12 ] ,   [   5 ,   10 ,   15 ] ,   [   6 ,   12 ,   18 ] ] )   > > >     ( ! document . getElementById ( ' mathjaxscript _ pelican _#% @ # $ @ # ' ) )   {   var   align   =   \" center \" ,   indent   =   \" 0em \" ,   linebreak   =   \" false \" ;     ( false )   {   align   =   ( screen . width   <   768 )     \" left \"   :   align ;   indent   =   ( screen . width   <   768 )     \" 0em \"   :   indent ;   linebreak   =   ( screen . width   <   768 )     ' true '   :   linebreak ;   }   var   mathjaxscript   =   document . createElement ( ' script ' ) ;   mathjaxscript . id   =   ' mathjaxscript _ pelican _#% @ # $ @ # ' ;   mathjaxscript . type   =   ' text / javascript ' ;   mathjaxscript . src   =   ' / theme / js / mathjax / MathJax . js ' ;   mathjaxscript [ ( window . opera     \" innerHTML \"   :   \" text \" ) ]   =   \" MathJax . Hub . Config ( { \"   +   \"   config :   [ ' MMLorHTML . js ' ] , \"   +   \"   TeX :   {   extensions :   [ ' AMSmath . js ' , ' AMSsymbols . js ' , ' noErrors . js ' , ' noUndefined . js ' , ' mhchem . js ' ] ,   equationNumbers :   {   autoNumber :   ' AMS '   }   } , \"   +   \"   jax :   [ ' input / TeX ' , ' input / MathML ' , ' output / HTML - CSS ' ] , \"   +   \"   extensions :   [ ' tex2jax . js ' , ' mml2jax . js ' , ' MathMenu . js ' , ' MathZoom . js ' ] , \"   +   \"   displayAlign :   ' \" +   align   + \" ' , \"   +   \"   displayIndent :   ' \" +   indent   + \" ' , \"   +   \"   showMathMenu :   true , \"   +   \"   messageStyle :   ' normal ' , \"   +   \"   tex2jax :   {   \"   +   \"   inlineMath :   [   [ ' \\ \\ \\ \\ ( ' , ' \\ \\ \\ \\ ) ' ]   ] ,   \"   +   \"   displayMath :   [   [ ' $ $ ' , ' $ $ ' ]   ] , \"   +   \"   processEscapes :   true , \"   +   \"   preview :   ' TeX ' , \"   +   \"   } ,   \"   +   \"   ' HTML - CSS ' :   {   \"   +   \"   styles :   {   ' . MathJax _ Display ,   . MathJax   . mo ,   . MathJax   . mi ,   . MathJax   . mn ' :   { color :   ' inherit   !   important ' }   } , \"   +   \"   linebreaks :   {   automatic :   \" +   linebreak   + \" ,   width :   ' 90%   container '   } , \"   +   \"   } ,   \"   +   \" } ) ;   \"   +   \"   ( ' default '   ! = =   ' default ' )   { \"   +   \" MathJax . Hub . Register . StartupHook ( ' HTML - CSS   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax [ ' HTML - CSS ' ] . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" MathJax . Hub . Register . StartupHook ( ' SVG   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax . SVG . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" } \" ;   ( document . body   | |   document . getElementsByTagName ( ' head ' ) [ 0 ] ) . appendChild ( mathjaxscript ) ;   }",
            "tags":"algorithm",
            "url":"articles/numpy-module.html"
        },
        {
            "title":"sql数据库基础知识",
            "text":"小节 sqlite3 简要 sql 数据库 理论知识 。 SQL 数据库 mysql ， postgresql 相关 知识 本文 讨论 。   术语   数据库 （ database ） 简单 理解 一个 文件柜 。 DBMS （ database   management   system ） 数据库 管理系统 。   table   表 看作 文件柜 里 一个 结构化 文件 。 表格 数据 都   按行 存储   ， 头脑 中 牢记 。 一行 数据 称之为 一个   记录   。 SQL （ Structured   Query   Language ） 结构化 查询语言 。   sqlite3 安装 不 罗嗦 ， 若有 请 网络 查阅 。   第一个 例子   sqlite3 postgresql ， 客户端 / 服务器 概念 ， 文件 管理 ， sqlite3 数据库 一个 文件 ， 连接 不 文件 ， 会 自动 创建 数据库 文件 。 删除 数据库 删除 数据库 文件 即可 ， 一块 sqlite3 很 简单 。   数据库 一点 东西 :   wanze @ wanze - ubuntu64 : ~ / 桌面 $   sqlite3   mydb   SQLite   version   3.8 . 2   2013 - 12 - 06   14 : 53 : 30   Enter   \" . \"     instructions   Enter   SQL   statements   terminated     a   \" ; \"   sqlite >   create   table   mytable ( id   integer   primary   key ,     text ) ;   sqlite >   insert     mytable ( id , )   values ( 1 , \" Micheal \" ) ;   sqlite >   select   *     mytable ;   1 | Micheal   sqlite >   . table   mytable   sqlite >   . database   seq     file   - - -   - - - - - - - - - - - - - - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   0   main   / home / wanze / 桌面 / mydb   sqlite >   . header     sqlite >   select   *     mytable ;   id |   1 | Micheal   例子 连接 创建 mydb 数据库 ， CREATE   TABLE 语句 创建 database 数据库 一个 表 ， 接下来 INSERT   INTO 语句 表 插入 数据 ， SELECT 语句 查看 数据 。     . database   列出 连接 数据库 信息   . table   列出 表格 信息   . header     显示 SQL 表格 头   . quit   退出 sqlite3 命令行   还   .   查看 更 相关 信息 。   CREATE   TABLE   所示 创建表格 命令 格式 :   CREATE   TABLE   mytable (   id   INTEGER   PRIMARY   KEY ,     TEXT ) ;   mytable 创建 表格 名字 ， 接下来 一行 定义 表格 一个 字 段 或者说 一列 。 第一个 字 段 名字 ， 第二个 字 段 数据类型 定义 ， 可选 还 跟上 约束 词 。 先 字 段 数据类型 做出 。   字 段 数据类型     sqlite3 官方 文档   介绍   ， 支持 五种 数据类型 ：   NULL   空值   INTEGER   整型   REAL   浮点 型   TEXT   字符串 型   BLOB   字节 流型   sqlite3 类型 声明 字符串 还 建立 一套 语法 糖 规则 ， 语法 糖 规则 所示 :   类型 声明 ， 视为   affinity ;   声明 字符串 中 \" int \" （ 不 区分 大小写 ） 子 字符串 ， 视为 integer   affinity ；   ， 接下来 找到 \" char \" \" clob \" \" text \" ， 视为 text   affinity ； varchar ( 80 ) 会 简单 视为 text   affinity ;   ， 接下来 找到 \" blob \" ， 视为 blob ， 没 数据类型 声明 ， 视为   affinity ;   ， 接下来 找到 \" real \" \" floa \" \" doub \" ， 视为 float   affinity ;   都 视为 numeric   affinity 。   affinity sqlite 特有 概念 ， text   affinity 内置 TEXT 字符串 型 ， NULL ， TEXT BLOB 。 输入 数值 会 自动 转换 字符串 型 。 NUMERIC 会 自动 分配 INTEGER REAL 型 ， 输入 字符串 还 负责 转化 。 ， sqlite3 类型 声明 上 很 灵活 就行了 ， 喜欢 一套 类型 声明 即可 ， 五个 :   null   int   float   text   blob     null   integer   float   varchar   blob   。   字 段 约束 词   请 看 例子 :   sqlite >   CREATE   TABLE   products (   ... >   id   int   PRIMARY   KEY ,   ... >     text   NOT   NULL ,   ... >   quantity   int   NOT   NULL   DEFAULT   1 ,   ... >   price   real   NOT   NULL ) ;   PRIMARY   KEY   一个 表格 只能 一个 PRIMARY   KEY ， PRIMARY   KEY 约束 字 段值 唯一 不 空 ， 使 表格 中 记录 唯一 标识 。 表格 中 一个 列 几个 列 选定 primary   key 。 值得一提的是   integer   primary   key   自动 自动 分配 属性 ， id 一列 ， 不 赋值 ， 会 自动 添加 。   NOT   NULL   约束 该字 段 不 可取 空值 ， 该字段 赋值 。   DEFAULT   指定 该字 段 默认值 。   创建表格 表格 不   create   table       exists   department   ( dept _ id   int   primary   key ,     varchar     null   ) ;   更改 表格 属性   sqlite3 更改 表格 属性 功能 很 有限 ， 两个 ， 一个 更改 表格 名字 ， 还 一个 新建 一个 字 段 。 sqlite3 CREATE   TABLE 字 段 属性 设置 好 （ 迁移 单独 写 脚本 ） 。   ALTER   TABLE   语句 ， 所示 :   ALTER   TABLE   tablename   RENAME   TO   _ tablename ;   ALTER   TABLE   tablename   ADD   COLUMN   column _   column _ datatype ;   删除 表格   删除 前 请 慎重 。   DROP   TABLE   tablename ;   插入 记录   插入 一条 记录 前 所示   INSERT   INTO   语句 ， 所示 ：   INSERT   INTO   products   ( product _ ,   ,   price )   VALUES   ( 1 ,   ' Cheese ' ,   9.99 ) ;   这是 推荐 风格 ， 圆括号 跟着 列名 不 顺序 ， 值 一一对应 ， 一条 记录 列 不 都 列出来 ， 不写 会 默认值 。 INSERT   INTO 语句 通用 。   简单 插入 新 一行 数据 insert   语句 。   sqlite >   insert     mytable ( age )   values ( 6 ) ;   sqlite >   select   *     mytable ;   id     age   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   1   Alice   2   Betty   3   Cassie   4   Doris   5   Emily   6   Abby   7   Bella   8   6   不 重复 插入   主 键值 不 重复 才 插入 ：   insert     ignore     department   ( dept _ id ,   )   values   ( 1 ,   ' Operations ' ) ;   insert     ignore     department   ( dept _ id ,   )   values   ( 2 ,   ' Loans ' ) ;   insert     ignore     department   ( dept _ id ,   )   values   ( 3 ,   ' Administration ' ) ;   更新 记录   语句 用于 更新 特定 表格 数据 ：   sqlite >   update   mytable   set   age = 18     id   = 1 ;   sqlite >   select   *     mytable ;   id     age   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   1   Alice   18   2   Betty   3   Cassie   4   Doris   5   Emily   6   Abby   7   Bella   8   6   删除 记录   DELETE   FROM   products   WHERE   price   =   10 ;   DELETE   FROM   products ;   ： 第二个 语句 表内 记录 都 删除 ！   DELETE   FROM   语句 通用 。   查询 记录   讲解 ， 第一个 例子 简单 创建 一个 数据库 ， 代码 ：   ~ $   sqlite3   test . db   sqlite >   CREATE   TABLE   mytable ( id   INTEGER   PRIMARY   KEY ,     TEXT ) ;   sqlite >   INSERT   INTO   mytable ( id , )   values ( 1 , ' Alice ' ) ;   sqlite >   INSERT   INTO   mytable ( id , )   values ( 2 , ' Betty ' ) ;   sqlite >   INSERT   INTO   mytable ( id , )   values ( 3 , ' Cassie ' ) ;   sqlite >   INSERT   INTO   mytable ( id , )   values ( 4 , ' Doris ' ) ;   sqlite >   INSERT   INTO   mytable ( id , )   values ( 5 , ' Emily ' ) ;   sqlite >   . header     sqlite >   . mode   column   sqlite >   SELECT   *   FROM   mytable ;   id     - - - - - - - - - -   - - - - - - - - - -   1   Alice   2   Betty   3   Cassie   4   Doris   5   Emilyv   检索 语法 ：   sqlite >   SELECT   id   FROM   mytable ;   想要 显示 多个 列则 写 上 多个 列名 ， 列名 之间 逗号 隔开 。 检索 列 列名 处用 通配符   \\ verb + * +   匹配 列 。   排序   SELECT 语句 默认 情况 排序 ， 排序 ORDER   BY 字句 。 插入 几个 新 名字 ：   sqlite >   INSERT   INTO   mytable ( id , )   values ( 6 , ' Abby ' ) ;   sqlite >   INSERT   INTO   mytable ( id , )   values ( 7 , ' Bella ' ) ;   输入 排序 ：   sqlite >   SELECT   id ,   FROM   mytable   ORDER   BY   ;   id     - - - - - - - - - -   - - - - - - - - - -   6   Abby   1   Alice   7   Bella   2   Betty   3   Cassie   4   Doris   5   Emily   多个 列 排序   更新 表格 数据 。   sqlite >   ALTER   TABLE   mytable   ADD   COLUMN   age   int ;   sqlite >   UPDATE   mytable   set   age = 18   WHERE   id = 1 ;   sqlite >   update   mytable   set   age = 20     id   = 2 ;   sqlite >   update   mytable   set   age = 6     id   = 3 ;   sqlite >   update   mytable   set   age = 25     id   = 4 ;   sqlite >   update   mytable   set   age = 30     id   = 5 ;   sqlite >   update   mytable   set   age = 66     id   = 6 ;   sqlite >   update   mytable   set   age = 20     id   = 7 ;   sqlite >   INSERT   INTO   mytable ( id , , age )   values ( 8 , ' Alice ' , 20 ) ;   sqlite >   SELECT   *   FROM   mytable ;   id     age   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   1   Alice   18   2   Betty   20   3   Cassie   6   4   Doris   25   5   Emily   30   6   Abby   66   7   Bella   20   8   Alice   20   多个 列 排序 ：   sqlite >   SELECT   *   FROM   mytable   ORDER   BY     ,   age ;   id     age   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   6   Abby   66   1   Alice   18   8   Alice   20   7   Bella   20   2   Betty   20   3   Cassie   6   4   Doris   25   5   Emily   30   排序 ， 名字 age 排序 。   降序 排序   ORDER   BY 字句 默认 排序 升序 ， 想要 其为 降序 DESC 关键词 ， 所示 :   sqlite >   SELECT   *   FROM   mytable   ORDER   BY     ,   age   DESC ;   id     age   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   6   Abby   66   8   Alice   20   1   Alice   18   7   Bella   20   2   Betty   20   3   Cassie   6   4   Doris   25   5   Emily   30   DESC 关键词 放在 想要 降序 排序 列 。 想要 多个 列 降序 排序 ， 列   \\ uline { 都 加上 DESC 关键词 }   。   过滤 数据   SQL WHERE 字句 查询 时 过滤 数据 功能 ， WHERE 字句 ORDER   BY 字句 ， ORDER   BY 字句 放在 。   一个 简单 例子 所示 :   sqlite >   SELECT   *   FROM   mytable   WHERE   age   <   30 ;   id     age   - - - - - - - - - -   - - - - - - - - - -   - - - - - - - - - -   1   Alice   18   2   Betty   20   3   Cassie   6   4   Doris   25   7   Bella   20   8   Alice   20   值 字符串 加上 单引号 ， :   ' string '   ， 符号 含义 都 一目了然 ， :   =   ,   < >   ,   ! =   ,   <   ,   < =   ,   ! <   ,   >   ,   > =   , ! >   。   BETWEEN   两个 值 之间 ，   IS   NULL   判断 NULL 值 。   BETWEEN :   SELECT   prod _ ,   prod _ price   FROM   Products   WHERE   prod _ price   BETWEEN   5   AND   10 ;   NULL   无值 ， 字 段 包含 0 ， 空 字符串 。   IS   NULL   用法 :   SELECT   prod _   FROM   Products   WHERE   prod _ price   IS   NULL ;   外键 引用   外键 引用 sqlite3 中 加上 一行 设置 :   PRAGMA   foreign _ keys   =   ON ;   外键 引用 语法 mysql 类似 ，   constraint   pk _ product _ type   这一 描述 外 。 sqlite3   \\ textbf { date }   类型 ， 内部 会 自动 text , int real 类型 。 声明 写 ， 值得一提的是 sqlite3 date 相关 函数 支持 。   外键 引用 更 信息 请 参看   官方 文档   。   PRAGMA   foreign _ keys   =   ON ;   create   table       exists   employee   ( emp _ id   int   primary   key ,   fname   varchar     null ,   lname   varchar     null ,   start _ date   date     null ,   end _ date   date ,   superior _ emp _ id   int   ,   dept _ id   int   ,   title   varchar ,   assigned _ branch _ id   int   ,   foreign   key   ( superior _ emp _ id )   references   employee   ( emp _ id ) ,   foreign   key   ( dept _ id )   references   department   ( dept _ id ) ,   foreign   key   ( assigned _ branch _ id )   references   branch   ( branch _ id )   ) ;   SQL 关系 模型 浅谈   内部 联接   联接 抽象 理论 讨论 很 ， 谈论 ， 读者 沉思 。 一个 SQL 表格 看作 一个 外部 世界 模型 ， 看作 柏拉图 谈论 理念 。 外部 世界 模型 来说 ， 彼此之间 两种 关系 :   第一种 继承 关系 ， 第二种 组合 关系 。 继承 关系 指 一个 苹果 实体 来说 ， 各种各样 属性 ， 不 装入 一个 数据库 中 ， 比如说 苹果 实体 供应商 信息 ， 苹果 重量 颜色 信息 。 更 做法 描述 苹果 （ 产品 ） 供应商 信息 单独 放入 一个 模型 ， 描述 苹果 重量 颜色 信息 单独 放入 一个 模型 ， 水果店 信息 。 ， 衍生 模型 都 一个   parent _ id   类似 字 段 属性 描述 衍生 模型 记录 母体 parent ， 多个 衍生 模型 一个 实体 对象 上 统一 ， 表 联接 。 看作 表 联接 最终 成果 心目 中所想 超大型 SQL 表格 ， 苹果 模型 ， 存放 苹果 相关 属性 信息 。 SELECT 语句 查 即可 。   第二个 组合 关系 苹果 苹果皮 苹果肉 ， 各子 母体 某种 实体性 ， 苹果 模型 上 如同   pingguopi _ id     pingguorou _ id   字 段 属性 ， 约定   _ id   结尾 都 视作 苹果 组成部分 ， 都 视作 非 组成部分 独独 苹果 模型 属性 。 组合 关系 很 ， 再 谈及 ， 谈论 表格 联接 ， 表格 联接 描述 模型 之间 继承 关系 。   语法 所示 :   SELECT   , price , weight   FROM   Supplier , Info   WHERE   Supplier . parent _ id   =   Info . parent _ id   约定 Supplier Info 两个 衍生 模型 内 存储   parent _ id   Pingguo 模型 中 记录 号 。 记录 号 代表 同一个 苹果 实体 。 同一个 苹果 实体 ,   price ,   weight   属性 列出来 。   不 WHERE 字句 会 执行 笛卡尔 乘积 操作 ， 字 段 属性 随意 组合 ， 现实意义 。   SQL 规范 ， 不 推荐 WHERE 字句 表达 ， 内部 联接 （ INNER   JOIN ） 语句 更 推荐 写成 形式 :   SELECT   , price , weight   FROM   Supplier   INNER   JOIN   Info   ON   Supplier . parent _ id   =   Info . parent _ id   SQL 语法 一个 术语 形容 SELECT 语句 ， 内部 联接 。 WHERE ON ， 关键词 INNER   JOIN 。 SQL 联接 默认 方式 内部 联接 。   视图   视图 虚拟 表 ， 不 包含 数据 ， 更 确切 来说 一种 检索 手段 。 视图 嵌套 视图 ， 视图 不 包含 数据 ， 依赖于 检索 ， 过多 视图 会 很 降低 性能 。",
            "tags":"SQL",
            "url":"articles/sql-basic.html"
        },
        {
            "title":"sql数据库学习之cookbook",
            "text":"前言   列出 日常 操作 案例 ， 参考 学习 ， 触类旁通 学习 下 SQL 高级 知识 。   条件 删除 表格 重复 行   DELETE   FROM   news   T1   USING   news   T2   WHERE   T1   .   id   <   T2   .   id   - -   delete     older   versions   AND   T1   .   url   =   T2   .   url   ;   - -   add     columns     needed   这句 话 删除 news 表格 中 url 重复 行 ， 删除 id 小 行 （ T1 . id <   T2 . id ）   delete 语句 说 简单 点 子句 表格 ， 类似 select ； 说 点 表格 ， 连接 - join 。   join 简单 理解   ( a , b )   *   ( a ,   b )   = >   a   a   ,   a   b   ,   b   a   ,   b   b   SQL 表格 笛卡尔 乘积 组合 再 基于 给定 条件 过滤 。   delete   ...     ...   参考   postgresql 文档   表格 名字 - join ， 而本 表格 表格   join 组合 过滤 过滤 ， 举个 例子 会 清晰 一点 ：   id   url   1   a   2   b   3   a   - join 后 组合 ：   1   a   - - -   1   a   1   a   - - -   2   b   1   a   - - -   3   a   2   b   - - -   1   a   2   b   - - -   2   b   2   b   - - -   3   a   3   a   - - -   1   a   3   a   - - -   2   b   3   a   - - -   3   a   再 过滤 ， url 行   select   *     newtable   T1     join   newtable   T2     T1   .   url   =   T2   .   url   1   a   - - -   1   a   1   a   - - -   3   a   2   b   - - -   2   b   3   a   - - -   1   a   3   a   - - -   3   a     id 小 一点   select   *     newtable   T1     join   newtable   T2     T1   .   url   =   T2   .   url     T1   .   id   <   T2   .   id   1   a   - - -   3   a   T1     1   a   一行 ， 执行 delete 操作 删掉 。   - join 情况 重复 行 过滤 ，   T1 . id   < =   T2 . id   会 表格 删掉 。   表格 字 段值 更新 表格   update   news   set   insert _ time   =   t2   .   pub _ time     news   t2     news   .   html   =   ' '     news   .   insert _ time   > =   ' 2019 - 11 - 19 '     news   .   id   =   t2   .   id   ;   参考 postgresql 官方 文档 ， update ... ...   类似   select   _ list   table ， 表格     join 。     join update 操作 引用 表格 值 。   快速 检查 一行   参考   网页   ， 所示 ：   select   exists ( select   1     contact     id = 12 )   值得一提的是 ， python SQL 数据库 通用 DB2 接口 ， pymysql psycopg2 查询 python bool 对象 ， True False ， exists 函数 。",
            "tags":"SQL",
            "url":"articles/sqlshu-ju-ku-xue-xi-zhi-cookbook.html"
        },
        {
            "title":"mysql数据库",
            "text":"简介   本文 假设 读者 sql 一个 初步 ， 讨论 mysql 相关 细节 。 安装 ubuntu 下 简单 apt - 安装 ， 所示 ， 不 赘述 。   sudo   apt -   install   mysql - server   mysql - client   mysql 入门   小节 代码 依次 演示 第一个 例子 ， 好 读者 mysql 有个 初步 。   登录   root 用户 登录   mysql   - u   root   - p   密码 安装 mysql 时 情况 ， 设置 密码 Enter 。   mysql 数据库 配置   mysql   /     . conf   配置 外 ， 很多 相关 配置 一个 名叫 mysql 数据库 。   列出 数据库   show   databases   ;   切换 数据库   先 切换 mysql 数据库 看 。     mysql   ;   列出 表格   show   tables   ;   描述 过程 GUI 程序 （   emma   ） 来点 开看 。 先 user 表格 ， 表格 存储 mysql 用户 信息 。   简单 检索 表格   select   *     user   ;   内容 ， 显示 效果 不太好 。   创建 用户   user 表格 插入 一条 记录 实际上 新建 一个 新 mysql 用户 ， 所示 :   insert     user   (   host   ,   user   ,   password   ,   select _ priv   ,   insert _ priv   )   values   (   ' localhost '   ,   ' wanze '   ,   password   (   ' 123456 '   ) ,   ' Y '   ,   ' Y '   ) ;   删除 用户   user 表格 删除 一条 记录 删除 mysql 用户 ， 创建 用户 删除 :   delete     user     user   =   ' wanze '   ;   好 ， 再 用户 加进去 ， 只 用户 select insert 权限 ， 再 几个 权限 。   更新 记录   mysql   >   update   user   - >   set   update _ priv   =   ' Y '   ,   - >   delete _ priv   =   ' Y '   ,   - >   create _ priv   =   ' Y '   ,   - >   drop _ priv   =   ' Y '   - >     user   =   ' wanze '   ;   用户 新 加上 update ， delete ， create drop 权限 。 用户 很多 权限 设置 ，   用户 访问 权限 管理   修改 mysql user 数据库 方法 之外 ， 推荐 用户 访问 权限 管理 语句 ：   GRANT   ALL   PRIVILEGES   ON   test   .   *     ' username '   @   ' localhost '   ;   test database   ， 带个   *   表格 ， 想要 用户 访问 database ， 写   * . *   。   第二个 username 用户名 ， localhost 本地连接 。 再 来看 例子 ：   GRANT   ALL   PRIVILEGES   ON   * . *     wanze @ ' % '   IDENTIFIED   BY   ' 123455 ' ;     %   远程 连接 ， 写 host 。 跟上   IDENTIFIED   BY   设置 用户 登录 密码 。   创建 数据库   先 创建 一个 新 数据库 :   create   database   test   ;   创建 数据库 指定 字符集   create   database   database _   character   set   utf8   collate   utf8 _ unicode _ ci ;   创建表格   mysql   >   create   table   test   (   x   int   ,   y   integer   ,   z   integer   ) ;   简单 创建 一个 名叫 test 表格 ， 定义 表头 三个 整数 ， integer int 一个 。   插入 数据   插入 数据 sql 数据库 insert   语句 格式 。   mysql   &   gt   ;   insert     test   (   x   ,   y   ,   z   )   values   (   1   ,   2   ,   3   )   ;   第一个 例子 ， 简单 mysql 情况 ， 详细 讨论 。   删除 table   drop   table   test   ;   删除 database   drop   database   test   ;   至此 新建 数据库 信息 都 删除 ， 第二个 例子 ， 建立 更 现实意义 数据库 。   mysql 进阶   创建 learning _   database 。 创建 一个 student 用户 ， learning _   database 拥有 权限 。   mysql   -   u   root   mysql   >   create   database   learning _   ;   mysql   >   grant     privileges     learning _   .   *     ' student '   @   ' localhost '   ;   创建表格   写 好 sql 语句 文件 刷 进去 ， 所示 :   mysql   - u   student   learning _   <   mysql _ learning _ . sql     - u   接 用户名 ， 操作 database 名字 。   文件 简单 写 上 一句 :   create   table   department   (   dept _ id   smallint   unsigned     null   auto _ increment   ,     varchar   (   20   )     null   ,   constraint   pk _ department   primary   key   (   dept _ id   )   ) ;   很 ， 新建 department table ， 定义 一列 dept _ id   ， 其为   smallint   ，   unsigned   （ 是从 0 65535 ） ，     null   说 这列 为空 ，   auto _ increment   说 这列 数值 自动 增加 （ 主键 id ） ； 一列   varchar ( 20 )   ， 变长 字符串 ， 长度 20 ， 类似   char ( 20 )   ， 其为 定长 字符串 ， 都 会   自动 填充 空格   ，   null 限定 非空 。 约束 语句 额外 说 。   constraint   约束 ， pk _ department （ 名字 貌似 随意 ） 指 约束 department table primary   key ， 跟上 primary   key   ( dept _ id )   ， 约束 table   department 主 键值   dept _ id   一列 。   create   table       exists   department   (   dept _ id   smallint   unsigned     null   auto _ increment   ,     varchar   (   20   )     null   ,   constraint   pk _ department   primary   key   (   dept _ id   )   ) ;   create   table       exists   branch   (   branch _ id   smallint   unsigned     null   auto _ increment   ,     varchar   (   20   )     null   ,   address   varchar   (   30   ) ,   city   varchar   (   20   ) ,   state   varchar   (   2   ) ,   zip   varchar   (   12   ) ,   constraint   pk _ branch   primary   key   (   branch _ id   )   ) ;   创建 department 表格 语句 加上       exists   ， 表格 不 才 会 新建 table ， sql 文件 重复 刷 出错 。 新建 branch 表格 sql 语句 增加 新 东西 ， 往下 看 。   值得一提的是 mysql date 类型 只能 存储 公元前 1000 年 公元 9999 年 之间 date 。   接下来 重点 讲   foreign   key   约束 写法 。   constraint   fk _ e _ emp _ id   foreign   key   ( superior _ emp _ id )   references   employee   ( emp _ id ) ,   fk _ e _ emp _ id 名字 带有 随意性 ， 大致 表达 出 fk _ table 下 一列 即可 。   foreign   key   外 键值   ( superior _ emp _ id )   一列 外 键值 ， references   引用   employee   表格 ( emp _ id )   一列 。 总 superiro _ emp _ id 一列 一个 外 键值 约束 列 ， 其值 只 取自 employee 表格 emp _ id 一列 ， 逻辑 含义 其值 引用 自它 。 比如说 雇员 张三在 id 3 ， 张三 上司 张三丰 ， id 4 。 张三 修改 上司 值 ， 雇员 列表 id 号 雇员 。 （ 外键 引用 用于 SQL 表格 中               情况 ， 用内 连接 查询 ， 该外 键值 约束 列 取值 一个 表格 很多 列 ， 再 详细 讨论 。 ）   刷下去 ， 强烈推荐 读者 emma GUI 程序 实时 查看 :   create   table       exists   customer   (   cust _ id   integer   unsigned     null   auto _ increment   ,   fed _ id   varchar   (   12   )     null   ,   cust _ type _ cd   enum   (   ' I '   ,   ' B '   )     null   ,   address   varchar   (   30   ) ,   city   varchar   (   20   ) ,   state   varchar   (   20   ) ,   postal _ code   varchar   (   10   ) ,   constraint   pk _ customer   primary   key   (   cust _ id   )   ) ;   值得 一讲 :   cust _ type _ cd   enum ( ' I ' , ' B ' )     null ,   mysql 枚举 类型 ， cust _ type _ cd 一列 只能 取 ' I ' ' B ' 两个 值 。   插入 数据   代码 :   insert     department   (   dept _ id   ,     )   values   (   null   ,   ' Operations '   ) ;   insert     department   (   dept _ id   ,     )   values   (   null   ,   ' Loans '   ) ;   insert     department   (   dept _ id   ,     )   values   (   null   ,   ' Administration '   ) ;   department dept _ id 打开 auto _ increment 特性 ， 简单 一列 赋值   null   即可 ， 其会 自动 添加 一个 主键 数字 。   创建表格     exists 逻辑 ， sql 脚本 重复 刷 都 ， 插入 数据     exists 逻辑 ？ 请 参看   网页   。   insert   ignore   语句 重复 插入 ， 这是 插入 语句 改成 样子 :   insert   ignore     department   (   dept _ id   ,     )   values   (   1   ,   ' Operations '   ) ;   insert   ignore     department   (   dept _ id   ,     )   values   (   2   ,   ' Loans '   ) ;   insert   ignore     department   (   dept _ id   ,     )   values   (   3   ,   ' Administration '   ) ;   id 赋值 ， 其为 primarykey ， 设置 null 语句 会 重复 插入 ， primarykey 重复 ， insert 语句 才 插入 。   这句 :   insert   ignore     employee   (   emp _ id   ,   fname   ,   lname   ,   start _ date   ,   dept _ id   ,   title   ,   assigned _ branch _ id   )   values   (   1   ,   ' Michael '   ,   ' Smith '   ,   ' 2001 - 06 - 22 '   ,   (   select   dept _ id     department       =   ' Administration '   ) ,   ' President '   ,   (   select   branch _ id     branch       =   ' Headquarters '   ) ) ;   子 查询   SQL 三种 类型 表 :   一种 常见 存储 那种 SQL 表格 ； 第二种 临时 表格 ， 子 查询 返回 表格 ； 一种 虚拟 表 ， 视图 。   子 查询 实际上 一个 select 语句 返回 一个 临时 SQL 表格 ， 最 简单 一个 select 语句 语句 ， 一种 用法 常用 表格 多列 值 复制 转移 操作 ，   insert   select   语句 ， 一个 insert 语句 一个 select 语句 组合而成 。 所示   1   :   INSERT   INTO   Customers   ( CustomerName ,   Country )   SELECT   SupplierName ,   Country   FROM   Suppliers ;   SQL 语句 Suppliers 表格 SupplierName Country 两列 值 都 复制到 Customers 表格 中 去 ， CustomerName Country 两列 。   例子 第三种 用法 ， 其是 一个 select 语句   括号 ( ) 括   。 返回 一列 值 ， 情况 一个 值 ， 值 提取 insert   语句 ， 返回 多个 值 情况 ， 过滤 条件       ( select   … )   ， 子 查询 返回 多个 值 。   往下 看 :   create   temporary   table   emp _ tmp     select   emp _ id   ,   fname   ,   lname     employee   ;   update   employee   set   superior _ emp _ id   =   (   select   emp _ id     emp _ tmp     lname   =   ' Smith '     fname   =   ' Michael '   )     ( (   lname   =   ' Barker '     fname   =   ' Susan '   )     (   lname   =   ' Tyler '     fname   =   ' Robert '   ) ) ;     create   temporary   table   语句 select 语句 创建 一个 临时 表格 ， 临时 表格 session 看 ， 退出 session 临时 表格 会 自动 drop 掉 。   update 语句 格式 熟悉 ， 关键 理解 字句 过滤 条件 。 SQL 语句 : employee 表格 中 Barker   Susan Tyler   Robert 两个 伙计 上司 设置 Michael   Smith emp _ id 。 过滤 条件 逻辑 逻辑 想 熟悉 编程 都 很 ， 不 赘述 。   交叉 连接   接下来 语句 显得 :   insert   ignore     account   (   account _ id   ,   product _ cd   ,   cust _ id   ,   open _ date   ,   _ activity _ date   ,   status   ,   open _ branch _ id   ,   open _ emp _ id   ,   avail _ balance   ,   pending _ balance   )   select   1   ,   a   .   prod _ cd   ,   c   .   cust _ id   ,   a   .   open _ date   ,   a   .   _ date   ,   ' ACTIVE '   ,   e   .   branch _ id   ,   e   .   emp _ id   ,   a   .   avail   ,   a   .   pend     customer   c   cross   join   (   select   b   .   branch _ id   ,   e   .   emp _ id     branch   b     join   employee   e     e   .   assigned _ branch _ id   =   b   .   branch _ id     b   .   city   =   ' Woburn '   limit   1   )   e   cross   join   (   select   ' CHK '   prod _ cd   ,   ' 2000 - 01 - 15 '   open _ date   ,   ' 2005 - 01 - 04 '   _ date   ,   1057   .   75   avail   ,   1057   .   75   pend   union     select   ' SAV '   prod _ cd   ,   ' 2000 - 01 - 15 '   open _ date   ,   ' 2004 - 12 - 19 '   _ date   ,   500   .   00   avail   ,   500   .   00   pend   union     select   ' CD '   prod _ cd   ,   ' 2004 - 06 - 30 '   open _ date   ,   ' 2004 - 06 - 30 '   _ date   ,   3000   .   00   avail   ,   3000   .   00   pend   )   a     c   .   fed _ id   =   ' 111 - 11 - 1111 '   ;   SQL 语句 主体 insert   select 语句 ， 显得 select 语句 customer （ 别名 c ） 一个 子 查询 语句 生成 表格 （ 别名 e ） 一个 子 查询 语句 生成 表格 （ 别名 a ）   cross   join   而成 一个 表格 。   理解 cross   join 概念 ， 不 读者 接触   join ， 内 连接 概念 ， 接触 SQL 表格 join 不 加 过滤 条件 生成 表格 两个 SQL 表格 笛卡尔 积 。 笛卡尔 积 ， 假设 一个 表格 三行 ， a 行 b 行 c 行 ， 假设 一个 表格 两行 ， 1 行 2 行 ， 两个 表格 笛卡尔 积 生成 一个 大 表格 ， ( a1 行 a2 行 b1 行 b2 行 c1 行 c2 行 ) ， 一共 3 * 2 = 6 行 。   cross   join 交叉 连接 实际上 多个 表格 之间 笛卡尔 积 运算 组合 一个 更大 表格 。   内 连接   例子 中 第一个 子 查询 语句     join   关键词 ， 其是 内 连接 。 内 连接 看作 交叉 连接 生成 表格 基础 上 进一步 加上 过滤 条件 行给 删除 掉 。   来看 :   select   b . branch _ id ,   e . emp _ id ,   e . assigned _ branch _ id     branch   b   cross   join   employee   e   ;   branch 表格 4 条 记录 ， branch 18 条 记录 ， cross   join 组合 出 72 条 记录 。   再 来看 查询 :   select   b . branch _ id ,   e . emp _ id     branch   b     join   employee   e     e . assigned _ branch _ id   =   b . branch _ id ;   两个 SQL 表格 cross   join 大S QL 表格 数据 组合 不 ，   join 关键词 过滤 生成 大S QL 表格 更 现实意义 。 一个 雇员 只 一个 分公司 ， cross   join 雇员 都 四个 分公司 ，   join 加上 控制 雇员 分配 分公司 正是 连接 分公司 号 。 更 现实意义 连接 。 理解 ， 雇员 分公司 属性 id 1 ， 连接 分公司 表格 ， ， 才能 保证 分公司 表格 属性 雇员 。   :   mysql >   select   b . branch _ id ,   e . emp _ id , b . city     branch   b     join   employee   e     e . assigned _ branch _ id   =   b . branch _ id ;   + - - - - - - - - - - - + - - - - - - - - + - - - - - - - - - +   |   branch _ id   |   emp _ id   |   city   |   + - - - - - - - - - - - + - - - - - - - - + - - - - - - - - - +   |   1   |   1   |   Waltham   |   |   1   |   2   |   Waltham   |   |   1   |   3   |   Waltham   |   |   1   |   4   |   Waltham   |   |   1   |   5   |   Waltham   |   |   1   |   6   |   Waltham   |   |   1   |   7   |   Waltham   |   |   1   |   8   |   Waltham   |   |   1   |   9   |   Waltham   |   |   2   |   10   |   Woburn   |   |   2   |   11   |   Woburn   |   |   2   |   12   |   Woburn   |   |   3   |   13   |   Quincy   |   |   3   |   14   |   Quincy   |   |   3   |   15   |   Quincy   |   |   4   |   16   |   Salem   |   |   4   |   17   |   Salem   |   |   4   |   18   |   Salem   |   + - - - - - - - - - - - + - - - - - - - - + - - - - - - - - - +   18   rows     set   ( 0.00   sec )       b . city   =   ' Woburn '   实际上 限定 一个 分公司 。   mysql >   select   b . branch _ id ,   e . emp _ id , b . city     branch   b     join   employee   e     e . assigned _ branch _ id   =   b . branch _ id     b . city = ' Woburn ' ;   + - - - - - - - - - - - + - - - - - - - - + - - - - - - - - +   |   branch _ id   |   emp _ id   |   city   |   + - - - - - - - - - - - + - - - - - - - - + - - - - - - - - +   |   2   |   10   |   Woburn   |   |   2   |   11   |   Woburn   |   |   2   |   12   |   Woburn   |   + - - - - - - - - - - - + - - - - - - - - + - - - - - - - - +   3   rows     set   ( 0.00   sec )     limit   1   只 返回 一条 记录 。 最终 cross   join 生成 大 表格 还 加上 过滤 条件     c . fed _ id   =   ' 111 - 11 - 1111 ' ;   一个 顾客 fed _ id 都 唯一 ， 实际上 custom 表格 交叉 连接 一条 记录 ， 三个 表格 cross   join 情况 等同于 两个 表格 一条 记录 属性 都 加上 ， 再 cross   第三个 表格 ， 第三个 表格 三条 记录 ， 最终 大 表格 三条 记录 。   union     union     多个 数据 集 合并 。 一种   union   用法 ，   union   会 删除 重复 项 ， union   单纯 合并 。 所示 :   mysql >   select   ' CHK '   prod _ cd ,   ' 2000 - 01 - 15 '   open _ date ,   ' 2005 - 01 - 04 '   _ date ,   - >   1057.75   avail ,   1057.75   pend   union     - >   select   ' SAV '   prod _ cd ,   ' 2000 - 01 - 15 '   open _ date ,   ' 2004 - 12 - 19 '   _ date ,   - >   500.00   avail ,   500.00   pend   union     - >   select   ' CD '   prod _ cd ,   ' 2004 - 06 - 30 '   open _ date ,   ' 2004 - 06 - 30 '   _ date ,   - >   3000.00   avail ,   3000.00   pend ;   + - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - + - - - - - - - - - +   |   prod _ cd   |   open _ date   |   _ date   |   avail   |   pend   |   + - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - + - - - - - - - - - +   |   CHK   |   2000 - 01 - 15   |   2005 - 01 - 04   |   1057.75   |   1057.75   |   |   SAV   |   2000 - 01 - 15   |   2004 - 12 - 19   |   500.00   |   500.00   |   |   CD   |   2004 - 06 - 30   |   2004 - 06 - 30   |   3000.00   |   3000.00   |   + - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - + - - - - - - - - - +   3   rows     set   ( 0.01   sec )   别名   说 select 字句 运算 列 ， 还 构建 一个 列 ， 列 mysql 会 自动 创建 默认 名字 ， 指定 名字 ，     关键词 ， 所示 :   select   emp _ id ,   ' ACTIVE '     status ,   emp _ id   *   3.1415926     empid _ x _ pi ,   upper ( lname )     _ _ upper     employee ;     关键词 省略 ， 表达 ， 推荐 加上     关键词 ， SQL 语句 可读性 更高 。   去除 重复 行   所示   distinct   关键词 select 字句 过滤 掉 重复 行 。   select   distinct   cust _ id     account ;   备份 还原   mysql 备份 操作   mysqldump   命令 ， 生成 一个 sql 文件 ， 还原 实际上 加载 sql 文件 即可 。   还原   过程 所示 :   mysql   - u   root   - p   newdatabase   <   dump . sql   备份     mysqldump   命令 ：   mysqldump   - u   user   - h   127.0 . 0.1   - P   8888   - p   - v   olddatabase   >   dump . sql   - u   :   设置 登录 用户名   - h   :   连接 数据库 服务器 地址   - P   :   连接 数据库 服务器端 口   - v   :   显示 聒噪 信息   - p   :   mysql 命令 类似 ， 下 输入 密码   其后 必填 参数 想要 dump database 名字 。   备份 还 加上 查询 语句   mysqldump   - - tables   article   - - = \" created _   >   ' 2017 - 11 - 19 ' ; \"   - - databases   wxarticles   - u   root   - p123456   重命名 数据库   备份 还原 过程 组合 重命名 数据库 。   hendrasaputra   介绍 ， 做 降低 I / O 。   mysqladmin   - u   username   - p   create   newdatabase   mysqldump   - u   username   - v   olddatabase   - p   |   mysql   - u   username   - p   - D   newdatabase   推荐 扩展 略读 篇文章 ， mysqlworkbench 相关 备份 还原 重命名 操作 ：   mysqlworkbench 数据库 重命名   python 连接   django 连接 mysql 默认   mysql - python ， 更 喜欢 pymysql ，   manage . py   加上 两句 ：   import   pymysql   pymysql . install _ _ MySQLdb ( )   参考   网页   。   附录   server       错误   错误 原因 很多 ， 情况 mysql 包 大小 设定 太小 ：   max _ allowed _ packet   =   16M   参考资料   本网页 参考 《 SQL 学习指南 一书 ， 第二 版 ， Alan   Beaulieu 著 ， 张伟超 ， 林 青松 译 。   Footnotes :   1   参考 [ 网页 ] ( http : / / www . w3schools . / sql / sql _ insert _ _ select . asp ) 。",
            "tags":"SQL",
            "url":"articles/mysqlshu-ju-ku.html"
        },
        {
            "title":"postgresql数据库",
            "text":"安装 配置   ubuntu 下 简单 安装 ：   sudo   apt -   install   postgresql   centos 下 安装 ：   sudo   yum   install   postgresql - server   postgresql - contrib   centos 下 运行 命令 ：   sudo   postgresql - setup   initdb   安装 ， 牢记 一点 ， 新 安装 PostgreSQL 数据库 还   postgres   用户 新建 role （ 说 用户 ） 新建 数据库 权限 。   postgres   用户 执行   createuser     createdb   命令 。 先不急 学习 SQL 语句 ， postgresql 用户 群组 权限 设置 稍微 ， postgresql ， 一块 有个 。   用户 群组 权限 管理   postgresql 登录 用户 用户 概念 术语 Rules ， 都 称之为 用户 （ rules ） ， 理解 用户 确立 一系列 访问 修改 数据库 规则 。 rules 包含 rules ， 包含 rules rules 称之为 群组 （ group   rules ） ， 群组 包含 群组 ， 都 推荐 简单 分为 用户 （ rules ） 群组 用户 （ group   rules ） 两类 。 用户 登录 权限 称之为 登录 用户 （ login   rules ） ， 群组 用户 赋予 登录 权限 ， 出于 简单 没 做 。 rules 简单 划分 分为 这三类 :   用户 ， 指 登录 权限 用户 。   登录 用户 ， 登录 用户 ， 用户 ， 登录 权限 。   群组 用户 ， 包含 用户 rules 。   postgresql 还 提供   superuser   超级 用户 这一 类型 ， 默认 登录 ， 数据库 拥有 权限 — — 创建 数据库 ， 创建 用户 ， 数据库 查 增删 改等 。 实际上 superuser 加上   login   属性 ， 不 推荐 做 ， 不 超级 用户 ， 用户 数据库 权限 分配 。   默认 创建 postgres 用户 连接 ， 至少 postgres 数据库 权限 ， 还 不 太 superuser ， 数据库 权限 ， 再谈 。   修改 postgres 密码   sudo   - u   postgres   psql   postgres   postgres = #   \\ password   postgres   Enter     password :   Enter     :   一点 psql 连接 （ postgres ） 输入   \\ password   修改 postgres 密码   TCP / IP   方式 连接 postgresql 数据库 密码 ， 系统 passwd 管理 密码 。   postgres 用户   postgres 用户 信息 所示 :   postgres : x : 121 : 131 : PostgreSQL   administrator , , , : / var / lib / postgresql : / bin / bash   新建 postgres 群组 :   postgres : x : 131 :   121 uid ， 131 gid ，   / var / lib / postgresql   文件夹 postgres 用户 主 文件夹 ， postgresql 配置 数据 都 放在 。 会 保存   . psql _ history   文件 权限 ， 参看   网页   ， 确认 文件夹 用户 群组 都 postgres 。   查看 用户     这篇 网页   介绍 ，   pg _ roles   一个 view 视图 ， 一个   pg _ authid   简单 可读 视图 封装 ， 所示 ， 来说 差异 ， postgres superuser ， login   user 。   select   rolname , rolsuper , rolcreaterole , rolcreatedb , rolcanlogin     pg _ roles ;   rolname   |   rolsuper   |   rolcreaterole   |   rolcreatedb   |   rolcanlogin   - - - - - - - - - - + - - - - - - - - - - + - - - - - - - - - - - - - - - + - - - - - - - - - - - - - + - - - - - - - - - - - - -   postgres   |   t   |   t   |   t   |   t   wanze   |   t   |   t   |   t   |   t   select   rolname , rolsuper , rolcreaterole , rolcreatedb , rolcanlogin     pg _ authid ;   rolname   |   rolsuper   |   rolcreaterole   |   rolcreatedb   |   rolcanlogin   - - - - - - - - - - + - - - - - - - - - - + - - - - - - - - - - - - - - - + - - - - - - - - - - - - - + - - - - - - - - - - - - -   postgres   |   t   |   t   |   t   |   t   wanze   |   t   |   t   |   t   |   t   新建 用户   新建 一个 用户 :   create   role   _ ;   最起码 登录 login 权限 :   create   role   _   login ;   postgresql 时 ， 用户 不 ， PostgreSQL 将会 报错 :   createdb :       connect     database   template1 :   FATAL :   role   \" wanze \"       exist   删除 用户   drop   role   _ ;   用户名 不 报错 写法 :   drop   role     exists   _ ;   改变 用户 权限   所示 改变 一个 用户 权限 。   alter   role   _   createdb ;   参照 手册 ， 关键词 :   SUPERUSER   |   NOSUPERUSER   CREATEDB   |   NOCREATEDB   CREATEROLE   |   NOCREATEROLE   CREATEUSER   |   NOCREATEUSER   INHERIT   |   NOINHERIT   LOGIN   |   NOLOGIN   REPLICATION   |   NOREPLICATION   改变 用户 密码   新建 用户 ， :   create   role   _   password   \" _ password \" ;     alter   role   :   alter   role   _   password   \" _ password \" ;   新建 一个 群组   CREATE   ROLE   royalty   INHERIT ;   群组 用户 增加 登录 用户   GRANT   royalty   TO   leo ;   GRANT   royalty   TO   regina ;   pg _ hba . conf   很多 连接 文件 配置 好 ， 详细 研究 文件 。   #   #   local   DATABASE   USER   METHOD   [ OPTIONS ]   #   host   DATABASE   USER   ADDRESS   METHOD   [ OPTIONS ]   #   hostssl   DATABASE   USER   ADDRESS   METHOD   [ OPTIONS ]   #   hostnossl   DATABASE   USER   ADDRESS   METHOD   [ OPTIONS ]   local   指 本地连接   host   指 plain ssl 加密 TCP 套 接字 连接 （ 指 http https ）   hostssl   指 ssl 加密 TCP 套 接字 连接   hostnossl   指 plain   简单 TCP 套 接字 连接   DATABASE   设置 连接 数据库 ， 常见   ADDRESS     127.0 . 0.1 / 32   本地连接 ipv4 ，   0.0 . 0.0 / 0   指 ipv4 外网 。 这是 一种 网域 段 表示法 。   METHOD   trust ， reject ， md5 （ 加密 密钥 ） ， password （ 明文 密钥 ）   人 困惑 peer 方法 查阅 文档 解释 ：   The   peer   authentication   method   works     obtaining     client ' s   operating   system   user         kernel             allowed   database   user     (   optional   user     mapping ) .   This   method       supported     local   connections .   peer 认证 方法 获取 客服 端 操作系统 用户名 ， 数据库 用户名 。 方法 只 local 连接 。   ident 方法 本地连接 会 peer 方法 ， 官方 文档 解释 上 字面 很 ， 区别     ident   server   , 一个   kernel ，   一个   ident   server ，   暂时 不 懂 ？   psql   参考   网页   。   \\ l     \\ list   :   列出 数据库   \\ du   :   列出 用户   \\ dt   *   :   列出 数据库 表格   \\ c     \\ connect   :   切换 数据库   数据库 操作 基础   创建 数据库   CREATE   DATABASE   mydb ;     CREATEDB   权限 用户 新建 数据库 。   创建 一个 数据库 ， 指定 数据库 owner 。   CREATE   DATABASE   mydb   WITH   owner   =   mydb _ admin ;   mydb _ admin 登录 数据库 操作 。   备份 还原   两个 backup 方法   pg _ dump     pg _ dumpall   pg _ restore   还原 ，   改变 数据库 所有者   postgres 身份 连接 postgres 数据库 ， 更改 数据库 所有者 ， 数据库 所有者 。   wanze @ wanze - ubuntu : ~ $   sudo   - u   postgres   psql   postgres   psql   ( 9.3 . 8 )   Type   \" \"     .   postgres = #   ALTER   DATABASE   mydb   OWNER   TO   learner ;   ALTER   DATABASE   postgres = #   \\ q   ALTER   DATABASE 语句   mydb   更改 数据库 名字 ， learner 更 改为 所有者 名字 。   类似 谈及 ，   dropdb   用于 删除 数据库 ，   dropuser   用于 删除 用户 。   CREATE   TABLE 语句 都 熟悉 ， 数据类型 上 ， 还 详细 讨论 一番 。   postgresql 字段 数据类型   int   ,   smallint   ,   real   ,   double   precision   ,   char (   N   )   ,   varchar (   N   )   ,   date   ,   time   ,   timestamp   ,     interval   ,   postgresql 支持 数据类型 ， ： int ， smallint ， real ， boolean ， date ， time ， integer ， text ， char ( N ) ， varchar ( N )   json 。 慢慢 ， 更 细节 请 参看 官方 文档 第八章   Data   Types ， 这是   版本 9.3 网页 链接   。   整数 简单 integer ， 字符串 简单 text ， 小数 简单 real ， 布尔值 boolean ， 用途 数据类型 值得 ， uuid ， json ， arrays ， money ， bytea ， 日期 时间 date ， time ； 几何 类型 支持 point ， line   Cookbook   修改 列为 unique   参考   网页   。   ALTER   TABLE   _ table   ADD   CONSTRAINT   constraint _   UNIQUE   (   thecolumn   ) ;   删除 基于 某列 重复 值 重复 行   参考   网页   。   DELETE   FROM   dupes   T1   USING   dupes   T2   WHERE   T1   .   id   <   T2   .   id   - -   delete     older   versions   AND   T1   .   key   =   T2   .   key   ;   - -   add     columns     needed   USING 语句 古怪 ， 参看 postgresql delete 一章 ， 介绍 语法 ：   DELETE   FROM   [   ONLY   ]   table _   [   *   ]   [   [   AS   ]   alias   ]   [   USING   _ list   ]   [   WHERE   condition   |   WHERE   CURRENT   OF   cursor _   ]   [   RETURNING   *   |   output _ expression   [   [   AS   ]   output _   ]   [ ,   ... ]   ]   _ list   A   list     table   expressions ,   allowing   columns       tables           WHERE   condition .   This     similar       list     tables               FROM   Clause     a   SELECT   statement ;     ,     alias       table         .   Do     repeat     target   table       _ list ,           set     a   - join .   DELETE   FROM   films   USING   producers   WHERE   producer _ id   =   producers . id   AND   producers .   =   ' foo ' ;   select 区别 ， 更 像是 引用 表 ， 语句 中 。   理解 postgresql timestamptz 字段 类型   数据库 都 存放 UTC 时间 ， 说 timestamp 程序 上 强制性 规范 ， 纠结 时 区 。 postgresql timestamp 字段 对外 说 支持 时区 ， 内部 存放 UTC 时间 ， 帮 自动 转换 。   isoformat 格式 存放 timestamptz 字段 ， isoformat 格式 查询 时间 ， 程序员 都 不用 操心 时区 ， isoformat 区 信息 。 程序 表现 ， 推荐 程序运行 时 服务器时 区 设置 好 。 数据库 服务器时 区 设置 好 查看 时间 上会 更好 本地 体验 。   附录   配置文件   sudo   - u   postgres   psql   postgres   psql >   SELECT   , setting   FROM   pg _ settings   WHERE   category   =   ' File   Locations ' ;     |   setting   - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   config _ file   |   / / postgresql / 9.3 / main / postgresql . conf   data _ directory   |   / var / lib / postgresql / 9.3 / main   external _ pid _ file   |   / var / run / postgresql / 9.3 - main . pid   hba _ file   |   / / postgresql / 9.3 / main / pg _ hba . conf   ident _ file   |   / / postgresql / 9.3 / main / pg _ ident . conf   ( 5   rows )   重启 postgresql 服务   linux 下 运行 命令行 目的 :   sudo   service   postgresql   restart     sudo   service   postgresql   reload   参考资料   PostgreSQL 官方 参考 文档   PostgreSQL   Up     Running ,   2nd   Edition",
            "tags":"SQL",
            "url":"articles/postgresqlshu-ju-ku.html"
        },
        {
            "title":"github pages",
            "text":"  github 上 新建 一个   _ . github . io   项目 ， 内容 一个 静态 网站 生成 工具 输出 内容 。   自定义 域名   简单 来说 写 一个   CNAME   文件 ， 实际上 github   settings 还 提供 功能 ， 做 工作 创建 一个   CNAME   文件 。   自定义 域名 https 支持   小节 参考   篇文章   。 简单 来说 利用   cloudflare   提供 服务 。 提供 DNS 域名解析 服务 ， 还 做 很多 额外 工作 ， 缓存 ， 统计 ， https 支持 。   设置 很 详细 ， 很多 一键 式 设置 ， 东西 很 ，   SSL   模式 推荐 选择   Flexible     Full   支持 github   pages 不得而知 ， 设置 后 好 好几个 小时 才能 生效 。     Automatic   HTTPS   Rewrites     Always     HTTPS   推荐 选上 ， 篇文章 提到   page   rules   设置 下 ， 勾选   Always     HTTPS   总 选项 ， 不 重复 设置 。   挂 上 gitbook 内容   WARNING :   小节 内容 年久失修 过时 。     gitbook   build     _ book   内容 复制到 主目录 下 ， 引用 即可 ：   / html5 - learning - notes   指向 文件夹 工作 。   参考   网页     create - react - app   分支 管理 建议   ， 综合 更好 解决方案 ：   yarn   init   读者 yarn   npm 不太熟悉 ， 都   Enter   。   yarn   add   gh - pages     packages . json   加上   （ PS :   json 语法 object 一项 带 逗号 ） ：   \" scripts \" :   {   \" predeploy \" :   \" npm   run   build \" ,   \" deploy \" :   \" gh - pages   - d   _ book \" ,   \" build \" :   \" gitbook   build \"   }   运行   gitbook   deploy   好 ， gitbook 挂载   _ . github . io / project   。",
            "tags":"others",
            "url":"articles/github-pages.html"
        },
        {
            "title":"国内源",
            "text":"前言   GFW ， 下载 资源 速度 会 很慢 ， 这时候 配置 国内 源来 下载 ， 本文 罗列 相关 信息 。   pypi 下载 国内 源   豆瓣 pypi 源   https : / / pypi . douban . / simple     清华 pypi 源   https : / / pypi . tuna . tsinghua . . cn / simple   都 。   临时   - i     - - index   选项 ：   pip   install   - i   https : / / pypi . tuna . tsinghua . . cn / simple   - package   永久 更改 本地 配置 ：   pip   install   pip   - U   pip   config   set   global . index - url   https : / / pypi . tuna . tsinghua . . cn / simple   js   国内 cdn 源   推荐   网站   。   docker 国内 加速 镜像   推荐 类似 命令 ：   docker   pull   daocloud . io / ubuntu : 16.04   docker   pull   daocloud . io / centos : 7   docker   pull   daocloud . io / python : 3   镜像文件 下载 。   ubuntu 更新 源   ubuntu 更新 源 换成 国内 源 。   android   studio   sdk 更新 太慢   请 参考   https : / / github . / inferjay / AndroidDevTools   。 网站 很多 android 开发 相关 资料 。",
            "tags":"others",
            "url":"articles/guo-nei-yuan.html"
        },
        {
            "title":"markdown",
            "text":"前言   markdown 基础知识 本文 不 赘述 ， 网上 随便 搜 ， 本文 讲 值得一提 知识点 。   添加 脚注   显示 插入 脚注 [ &# 94 ; 1 ]   [ &# 94 ; 1 ] :   这是 一个 脚注 。   效果 所示 ：   显示 插入 脚注   1   插入 描述 列表   sqrt   :   开 平方根 函数 ， sqrt ( x ) 。   sin   :   正弦 函数 ， 类似 cos ， tan ， sin ( x ) 。   sqrt   开 平方根 函数 ， sqrt ( x ) 。   sin   正弦 函数 ， 类似 cos ， tan ， sin ( x ) 。   github   flavored   markdown   gfm 官方 文档     。 github   flavored   markdown   github markdown 方言 ， 区别 :   下划线 下划线 。   URL   输入 ，   http : / / www . google .   ， 转化 链接 。 一个 新 功能 支持 ， 链接 插入方式 。   删除 线   :   ~ ~ 删除 线 ~ ~   添加 新 特性 。   最 有名 代码 块 染色 支持 。   ` ` ` elisp   ( +   1   1 )   ​ ` ` `   语言 列表 参看     。   这是 一个 脚注 。   ↩",
            "tags":"others",
            "url":"articles/markdown.html"
        },
        {
            "title":"统计学学习笔记",
            "text":"均值 中位数 众数     均值 ， 算术 平均数 ， 熟知 数加 除以 个数 ， 数 平均 大 。   median   中位数 ， 概念 ： 一组 数 从小到大 排列 ， 最 数 中位数 。 最 解释 ， 一共 奇数 数字 ， 去掉 一个 最小 去掉 一个 ， 类推 ， 剩下 数 中位数 ； 一共 偶数 数字 ， 会 剩下 两个 数字 ， 中位数 两个 数字 均值 。   mode   众数 ， 一组 数中 频率 或者说 分布 最多 数 。 比如说 [ 1 , 2 , 2 , 3 ] 一个 样本 ， 数字 2 次数 最 ， 说 样本 众数 2 。   统计 意义   平均值 概念 最 熟悉 ， 最 统计学 手段 。 物理学 上 测量 ， 精确 测量 取 平均值 。 再 衡量 一类 数据 大致 平均 情况 ， 考试 平均 成绩 ， 平均 成绩 大致 对待 本学期 学业 态度 。   中位数 均值 考察 样本 总体 状态 ， 区别 中位数 极值 （ 偏离 特别 远 值 ） 不 敏感 。 收入 来举 例子 ： 人 收入 特别 高 ， 均值 考察 社会 收入水平 会 抬高 嫌疑 。 家庭 之间 收入 共享 ， 计算 中 却 一并 。 中位数 考察 看着 社会 总体 收入水平 。 考察 家庭 平均收入 中位数 。   众 数只 关注 次数 最多 数 ， 来讲 不 考察 样本 总体 状态 能力 ， 情况 下 却 。 比如说 头发 颜色 定性描述 ， 众数 很 合适 。   python 相关   python3.4 ， python statistics 模块 ， 不 重复 发明 轮子 。 ， median mode 三个 名字 statistics 模块 中 都 函数 ， 演示 例子 ：     statistics   import     ,   mode   ,   median   > > >   lst   =   [   23   ,   29   ,   20   ,   32   ,   23   ,   21   ,   33   ,   25   ]   > > >     (   lst   )   25.75   > > >   median   (   lst   )   24.0   > > >   mode   (   lst   )   23   三个 函数 都 接受 一个 迭代 对象 ， 相关 操作 ， 空 数据 ， raise   statistics . StatisticsError   。   值得注意 mode 还 操作 字符串 ：   > > >   mode ( [ ' a ' , ' b ' , ' a ' , ' c ' , ' d ' ] )   ' a '   mode 函数 几个 数都 频率 情况 ， 运行 命令 ， raise   statistics . StatisticsError   。   > > >   lst   =   [ 1 , 1 , 2 , 3 , 3 ]   > > >   mode ( lst )   利用 collections 模块 Counter 类 _ common 方法 更 健壮 mode 函数 。     collections   import   Counter   def   mode   (   obj   ) :   \" \" \"   多个 情况   \" \" \"   c   =   Counter   (   obj   )     =   0     =   True     k   ,   v     c   .   _ common   ( ) :       :     =   v     =   False   yield   k     :       = =   v   :   yield   k     :   break   python3   statistics   内置 模块   均值   中位数     众数 运算 ， ， python2 模块 不 说 ， 矢量 思维 计算 效率 。 好 ， numpy     scipy   出场 。   python 迭代 对象 （ Iterable ） numpy ndarray 对象 ， ， pass 掉 。   利用 numpy scipy 函数 支持 。   import   numpy     np     collections   import   Iterable   def   _ ndarray   (   pyobj   ,   dtype   =   None   ) :       isinstance   (   pyobj   ,   Iterable   ) :   raise   TypeError   (   '       a   iterable   object '   )     isinstance   (   pyobj   ,   np   .   ndarray   ) :   return   pyobj     dtype       None   :   return   np   .   array   (   pyobj   ,   dtype   )     :   return   np   .   array   (   pyobj   )   def     (   obj   ) :   obj   =   _ ndarray   (   obj   )   return   obj   .     ( )   def   median   (   obj   ,   axis   =   None   ) :   obj   =   _ ndarray   (   obj   )   return   np   .   median   (   obj   ,   axis   =   axis   )   mode 统计 频数 scipy   scipy . stats . mode   函数 ， 返回 频数 ， 频数 多个 情况 只 返回 一个 。   方差 标准差   来说 总体 情况 ， 总体 均值   \\ ( \\ mu \\ )   ， 总体 方差 公式 所示 :   $ $   { \\ sigma   } &# 94 ; { 2   }   = \\ frac   {   1   } { n   }   \\ sum   _ {   i = 1   } &# 94 ; {   n   } { (   X _ i   -   \\ mu ) &# 94 ; 2 }   $ $   总体 方差 一个 数 总体 均值 差 平方和 均值 。   > > >     statistics   import   *   > > >   pvariance ( [ 0 , 0 , 5 , 5 ] )   6.25   statistics . pvariance ( data ,   mu = None )   上 所示 ， pvariance 还 接受   mu   选 参数 ， 总体 均值 ， 重复 计算 ， 赋值 函数 会 自动 计算 。   总体 标准差 总体 方差 平方根 ， 或者说   \\ ( \\ sigma \\ )   。   > > >     statistics   import   *   > > >   pstdev ( [ 0 , 0 , 5 , 5 ] )   2.5   pstdev （ Population   standard   deviation ） 还 接受   mu   选 参数 。   中 ， 绝大多数 情况 都 考察 样本 总体 ， 更 常用 样本 方差 :   $ $   { S   } &# 94 ; { 2   }   = \\ frac   {   1   } { n - 1   }   \\ sum   _ {   i = 1   } &# 94 ; {   n   } { (   X _ i   -   \\ overline   {   X   }   ) &# 94 ; 2 }   $ $   ，   ( n - 1 )     ( n )   ， 统计学 ， 无偏 估计 ， 样本 评估 总体 方差 ， 总会 估计值 偏小 ， 再 加上 一个 额外 数据量 估计值 更 准确 些 ， 大体 ，   n - 1   ， 统计学 高级 内容 ， 更好 估计 （ 样本 估计 总体 ） 。   python 中 样本 方差   variance   函数 ， 样本 标准差   stdev   函数 :   > > >   variance ( [ 0 , 0 , 5 , 5 ] )   8.333333333333334   > > >   stdev ( [ 0 , 0 , 5 , 5 ] )   2.886751345948129   > > >   统计 意义   方差 描述 数据 集 离散 程度 ， 标准差 方差 平方根 ， 用来 描述 数据 集 离散 程度 。 标准差 数据 会 更 ， 比如说 统计 一班 身高 标准差   10cm   ， 人 一个 直观 感受 。 正态分布 中有   均值   $   \\ pm   $   三个 标准差 ， 样本 中   99 点 数据 都 包含 在内 。   简单 来说 ， 总体 考察 对象 ， 简单 均值 ， 中位数 ， 众数 描述性 概念 ， 总体 来说 都 很 难 考察 。 总体 中 取出 考察 对象 （ 理论 上 近似于 随机取样 ） ， 一个 样本 。 希望 样本 统计 描述性 数据 很 好 总体 数据 状况 。 统计学 量 实际上 都 两种 类型 ， 均值 总体 均值   \\ ( \\ mu \\ )   样本均值   \\ ( \\ overline { X } \\ )   。   python 相关   利用 numpy 计算 ：   def   pvariance   (   obj   ) :   obj   =   _ ndarray   (   obj   )   return   np   .   var   (   obj   )   def   pstd _ deviation   (   obj   ) :   obj   =   _ ndarray   (   obj   )   return   np   .   std   (   obj   )   def   variance   (   obj   ) :   obj   =   _ ndarray   (   obj   )   return   np   .   var   (   obj   ,   ddof   =   1   )   def   std _ deviation   (   obj   ) :   obj   =   _ ndarray   (   obj   )   return   np   .   std   (   obj   ,   ddof   =   1   )   计算 样本 方差   variance   ddof = 1   设置 1 ， 默认 0 。 计算 样本 样本 方差 样本 标准差 。   中位数 分 位数   中位数 谈过 ， 最 数 。 一种 说法 数据 集里   50%   数比 小 ，   百分之 50 数比 大 。 分 位数 概念 由此 ，   25%   分 位数 （ quantile ） 数据 集里   25%   数比 小 。 联想 统计学 分布图 ，   25% 分 位数 看作 数画 一条线 ， 左边 面积 总面积   25% 。   python 相关   def   quantile   (   obj   ,   seq   =   None   ) :   obj   =   _ ndarray   (   obj   )     seq     None   :   seq   =   range   (   0   ,   101   ,   25   )   res   =   pd   .   Series   (   np   .   percentile   (   obj   ,   seq   ) ,   index   =   seq   )   return   res   numpy     percentile   函数 分 位数   quantile ， 显示 几个 分 位数 位置 定制 。 利用 pandas   Series   数据结构 返回 ， 好 分 位数 。   极差   中程 数   极差 （ range ） 一组 数 最大值 最小值 差值 。 中程 数 （ midrange ） 一组 数 最大值 最小值 均值 。   python 相关   极差 range 名字 python 语言 range 函数 相冲突 ， python 极差 定义 一个 函数 ， 计算公式 简单 ， 不 额外 定义 一个 公式 。 ：   max   (   lst   )   -   min   (   lst   )   中程 数   (   max   (   lst   )   +   min   (   lst   ) )   /   2   统计 意义   极差 统计学 上 入门级 粗略 样本 离散 程度 考察 ， 一组 数 很 分散 ， 都 均值 ， 极差 会 很小 ， 情况 另一组 数 极差 更大 ， 说 第二组 数 离散 程度 更大 。   中程 数 样本 数组 离散 程度 很 高 ， 均值 近似 快速 计算 。   标准分   标准分   \\ ( z   =   \\ frac { x -   \\ mu } { \\ sigma } \\ )   标准分 正态分布 映射 一个 标准 正态分布 上 手段 ， 简单 来说 一种 均值 标准差 正态分布 标准化 过程 ， 理解 过程 理解 标准 正态分布 ：   标准 正态分布 值 均值 0 ， 标准差 1 正态分布 。   标准分 做出 假设   目标 研究 数据 集   或者说 学生 得分 数据 集是   正态分布   。 正态分布 。 正态分布 中有 规律 ：   95.45%   数据 位于 两个 标准差 内   99.73%   数据 位于 三个 标准差 内 。   （ 公式 ）   参考 同济大学 概率论 数理统计 第四版 一书   p48   引理 ：     X   分布 正态分布 ，   \\ ( Z   =   \\ frac { X - \\ mu } { \\ sigma } \\ )   分布 标准 正态分布 。 ， 简单 看 下 数学公式 推导 ， 信心 足 ， 没 。   条件 概率   条件 概率 维恩 图解 很 有意思 ：   $ $   P ( A | B )   =   \\ frac { P ( A   \\ cap   B ) } { P ( B ) }   $ $   用维恩图 基本上 写出 公式 ， 含义 很 。   ：   $ $   P ( A | B )   P ( B )   =   P ( A   \\ cap   B )   $ $   $ $   P ( A   \\ cap   B )   =   P ( B   \\ cap   A )   =   P ( B | A )   P ( A )   $ $   概率 树来 理解 ， 先 发生 B 发生 A 事件 ， 事件 AB 概率 两个 事件 概率 乘积 ， 困惑 ， AB 事件 BA 事件 两个 概率 ？ （ 针对 古典 概率模型 ， 顺序 地方   P ( a , b )   符号 ，   P ( a , b )   不 等于   P ( b , a ) 。 ）   互斥 事件 A ， B ， 不 发生 事件 ，   \\ ( P ( A   \\ cap   B )   = 0 \\ )   全 概率 公式 ：   $ $   P ( B )   =   P ( A )   \\ times   P ( B   |   A )   +   P ( A ' )   \\ times   P ( B   |   A ' )   $ $   贝叶斯 定理 ：   $ $   P ( A | B )   =   \\ frac { P ( B | A )   P ( A ) } { P ( B )   =   P ( A )   \\ times   P ( B   |   A )   +   P ( A ' )   \\ times   P ( B   |   A ' ) }   $ $   贝叶斯 定理 提供 一个 计算 逆 条件 概率 方法 ， 情况 先 发生   A   再   发生 B   ， 想 B 发生 A 发生 概率 。   贝叶斯 定理 思想 提及 更深 ， 假设   A   事件 ， 机器 人 针对 A 事件 做 推断   B ， 想 推断 B 正确 可能性 大 ， A 事件 发生 概率 ， A 事件 发生 后 B 推断 概率 ， A 事件 发生 B 推断 发生 概率 都 是从 经验 数据 中 学习 。 后验 B 推断 发生 ， A 事件 发生 推断 错误 ， A 事件 发生 推断 正确 ，   $ P ( A | B )   $   常 统计学家 称为   后验 概率 ， 实际上 逆 概率 ， 计算 过程 贝叶斯 公式 计算 。   参考资料   深入浅出 统计学   同济大学   概率论 数理统计   机器学习   周志华     ( ! document . getElementById ( ' mathjaxscript _ pelican _#% @ # $ @ # ' ) )   {   var   align   =   \" center \" ,   indent   =   \" 0em \" ,   linebreak   =   \" false \" ;     ( false )   {   align   =   ( screen . width   <   768 )     \" left \"   :   align ;   indent   =   ( screen . width   <   768 )     \" 0em \"   :   indent ;   linebreak   =   ( screen . width   <   768 )     ' true '   :   linebreak ;   }   var   mathjaxscript   =   document . createElement ( ' script ' ) ;   mathjaxscript . id   =   ' mathjaxscript _ pelican _#% @ # $ @ # ' ;   mathjaxscript . type   =   ' text / javascript ' ;   mathjaxscript . src   =   ' / theme / js / mathjax / MathJax . js ' ;   mathjaxscript [ ( window . opera     \" innerHTML \"   :   \" text \" ) ]   =   \" MathJax . Hub . Config ( { \"   +   \"   config :   [ ' MMLorHTML . js ' ] , \"   +   \"   TeX :   {   extensions :   [ ' AMSmath . js ' , ' AMSsymbols . js ' , ' noErrors . js ' , ' noUndefined . js ' , ' mhchem . js ' ] ,   equationNumbers :   {   autoNumber :   ' AMS '   }   } , \"   +   \"   jax :   [ ' input / TeX ' , ' input / MathML ' , ' output / HTML - CSS ' ] , \"   +   \"   extensions :   [ ' tex2jax . js ' , ' mml2jax . js ' , ' MathMenu . js ' , ' MathZoom . js ' ] , \"   +   \"   displayAlign :   ' \" +   align   + \" ' , \"   +   \"   displayIndent :   ' \" +   indent   + \" ' , \"   +   \"   showMathMenu :   true , \"   +   \"   messageStyle :   ' normal ' , \"   +   \"   tex2jax :   {   \"   +   \"   inlineMath :   [   [ ' \\ \\ \\ \\ ( ' , ' \\ \\ \\ \\ ) ' ]   ] ,   \"   +   \"   displayMath :   [   [ ' $ $ ' , ' $ $ ' ]   ] , \"   +   \"   processEscapes :   true , \"   +   \"   preview :   ' TeX ' , \"   +   \"   } ,   \"   +   \"   ' HTML - CSS ' :   {   \"   +   \"   styles :   {   ' . MathJax _ Display ,   . MathJax   . mo ,   . MathJax   . mi ,   . MathJax   . mn ' :   { color :   ' inherit   !   important ' }   } , \"   +   \"   linebreaks :   {   automatic :   \" +   linebreak   + \" ,   width :   ' 90%   container '   } , \"   +   \"   } ,   \"   +   \" } ) ;   \"   +   \"   ( ' default '   ! = =   ' default ' )   { \"   +   \" MathJax . Hub . Register . StartupHook ( ' HTML - CSS   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax [ ' HTML - CSS ' ] . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" MathJax . Hub . Register . StartupHook ( ' SVG   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax . SVG . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" } \" ;   ( document . body   | |   document . getElementsByTagName ( ' head ' ) [ 0 ] ) . appendChild ( mathjaxscript ) ;   }",
            "tags":"math",
            "url":"articles/tong-ji-xue-xue-xi-bi-ji.html"
        },
        {
            "title":"小分子网页显示第二版",
            "text":"第二 版     第一版 中   介绍 html 文件 中 绘制 数学 表达式 化学 分子式 ， 简单 来说 利用   mathjax   javascript 库 。 喜欢 markdown pelican ， pelican 下该 做 。   最 优雅 方法 引入   render _ math   插件 。   #     plugin   PLUGIN _ PATHS   =   [ ' myplugins ' ]   PLUGINS   =   [ extract _ toc ' ,   ' render _ math ' ]   MATH _ JAX   =   { ' tex _ extensions ' :   [ ' mhchem . js ' ] }   剩下 交给 pelican ， 检测 markdown 下 插入 数学公式 或者说 化学 分子式 ， 引入   mathjax   库 。   数学 环境 简要 介绍   行内 数学 环境   TeX     $   $   ， 单独 一行 数学 表达式   ：   $ $   ...   $ $   更 多用   Tex 写 数学 知识 请 参看   wikibook   。 值得一提的是   LaTeX 风格   \\ (   不 支持 。   \\ begin { equation }   支持 ， markdown 编辑器 不 支持 实时 预览 ， 推荐   $     $ $   。   ：   $ $   {   \\ sigma   } &# 94 ; {   2   }   =   \\ frac   {   1   } { n   }   \\ sum   _ {   i   =   1   } &# 94 ; {   n   } {   (   X _ i   -   \\ mu   )   &# 94 ;   2   }   $ $   显示 效果 ：   $ $   { \\ sigma   } &# 94 ; { 2   }   = \\ frac   {   1   } { n   }   \\ sum   _ {   i = 1   } &# 94 ; {   n   } { (   X _ i   -   \\ mu ) &# 94 ; 2 }   $ $   显示 小 分子     $ \\ ce { H _ 2O } $   显示   \\ ( \\ ce { H _ 2O } \\ )   ，   $ \\ ce { AgCl _ 2 &# 94 ; - } $   显示   \\ ( \\ ce { AgCl _ 2 &# 94 ; - } \\ )   。   一种 简写 写法 ：   $ \\ ce { H2O } $   显示   \\ ( \\ ce { H2O } \\ )   ，   $ \\ ce { AgCl2 - } $   显示   \\ ( \\ ce { AgCl2 - } \\ )   。   看   ce   命令 包装 纯数学 环境 表达 显示 效果 ：   \\ ( H _ 2O \\ )     \\ ( AgCl _ 2 &# 94 ; - \\ )   。 区别 。   数字 上标 加减 号 自动 情况 见 两个 例子 ：   $ \\ ce { Y &# 94 ; { 99 } + } $   \\ ( \\ ce { Y &# 94 ; { 99 } + } \\ )     $ \\ ce { Y &# 94 ; { 99 + } } $   \\ ( \\ ce { Y &# 94 ; { 99 + } } \\ )   。   配位 化合物   数字 写 上 即可   $ \\ ce { 0.5 H2O } $   \\ ( \\ ce { 0.5 H2O } \\ )   ， 值得一提的是 ， 数字 分数 形式 会 自动 ：   $ \\ ce { 1 / 2   H2O } $   \\ ( \\ ce { 1 / 2   H2O } \\ )   。   会 带上 小数点 数字 显示 古怪 。 小数点 会 解释 配位 化合物 结晶水 分隔 点 。   $ \\ ce { KCr ( SO4 ) 2.12 H2O } $   \\ ( \\ ce { KCr ( SO4 ) 2.12 H2O } \\ )   。 正确 显示 例子 ， 0.5 放入 数学 环境 中 即可 ：   $ \\ ce { $ 0.5 $ H2O } $   $ $   \\ ce { $ 0.5 $ H2O }   $ $   上 所示 ， mathjax 支持 ce 命令 再 数学 环境   $   $   。   显示 化学键   -   =   #   单键 ， 双键 三键 。   \\ ( \\ ce { A - A   B = B   C# C } \\ )     \\ bond   命令 还 额外 键 ，   $ \\ ce { \\ bond { ~ } } $     \\ ( \\ ce { \\ bond { ~ } } \\ )     $ \\ ce { \\ bond { ~ - } } $     \\ ( \\ ce { \\ bond { ~ - } } \\ )   ， 类推 。   显示 化学反应 式   $ $   \\ ce { CO2   +   C   < -   2CO }   $ $   $ $   \\ ce { CO2   +   C   < -   2CO }   $ $   $ $   \\ ce { CO2   +   C   - > [ \\ text { text 命令 } ]   2CO }   \\ ce { CO2   +   C   - > T [ 支持 ] [ 中文 ]   2CO }   $ $   $ $   \\ ce { CO2   +   C   - > [ \\ text { text 命令 } ]   2CO }   $ $   $ $   \\ ce { CO2   +   C   - > T [ 支持 ] [ 中文 ]   2CO }   $ $   不 text 命令 ， 中文 显示 。 例子 第二个 text 命令 ， 是因为 加上 T ， 箭头 文字 都 不 。   显示 箭头   $ $   \\ ce   { SO   4   &# 94 ;   2   -   +   Ba &# 94 ;   2   +   -   >   BaSO   4   v   &# 94 ; }   $ $   $ $   \\ ce { SO4 &# 94 ; 2 -   +   Ba &# 94 ; 2 +   - >   BaSO4   v   &# 94 ; }   $ $   下降 箭头   v   ， 上 式 箭头   &# 94 ;   ， 内容 一个 空格 。   推荐 一个 markdown 编辑器   typora   markdown 编辑器 ， 实时 预览 修改 markdown ， 包括 化学 公式 数学公式 。     ( ! document . getElementById ( ' mathjaxscript _ pelican _#% @ # $ @ # ' ) )   {   var   align   =   \" center \" ,   indent   =   \" 0em \" ,   linebreak   =   \" false \" ;     ( false )   {   align   =   ( screen . width   <   768 )     \" left \"   :   align ;   indent   =   ( screen . width   <   768 )     \" 0em \"   :   indent ;   linebreak   =   ( screen . width   <   768 )     ' true '   :   linebreak ;   }   var   mathjaxscript   =   document . createElement ( ' script ' ) ;   mathjaxscript . id   =   ' mathjaxscript _ pelican _#% @ # $ @ # ' ;   mathjaxscript . type   =   ' text / javascript ' ;   mathjaxscript . src   =   ' / theme / js / mathjax / MathJax . js ' ;   mathjaxscript [ ( window . opera     \" innerHTML \"   :   \" text \" ) ]   =   \" MathJax . Hub . Config ( { \"   +   \"   config :   [ ' MMLorHTML . js ' ] , \"   +   \"   TeX :   {   extensions :   [ ' AMSmath . js ' , ' AMSsymbols . js ' , ' noErrors . js ' , ' noUndefined . js ' , ' mhchem . js ' ] ,   equationNumbers :   {   autoNumber :   ' AMS '   }   } , \"   +   \"   jax :   [ ' input / TeX ' , ' input / MathML ' , ' output / HTML - CSS ' ] , \"   +   \"   extensions :   [ ' tex2jax . js ' , ' mml2jax . js ' , ' MathMenu . js ' , ' MathZoom . js ' ] , \"   +   \"   displayAlign :   ' \" +   align   + \" ' , \"   +   \"   displayIndent :   ' \" +   indent   + \" ' , \"   +   \"   showMathMenu :   true , \"   +   \"   messageStyle :   ' normal ' , \"   +   \"   tex2jax :   {   \"   +   \"   inlineMath :   [   [ ' \\ \\ \\ \\ ( ' , ' \\ \\ \\ \\ ) ' ]   ] ,   \"   +   \"   displayMath :   [   [ ' $ $ ' , ' $ $ ' ]   ] , \"   +   \"   processEscapes :   true , \"   +   \"   preview :   ' TeX ' , \"   +   \"   } ,   \"   +   \"   ' HTML - CSS ' :   {   \"   +   \"   styles :   {   ' . MathJax _ Display ,   . MathJax   . mo ,   . MathJax   . mi ,   . MathJax   . mn ' :   { color :   ' inherit   !   important ' }   } , \"   +   \"   linebreaks :   {   automatic :   \" +   linebreak   + \" ,   width :   ' 90%   container '   } , \"   +   \"   } ,   \"   +   \" } ) ;   \"   +   \"   ( ' default '   ! = =   ' default ' )   { \"   +   \" MathJax . Hub . Register . StartupHook ( ' HTML - CSS   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax [ ' HTML - CSS ' ] . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" MathJax . Hub . Register . StartupHook ( ' SVG   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax . SVG . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" } \" ;   ( document . body   | |   document . getElementsByTagName ( ' head ' ) [ 0 ] ) . appendChild ( mathjaxscript ) ;   }",
            "tags":"chemistry",
            "url":"articles/xiao-fen-zi-wang-ye-xian-shi-di-er-ban.html"
        },
        {
            "title":"SMILE",
            "text":"SMILE   Simplified   molecular   input   line   entry   specification ， 简化 分子 线性 输入 规范 。 最广 最为 熟知 线性 标记 法 。 详细 介绍 线性 标记 法 规则 ， 更 细节 请 参看   网页   。   SMILE 规则 简介   原子   钠 原子 ：   [ Na ]   氯 原子   [ Cl ]   ， 原子 同位素   [ 2H ]   ，   [ 13C ]   。   离子   钠离子 ：   [ Na + ]   氯离子 ：   [ Cl - ]   铜 离子 ：   [ Cu + 2 ]     [ Cu ++ ]   。   离子 化合物   点 符号   .   两个 原子 之间 不 成键 ， 氯化钠   [ Na + ] . [ Cl - ]   。   单质   氢气   [ H ] [ H ]   ,   氧气   [ O ] = [ O ]   ， 氮气   [ N ] # [ N ]   ， 原子 外面 默认 单键 连接 ，   =   双键 ，   #   三键 。   氧气 氮气 简写   O = O     N # N   ， 氢气 不行 。 氢原子 ， 会 自动 加上 ， 这是 符合 日常 有机化学 结构式 表达 风格 ， 双氧水   表达   OO   即可 。 加氢 规则 不用 说 ， 学过 有机化学 。 值得一提 方括号 不 自动 加氢 ，   [ H ]   一个 氢原子 ，   [ OH2 ]   两个 氢原子 ， 这是 水分子 。   有机 化合物   讨论 ， 有机 化合物 表达式 猜出 ， ：   CCCC   丁烷 ，   CCO   乙醇 。 分支 ： 一是 有机 化合物 顺序 链 有机化学 中 学习 IUPAC 命名 法来 ； 二是 圆括号 分支 子 基团   ( )   。 异丁烷   CC ( C ) C   ， 新 戊烷   CC ( C ) ( C ) C   ， 醋酸   CC ( = O ) O   ， 双键 。   环   环己烷   C1CCCCC1   , 核心理念 编号 原子 连键 。 化合物 萘 ：   SMILES 表达 ：   c1ccc2ccccc2c1   涉及 萘 IUPAC 编号 ， 顺时针 从右 上 1 ， 4 跳到 5 ， 再 678 ， 两个 碳 跳 ， 知识 冷门 。 数字 1 2 互换 ， 任意 。   例子 还 涉及 一个 知识点 ， 芳香性 原子 （ 苯环 上 C ， 杂环 原子 ONS ） 都 小写 。 苯 写 ：   c1ccccc1   。   立体化学   双键 两端   / C = C /     \\ C = C \\   反 ( trans ) 双键 ，     / C = C \\     \\ C = C /   ( cis ) 。   手性 还 很 熟悉 ， 暂时 略过 。   isometric _ smile   isomeric _ smile   说   unique   SMILE   唯一 smile ， 加上 同位素 手性 。 正是 唯一性 ， 化学 信息 数据库 isometric _ smile 化学分子 唯一 ID 。   参考资料   维基百科 SMILES   open   smiles   官方 文档",
            "tags":"chemistry",
            "url":"articles/smile.html"
        },
        {
            "title":"小分子网页显示第一版",
            "text":"mhchem 宏包   latex 基于 tikz chemfig 宏包来 小 分子结构 显示 ， 包括 大型 有机 分子 结构 显示 ， 简单 小 分子 显示 推荐   mhchem   宏包 。   mhchem 看得出来 latex 数学 环境 显示 小 分子结构 ， 马上 html 上 mathjax 支持 ， chemfig tikz 机制 ， 永远 都 mathjax 支持 （ svg 途径 ？ ） 。 加载 宏包 ：   \\ usepackage   [ version = 3 ]   {   mhchem   }   来说 ， 假定 读者 latex 数学 环境 内 语法 都 很 熟悉 ， 简单 理解 mhchem 宏包 数学 环境 下 ， 一个 新 命令   \\ ce {   }   ， ce 命令 上标 下 标语 法是 类似 数学 环境 内 语法 ， 化学 表达式 显示 会 美观 。     $ \\ ce { H _ 2O } $   显示   \\ ( \\ ce { H _ 2O } \\ )   ，   $ \\ ce { AgCl _ 2 &# 94 ; - } $   显示   \\ ( \\ ce { AgCl _ 2 &# 94 ; - } \\ )   。   一种 简写 写法 ：   $ \\ ce { H2O } $   显示   \\ ( \\ ce { H2O } \\ )   ，   $ \\ ce { AgCl2 - } $   显示   \\ ( \\ ce { AgCl2 - } \\ )   。   看 ce 命令 包装 纯数学 环境 表达 显示 效果 ：   \\ ( H _ 2O \\ )     \\ ( AgCl _ 2 &# 94 ; - \\ )   。 区别 。   数字   数字 写 上 即可   $ \\ ce { 0.5 H2O } $   \\ ( \\ ce { 0.5 H2O } \\ )   ， 值得一提的是 ， 数字 分数 形式 会 自动 ：   $ \\ ce { 1 / 2   H2O } $   \\ ( \\ ce { 1 / 2   H2O } \\ )   。   会 带上 小数点 数字 显示 古怪 。 小数点 会 解释 配位 化合物 结晶水 分隔 点 。   $ \\ ce { KCr ( SO4 ) 2.12 H2O } $   \\ ( \\ ce { KCr ( SO4 ) 2.12 H2O } \\ )   。 正确 显示 例子 ， 0.5 放入 数学 环境 中 即可 ：   $ \\ ce { $ 0.5 $ H2O } $   $ $   \\ ce { $ 0.5 $ H2O }   $ $   数学 环境   ， 上 所示 ， mathjax 支持 ce 命令 再 数学 环境   $   $   。   键   -   =   #   单键 ， 双键 三键 。   \\ ( \\ ce { A - A   B = B   C# C } \\ )     \\ bond 命令 还 额外 键 ，   $ \\ ce { \\ bond { ~ } } $     \\ ( \\ ce { \\ bond { ~ } } \\ )   ，   $ \\ ce { \\ bond { ~ - } } $     \\ ( \\ ce { \\ bond { ~ - } } \\ )   ， 类推 。   化学反应 式   $ $   \\ ce   { CO   2   +   C   <   -   2   CO }   $ $   $ $   \\ ce { CO2   +   C   < -   2CO }   $ $   $ $   \\ ce   { CO   2   +   C   -   >   [   \\ text   { text 命令 }   ]   2   CO }   \\ ce   { CO   2   +   C   -   > T   [   支持   ] [   中文   ]   2   CO }   $ $   $ $   \\ ce { CO2   +   C   - > [ \\ text { text 命令 } ]   2CO }   $ $   $ $   \\ ce { CO2   +   C   - > T [ 支持 ] [ 中文 ]   2CO }   $ $   不 text 命令 ， 中文 latex 显示 。 例子 第二个 text 命令 ， 是因为 加上 T ， 箭头 文字 都 不 。   箭头   $ $   \\ ce   { SO   4   &# 94 ;   2   -   +   Ba &# 94 ;   2   +   -   >   BaSO   4   v   &# 94 ; }   $ $   $ $   \\ ce { SO4 &# 94 ; 2 -   +   Ba &# 94 ; 2 +   - >   BaSO4   v   &# 94 ; }   $ $   下降 箭头 v ， 上 式 箭头 &# 94 ; ， 内容 一个 空格 。   mathjax 简介   网页 显示 数学公式 利用 mathjax javascript 库 ， 显示 简单 化学 是因为 mathjax 还 引入 mhchem . js 插件 。   简单 引入 代码 所示 ：   <   script   type   =   \" text / javascript \"   >   window   .   MathJax   =   {   tex2jax   :   {   inlineMath   :   [   [   ' $ '   ,   ' $ '   ] ,   [   \" \\ \\ ( \"   ,   \" \\ \\ ) \"   ]   ] ,   processEscapes   :   true   } ,   TeX   :   {   extensions   :   [   \" AMSmath . js \"   ,   \" AMSsymbols . js \"   ,   \" noErrors . js \"   ,   \" noUndefined . js \"   ,   \" mhchem . js \"   ]   }   } ;   < /   script   >   <   script   type   =   \" text / javascript \"   src   =   \" https : / / cdn . bootcss . / mathjax / 2.6 . 0 / MathJax . js config = TeX - MML - AM _ CHTML \"   > < /   script   >   最 关键 配置   TeX     extensions   引入   mhchem . js   。   参考资料   网站   一块 内容 讲解 很 详细 。     ( ! document . getElementById ( ' mathjaxscript _ pelican _#% @ # $ @ # ' ) )   {   var   align   =   \" center \" ,   indent   =   \" 0em \" ,   linebreak   =   \" false \" ;     ( false )   {   align   =   ( screen . width   <   768 )     \" left \"   :   align ;   indent   =   ( screen . width   <   768 )     \" 0em \"   :   indent ;   linebreak   =   ( screen . width   <   768 )     ' true '   :   linebreak ;   }   var   mathjaxscript   =   document . createElement ( ' script ' ) ;   mathjaxscript . id   =   ' mathjaxscript _ pelican _#% @ # $ @ # ' ;   mathjaxscript . type   =   ' text / javascript ' ;   mathjaxscript . src   =   ' / theme / js / mathjax / MathJax . js ' ;   mathjaxscript [ ( window . opera     \" innerHTML \"   :   \" text \" ) ]   =   \" MathJax . Hub . Config ( { \"   +   \"   config :   [ ' MMLorHTML . js ' ] , \"   +   \"   TeX :   {   extensions :   [ ' AMSmath . js ' , ' AMSsymbols . js ' , ' noErrors . js ' , ' noUndefined . js ' , ' mhchem . js ' ] ,   equationNumbers :   {   autoNumber :   ' AMS '   }   } , \"   +   \"   jax :   [ ' input / TeX ' , ' input / MathML ' , ' output / HTML - CSS ' ] , \"   +   \"   extensions :   [ ' tex2jax . js ' , ' mml2jax . js ' , ' MathMenu . js ' , ' MathZoom . js ' ] , \"   +   \"   displayAlign :   ' \" +   align   + \" ' , \"   +   \"   displayIndent :   ' \" +   indent   + \" ' , \"   +   \"   showMathMenu :   true , \"   +   \"   messageStyle :   ' normal ' , \"   +   \"   tex2jax :   {   \"   +   \"   inlineMath :   [   [ ' \\ \\ \\ \\ ( ' , ' \\ \\ \\ \\ ) ' ]   ] ,   \"   +   \"   displayMath :   [   [ ' $ $ ' , ' $ $ ' ]   ] , \"   +   \"   processEscapes :   true , \"   +   \"   preview :   ' TeX ' , \"   +   \"   } ,   \"   +   \"   ' HTML - CSS ' :   {   \"   +   \"   styles :   {   ' . MathJax _ Display ,   . MathJax   . mo ,   . MathJax   . mi ,   . MathJax   . mn ' :   { color :   ' inherit   !   important ' }   } , \"   +   \"   linebreaks :   {   automatic :   \" +   linebreak   + \" ,   width :   ' 90%   container '   } , \"   +   \"   } ,   \"   +   \" } ) ;   \"   +   \"   ( ' default '   ! = =   ' default ' )   { \"   +   \" MathJax . Hub . Register . StartupHook ( ' HTML - CSS   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax [ ' HTML - CSS ' ] . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" MathJax . Hub . Register . StartupHook ( ' SVG   Jax   Ready ' , function   ( )   { \"   +   \" var   VARIANT   =   MathJax . OutputJax . SVG . FONTDATA . VARIANT ; \"   +   \" VARIANT [ ' normal ' ] . fonts . unshift ( ' MathJax _ default ' ) ; \"   +   \" VARIANT [ ' bold ' ] . fonts . unshift ( ' MathJax _ default - bold ' ) ; \"   +   \" VARIANT [ ' italic ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" VARIANT [ ' - tex - mathit ' ] . fonts . unshift ( ' MathJax _ default - italic ' ) ; \"   +   \" } ) ; \"   +   \" } \" ;   ( document . body   | |   document . getElementsByTagName ( ' head ' ) [ 0 ] ) . appendChild ( mathjaxscript ) ;   }",
            "tags":"chemistry",
            "url":"articles/xiao-fen-zi-wang-ye-xian-shi-di-yi-ban.html"
        },
        {
            "title":"pyqt5学习笔记",
            "text":"WARNING   警告 ， 文档 归档 ， 缺少 新 内容 ， 旧 内容 错误 ， 推荐 pyside2 GUI 编程 。 GUI 编程 请 参看   pyside2 学习 笔记   。   安装 配置   利用 pip3   安装 ：   pip3   install   pyqt5   安装 qt5 ， windows 下 测试 发现 不 安装 qt5 ， 估计 ubuntu 下 不 安装 qt5 。   写 上 ， 读者 程序 提示 没 找到 qt 类似 错误 ， 安装 qt ：   sudo   apt -   install   qt5 - default   sudo   apt -   install   qtbase5 - dev   sudo   apt -   install   qtdeclarative5 - dev   安装 SIP 挺 麻烦 ， sip pip 安装 ， 安装 pyqt5 ， 顺便 装上 。 发现 windows 下   pyuic5     pyrcc5   两个 命令 ， pip 安装 装上 。   ubuntu 下 安装 东西 ， 估计 不 ：   sudo   apt -   install   pyqt5 - dev - tools   检查 pyqt5 安装 情况 执行 脚本 即可 ， 显示 安装 pyqt5 版本号 :   > > >     PyQt5 . QtCore   import   QT _ VERSION _ STR   > > >   print ( QT _ VERSION _ STR )   > > >   5.9 . 2   本文 代码 都 PyQt 版本号 都 ， 特别 理由 ， 会 版本号 。   第一个 例子   窗口   【 beginning - first01 】   import   sys     PyQt5 . QtGui   import   *     PyQt5 . QtWidgets   import   *   class   MyWidget   (   QWidget   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )     .   setGeometry   (   0   ,   0   ,   800   ,   600   )   # 坐标 0   0   大小 800   600     .   setWindowTitle   (   ' myapp '   )   myapp   =   QApplication   (   sys   .   argv   )   mywidget   =   MyWidget   ( )   mywidget   .   show   ( )   sys   .   exit   (   myapp   .   exec _   ( ) )   导入 sys 宏包 ， 这是 接受 sys . argv 参数 。   接下来 定义 MyWidget 类 ， 继承 QWidget 类 。 QWidget 类   setGeometry   方法 调整 窗口 左 顶点 坐标 位置 窗口 大小 。     setWindowTitle   方法 设置 窗口 程序 标题 ， 简单 设置 \" myapp \" 。   窗口 程序 都 创建 一个 QApplication 类 实例 ， myapp 。 接下来 创建 QWidget 类 实例 mywidget ， 调用 mywidget 方法   show   显示 窗体 。   系统 退出 调用 myapp 实例   exec _   方法 。   加上 图标   【 beginning - first02 】   import   sys     PyQt5 . QtGui   import   QIcon     PyQt5 . QtWidgets   import   QWidget   ,   QApplication   class   MyWidget   (   QWidget   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )     .   resize   (   800   ,   600   )     .   setWindowTitle   (   ' myapp '   )     .   setWindowIcon   (   QIcon   \\   (   ' icons / myapp . ico '   ) )   myapp   =   QApplication   (   sys   .   argv   )   mywidget   =   MyWidget   ( )   mywidget   .   show   ( )   sys   .   exit   (   myapp   .   exec _   ( ) )   程序 程序 增加 一个   setWindowIcon   方法 ， 方法 调用   QtGui . QIcon   方法 ， 图标 存放 路径 ， 相对路径 。 运行 例子 ， 请 随便 弄个 图标 文件 。   简单 见 程序 QWidget 类   resize   方法 设置 窗体 大小 。   弹 出 提示信息   【 beginning - first03 】   import   sys     PyQt5 . QtGui   import   *     PyQt5 . QtWidgets   import   *   class   MyWidget   (   QWidget   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )     .   resize   (   800   ,   600   )     .   setWindowTitle   (   ' myapp '   )     .   setWindowIcon   (   QIcon   \\   (   ' icons / myapp . ico '   ) )     .   setToolTip   (   ' 看 看 &# 94 ; _&# 94 ; '   )   QToolTip   .   setFont   (   QFont   \\   (   ' 微软 雅黑 '   ,   12   ) )   myapp   =   QApplication   (   sys   .   argv   )   mywidget   =   MyWidget   ( )   mywidget   .   show   ( )   sys   .   exit   (   myapp   .   exec _   ( ) )   段 代码 代码 在于 MyWidget 类 初始 函数 新 两条 命令 。   setToolTip   方法 设置 显示 弹出 提示 文本 内容 ， 调用 QToolTip 类   setFont   方法 设置 字体 字号 ， 不 太 随便 设置 系统 字体 微软 雅黑 。   鼠标 停放 窗口 上 一会儿 会弹 出 一小 段 提示 文字 。   关闭 窗体 时 询问   【 beginning - first04 】   import   sys     PyQt5 . QtGui   import   *     PyQt5 . QtWidgets   import   *   class   MyWidget   (   QWidget   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )     .   resize   (   800   ,   600   )     .   setWindowTitle   (   ' myapp '   )     .   setWindowIcon   (   QIcon   \\   (   ' icons / myapp . ico '   ) )     .   setToolTip   (   ' 看 看 &# 94 ; _&# 94 ; '   )   QToolTip   .   setFont   (   QFont   \\   (   ' 微软 雅黑 '   ,   12   ) )   def   closeEvent   (     ,   event   ) :   # 定义 colseEvent   reply   =   QMessageBox   .   question   \\   (     ,   ' 信息 '   ,   \" 退出 ？ \"   ,   QMessageBox   .   Yes   ,   QMessageBox   .   No   )     reply   = =   QMessageBox   .   Yes   :   event   .   accept   ( )     :   event   .   ignore   ( )   myapp   =   QApplication   (   sys   .   argv   )   mywidget   =   MyWidget   ( )   mywidget   .   show   ( )   sys   .   exit   (   myapp   .   exec _   ( ) )   段 代码 代码 定义   colseEvent   事件 。 段 代码 核心 QtGui 类 QMessageBox 类 question 方法 ， 方法 将会弹 出 一个 询问 窗体 。 方法 接受 四个 参数 ： 第一个 参数 窗体 所属 母体 ， 实例 mywidget ； 第二个 参数 弹出 窗体 标题 ； 第三个 参数 一个 标准 button ； 第四个 参数 一个 标准 button ， 默认 （ enter 选定 ） button 。 方法 返回 点击 标准 button 标识符 ， 标准   QMessageBox . Yes   ， 执行 event accept 方法 。   屏幕 居中 显示 窗体   【 beginning - first05 】   import   sys     PyQt5 . QtGui   import   *     PyQt5 . QtWidgets   import   *   class   MyWidget   (   QWidget   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )     .   resize   (   800   ,   600   )     .   center   ( )     .   setWindowTitle   (   ' myapp '   )     .   setWindowIcon   (   QIcon   \\   (   ' icons / myapp . ico '   ) )     .   setToolTip   (   ' 看 看 &# 94 ; _&# 94 ; '   )   QToolTip   .   setFont   (   QFont   \\   (   ' 微软 雅黑 '   ,   12   ) )   def   closeEvent   (     ,   event   ) :   # 定义 colseEvent   reply   =   QMessageBox   .   question   \\   (     ,   ' 信息 '   ,   \" 退出 ？ \"   ,   QMessageBox   .   Yes   ,   QMessageBox   .   No   )     reply   = =   QMessageBox   .   Yes   :   event   .   accept   ( )     :   event   .   ignore   ( )   # center   method   def   center   (     ) :   screen   =   QDesktopWidget   ( )   .   screenGeometry   ( )   size   =     .   geometry   ( )     .   move   ( (   screen   .   width   ( )   -   size   .   width   ( ) )   /   2   ,   \\   (   screen   .   height   ( )   -   size   .   height   ( ) )   /   2   )   myapp   =   QApplication   (   sys   .   argv   )   mywidget   =   MyWidget   ( )   mywidget   .   show   ( )   sys   .   exit   (   myapp   .   exec _   ( ) )   例子 相比 改动 新建 一个   center   方法 ， 接受 一个 实例 ， mywidget 。 实例 窗口 具体位置 做 调整 。   QDesktopWidget 类   screenGeometry   方法 返回 一个 量 ， 量 width 属性 屏幕 宽度 （ pt 像素 计 ， 1366 × 768 ， 宽度 1366 ） ， 量 height 属性 屏幕 高度 。   QWidget 类   geometry   方法 返回 一个 量 ， 量 width 窗体 宽度 ， 量 height 属性 窗体 高度 。   调用 QWidget 类 move 方法 ， mywidget 实例 作用 。 move 方法 X ， Y 是从 屏幕 坐标 原点   ( 0 , 0 )   计算 。 第一个 参数 X 右 宽度 ， Y 向下 高度 。   函数 作用 效果 窗体 居中 显示 。   QMainWindow 类   QtGui . QMainWindow 类 提供 应用程序 主 窗口 ， 创建 一个 经典 拥有 状态栏 、 工具栏 菜单栏 应用程序 骨架 。 （ QWidget 类 ， 换成 QMainWindow 类 。 ）   第一个 例子 都 QtGui . QWidget 类 创建 一个 窗体 。 QWidget QMainWindow 两个 类 区别   网站   结论 ： QWdget 类 Qt 中是 可画类 基础 （ 窗体 基础 。 ）   基于 QWidget 类 都 独立 窗体 显示 不 母体 （ parent ） 。   QMainWindow 类 针对 主 窗体 需求 设计 ， 预定 义 菜单栏 状态栏 widget （ 窗口 小 部件 ）   。 继承 QWidget ， 谈及 属性 修改 都 。 代码 中 QWidget 类 换成 QMainWindow 类 。   【 beginning - first06 】   import   sys     PyQt5 . QtGui   import   *     PyQt5 . QtWidgets   import   *   class   MyWidget   (   QMainWindow   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )     .   resize   (   800   ,   600   )     .   center   ( )     .   setWindowTitle   (   ' myapp '   )     .   setWindowIcon   (   QIcon   \\   (   ' icons / myapp . ico '   ) )     .   setToolTip   (   ' 看 看 &# 94 ; _&# 94 ; '   )   QToolTip   .   setFont   (   QFont   \\   (   ' 微软 雅黑 '   ,   12   ) )   def   closeEvent   (     ,   event   ) :   # 定义 colseEvent   reply   =   QMessageBox   .   question   \\   (     ,   ' 信息 '   ,   \" 退出 ？ \"   ,   QMessageBox   .   Yes   ,   QMessageBox   .   No   )     reply   = =   QMessageBox   .   Yes   :   event   .   accept   ( )     :   event   .   ignore   ( )   # center   method   def   center   (     ) :   screen   =   QDesktopWidget   ( )   .   screenGeometry   ( )   size   =     .   geometry   ( )     .   move   ( (   screen   .   width   ( )   -   size   .   width   ( ) )   /   2   ,   \\   (   screen   .   height   ( )   -   size   .   height   ( ) )   /   2   )   myapp   =   QApplication   (   sys   .   argv   )   mywidget   =   MyWidget   ( )   mywidget   .   show   ( )   sys   .   exit   (   myapp   .   exec _   ( ) )   程序运行 情况 ， 加点 东西 进去 。   加上 状态栏   【 beginning - first07 】   import   sys     PyQt5 . QtGui   import   *     PyQt5 . QtWidgets   import   *   class   MainWindow   (   QMainWindow   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )     .   resize   (   800   ,   600   )     .   center   ( )     .   setWindowTitle   (   ' myapp '   )     .   setWindowIcon   (   QIcon   \\   (   ' icons / myapp . ico '   ) )     .   setToolTip   (   ' 看 看 &# 94 ; _&# 94 ; '   )   QToolTip   .   setFont   (   QFont   \\   (   ' 微软 雅黑 '   ,   12   ) )   def   closeEvent   (     ,   event   ) :   # 定义 colseEvent   reply   =   QMessageBox   .   question   \\   (     ,   ' 信息 '   ,   \" 退出 ？ \"   ,   QMessageBox   .   Yes   ,   QMessageBox   .   No   )     reply   = =   QMessageBox   .   Yes   :   event   .   accept   ( )     :   event   .   ignore   ( )   # center   method   def   center   (     ) :   screen   =   QDesktopWidget   ( )   .   screenGeometry   ( )   size   =     .   geometry   ( )     .   move   ( (   screen   .   width   ( )   -   size   .   width   ( ) )   /   2   ,   \\   (   screen   .   height   ( )   -   size   .   height   ( ) )   /   2   )   myapp   =   QApplication   (   sys   .   argv   )   mainwindow   =   MainWindow   ( )   mainwindow   .   show   ( )   mainwindow   .   statusBar   ( )   .   showMessage   (   ' 程序 已 就绪 ... '   )   sys   .   exit   (   myapp   .   exec _   ( ) )   程序 区别 在于 倒数 第二行 ， 调用 mainwindow QMainWindow 类 生成 实例   statusBar   方法 生成 一个 QStatusBar 对象 ， 调用 QStatusBar 类   showMessage   方法 显示 一段 文字 。   希望 段 代码   __ init __   方法 ， 过程 描述 类似 。   加上 菜单栏   【 beginning - first08 】   import   sys     PyQt5 . QtGui   import   *     PyQt5 . QtWidgets   import   *   class   MainWindow   (   QMainWindow   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )     .   initUI   ( )   def   initUI   (     ) :     .   resize   (   800   ,   600   )     .   center   ( )     .   setWindowTitle   (   ' myapp '   )     .   setWindowIcon   (   QIcon   \\   (   ' icons / myapp . ico '   ) )   # 菜单栏   menu _ control   =     .   menuBar   ( )   .   addMenu   (   ' Contorl '   )   act _ quit   =   menu _ control   .   addAction   (   ' quit '   )   act _ quit   .   triggered   .   connect   (     .   close   )   menu _   =     .   menuBar   ( )   .   addMenu   (   ' Help '   )   act _   =   menu _   .   addAction   (   ' ... '   )   act _   .   triggered   .   connect   (     .     )   act _ aboutqt   =   menu _   .   addAction   (   ' aboutqt '   )   act _ aboutqt   .   triggered   .   connect   (     .   aboutqt   )   # 状态栏     .   statusBar   ( )   .   showMessage   (   ' 程序 已 就绪 ... '   )     .   show   ( )   def     (     ) :   QMessageBox   .     (     ,   \"     software \"   ,   \" wise   system \"   )   def   aboutqt   (     ) :   QMessageBox   .   aboutQt   (     )   def   closeEvent   (     ,   event   ) :   # 定义 colseEvent   reply   =   QMessageBox   .   question   \\   (     ,   ' 信息 '   ,   \" 退出 ？ \"   ,   QMessageBox   .   Yes   ,   QMessageBox   .   No   )     reply   = =   QMessageBox   .   Yes   :   event   .   accept   ( )     :   event   .   ignore   ( )   # center   method   def   center   (     ) :   screen   =   QDesktopWidget   ( )   .   screenGeometry   ( )   size   =     .   geometry   ( )     .   move   ( (   screen   .   width   ( )   -   size   .   width   ( ) )   /   2   ,   \\   (   screen   .   height   ( )   -   size   .   height   ( ) )   /   2   )   myapp   =   QApplication   (   sys   .   argv   )   mainwindow   =   MainWindow   ( )   sys   .   exit   (   myapp   .   exec _   ( ) )   讨论 加上 状态栏 类似 ， QMainWindow 类   menuBar   方法 一个 菜单栏 对象 。 菜单栏 对象   addMenu   方法 创建 一个 新 菜单 对象 （ QMenu 类 ） ， addMenu 方法 内容 新建 菜单 显示 文本 。   菜单 对象 加上 动作 ， 调用 菜单 对象   addAction   方法 ， menuBar 创建 一个 菜单栏 对象 ， addMenu 方法 创建 一个 菜单 ， 返回 一个 菜单 对象 ， 菜单 对象 addAction 方法 ， 方法 菜单 添加 一个 动作 ， 或者说 一个 item 一个 内容 ， addAction 返回 一个 动作 对象 ， 动作 对象 信号 － 槽 机制 连接 ， 一个 函数 连接起来 。   动作 对象 ， 菜单 下 拉 选项 ， 鼠标 点击 ， 将会 触发   triggered   信号 ， connect 方法 连接 槽 上 （ 定义 函数 ） ， 将会 触发 函数 执行 。 信号 － 槽 机制 详细 。   信号 － 槽 机制   GUI 程序 都 引入 一种 事件 信号 机制 ， ， 简单 来说 一个 循环 程序 ， 循环 程序 等到 时刻 程序 会 自动 做 事情 刷新 程序界面 ， 扫描 键盘 鼠标 ， 用户 点击 鼠标 键盘 ， 它会 接受 信号 做出 。   猜到 ，   close   函数 退出 循环 程序 。 调用 主程序   exec _   方法 ， 开启 循环 程序 。   pyqt4 旧 信号 － 槽 连接 语句 忽略 ， 值得 提醒 pyqt5 不 支持 旧 信号 － 槽 连接 语句 。 新 语句 。   act _ exit   .   triggered   .   connect   (     .   close   )   新 信号 － 槽 机制 语句 变得 更 精简 更 易懂 。 过程 所述 ， 对象 发出 信号 ， connect 信号 槽 （ 定义 函数 ） 连接起来 一个 反射弧 。   槽 主 窗口 实例 close 方法 ， 主 窗口 自带 函数 。   aboutqt 函数 。 读者 不 懂 请 翻阅 QMessageBox 类 静态方法       aboutqt   。   信号 － 槽 详解   pyqt5 只 支持 新式 信号 － 槽 机制 ， 新式 信号 － 槽 机制 详细 。   信号 ( singal ) 连接 无数 多个 槽 ( slot ) ， 连接 槽 ， 信号 连接 信号 。 所述 ， 连接 语句 形式 ：   . singal . connect ( slot )   。 比如说 按钮 最 常见 内置 信号   triggered   ， 槽 实际上 函数 ， 主 窗体   . close   方法 。   信号   QObject   一个 属性 ， pyqt 窗体 很多 内置 信号 ， 定义 信号 ， 再 提及 。 信号 还 没 槽 连接起来 一个 属性 ，   connect   方法 连接起来 ， 信号 － 槽 机制 建立 。 类似 信号   disconnect   方法   emit   方法 。 disconnect 断开 信号 － 槽 机制 ， emit 激活 信号 。   pyqt 很多 内置 信号 内置 槽 GUI 事件驱动 细节 隐藏 ， 定义 信号 槽 . singal . connect ( slot ) 简洁 形式 工作 感到 困惑 。 先 简要地 介绍 。   信号 都 类 一个 属性 ， 新 信号 继承 QObject ，   PyQt5 . QtCore . pyqtSingal   方法 创建 ， 方法 接受 参数 中 最 types 类型 ， int ， bool ， 这是 信号 传递 参数 类型 ， 传递 参数值 emit 方法 。 槽 实际上 封装 函数 ， 函数 接受 参数 不 接受 参数 ， 参数 值 传 进来 emit 方法 执行 ， . singal . connect ( slot ) 形式 信号 槽 连接起来 ， 信号 ， 信号 类 自带 连接 方法 ， 连接 slot 函数 上 ， 隐藏 一个 细节 emit 方法 ， 比如说 定义 一个 新 信号 ， 点击 屏幕 x , y 坐标 发送 ， 内置 信号 － 槽 机制 都 ， 定义 信号 槽 ，   pyqtSingal ( int , int )   ， 发送给 func ( x , y ) ， x y 值 emit ( x , y ) 发送 。 发送 ， 发送 x , y 值 获取 ， 一个 信号 － 槽 机制 细节 。   请 看 例子 ：   【 singal - slot / age 】   import   sys     PyQt5 . QtWidgets   import   QHBoxLayout   ,   QSlider   ,   QSpinBox   ,   QApplication   ,   QWidget     PyQt5 . QtCore   import   Qt   app   =   QApplication   (   sys   .   argv   )   window   =   QWidget   ( )   window   .   setWindowTitle   (   \" enter     age \"   )   spinBox   =   QSpinBox   ( )   slider   =   QSlider   (   Qt   .   Horizontal   )   spinBox   .   setRange   (   0   ,   130   )   slider   .   setRange   (   0   ,   130   )   spinBox   .   valueChanged   .   connect   (   slider   .   setValue   )   slider   .   valueChanged   .   connect   (   spinBox   .   setValue   )   spinBox   .   setValue   (   35   )   layout   =   QHBoxLayout   ( )   layout   .   addWidget   (   spinBox   )   layout   .   addWidget   (   slider   )   window   .   setLayout   (   layout   )   window   .   show   ( )   sys   .   exit   (   app   .   exec _   ( ) )   16 行将 spinBox   valueChanged   信号 slider   setValue   槽 连接起来 ， QSpinBox 内置   valueChanged   信号 发射 自带 一个 参数 改变 后 值 ， 值 传递 QSlider 内置 槽   setValue   ， slider 值 设置 新值 。 17 行 slider 值 发生 改变 ， 会 发送 valueChanged 信号 ， 传递 spinBox ， 执行 内置 槽 setValue ， 值 原值 ， spinBox 内 值 发生 改变 ， 程序 陷入 死循环 。   自定义 信号   正 如前所述 自定义 信号   PyQt5 . QtCore . pyqtSingal   方法 创建 ， 格式 ：     PyQt5 . QtCore   import   QObject   ,   pyqtSignal   class   Foo   (   QObject   ) :   closed   =   pyqtSignal   ( )   range _ changed   =   pyqtSignal   (   int   ,   int   ,     =   ' rangeChanged '   )   Foo 类 自定义 一个 新 信号 ， GObject 子类 。 定义 一个 closed 信号 ， 接受 参数 。 range _ changed 信号 ， 接受 一个 int 一个 int 类型 ， 信号 名字 rangeChanged ， 选项 一个 可选项 ， 不填 信号 名字 range _ changed 。   信号 还 overload ， 不太 适合 python 。   信号 定义 为类 属性 ， GObject 子类 。   自定义 槽   python 格式 定义 函数 自定义 槽 。 推荐 pyqt 槽 装饰器 定义 槽 。     PyQt4 . QtCore   import   pyqtSlot   # 1   @ pyqtSlot   ( )   def   foo   (     ) :   pass   # 2   @ pyqtSlot   (   int   ,   str   )   def   foo   (     ,   arg1   ,   arg2   ) :   pass   # 3   @ pyqtSlot   (   int   ,     =   ' bar '   )   def   foo   (     ,   arg1   ) :   pass   # 4   @ pyqtSlot   (   int   ,   result   =   int   )   def   foo   (     ,   arg1   ) :   pass   # 5   @ pyqtSlot   (   int   ,   QObject   )   def   foo   (     ,   arg1   ) :   pass   第一个 例子 定义 名叫 foo 一个 槽 ， 不 接受 参数 。 第二个 槽 接受 一个 int 类型 值 str 类型 值 。 第三个 槽 名字 bar ， 接受 一个 int 类型 值 ， 第四个 槽 接受 一个 int 类型 值 ， 返回 一个 int 类型 值 ， 第五个 操作 接受 一个 int 类型 值 一个 GObject 类型 值 ， 此处 暗指 pyqt 窗体 类型 都 参数 传递 。   @ pyqtSlot   (   int   )   @ pyqtSlot   (   ' QString '   )   def   valueChanged   (     ,     ) :   pass   定义 两个 槽 ， 名字 都 valueChanged ， 一个 接受 int 类型 ， 一个 接受 QString 类型 ， 信号 overload ， python 中 不 推荐 ， 明晰 一点 好 。   发射 信号   信号 对象 emit 方法 用来 发射 信号 ， 信号 对象 disconnect 方法 断开 信号 槽 连接 。   一个 信号 连接 多个 槽 ， 多个 信号 连接 同一个 槽 ， 一个 信号 一个 信号 相连接 。   一个 例子 详解 建 信号 自建槽 建立 发射 机制 情况 。   【 singal - slot / FindDialog 】     PyQt5 . QtWidgets   import   QDialog   ,   QLabel   ,   QLineEdit   ,   QCheckBox   ,   QPushButton   ,   QHBoxLayout   ,   QVBoxLayout   ,   QApplication     PyQt5 . QtCore   import   Qt   ,   pyqtSignal   ,   QObject   ,   pyqtSlot   class   FindDialog   (   QDialog   ) :   findNext   =   pyqtSignal   (   str   ,   Qt   .   CaseSensitivity   )   findPrevious   =   pyqtSignal   (   str   ,   Qt   .   CaseSensitivity   )   def   __ init __   (     ,   parent   =   None   ) :   super   ( )   .   __ init __   (   parent   )   label   =   QLabel   (     .   tr   (   \" Find   & : \"   ) )     .   lineEdit   =   QLineEdit   ( )   label   .   setBuddy   (     .   lineEdit   )     .   caseCheckBox   =   QCheckBox   (     .   tr   (   \" Match   & case \"   ) )     .   backwardCheckBox   =   QCheckBox   (     .   tr   (   \" Search   & backward \"   ) )     .   findButton   =   QPushButton   (     .   tr   (   \" & Find \"   ) )     .   findButton   .   setDefault   (   True   )     .   findButton   .   setEnabled   (   False   )   closeButton   =   QPushButton   (     .   tr   (   \" Close \"   ) )     .   lineEdit   .   textChanged   .   connect   (     .   enableFindButton   )     .   findButton   .   clicked   .   connect   (     .   findClicked   )   closeButton   .   clicked   .   connect   (     .   close   )   topLeftLayout   =   QHBoxLayout   ( )   topLeftLayout   .   addWidget   (   label   )   topLeftLayout   .   addWidget   (     .   lineEdit   )   leftLayout   =   QVBoxLayout   ( )   leftLayout   .   addLayout   (   topLeftLayout   )   leftLayout   .   addWidget   (     .   caseCheckBox   )   leftLayout   .   addWidget   (     .   backwardCheckBox   )   rightLayout   =   QVBoxLayout   ( )   rightLayout   .   addWidget   (     .   findButton   )   rightLayout   .   addWidget   (   closeButton   )   rightLayout   .   addStretch   ( )   mainLayout   =   QHBoxLayout   ( )   mainLayout   .   addLayout   (   leftLayout   )   mainLayout   .   addLayout   (   rightLayout   )     .   setLayout   (   mainLayout   )     .   setWindowTitle   (     .   tr   (   \" Find \"   ) )     .   setFixedHeight   (     .   sizeHint   ( )   .   height   ( ) )   def   enableFindButton   (     ,   text   ) :     .   findButton   .   setEnabled   (   bool   (   text   ) )   @ pyqtSlot   ( )   def   findClicked   (     ) :   text   =     .   lineEdit   .   text   ( )       .   caseCheckBox   .   isChecked   ( ) :   cs   =   Qt   .   CaseSensitive     :   cs   =   Qt   .   CaseInsensitive       .   backwardCheckBox   .   isChecked   ( ) :     .   findPrevious   .   emit   (   text   ,   cs   )     :     .   findNext   .   emit   (   text   ,   cs   )     __ __   = =   ' __ main __ '   :   import   sys   app   =   QApplication   (   sys   .   argv   )   findDialog   =   FindDialog   ( )   def   find   (   text   ,   cs   ) :   print   (   ' find : '   ,   text   ,   ' cs '   ,   cs   )   def   findp   (   text   ,   cs   ) :   print   (   ' findp : '   ,   text   ,   ' cs '   ,   cs   )   findDialog   .   findNext   .   connect   (   find   )   findDialog   .   findPrevious   .   connect   (   findp   )   findDialog   .   show   ( )   sys   .   exit   (   app   .   exec _   ( ) )   自建 信号 类 属性 ， 类 QObject 子类 ， QDialog 继承 QObject 。 请 9 行 10 行 ， pyqtSignal 函数 来自 建 信号 ， 信号 两个 参数 ， 一个 str 字符 变量 ， 一个 Qt . CaseSensitivity 枚举 值 。 假设 输入 文字 ， 点击 Find 按钮 ， 请 26 行 ， 点击 执行 findClicked 槽 ， 按钮 clicked 信号 不带 参数 。 定义 findClicked 槽 （ 简单 函数 ） 参数 。   findClicked 槽 53 - 57 行 QLineEdit text 值 cs 大小写 检查 状态 。 向前 后 勾选来 接下来 发送 信号 。 findNext 信号 调用 emit 方法 ， 两个 参数 传递 。 findNext 正是 自定义 信号 ， 正是 两个 参数 类型 。   再 简单 做 一个 测试程序 ， 70 - 73 行 定义 两个 简单 函数 ， 75 ， 76 行将 findDialog 两个 信号 两个 函数 连接起来 。 点击 Find 按钮 ， 执行 findClicked 槽 ， 假设 发送 findNext 信号 （ 附带 两个 参数 ） ， 信号 find 函数 相连 （ 参数传递 find 函数 ） ， 执行 find 函数 。 过程 。   信号 － 槽 机制 反思   接下来 Qt   designer 一章 会 详细 讨论 ， Qt   designer 设计 修改 ui 文件 — — 程序 中 大部分 静态 视图 元素 ， 目的 倒 快速 GUI 程序 编写 ， 写 代码 挺快 ， 目的 代码 复用 。 养成 习惯 ， 强迫 程序 中 静态 视图 元素 都 ui 文件 ， 增强 ui 文件 复用 性 ， 增强 剩下 python 代码 复用 性 。 很大 一部分 讨论 信号 － 槽 机制 功劳 。   自定义 类 加载 好 ui 文件 ， 该类 代码 实际上 剩下 两个 工作 ：   窗体 信号 槽 都 编写 好   母 窗体 和子 窗体 信号 － 槽 接口 写 好 。   程序 用户 互动 接口 大多 最 顶层 ， 用户 喜欢 菜单栏 找到 程序 控制 ， 控制 函数 放在 都 放在 母 窗体 ， 程序 代码 复用 性会 降到 最低 ， 函数 移到 视图 窗体 最 紧密 窗体 类中 ， 代码 复用 性会 大大提高 ， 槽 函数 编写 会 简单 很多 。 组织 信号 槽 （ 函数 ） ？ 提出 组织学 上 抽象 原则 ：   最小 组织 原则 ， 凡是 小 组织 自我实现 功能 绝不 上 传到 更大 一级 组织 中 去 。   大 组织 小 组织 元素 引用 ， 采用 明文 引用 原则 。 比如说 母 窗体 中有 一个 小窗 体有 一个 编辑器 ， 母 窗体 想要 操控 编辑器 执行 剪切 操作 ， 采用 明文 引用 ， . textEdit . cut 。   小 组织 对大 组织 属性 引用 采用 信号 激活 原则 ， 比如说 编辑器 发生 内容 修改 ， 自定义 一个 信号 ， 信号 标题 修改 信号 ， 信号 触发 母 窗体 方法 ， 修改 母 窗体 标题 目的 。 母 窗体 中 ， 只 声明 小 组织 信号 大 组织 方法 连接起来 即可 。   引用 信号 发射 对象   sender   方法 来自 GObject ， Qt 里 窗体 对象 都 。 用法 槽 ， 调用   . sender ( )   ， 返回 一个 发射 信号 调用 槽 对象 。   布局 管理   布局 管理 GUI 设计 中 回避 一个 话题 ， 详细 讨论 下 pyqt 布局 管理 。 正 如前所述 ， pyqt5 用于 布局 管理 类 都 移到 QtWidgets 子 模块 ， 最   QHBoxLayout     QVBoxLayout   。   QBoxLayout   QHBoxLayout     QVBoxLayout   一个 横向 排布 ， 一个 竖向 排布 。 方法 所示 ：   mainLayout   =   QHBoxLayout   ( )   mainLayout   .   addWidget   (   button1   )   mainLayout   .   addWidget   (   button2   )     .   setLayout   (   mainLayout   )   Layout 对象 好像 一个 封装 器 ， Layout 还 Layout ， 窗体 子 单元 ， 都   addWidget   方法 确立 封装 关系 。 主母 窗口 接受 一个 Layout 对象 ，   setLayout   方法 。   【 layout / 】     PyQt5 . QtWidgets   import   QApplication   ,   QWidget   ,   QLabel   ,   QVBoxLayout   ,   QPushButton   ,   QLineEdit   ,   QMessageBox   class   Form   (   QWidget   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )   nameLabel   =   QLabel   (   \" Name : \"   )     .   nameLine   =   QLineEdit   ( )     .   submitButton   =   QPushButton   (   \" Submit \"   )   bodyLayout   =   QVBoxLayout   ( )   bodyLayout   .   addWidget   (   nameLabel   )   bodyLayout   .   addWidget   (     .   nameLine   )   bodyLayout   .   addWidget   (     .   submitButton   )     .   submitButton   .   clicked   .   connect   (     .   submit   )     .   setLayout   (   bodyLayout   )     .   setWindowTitle   (   \" Hello   Qt \"   )     .   show   ( )   def   submit   (     ) :     =     .   nameLine   .   text   ( )       = =   \" \"   :   QMessageBox   .   information   (     ,   \" Empty   Field \"   ,   \" Please   enter   a   . \"   )   return     :   QMessageBox   .   information   (     ,   \" Success ! \"   ,   \" Hello   % s   ! \"   %     )     __ __   = =   ' __ main __ '   :   import   sys   app   =   QApplication   (   sys   .   argv   )   screen   =   Form   ( )   sys   .   exit   (   app   .   exec _   ( ) )   addStretch 方法   插入 一个 分隔符 ， 设计 器 弹簧 。   QGridLayout   tkinter 中有 grid 方法 ， 网格 布局 ， pyqt 中 网格 布局 对象 QGridLayout 。 QGridLayout 用法 QBoxLayout 类似 ，   addWidget   方法 还 接受 两个 额外 参数 几行 几列 。   请 例子 。 例子 很 好 演示 QGridLayout 。   ( i - 1 ) / / 3   该数 3 取商 ， 本来 1   2   3   4   5   6 … 0   0   0   1   1   1   2   2   2 … 正好 网格 中 几行 ，   ( i - 1 ) % 3   该数 3 取余 ， 本来 1   2   3   4   5   6 … 0   1   2   0   1   2   0   1   2 … 正好 网格 中 几列 概念 。   【 layout / gridlayout 】     PyQt5 . QtWidgets   import   QApplication   ,   QWidget   ,   QPushButton   ,   QGridLayout   class   Form   (   QWidget   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )   bodyLayout   =   QGridLayout   ( )     i     range   (   1   ,   10   ) :   button   =   QPushButton   (   str   (   i   ) )   bodyLayout   .   addWidget   (   button   , (   i   -   1   )   / /   3   , (   i   -   1   )   %   3   )   print   (   i   , (   i   -   1   )   / /   3   , (   i   -   1   )   %   3   )     .   setLayout   (   bodyLayout   )     .   setWindowTitle   (   \"   grid   layout \"   )     .   show   ( )     __ __   = =   ' __ main __ '   :   import   sys   app   =   QApplication   (   sys   .   argv   )   screen   =   Form   ( )   sys   .   exit   (   app   .   exec _   ( ) )   QFormLayout   QFormLayout ， 表单 布局 ， 常用 提交 配置 信息 表单 。   请 例子 。 例子 来自 pyqt5 源码 examples 文件夹 layouts 文件夹 basiclayouts . py 文件 ， 做 简化 用于 演示 表单 布局 。   【 layout / basiclayouts 】     PyQt5 . QtWidgets   import   (   QApplication   ,   QDialog   ,   QDialogButtonBox   ,   QFormLayout   ,   QGroupBox   ,   QLabel   ,   QLineEdit   ,   QSpinBox   ,   QVBoxLayout   ,   QTextEdit   )   class   Dialog   (   QDialog   ) :   def   __ init __   (     ) :   super   ( )   .   __ init __   ( )     .   createFormGroupBox   ( )   buttonBox   =   QDialogButtonBox   (   QDialogButtonBox   .   Ok   |   QDialogButtonBox   .   Cancel   )   buttonBox   .   accepted   .   connect   (     .   accept   )   buttonBox   .   rejected   .   connect   (     .   reject   )   mainLayout   =   QVBoxLayout   ( )   mainLayout   .   addWidget   (     .   formGroupBox   )   mainLayout   .   addWidget   (   buttonBox   )     .   setLayout   (   mainLayout   )     .   setWindowTitle   (   \" user   info \"   )   def   createFormGroupBox   (     ) :     .   formGroupBox   =   QGroupBox   (   \"   infomation \"   )   layout   =   QFormLayout   ( )   layout   .   addRow   (   QLabel   (   \" : \"   ) ,   QLineEdit   ( ) )   layout   .   addRow   (   \" age : \"   ,   QSpinBox   ( ) )   layout   .   addRow   (   QLabel   (   \"   infomation : \"   ) ,   QTextEdit   ( ) )     .   formGroupBox   .   setLayout   (   layout   )     __ __   = =   ' __ main __ '   :   import   sys   app   =   QApplication   (   sys   .   argv   )   dialog   =   Dialog   ( )   sys   .   exit   (   dialog   .   exec _   ( ) )     QDialog   类   QDialogButtonBox   类 不 去 ， QDialog 类 accept reject 方法 ， QDialogButtonBox 最 两个 按钮 绑定 喜好 accepted rejected 。   创建 表单 函数 ，   QGroupBox   一个 窗体 类型 ， 带有 标题 。 接下来 QFormLayout 表单 布局 核心 代码 ：   layout   =   QFormLayout   ( )   layout   .   addRow   (   QLabel   (   \" : \"   ) ,   QLineEdit   ( ) )   layout   .   addRow   (   QLabel   (   \" age : \"   ) ,   QSpinBox   ( ) )   layout   .   addRow   (   QLabel   (   \"   infomation : \"   ) ,   QTextEdit   ( ) )     .   formGroupBox   .   setLayout   (   layout   )   layout 创建 母 窗体 layout   setLayout   方法 两个 布局 都 类似 ， 表单 布局 一行行 ， 方法 addWidget ，   addRow   ， addRow 方法 意义 上 接受 两个 窗体 类型 （ 包括 layout 类型 ） ，   第一个 参数 还 字符串 ， 显示 文字   。   ui 文件 管理   利用   Qt   designer   设计 输出   ui   界面 文件 ，   PyQt5 . uic . loadUi   加载 进来 ， ui 文件 利用 pypi 资源管理 机制 ， 一种 解决方案 ， pythonic 。   推荐   pyuic5   输出 ui 文件 py 文件 。 大体 利用 命令行 ：   pyuic5   {   filename   }   .   ui   -   o   {   filename   }   _ ui   .   py   - -   import   -     =   {   project   }   ' . format ( filename = filename ,   project   =   PROJECT   )     - - import -   选项 影响 输出 py 文件 资源 引入 语句 ， 默认   import   main _ rc   ， 设置 选项 更 改为 ：     project   import   main _ rc   利用 输出 py 文件 ui 类 。     . uis . main _ ui   import   Ui _ MainWindow   class   MainWindow   (   QMainWindow   ) :   def   __ init __   (     ,   parent   =   None   ,   *   args   ) :   super   ( )   .   __ init __   (   parent   ,   *   args   )   ###   setup   ui     .   mainUi   =   Ui _ MainWindow   ( )     .   mainUi   .   setupUi   (     )   引入 官方 教程 几种 写法 ， 写法 中   setupUi   函数 跟着 窗体 parent ， 挂 窗体 上 ， 窗体 挂 母 窗体 即可 。   配置文件 管理   pyqt5 里 QtCore 子 模块 里 提供   QSettings   类来 管理软件 配置文件 。   QSettings 构造函数   先 推荐 OrganizationName ApplicationName 设置 好 。   app   .   setOrganizationName   (   \" Wise \"   )   app   .   setApplicationName   (   \" wise \"   )   接下来 构建 一个 QSettings 对象 。   QSettings   (   parent   )   设置 好 组织 名 软件 名 ， 上 简单   QSettings ( )   创建 一个 配置文件 对象 ， 不带 参数 ， parent 取 默认值 ， format 取 默认值   QSettings . NativeFormat   ， scope 取 默认值   QSettings . UserScope   。 scope QSettings . SystemScope ， 软件 配置文件 权限 ， 先 略过 ， 默认 UserScope 。   fromat 取 默认 NativeFormat 软件 配置文件 安装 目录 ：   linux 系统 ， 例子 配置文件 ：   / home / wanze / . config / Wise / wise . conf   windows 系统 ， 例子 ：   HKEY _ CURRENT _ USER \\ Software \\ Wise \\ wise   windows 下 配置 放在 注册表 。   IniFormat   希望 配置文件 都 ini 形式 存储 ， 格式 初始化 配置文件 对象 ：   . settings   =   QSettings ( QSettings . IniFormat , QSettings . UserScope , \" Wise \" , \" wise \" )   配置文件 ：   / home / wanze / . config / Wise / wise . ini   。 linux 系统 情况 ， windows 系统 官方 文档 给出 ：   % APPDATA% \\ Wise \\ wise . ini   ，   % APPDATA%     C : \\ Documents     Settings \\ * User   Name * \\ Application   Data   调用   . settings . fileName ( )   查看 配置文件 对象 路径 所在 。   推荐 配置文件 mainwindow 实例 属性 如上 . settings ， 子 窗体 都 调用 配置文件 对象 。   ini 文件 存放 DIY   希望 ini 文件 放在 喜欢 地方 ， 配置文件 构造函数 第三种 形式 ：   QSettings ( \" wise . ini \" , QSettings . IniFormat )   第一个 参数 配置 文件名 ， 第二个 参数 format 。 上 相对路径 是从 软件 运行 时 文件夹 算 。   调用   settings . fileName ( )   配置文件 所在 。   ini 文件 注意事项   ini 文件 大小写 不 敏感 ， 尽量避免 两个 变量名 相近 大小写 。   \" \\ \" \" / \" 。 windows 里 \\ 会 转换成 / ， \" / \" 配置文件 中 分组 关系 。   存值 读值   配置文件 对象 建立 很 存放 值 读 取值 。 存值   setValue   方法 ， 取值     方法 。 所示 ：   settings . setValue ( \" editor / wrapMargin \" ,   68 )   margin   =   . settings . ( \" editor / wrapMargin \" )   setValue 键 配置文件 对象 中 ， 更新 值 ， 修改 生效 ，   sync   方法 ， sync 方法 不 接受 参数 ， 同步 配置文件 中 更新 。     方法 第一个 参数 \" 键 \" ， 第二个 参数 选值 ， 没 找到 键 ， 将会 返回 值 。 写 上 ， 配置文件 不 ， 会 发生 读取 错误 。   方法 ：   :   接受 一个 \" 键 \" ， 字符串 对象 ， 返回 bool 值 ， 键 。   remove :   接受 一个 \" 键 \" ， 移除 该键 。   allkeys :   不 接受 参数 ， 返回 \" 键 \" 。   clear :   不 接受 参数 ， 清除 \" 键 \" 。   群组 管理   settings . setValue ( \" editor / wrapMargin \" ,   68 )   上 例子 所示 \" / \" 数据结构 中 分组 ， 很多 值 都 前缀 ， 同属 一组 ， beginGroup 方法 endGroup 方法 管理 。 所示 ：   settings . beginGroup ( \" editor \" )   settings . setValue ( \" wrapMargin \" ,   68 )   settings . engGroup ( )   快捷键 Tab 键 管理   创建 ui 文件 Action 快捷键 设置 好 。   伙伴关系   QLabel setBuddy 方法 关联 输入 窗体 。 QLabel 一个 快捷键 ， 下 快捷键 ， 输入 焦点 就会 转到 QLabel 伙伴 输入 窗体 上 。   快捷键   QShortcut 类   文本 前用 & 会 引入 Alt + w 快捷键 。   QAction 初始化   QAction 方法   QKeySequence   QKeySequence   类 pyqt4 pyqt5 中 来自 QtGui 子 模块 ， 快捷键 解决方案 。 引用   QKeySequence . Open   快捷键 Ctrl + O 。 可用 构造函数 所示 ：   QKeySequence ( QKeySequence . Print )   QKeySequence ( tr ( \" Ctrl + P \" ) )   QKeySequence ( tr ( \" Ctrl + p \" ) )   QKeySequence ( Qt . CTRL   +   Qt . Key _ P )   不 太 喜欢 第一种 表达方式 ， 软件 都 打印 操作 ， 打印 快捷键 之间 逻辑联系 ， 程序员 经验 ， 这是 不小 记忆负担 。 喜欢 第四种 写法 ， 看上去 意义 清晰 ， Qt 来自 QtCore 子 模块 。   字母 按键 类似   Qt . Key _ W   形式 ， Shift 按键 Qt . SHIFT ， Meta 按键 Qt . META ， CTRL 按键   Qt . CTRL   ， ALT 按键   Qt . ALT   。   资源 文件 管理   资源管理   pyqt 都 qrc 文件 管理软件 内部 资源 文件 （ 图标 文件 ， 翻译 文件 ） 。 qrc 文件 编写 格式 ：   < ! DOCTYPE   RCC >   < RCC   version =   \" 1.0 \"   >   < qresource >   < file >   images / copy . png   < / file >   < / qresource >   < / RCC >   qrc 编写 很 简单 ， 手工 编写 。 代码 第三行 images / copy . png qrc 文件 所在 目录 下 images 文件夹 ， copy . png 文件 。   qrc 文件 编写 好 运行 命令   pyrcc5   wise . qrc   - o   wise _ rc . py   将会 输出 一个   wise _ rc . py   文件 ， 资源 ，   import   wise _ rc   引用 路径   : / images / copy . png   ， 图标 文件 。   推荐 一个 项目 资源 文件 都 一个 qrc 文件 管理 。   国际化 支持   小节 参考资料 官方 文档 之外   网站   。   指 pyqt 软件 国际化 支持 指 i18n ， 两种 语言 ， 英语 本土 语言 。 软件 字符串 都 英语 ，   . tr ( )   封装 ， 官方 pyqt5 文档     ， 推荐 形式 ：     PyQt5 . QtCore   import   QCoreApplication   QCoreApplication . translate ( ' A ' ,   \" Hello \" )   translate 函数 第一个 参数 翻译 目标 类 ， 第二个 翻译 字符串 。 写个 translate 函数 ， 翻译 都 统一 程序 主类 上 。   def   translate   (   string   ,   targetobj   =   None   ) :     targetobj     None   :   targetobj   =   \" MainWindow \"   return   QCoreApplication   .   translate   (   targetobj   ,   string   )   项目 里 新建 一个 translations 文件夹 ， 新建 一个 小 文件   wise . pro   ， wise 模块 名字 ， 随意 修改 。 文件 内容 简要 ：   SOURCES   + =   .. / main . py   .. / __ init __. py   \\   .. / Widgets / __ init __. py   TRANSLATIONS   + =   wise _ zh _ CN . ts   SOURCES   希望 扫描 py 文件 ， 文件 所说 translate 封装 ， 字符串   pylupdate5   工具 扫描 。 支持 路径 表达 。 不 支持 glob 语法 。   第二个 变量 TRANSLATIONS 希望 生成 目标 翻译 ts 文件 文件名 ， 格式 ：   { PROJECT _ NAME } _ { QLocale . system ( ) . ( ) } . ts   PROJECT _ NAME 项目 名字 ， QLocale . system ( ) . ( ) 机器 所用 目标语言 简写 ， python3 eval 模式 下 查看 ：   > > >     PyQt5 . QtCore   import   QLocale   > > >   QLocale . system ( ) . ( )   ' zh _ CN '     pylupdate5   小 工具 pro 文件 ：   pylupdate5   wise . pro   生成   wise _ zh _ CH . ts   文件 。   翻译 文件   样 下 ：     PyQt5 . QtCore   import   QTranslator   ,   QLocale   myapp   =   QApplication   (   sys   .   argv   )   translator   =   QTranslator   ( )     translator   .   load   (   ' wise _ '   +   QLocale   .   system   ( )   .     ( )   +   ' . qm '   ,   \" : / translations / \"   ) :   myapp   .   installTranslator   (   translator   )   构建 一个 QTranslator 对象 ， 调用 对象 方法 load ， 第一个 参数 load qm 文件名 ， 第二个 参数 qm 文件 路径 ， 谈及 qrc 引用 路径 。   主母 窗口 myapp installTranslator 方法 QTranslator 对象 加进去 即可 。   qt 官方 翻译 文件   qt 窗体 内部 文字 不好 DIY ， 上 加载 qt 官方 翻译 文件 。 代码 所示 ：   translator _ qt   =   QTranslator   ( )     translator _ qt   .   load   (   ' qt _ '   +   QLocale   .   system   ( )   .     ( )   +   ' . qm '   ,   \" : / translations / \"   ) :   #   print ( ' i   found   qt ' )   myapp   .   installTranslator   (   translator _ qt   )   主母 窗口 myapp 加载 两个 翻译 文件 。   官方 qt 翻译 文件 qt 源码 translations 文件夹 ， git   clone 获取 。   git   clone   https : / / gitorious . org / qt / qttranslations . git   ts 文件 如前所述   lrelease   命令 ， 语言 工具 打开 发布 即可 。   exe 制作 安装程序 制作   exe 制作   exe 制作 写 pyqt 程序 或者说 python 程序 freeze ， 目标 机器 上 用户 安装 python 依赖 都 运行 程序 。   推荐 pyinstaller 。   pyinstaller 官网     。   pip   安装 ， 推荐 项目 根目录 下 创建 一个 简单 启动 脚本 ， 平时 测试 ， pyinstaller 程序 入口 。   \" \" \"     pyinstaller   脚本 名字 设置   quicktikz   \" \" \"   import   quicktikz . main     __ __   = =   ' __ main __ '   :   quicktikz   .   main   .   gui   ( )   NOTICE :   脚本 名字 pyqt 程序 模块 名字 ， 安装 后 闪退 脚本 名字 没取 好 。   很 简单 ：   import   subprocess   PROJECT   =   ' quicktikz '   cmd   =   ' pyinstaller . exe   - - noconsole   - y   QuickTikz . py '   subprocess   .   call   (   cmd   ,   shell   =   True   )     - y   选项 自动 删除 原 输出 文件 ，   - - noconsole   隐藏 pyqt 程序 终端 界面 ， 程序 会开 两个 窗口 不太好 看 。   一切顺利 ，   dist   文件夹 下 运行 目标程序 exe 运行 ， 都 OK ， 出 ， 请 钻研 官方 文档 。 。   安装程序 制作   推荐   advanceinstaller 程序 ， 程序   官网 地址   。 推荐 安装 官网 simple   过程 ， 请 参看 官网   入门 tutorial   。   设置 文件 文件夹   dist   内容 都 加进去 即可 ， 软件 操作 说 添加 文件 只能 添加 文件 ， dist   PyQt5 文件夹 再 操作 添加 文件夹 。   运行 顺利 ， 太好了 ， 程序 安装程序 ， 赶快 分享 小伙伴 。",
            "tags":"archived",
            "url":"articles/pyqt5-learning-notes.html"
        },
        {
            "title":"wxpython学习笔记",
            "text":"WARNING   警告 ， 文档 归档 ， 缺少 新 内容 ， 旧 内容 错误 ， 推荐 pyside2 GUI 编程 。 GUI 编程 请 参看   pyside2 学习 笔记   。   wxpython   本文 假设 读者 熟悉 一种 桌面 图形 开发 ， 比如说 PyQt ， 图形 桌面开发 概念 读者 熟悉 ， 言简意赅 wxpython 相关 特色 核心 概念 ， 针对 讨论 。   说 下 安装 ， wxpython pyqt5 都 ， 都 pip 安装 ， linux 下 windows 都 安装 。   Sizer . Add 参数 详解   Sizer . Add ( item ,   0   ,   wx . ALIGN _ RIGHT ,   0 )   右 对齐 布局 ， 第一个 参数 proportion 详细 讨论 ， 第三个 参数 设置 border 宽度 。   Sizer . Add ( item ,   0 ,   wx . ALIGN _ CENTER ,   0 )   居中 布局   Sizer . Add ( item ,   0 ,   wx . EXPAND ,   0 )   扩展 布局 ， （ vertical   sizer 水平 扩展 ； horizontal   sizer 垂直 扩展 ）   proportion 参数   默认 0 ， 0 不 缩放 ， 估计 设置 父 窗体 Layout ， 而子 窗体 自动 Layout 。 设置 整数 某种 缩放 。 参考资料 谈 缩放 ， 暂时 很 关心 。 讨论 原文 ：   proportion 参数 wx . BoxSizer 用作 因数 去 sizer 大小 改变 时 ， sizer 调整 孩子 尺寸 。 水平 方向 调整 sizer ， stretch 因数 孩子 水平 尺寸 改变 （ 坚直 方向 改变 box   sizer 基于 第三个 参数 ） 。   0 不 缩放 ， 1 父 窗体 缩放 缩放 。   Flag 参数   这块 东西 ， Flag ， 建议 沉下 心来学 ， 会 频繁 用到 ：   控制 border   wx . TOP   wx . BOTTOM   wx . LEFT   wx . RIGHT   wx . ALL   扩展   wx . EXPAND   空间 扩展   wx . SHAPED   扩展 宽高比   对齐   wx . ALIGN _ CENTER     wx . ALIGN _ CENTRE   wx . ALIGN _ LEFT   wx . ALIGN _ RIGHT   wx . ALIGN _ RIGHT   wx . ALIGN _ TOP   wx . ALIGN _ BOTTOM   wx . ALIGN _ CENTER _ VERTICAL     wx . ALIGN _ CENTRE _ VERTICAL   wx . ALIGN _ CENTER _ HORIZONTAL     wx . ALIGN _ CENTRE _ HORIZONTAL   举 组合 例子 ：   wx . EXPAND   |   wx . LEFT   空间 扩展 ， border 左边 ， 会 左边 空白   wx . EXPAND   |   wx . LEFT   |   wx . RIGHT   空间 扩展 ， border 左边 右边 ， 会 左边 右边 空白   wx . EXPAND   |   wx . ALL   空间 扩展 ， 上下左右 border 都   Frame 样式   wx . FRAME _ NO _ TASKBAR   任务栏   wx . FRAME _ SHAPED   非 矩形 框架   wx . FRAME _ TOOL _ WINDOW   wx . FRAME _ FLOAT _ ON _ PARENT   框架 漂浮 父 窗体 之上   wx . STAY _ ON _ TOP   总在 最上   wx . SIMPLE _ BORDER   装饰 边框   布局 太 布局   手写 布局 代码 ， 肯定 Sizer ， BoxSizer 最 常用 ， 特别 布局 BoxSizer ， 横竖 拼接 加上 Add 参数 调配 ， 基本上 都 调 。 panel 类 都 写 上 一个   . box   惯例 ， 情况 下会 Sizer ， GridSizer ， GridSizer 放在 BoxSizer ， 不 大 。 惯例 ， 引用 面板 ， 想到 主 Sizer ， panel . box 即可 ， 这是 题外话 。   FlexGridSizer   FlexGridSizer 布局 页面 分成 二维 表格 ， 表格 元素 高度 ， 宽度 不 （ GridSizer ） 。   wx . FlexGridSizer ( int   rows = 1 ,   int   cols = 0 ,   int   vgap = 0 ,   int   hgap = 0 )   rows   行   cols   列   vgap   垂直 加点 空间   hgap   水平 加点 空间   wxpython ID   window   identifiers   整数   窗体 系统 中 唯一性 ， wxpython 中 定义 窗体 ID ：   窗体 ID 定义   赋值 一个 正整数 ， 不 推荐   wx . NewID ( )   传递 wx . ID _ ANY     - 1   窗体 构造 器   frame   =   wx . Frame .__ init __ ( None ,   - 1 )   id   =   frame . GetId ( )   笔者 强烈推荐 读者 名字 定义 定位 窗体 ， 代码 更 可读性 。   标准 ID   官方 文档 标准 ID 列表   ID 查找 窗体   1 、 wx . FindWindowById ( id ,   parent = None )   2 、 wx . FindWindowByName ( ,   parent = None )   3 、 wx . FindWindowByLabel ( label ,   parent = None )   窗 体内 调用   . FindWindowById   本窗 体内 查找 ， 找到 第一个 。   名字 查找 窗体   笔者 强烈推荐 读者 写 大型 GUI 程序 几个 核心 窗体 都 定义 好 唯一 名字 （ 大部分 窗体 都 接受 一个 可选 参数 ） ， 查找 。 编程 会 带来 很大 便利 。   import   wx   def   find _ window _ _   (     ) :   \" \" \"   窗体 名字 返回 窗体 ， 推荐 风格   : param   :   : return :   \" \" \"   window   =   wx   .   FindWindowByName   (     )   return   window   def   _ _ window _   (   window   ,     ) :   \" \" \"   名字 判断 是否是 窗体   : param   window :   : param   :   : return :   \" \" \"     window   .   SetName   ( )   = =     :   return   True     :   return   False   理解 wxpython 中 事件   Bind ( event ,   handler ,   source = None ,   id = wx . ID _ ANY ,   id2 = wx . ID _ ANY )   event   wx . Button 上 鼠标 单击 触发 一个   wx . EVT _ BUTTON   事件 ， event 定义 想要 绑定 事件 。   handler   处理器   source   不 指定 ， 父 窗口 多个 触发 源 ， 比如说 多个 按钮 ， 指定 下 。   id   id 定义 事件 触发 源 ， 情况 下 id 来会 更 些 ， id2 id 一串 连续 窗体 。   wxpython 事件 处理过程   事件 触发 - - >   获取 事件 触发 对象   检查 事件 触发 对象 处理事件 （   SetEvtHandlerEnabled ( boolean )   禁用 窗体 处理事件 ） 【 UI 层面 Disable   Enable 禁用 窗体 用户 交互 ， 间接 接受 事件 ， PostEvent 】   event . Skip ( )   方法 事件 跳过 ， 理解 错误 ， 更 准确 说法   事件处理   。   事件 触发 链中 ， 方法 ， 事件 将会 传播 ， 事件处理 终止 。   目标 事件   传播 propagate   ，   还会 触发 父 容器 事件 ， App ， 最 顶层 结束 传播 。 【 默认 情况 ， wx . CommandEvent 子类 实例 向上 展开 容器 级 。 事件 都 不 传播 。 】 【 Button 单击 CommandEvent ， 鼠标 浮动 上 离开 都 MouseEvent 】   习题 1   请 读者 解释 写法 ， 鼠标 浮动 上 离开 事件 只能 定向 . button 。   . Bind ( wx . EVT _ BUTTON ,   . OnButtonClick ,   . button )   # 1   绑定 按钮 事件   . button . Bind ( wx . EVT _ ENTER _ WINDOW ,   . OnEnterWindow )   # 2   绑定 鼠标 位于 其上 事件   . button . Bind ( wx . EVT _ LEAVE _ WINDOW ,   . OnLeaveWindow )   # 3   绑定 鼠标 离开 事件   按钮 点击 传播 ， 窗体 上 触发 按钮 事件 ， 窗体 上 找 方法   OnButtonClick   ， 找到 方法 ， 执行 ， 执行 过程 中 Skip 方法 ， 事件处理 到此结束 ； ， 会试 向上 传播 ， 顶层 窗体 。 向上 传播 过程 传播 事件 ， 窗体 父 窗体 触发 按钮 事件 ， 试着 实行   OnButtonClick   方法 。   鼠标 不 传播 事件 ， 指明 按钮 绑定 。   . button . Bind   过程 执行 初始 挂 方法 ， 找 不到 抛出 异常 。   大体 ， 读者 不 明白 ， 请 阅读   wxpython     action   本书 第三章 ， 这部分 ， 本书 讲 很 好 。   习题 2   一个 按钮 点击 事件 会 触发 两个 动作 。   简单 来说 写 两个   . button . Bind ( )   语句 绑定 两个 函数 ， 说 ， 两个 函数 都 跟上   event . Skip ( )   。   手动 触发 事件   手动 触发 一个 事件 会省 下 很多 代码 。   . Close ( True )   获取 事件 触发 对象   button   =   event . GetEventObject ( )   print ( button . GetName ( ) )   常见 wx . Event 子类   wx . CloseEvent   frame 框架 关闭 时 触发   wx . CommandEvent   按钮 单击   菜单 选择     wx . KeyEvent   按键 事件   wx . MouseEvent   鼠标 事件   wx . PaintEvent   窗体 重画 时 触发   wx . SizeEvent   窗体 大小 布局 改变 时 触发   wx . TimerEvent   wx . Timer 类 创建 定时 事件   按钮 三 事件   按钮 GUI 设计 中是 频率 高 一个 组件 ， 绑定 最 常用 三个 事件 ：   . Bind ( wx . EVT _ BUTTON ,   . OnButtonClick ,   . button )   绑定 按钮 事件   . button . Bind ( wx . EVT _ ENTER _ WINDOW ,   . OnEnterWindow )   绑定 鼠标 位于 其上 事件   . button . Bind ( wx . EVT _ LEAVE _ WINDOW ,   . OnLeaveWindow )   绑定 鼠标 离开 事件   调用 Layout 方法   动态 调整 GUI 元素 ， 会 网上 例子 会 调用   Layout 方法 ， 发现 不 调用 影响 不 大 ， 发现 不 调用 页面 会 变形 ， 到底 调用 Layout 方法 。 请 参看   篇文章   。   StaticText     SetLable   操作 ， Layout 下   sizer 显示 隐藏 面板 元素 Layout   下 。   窗体 触发   EVT _ SIZE   事件 ， wxpython 会 自动 Layout 重排 。 重排 父 窗体 sizer 会 自动 Layout ， 父 窗体 子 窗体 会 重排 操作 ， 子 窗体 不 重排 ， 接受   EVT _ SIZE   事件 ， 调用 Layout 方法 。 StaticText   更改 Layout ， 调用 其父 窗体 Layout ， StaticText 自动 调整 。     网页   介绍 ， 加上 一点 实践经验 ， 不 推荐   SetSizerAndFit   方法 ， 体验   SetSizer   工作 ， 加上 Fit 会 布局 带来 困扰 ， ScrolledPanel Fit 会 发生 截断 。   总 原则 试验 确实 可行 ：   SetSizer   发现 不对劲 ， Layout   Layout 还 不对劲 ， 布局 ， 情况 下 更改 数据 ， Refresh   TODO   Layout     Refresh   区别   一个 ， Refresh 才 ， 重画 透明 组件 再 设置 标签 ， Refresh 才 会 再次 重画 动作 ， 值得 读者 。 子 面板 Layout 会 自动 Refresh 。   ScrolledPanel   特别 值得一提的是   ScrolledPanel   内容 发生 变动 ， Layout 之外 还 加上 ：   . SetupScrolling ( )   实践 发现 内容 变动 都 加上 这句 ， 侧边 滚动条 会 丢失 ， 内容 会 隐藏 。   设置 背景 颜色 字体 颜色   wxpython 窗体 对象 （ 两个 方法 挂 wx . Window 上 ） ，   SetBackgroundColour   设置 背景 颜色 ，   SetForegroundColour   设置 前景 颜色 ， 前景 颜色 字体 颜色 。   动态 调 成 面板 背景 颜色 ， 记得 调用 Refresh 方法 激活 重画 事件 。   图片 转成 python 编码   编写 一个 python 脚本 ：   # ! / usr / bin / env   python   #   - * - coding : utf - 8 - * -   \" \" \"   项目 图片 文件 转成 python 文件 ，   import   images   引用 图片 。   \" \" \"   import   sys     wx . tools   import   img2py   command _ lines   =   [   \"   - F   - i   - n   Favicon   static / images / favicon . ico   images . py \"   ,   \" - a   - F   - n   ApplyTaiKa   static / images / apply _ tai _ ka . png   images . py \"   ,   \" - a   - F   - n   Address   static / images / address _ img . png   images . py \"   ,   ]     __ __   = =   \" __ main __ \"   :     line     command _ lines   :   args   =   line   .   split   ( )   img2py   .   main   (   args   )   调用 wxpython 提供 工具   img2py   ， 输出 images . py   图片 对象 方法 ：   def   GetBitmap ( ) :   return   wx . Bitmap ( . GetImage ( ) )   def   GetData ( ) :   data   =   . data     . isBase64 :   data   =   b64decode ( . data )   return   data   def   GetIcon ( ) :   icon   =   wx . Icon ( )   icon . CopyFromBitmap ( . GetBitmap ( ) )   return   icon   def   GetImage ( ) :   stream   =   BytesIO ( . GetData ( ) )   return   wx . Image ( stream )   最 常用   GetBitmap   获取 Bitmap 图片 对象 。   后台任务   wxpython 后台任务 推荐   wx . CallAfter     wx . CallLater   调用 。 python 内置 多线程 会 界面 奇怪 。   wx . CallAfter ( callable ,   * args ,   * * kwargs )   Timer   wxpython 计时器 挂上去 很 。   . timer   =   wx . Timer ( )   . timer . Start ( 1000 )   . Bind ( wx . EVT _ TIMER ,   . update ,   . timer )   动态 组件 切换   boxsizer 挂载 面板 ， 隐藏 面板 ， 显示 初始 想要 显示 panel 。 Add ,   Show   Hide   方法 操作 ， Layout ， 这是 基本功 。   值得一提的是 ， panel Layout ， 多个 panel 切换 父 panel 子 panel size 都 ， 子 panel size 大小 ， 动态 切换 更好 效果 ， 调用 父 panel Layout 。   子 Panel 重写   参数 变化 ， 子 panel 重写 ， 推荐 box Replace 方法 ：   _ panel   =     .   category _ sp2 _ panel   _ panel   =   CategorySPInnerPanel   (     ,   data _ list   =     )     .   box   .   Replace   (   _ panel   ,   _ panel   )   _ panel   .   Destroy   ( )     .   category _ sp2 _ panel   =   _ panel   大体 过程 上 ， 切换 推荐 采用 写法 ：   隐藏 box 包含 子 面板 ：   def   hide _ _ panel ( ) :     panel     . box . GetChildren ( ) :   . box . Hide ( panel . GetWindow ( ) )   显示 子 面板   . box . Show ( . category _ sp1 _ panel )   记得 调用 父 面板 级别 Layout 。   全局 捕捉 异常   import   sys   import   traceback   import   wx   class   Panel   (   wx   .   Panel   ) :   def   __ init __   (     ,   parent   ) :   super   (   Panel   ,     )   .   __ init __   (   parent   )   button   =   wx   .   Button   (     ,   label   =   ' 抛 异常 '   )   button   .   Bind   (   wx   .   EVT _ BUTTON   ,     .   OnButton   )   def   OnButton   (     ,   event   ) :   1   /   0   def   MyExceptionHook   (   etype   ,     ,   trace   ) :   \" \" \"   etype   exception   type     exception   message   trace   traceback   header   : param   etype :   : param   :   : param   trace :   : return :   \" \" \"   frame   =   wx   .   GetApp   ( )   .   GetTopWindow   ( )   tmp   =   traceback   .   format _ exception   (   etype   ,     ,   trace   )   exception   =   \" \"   .   join   (   tmp   )   print   (   exception   )   class   DemoFrame   (   wx   .   Frame   ) :   def   __ init __   (     ) :   super   (   DemoFrame   ,     )   .   __ init __   (   None   ,   -   1   ,   \" test   capture     excepiton \"   ,   size   =   (   600   ,   400   ) )   sys   .   excepthook   =   MyExceptionHook   panel   =   Panel   (     )     __ __   = =   ' __ main __ '   :   app   =   wx   .   App   ( )   frame   =   DemoFrame   ( )   frame   .   Show   ( )   app   .   MainLoop   ( )   过程 很 简单 ， python   sys . excepthook   重载   MyExceptionHook   函数 ， 异常 交给 。   验证 器   验证 器 最 对话框 数据格式 限定 ， 发现 验证 器 有用 ， 对话框 管理   . data   做 工作 交给 验证 器来 做 ， 验证 器 一块 早接触 。   验证 器先 定义 一个 验证 器类 ， 继承   wx . Validator   。 自定义 一个   Clone   方法 ， 返回 验证 器 副本 。   验证 器 第一个 功能 验证 数据 ， 验证 器类 中 定义   Validate   方法 做 。 方法 默认 还 传递 一个   win 参数 进来 ， win ， 比如说 验证 器类 挂载 TextCtrl 上 ， TextCtrl 实例 win ， 引用 win 数据 。     Validate   方法 返回   True   ， 验证 成功 ， 返回   False ， 验证 失败 。 再 返回 还 做 事情 。   验证 器类 还 定义   TransferToWindow   方法 ， 验证 器 启动 动作 ； 定义   TransferFromWindow   方法 验证 器 验证 结束 后 动作 。 两个 函数 都 简单   return   True   ， 都 不用 做 ， 两个 方法 一来一去 维护 一个 对话框 维护 全局 数据 集 。 还 没 接触 验证 器 ， 写 几十 行 代码 维护 一个 类似 data 数据 集 ， 对话框 控件 稍 变动 ， 就要 触发 一个 事件 数据 同步 动作 。 验证 器 方案 优雅 。   Dialog 几个 控件 ， 几个 控件 validator 独立 ， 写 验证 器类 统一 一个 类 ， 运行 时有 好几个 验证 器 作用 。 请 看 例子 ：   import   wx   class   CategorySPAddValidator   (   wx   .   Validator   ) :   def   __ init __   (     ,   data   ,   key   ) :   super   (   CategorySPAddValidator   ,     )   .   __ init __   ( )     .   data   =   data     .   key   =   key   def   Clone   (     ) :   return   CategorySPAddValidator   (     .   data   ,     .   key   )   def   handle _ targetCtrl _ state   (     ,   targetCtrl   ,   state   ) :   \" \" \"   成功 失败 动作 通用 动作   : param   state :   : return :   \" \" \"     state   :   targetCtrl   .   SetBackgroundColour   (   wx   .   SystemSettings   .   GetColour   (   wx   .   SYS _ COLOUR _ WINDOW   ) )   targetCtrl   .   Refresh   ( )     :   targetCtrl   .   SetBackgroundColour   (   \" pink \"   )   targetCtrl   .   SetFocus   ( )   targetCtrl   .   Refresh   ( )   def   Validate   (     ,   win   ) :   targetCtrl   =     .   GetWindow   ( )     =   targetCtrl   .   GetValue   ( )   state   =   True       .   key   = =   ' '   :     len   (     )   = =   0   :   dlg   =   wx   .   MessageDialog   (   win   ,   \" 科目 名称 为空 \"   ,   ' 输入 有误 '   )   dlg   .   ShowModal   ( )   state   =   False   elif     .   key   = =   ' code '   :     len   (     )   = =   0   :   dlg   =   wx   .   MessageDialog   (   win   ,   \" 税收 分类 编码 为空 . \"   ,   ' 输入 有误 '   )   dlg   .   ShowModal   ( )   state   =   False   elif   len   (     )   ! =   19   :   dlg   =   wx   .   MessageDialog   (   win   ,   \" 税收 分类 编码 19 位 . \"   ,   ' 输入 有误 '   )   dlg   .   ShowModal   ( )   state   =   False   elif     .   key   = =   ' unit '   :   pass   elif     .   key   = =   ' price '   :   pass     .   handle _ targetCtrl _ state   (   targetCtrl   ,   state   )   return   state   def   TransferToWindow   (     ) :   \" \" \"   对话框 打开 ， 读取数据 窗体   : return :   \" \" \"   targetCtrl   =     .   GetWindow   ( )   state   =   True     =   None       .   key   = =   ' '   :     =     .   data   .     (   ' spmc '   ,   ' '   )   elif     .   key   = =   ' code '   :     =     .   data   .     (   ' spbm '   ,   ' '   )   elif     .   key   = =   ' unit '   :     =     .   data   .     (   ' jldw '   ,   ' '   )   elif     .   key   = =   ' price '   :     =     .   data   .     (   ' dj '   ,   ' '   )   targetCtrl   .   SetValue   (     )   return   state   def   TransferFromWindow   (     ) :   \" \" \"   对话框 关闭   : return :   \" \" \"   targetCtrl   =     .   GetWindow   ( )     =   targetCtrl   .   GetValue   ( )   state   =   True       .   key   = =   ' '   :     .   data   [   ' spmc '   ]   =     elif     .   key   = =   ' code '   :     .   data   [   ' spbm '   ]   =     elif     .   key   = =   ' unit '   :     .   data   [   ' jldw '   ]   =     elif     .   key   = =   ' price '   :     .   data   [   ' dj '   ]   =     return   state   例子 跟着 wxpython     action   书上 例子 优化 ， 书上 例子 很 好地解决 dialog 数据传输 ， 最 神奇 ， 原 对话框   . data   属性 发生 更改 ， 确认   TransferFromWindow     . data   指 验证 器 ， 。 调用 dlg data 数据 ， 没想到 修改 好 数据 。 ， Why     works   .   一个 初步 猜测 wxpython 验证 器 聪明 传输   . data   数据 进来 记住 ， 只能 做 解释 。   试验 发现 面板 层次 稍微 点 ， . data 操作 风格 不行 ， 验证 器要 管理 多个 数据 做 。 验证 器 ， 数据传输 ， 到母 面板 ， 提取 数据 ， 都 小 细节 。   代码 一个 演示 功能 ， 读者 写 代码 寄托 神奇 魔法 ， 明晰 指定 数据 ， 去 。   wxpython asyncio 集成   小节 参考   代码 文件   。 看 ， 空闲 事件 Timer 事件 都 触发 ， 重复 很 ， 选择 一个 Timer 触发 即可 。   看 asyncio 相关 文档 ， stop 事件 循环 中 丢失 ， 总 效果 asyncio   事件 循环 后台 运行 。     .   timer   =   wx   .   Timer   (     )     .   timer   .   Start   (   1   )     .   Bind   (   wx   .   EVT _ TIMER   ,     .   idle _ handler   )     .   eventloop   =   asyncio   .   _ event _ loop   ( )   def   idle _ handler   (     ,   event   ) :   \" \" \"   Idle   handler   runs     asyncio   event   loop .   \" \" \"     .   eventloop   .   call _   (     .   eventloop   .   stop   )     .   eventloop   .   run _ forever   ( )   利用 进程 间通信 启动 一个   讲 wxpython 确保 一个 程序 实例 运行 ， 利用   wx . SingleInstanceChecker   类 ， 很 简单 。   那种 效果 ， 下 点击 图标 ， 弹出 原 窗体 ， 第二次 启动 尝试 悄然 结束 即可 。   仔细分析 查 资料 发现 ， 实际上 一个 简单 进程 间通信 。 第二次 启动 进程 ， 发送 一个 简单 消息 原 效果 。   进程 间通信 原理 发现 这块 还 挺 ， windows win32   API 操作 ， 不 熟悉 ， 套 接字 做 进程 间通信 ， 说白了 开 小 server 监听 端口 client 请求 。 方式 兼容性 ， 总 感觉 杀鸡 牛刀 ， 想 发个 简单 信号 即可 ， python signal 模块 windows 兼容性 不好 ， windows win32 操作 麻烦 还 不 好 方案 ， 写个 简单 套 接字 。   好 asyncio 事件 循环 提及 ， 挂载 上 ， 也就是说 只 利用 asyncio 模块 教程 写个 最 简单 套 接字 发送 一个 简单 消息 即可 。   LOCAL _ SOCKET _ PORT   =   10000   MSG _ INSTANCE   =   ' instance '   async   def   handle _ local _ socket _ server   (   reader   ,   writer   ) :   data   =   await   reader   .   read   ( )   message   =   data   .   decode   ( )     message   = =   MSG _ INSTANCE   :   logger   .   info   (   '   instance     calling . '   )   mainFrame   =   _ mainFrame   ( )   mainFrame   .   taskBarIcon   .   max _ show   ( )   async   def   handle _ local _ socket _ client   (   message   ,   loop   ) :   reader   ,   writer   =   await   asyncio   .   open _ connection   (   ' 127.0 . 0.1 '   ,   LOCAL _ SOCKET _ PORT   ,   loop   =   loop   )   writer   .   write   (   message   .   encode   ( ) )   await   writer   .   drain   ( )   writer   .   close   ( )   .....       .   instance   .   IsAnotherRunning   ( ) :     .   eventloop   .   run _ _ complete   (   handle _ local _ socket _ client   (   MSG _ INSTANCE   ,   loop   =     .   eventloop   ) )   logger   .   warning   (   ' 一个 潮 生活 发票 助手 程序 运行 ！ '   )   return   False     :   local _ socket _ server   =   asyncio   .   start _ server   (   handle _ local _ socket _ server   ,   ' 127.0 . 0.1 '   ,   port   =   LOCAL _ SOCKET _ PORT   ,   loop   =     .   eventloop   )     .   eventloop   .   run _ _ complete   (   local _ socket _ server   )   大概 代码 上 所示 ， 效果 还 挺不错 。   基本上 只用 asyncio 套 接字 编程 最 基础 知识 ， 有个 ， 还 试探 ： 道理 只   . eventloop . create _ task   挂上去 即可 ， 不   run _ _ complete   ， 提及 wxpython asyncio 集成 ， 稍 asyncio 事件 循环 才 启动 ， 计时器 才刚 创建 ， 没试 ， 。   程序 触发 事件   wxpython 程序 触发 事件 ， 所示 ：   homeButton   =   find _ window _ _   (   ' homeButton '   )   evt   =   wx   .   PyCommandEvent   (   wx   .   EVT _ BUTTON   .   typeId   ,   homeButton   .   GetId   ( ) )   wx   .   PostEvent   (   homeButton   ,   evt   )   核心   wx . PostEvent   方法 ， 值得一提的是 ， 方法 触发 事件 调用   event . GetEventObject ( )     button   =   find _ window _ _ id ( event . GetId ( ) )   找到 目标 button ，   GetId   方法 。   TextCtrl 代码 改变 文本   TextCtrl 代码 改变 文本 方法 ：   AppendText   尾部 添加 文本   Clear   EmulateKeyPress   一个 按键 事件   SetInsertionPoint   设置 插入 点   SetValue   WriteText   插入 点 插入 文本   Remove   删除 指定 文本   Replace   替换 指定 文本   对接 系统 剪贴板   文本 放入 剪贴板   data   =   wx   .   TextDataObject   ( )   text   =   \"   text \"   data   .   SetText   (   text   )     wx   .   TheClipboard   .   Open   ( ) :   wx   .   TheClipboard   .   SetData   (   data   )   # 数据 放置 剪贴板 上   wx   .   TheClipboard   .   Close   ( )     :   print   (   ' 剪贴板 打不开 .. '   )   剪贴板 中取 内容   data   =   wx   .   TextDataObject   ( )     wx   .   TheClipboard   .   Open   ( ) :   success   =   wx   .   TheClipboard   .   GetData   (   data   )   wx   .   TheClipboard   .   Close   ( )     success   :   return   data   .   GetText   ( )   清空 剪贴板 动作 ：   Clear   方法 。   ScrolledPanel   带 滚动条 面板 ， 值得 额外 一提 东西 ：   SetupScrolling   SetupScrolling   (     ,   scroll _ x   =   True   ,   scroll _ y   =   True   ,   rate _ x   =   20   ,   rate _ y   =   20   ,   scrollToTop   =   True   ,   scrollIntoView   =   True   )   方法 很 ， 谈到 ， 带 滚动条 面板 内容 发生 变动 ，   Layout   之外 ， 还 加上   SetupScrolling   一句 。   选项 很 ：   scroll _ x   设置 False   横向 滚动条 不 显示   scroll _ y   设置 False   竖向 滚动条 不 显示   rate _ x   最小 一步 滚动 距离   rate _ y   最小 一步 竖向 滚动 距离 ，   scroolIntoView   滚动 尽可能 让子 面板 合适 显示     Scroll   方法 程序 滚动 。   wxpython 鼠标 图案   面板 ， 继承 Window 类 都   SetCursor   方法 设置 鼠标 图形   . SetCursor ( wx . Cursor ( wx . CURSOR _ HAND ) )   默认 ：   wx . CURSOR _ ARROW   ， 常用 显示 点击 手型   wx . CURSOR _ HAND   ， ：   wx . CURSOR _ ARROWWAIT   只能 windows 下 ， 繁忙 光标   wx . CURSOR _ BLANK   不 光标   wx . CURSOR _ WAIT   沙漏 等待 光标   wx . CURSOR _ WATCH   手表 等待 光标   wx . CURSOR _ SPRAYCAN   绘图 光标   wx . CURSOR _ SIZING   尺寸 调整 时 光标 ， 四个 指向   wx . CURSOR _ SIZEWE   水平 尺寸 调整 光标 ， 指向   wx . CURSOR _ SIZENS   垂直 尺寸 调整 光标 ， 指向   wx . CURSOR _ RIGHT _ BUTTON   右 按键 按下 光标   wx . CURSOR _ PENCIL   钢笔 样 光标   wx . CURSOR _ PAINT _ BRUSH   画刷样 光标 ， 绘图 程序 中   wx . CURSOR _ MAGNIFIER   放大镜 ， 缩放   wx . CURSOR _ MIDDLE _ BUTTON   一个 按键 按下 鼠标   还 自定义 光标 图案 ：   wx . CursorFromImage ( image )   ComboBox 内容 修改   参考     。   ComboBox 官方 手册 上 找 不到 相关 方法 ， ComboBox 继承   ItemContainer   ， 调用 方法 ， 动态 修改 ComboBox 内容 。   Clear   清空   Append   附加   Delete ( ,   n )   删除   Insert   插入   Set ( ,   items )   替换   自定义 对话框   情况 下 继承   SizedDialog   会 很 ：   import   wx . lib . sized _ controls     sc   class   Dialog   (   sc   .   SizedDialog   ) :   def   __ init __   (     ,   parent   ,   *   args   ,   data   =   None   ,   type   =   ' simple '   ,   * *   kwargs   ) :   sc   .   SizedDialog   .   __ init __   (     ,   parent   ,   *   args   ,   size   =   (   400   ,   300   ) ,   * *   kwargs   )     .   parent   =   parent   pane   =     .   GetContentsPane   ( )   pane   .   SetSizerType   (   \" form \"   )   #   科目 名称   wx   .   StaticText   (   pane   ,   -   1   ,   \" 科目 名称 \"   )     .   nameText   =   wx   .   StaticText   (   pane   ,   -   1   ,   label   =     .     )     .   Fit   ( )     .   SetMinSize   (     .   GetSize   ( ) )     .   Layout   ( )     .   Center   ( )   继承   wx . Dialog   ， 自定义 panel 做 ， 添加 button 推荐 标准 ID ， 类似 关闭 对话框 判断 点击 按钮 ：   val   =   dlg . ShowModal ( )     val   = =   wx . ID _ DELETE   ...   列表 控件   列表 控件 支持 三种 模式 ：   style = wx . LC _ ICON   图标 模式 ， 大概 看上去 windows 上 文件 浏览 样子   style = wx . LC _ SMALL _ ICON   小图标 模式   style = wx . LC _ LIST   列表 模式   类似 小图标 模式 ， 按列 排列   style = wx . LC _ REPORT   报告 模式   类似 excel 表单 那种   更 详尽 查阅 文档 ， item 添加 Panel 控件 ， 建议 读者 下   wx . lib . agw . ultimatelistctrl . UltimateListCtrl   ， 读者 一列 排序 ， 下   wx . lib . mixins . listctrl . ColumnSorterMixin   item   textctrl   输入 ， 下   wx . lib . mixins . listctrl . TextEditMixin   ， mixin ，   ultimatelistctrl 没 mixin 。   网格 控件   网格 控件   wx . grid . Grid   感觉 列表 控件 ， 涉及 方法 很多 ， 建议 查阅 文档 。   树型 控件   TreeCtrl   显示 层次 数据 ， 目录 结构 时 用到 。   HTMLWindow   文本 显示 需求 ， HTMLWindow 种类 html 标记 语言 渲染 而成 ， 底层 浏览器 渲染 ， wxpython 渲染 ， 简单 来说 wxpython 种类 html 标记 语言 一种 快速 定义 文本 显示 界面 功能 。   wxpython 还 提供 html2 包 ， 其是 利用 浏览器 底层 渲染 ， 显示 ， 更 接近 浏览器 显示 效果 。   wxpython 打印 支持   一块 暂时 略过   DateTime python datetime 对象 互转   一节 参考   python   cook   book     # 12   recipe 。 记录 下 ， 有时候 会 用到 ：   import   datetime   import   wx   def   pydate2wxdate   (   date   ) :   assert   isinstance   (   date   ,   (   datetime   .   datetime   ,   datetime   .   date   ) )   tt   =   date   .   timetuple   ( )   dmy   =   (   tt   [   2   ] ,   tt   [   1   ]   -   1   ,   tt   [   0   ] )   return   wx   .   DateTimeFromDMY   (   *   dmy   )   def   wxdate2pydate   (   date   ) :   assert   isinstance   (   date   ,   wx   .   DateTime   )     date   .   IsValid   ( ) :   ymd   =   map   (   int   ,   date   .   FormatISODate   ( )   .   split   (   ' - '   ) )   return   datetime   .   date   (   *   ymd   )     :   return   None   boxsizer 两个 值得注意 方法   AddSpacer   作用 增加 一段 固定 空白 距离 ， boxsizer 覆写 sizer AddSpacer 方法 ， 横向 竖向 混淆 。   def   add _ vspace   (   box   ,   size   ) :   \" \" \"   boxsizer 竖向 增加 空白 距离 ， VERTICAL 抛 异常   : param   box :   : param   size :   : return :   \" \" \"     box   .   GetOrientation   ( )   = =   wx   .   VERTICAL   :   box   .   AddSpacer   (   size   )     :   raise   NotVerticalSizer   def   add _ hspace   (   box   ,   size   ) :   \" \" \"   boxsizer 横向 增加 空白 距离 ， HORIZONTAL 抛 异常   : param   box :   : param   size :   : return :   \" \" \"     box   .   GetOrientation   ( )   = =   wx   .   HORIZONTAL   :   box   .   AddSpacer   (   size   )     :   raise   NotHorizontalSizer   AddStretchSpacer   方法 sizer ， boxsizer 调用 ， 还 没 。 方法 方法 区别 增加 一段 缩放 空白 距离 ， Qt 一段 弹簧 样 东西 。 利用 缩放器 很 空间 居中 比例 位置 调整 。   wxpython 编码 风格 推荐     import   wx         import   *   引入 语法 。     size = ( 500 , 400 ) ， 不 推荐   wx . Size   ， 提法   网页   说 ， 会 争议性 ， 说 简单 好 。 点 x ,   y 两个 值 ， 来说 ， 确实 数组 对会 点 ， 编码 ， size 参数 实际上 指明 第一个 参数 x ， 第二个 参数 y 。   凡是 面板 都 子 类化 ， 面板 类 控件 面板 管理 。 说 做 ， 做 好处 很多 。 面板 类 控件 管理 ， 后续 管理 操作 编码 带来 很多 便利 ， 面板 子 类化 大型 GUI 程序 道路 。   多个 按钮 推荐   StdDialogButtonSizer   ，   TODO   ， 体验 再 讨论 几句 。   okButton   =   wx . Button ( ,   wx . ID _ OK ,   \" & OK \" )   okButton . SetDefault ( )   cancelButton   =   wx . Button ( ,   wx . ID _ CANCEL ,   \" & Cancel \" )   btnSizer   =   wx . StdDialogButtonSizer ( )   btnSizer . AddButton ( okButton )   btnSizer . AddButton ( cancelButton )   btnSizer . Realize ( )   代码 重构 ： 思考 视图 操作 分离   说 编程 世界 公认 理念 ， DRY 原则 。   编码 中 wxpython 额外 风格 推荐 。   DIY 原则 ， ：   数据 代码 分离 ， 数据 何种 方式 加载 进来 ， 都 完善 小 细节 ， GUI 编码 特殊性 ， 就要 数据 代码 分离 。   GUI 程序 编码 复杂度 提高 ， 请 立刻 重构 代码 ， 面向对象 风格 写法 ， GUI 程序 内在 面向对象 思想 很 融洽 ， 程序代码 很 简单 不用 上 面向对象 ， 稍微 写 几天 ， 就要 第一次 重构 。 请 视图 层 结构 特色 ， 编写 gui 模块 类 结构 层次 。   说 数据 代码 分离 ， GUI 很多 变量 数据 实际上 常量 数据 ， 建议 发生 变动 常量 数据 都 再 开个 模块 统一 管理 。 一个 不错 风格 常量 数据 包括 变量 数据 配置 数据 最终 都 一个 全局变量 模块 中 汇总 。 代码 中 编写 引用 ， 后续 写 代码 debug 模式 编写 ， GUI 程序运行 时 ， 写个 简单 debug 菜单 ， 程序运行 时 变量 常量 参数 打印 。   程序 核心 面板 都 一个 名字 ， 事件处理 ， 调用 窗体 ， 窗体 ， 调用 目标 窗体 子 窗体 操作 ， 做 完善 ， 窗体 提供 方法 操控 窗体 子 控件 ， 调用 子 控件 。   提到 篇 参考 文章 更进一步 提出 MVC 架构 ， 最 关键 一点 利用 pypubsub 模块 ， 程序 内部 消息 发送 接收 ， 视图 层 模型 层 解 耦 。 模型 层 只 负责管理 好本 应用程序 本地 数据 ， 控制 层 负责 模型 层 视图 层 交互 ， 控制 层 ， 视图 层 不 模型 层 交互 。   样例 代码 不 贴 ， pypubsub 模块 很 简洁 ， 关键在于 理解 MVC 层 层 分工 设计 思路 。 仔细分析 参考 文章 样例 代码 ， 会 发现 设计 很 精妙 地方 。 请 读者 设想 一个 ， GUI 程序 编写 类似 MVC 架构 中 都 会 ， 底层 模型 或者说 数据 更 精确 一点 变量 发生变化 ， 变化 内部 计算 ， 是从 外部 API 获取 数据 ， GUI 程序 数据 池 变动 ， 数据 视图 层 相关 ， 希望 视图 层 做出 调整 。 手工 请求 数据 ， 再 刷新 页面 想法 实在 太 愚蠢 ， 设计 一个 控制器 ， 控制器 负责 内部 运算 外部 获取 数据 ， 检测 数据 变化 ， 数据 变化 送给 本地 模型 层 ， 做好 变化 记录 ， 样例 程序   changing   过程 ， 本地 模型 层 数据 变化 ， 改变 视图 层 显示 ， 发送 changed   信号 页面 更新 驱动 。   视图 层   写 GUI 程序 放在 视图 层 ， 视图 层 panel 类 ， 面板 子 控件 ， 可变 元素 ， 挂 面板 上 调用 ， 业务 GUI 显示 需求 ， 些 更好 针对 面板 子 控件 组合 。   面板 属性 ， 利用 python   @ property   面板 属性 ， 面板 可变 元素 调用 属性 ， 引用 属性 方法 ， 指向 外部 可变 内容 ， 视图 层 内部 代码 每次 引用   .   ， 都 会 调用 定义 属性 方法 ， 实时 再 计算 ， 最新 信息 。   视图 层 常数 信息 ， 讨论 编码 风格 推荐 ， 慢慢 抽离 ， const 常数 模块 统一 管理 ， 一句 话 ， 努力做到 数据 代码 分离 。   控制 层   控制 层 ：   接受 模型 层 ， 组织 好 本地 常量 变量 数据   接受 好 视图 层 模型 层 发送 消息 ， 针对 消息 动作   ， 视图 层 引用 可变 数据 方法 支持 控制 层 提供   模型 层   模型 层 不 视图 层 交互 ， 所说 ， 只 负责管理 好 本地 数据 发送 信号 ， 实际上 模型 层 引入 控制 层 ， 一个 单纯 简单 管理 本地 数据 接口 。   一般来说 变动 业务 相关 数据 模型 层 。   二次 思考 MVC 架构   流行 web 框架 一种 成熟 MVC 架构 风格 ， 很多 东西 太大 ， GUI 编程 web 视图 层 控制 层 不太好 分离 。 GUI 程序 越来越 ， 确实 感觉 东西 杂乱 ， 思路 清晰 ， 一会 数据 变动 ， 视图 层 忘记 跟着 变动 ， 一会儿 数据 变动 ， 信号 忘记 发送 。   方式 ， 程序 常量 汇入 全局变量 池 ， 面板 控件 内 GUI 要素 ， 都 汇入 全局变量 池 ， 实际操作 带来 很大 便利 。 全局变量 池中 变量 ， 建立 模型 层 。   模型 层中 目标 变量 ， 发生 变化 ， 发送 一个 信号 。   视图 层 监听 目标 信号 ， 实时 变动 界面 体现 数据 变化 。   GUI 层 事件处理 。   控制 层 还 逻辑 模型 层 交互 。   提到 都 正确 ， 关键在于 都 混 杂乱 ， 再 加上 GUI 事件 信号 ， 程序员 思维 混乱 。   我试 约定 ， 再试 重构 整理 下 代码 试试看 。   常量 ， 模型 层 变量 ， 全局变量 分离   程序 涉及 常量 ， 模型 层 变量 ， 全局变量 分离 ， 早期 都 汇入 全局变量 挺 ， 全局变量 规模 变得 庞大 ， 分离 减轻 程序员 头脑 负担 。   模型 层 视图 层 分离   模型 层 不 视图 层 东西 ， 面板 。   视图 层 不 模型 层 东西 ， 全局变量 视图 层 （ 控制 好 这部分 量 ） ， 变量 模型 层 。 【 视图 层 模型 层 数据 ， 推荐 接口 统一 管理 】   模型 层 视图 层 发送 消息 （ _ changing ） 只 发送 （ _ changed ） ， 控制 层 修改 模型 层 数据 。 视图 层 只 负责 监听   ( _ changed )   消息 。 控制 层 只 监听 ( _ changing )   。   模型 层 信号 规范   模型 层 数据 层 ， 业务 逻辑 视图 层 数据 显示 ， 其是 数据 依赖 ， 或者说 数据 驱动 ， 控制 层 视图 层 监听 数据模型 。   监听 信号 名 规范 ：   变量名 _ changed   【 模型 层 数据 发生 变动 ， changed 模式 控制 层 视图 层 监听 】   变量名 _ changing   【 视图 层 数据 发生 变动 ， 发射 changing 信号 ， 信号 只 控制 层 监听 ， 模型 层 不用 。 】 （ 再 着重 讨论 下 changing 信号 changed 信号 分工 ， changed 信号 信息 变动 源 更 外部 ， 模型 层 数据 变动 ， 程序 内部 视图 层 跟踪 变动 ， 逻辑 交给 控制 层 中继 ； changing 信号 更 程序 本地 信息 变动 驱动 源 ， changing 第一 GUI 视图 层 内部 面板 组件 之间 信息 同步 ， 才 情况 控制 层 监听 更改 模型 层 数据 。 简言之 ， changing 第一 视图 层 内部 ， changed 第一 外部 数据 变动 视图 层 跟踪 变化 ， 才 视 控制 层 监听 信号 编写 更 内部 程序逻辑 。 ）   _ changing     _ changed   值 发生 变法 才 发送 消息 ， 情况 下 发送 消息 （ 设置 _ send 选项 ）   _ appending   _ appended   情况 下 列表 引入 append 模式 会 很   _ clearing   _ cleared   情况 下 数据 清空 还原 默认值 操作   传递 数据 值 ， append 模式 只 传递 附加 。   代码 重构 后感   思路 ， 模型 层 建立 通用 模型 ， 代码 重构 ， 发现 MVC 架构 项目 早期 实际上 还 增加 很多 额外 代码 量 ， 后期 会 降低 代码 量 。   写 代码 提及 规则 ， 还 额外 再 加上 一条 ：   写 代码 写 完 放在 一个 地方 供 ， 不用 阅读 。   涉及 代码 复用 性 ， 代码 设计 ， 提及 MVC 架构 努力实现 模型 层 视图 层 分离 时 努力 去 追求 一点 。   TODO ：   pypubsub 模块 学习 debug ， 查看 阅读 信息 发送 信息 函数 执行 。   三次 思考 MVC 架构 【 PLUS 】   二次 思考 MVC 架构 内容 正确 ， changing 信号 细节 补充 ：   建立 视图 层 变量 ， 写法 建立 方法 类似 模型 层 变量 做法   视图 层 面板 绑定 好 事件 ， 内容 发生 变更 发送 信号 视图 层 相关 面板 数据 同步 工作 。   视图 层 变量 更 面板 操作 记录 临时 变量 相关 ， 外部 驱动 发生 数据 更改 ， 驱动 方法 优先选择 面板 SetValue 还会 发送 GUI   Event 方法 ， 方法 ， 手工 添加 ， 好 模型 层 初始化 变更 会 自动 触发 视图 层 变更 。   注意事项   pypubsub   4.0 版本 确认 两个 面板 监听 topic ， 面板 函数 ， 参数 格式 。   def   _ topic _ test   (     ,     )   pass   一个 写为 ：   def   _ topic _ test   (     ,     =   None   )   pass   pypubsub 会 抛 异常 ， 两个 都 写作 ， 种 形式 ， 都 没 。   类 变量 实例 变量   算是 python 基础知识 ， 写 复用 面板 ， 千万 记得 ：   class   ...   a   =   1   变量 实例 都   def   __ init __ ( ) ...   b   =   1   变量 实例 都   写 方法 定义 特别 面板 上 元素 ， 挂 类 上 不 大 ， 定义 初始化 函数 ， 好 多个 实例 化后 面板 子 面板 元素 ， 才 出错 。   wxpython 自定义 窗体   本文 重点 讨论 wxpython 较为 底层 绘图 知识 利用 知识 建立 自定义 窗体 。   GDI   wxpython 底层 绘图 有个 GDI （ Graphics   Device   Interface ） 概念 ， 理解 通用 绘图 接口 ， 利用 通用 绘图 接口 ， 一套 绘图 方法 ， 显示器 ， 打印机 绘图 。 程序员 不用 硬件 底层 绘图 编程 。   GDI 具体来说 绘图 类 方法 。   DC   绘图 前 ， 创建 一个 设备 上下文 DC （ device   context ） ， DC 具体来说 wx . DC 类 。 中 不 wx . DC 类 ， 选择 更 设备 DC 子类 。 子类 分为 三类 ：   用于 绘制 屏幕 上下文   用于 绘制 地方 非 屏幕   用于 缓冲 一个 设备 上下文   用于 绘制 屏幕   wx . ClientDC   wx . PaintDC   EVT _ PAINT 事件 中 ， 设备 上下文 ， wx . ClientDC   。   wx . WindowDC   希望 客户 区 绘制 ， 窗体 边框 ， 标题栏 都 想 绘制 ， 。   wx . ScreenDC   希望 屏幕 上 绘制 ， 。   非 屏幕 设备 上下文   wx . MemoryDC   用于 内存 中 位图 bitmap 上 绘制   wx . MetafileDC   只 windows 下 ， 绘制 写入 文件 中   wx . PostScriptDC   跨平台 ， 写入 eps 文件 中   wx . PrinterDC   只 windows 下 ， 写入 打印机 中   缓冲 设备 上下文   wx . BufferedDC   wx . BufferedPaintDC   缓冲 一个 设备 上下文 ， 做 几个 重绘 ， 屏幕 闪烁 ， 缓冲 选择 。 绘制 屏幕 闪烁 ， 推荐   dc   =   wx . BufferedPaintDC ( )   带 颜色 线条   wxpython 里 StaticLine 不 定制 颜色 ， 请 看 类 一个 定义 颜色 线条 功能 。 例子 演示 自定义 窗体 ， OnPaint 上画 上 窗体 图形 ， Bind 好 想要 事件 动作 。   绘图 变得 越 更 定制 需求 ， 窗体 更 方法 支持 特性 。   import   wx   class   ColorStaticLine   (   wx   .   Panel   ) :   \" \" \"   带 颜色 线段   \" \" \"   def   __ init __   (     ,   parent   ,   color   =   ' black '   ,   mode   =   ' hline '   ,   * *   kwargs   ) :   super   (   ColorStaticLine   ,     )   .   __ init __   (   parent   =   parent   ,   * *   kwargs   )     .   parent   =   parent     .   color   =   color     .   mode   =   mode     .   Bind   (   wx   .   EVT _ PAINT   ,     .   OnPaint   )   def   OnPaint   (     ,   event   ) :   dc   =   wx   .   PaintDC   (     )   width   ,   height   =     .   GetClientSize   ( )   dc   .   SetPen   (   wx   .   Pen   (   wx   .   Colour   (     .   color   ) ) )       .   mode   = =   ' hline '   :   dc   .   DrawLine   (   0   ,   0   ,   width   ,   0   )   elif     .   mode   = =   ' vline '   :   dc   .   DrawLine   (   0   ,   0   ,   0   ,   height   )   这是 一个 很 简单 例子 ， 学到 很多 东西 ：   定义 重画 事件 ，   wx . PaintDC   。   绘画 区域 x , y 计算 ，   ( 0 , 0 )   面板 绘画 区域   . GetClientSize ( )   方法 。     dc . SetPen   设置 画笔 ， 这是 设置 颜色 ， dc . DrawLine 画 一条 直线 ， 绘画 过程 。   定义 一个 个性化 复用 小 面板 组件 。   TODO   ：   一个 ， 继承   wx . Panel   才行 ， 道理 暂时 还 没想 明白 。   形状 绘制   带 颜色 方块   dc . SetBrush ( wx . Brush ( ' # 1ac500 ' ) )   dc . DrawRectangle ( 130 ,   15 ,   90 ,   60 )   设置 画刷 ， 画 一个 矩形 。   绘制 圆弧   DrawArc ( x1 ,   y1 ,   x2 ,   y2 ,   xc ,   yc )   绘制 一个 圆弧 ， 起点   x1   y1   终点   x2   y2   中心点   xc   yc   弧线 逆时针 绘制 ， 设置 画 刷 ， 而会 填充 圆弧 区域 。   画 一个 圆   DrawCircle ( x ,   y ,   radius )   x   y   中心 ，   radius 半径 ， 画 一个 圆 。   画一 直线   DrawLine ( x1 ,   y1 ,   x2 ,   y2 )   起点   x1   y1   终点   x2   y2   画一 直线   画 多边形   DrawPolygon ( points )   定义 一系列 点 ， 画一 多边形 ， 起点 终点 自动 相连   画 圆角 矩形   DrawRoundedRectangle ( x ,   y ,   width ,   height ,   radius )   radius 控制 曲率   绘制 文本   DrawText ( text ,   x ,   y )   绘制 文本 ：   SetTextForeground   设置 字体 颜色     GetTextForeground   dc . SetBackgroundMode ( wx . SOLID )   默认   wx . SOLID   文本 背景 颜色 ， 设置   wx . TRANSPARENT   ， 文本 无 背景 颜色 。   dc . SetTextBackground   设置 文本 背景 颜色   dc . SetFont   设置 字体   绘图 图片   DrawBitmap   DrawIcon   设置 画笔   提到 形状 绘制 ， 填充 区域 由画 刷 控制 ， 形状 线条 颜色 ， 画笔 控制 。   SetPen   wx . Pen ( wx . Colour ,   width = 1 ,   style = wx . PENSTYLE _ SOLID )   画笔 样式   wx . PENSTYLE _ SOLID   默认 实线   wx . PENSTYLE _ DOT   小点   wx . PENSTYLE _ LONG _ DASH   虚线   wx . PENSTYLE _ SHORT _ DASH   短 虚线   wx . PENSTYLE _ DOT _ DASH   点 划线   wx . PENSTYLE _ TRANSPARENT   笔线   wx . PENSTYLE _ STIPPLE   提供 位图 笔触   wx . PENSTYLE _ BDIAGONAL _ HATCH   反 斜线   wx . PENSTYLE _ CROSSDIAG _ HATCH   XXX   线   wx . PENSTYLE _ FDIAGONAL _ HATCH   正 斜线   wx . PENSTYLE _ CROSS _ HATCH   +++   线   wx . PENSTYLE _ HORIZONTAL _ HATCH   水平线   wx . PENSTYLE _ VERTICAL _ HATCH   垂直线   设置 画刷   SetBrush ( )   wx . Brush ( colour ,   style = wx . SOLID )   画刷 样式   画刷 样式 列举如下 ：   wx . BRUSHSTYLE _ SOLID   默认 实心 填充   wx . BRUSHSTYLE _ TRANSPARENT   透明 ， 填充   wx . BRUSHSTYLE _ STIPPLE _ MASK _ OPAQUE   用位 图 做 笔触 ，   mask         blitting   monochrome     text   foreground     background   colors .   wx . BRUSHSTYLE _ STIPPLE _ MASK   用位 图 做 笔触 ，   mask         masking   areas       stipple   bitmap .   wx . BRUSHSTYLE _ STIPPLE   用位 图 做 笔触   wx . BRUSHSTYLE _ BDIAGONAL _ HATCH   反 斜线   wx . BRUSHSTYLE _ CROSSDIAG _ HATCH   XXX   线   wx . BRUSHSTYLE _ FDIAGONAL _ HATCH   正 斜线   wx . BRUSHSTYLE _ CROSS _ HATCH   +++   线   wx . BRUSHSTYLE _ HORIZONTAL _ HATCH   水平线   wx . BRUSHSTYLE _ VERTICAL _ HATCH   垂直线   自定义 画刷 图案   brush1   =   wx . Brush ( wx . Bitmap ( ' pattern1 . png ' ) )   dc . SetBrush ( brush1 )   dc . DrawRectangle ( 10 ,   15 ,   90 ,   60 )   画刷 指定 图片 其刷 图案 。   获取 绘图 区域 尺寸   width ,   height   =   . GetClientSize ( )   获取 窗体 尺寸   wxpython 内 窗体 （ 继承 Window ） 都   GetSize   方法 ， 窗体 尺寸 ：   width ,   height   =   . GetSize ( )   获取 文本 宽度 高度   w ,   h   =   . GetTextExtent ( line )   空行 写为 ：   w ,   h   =   . GetTextExtent ( ' M ' )   居中 定义   获取 绘图 区域 width ， 计算 好 想要 居中 对象 width （ w ） ， 居中 绘制 起点 x ：   start _ x   =   ( width   -   w ) / 2   居右 定义   获取 绘图 区域 width ， 计算 好 想要 居右 对象 window （ w ） , 居右 绘制 起点 x ：   start _ x   =   width   - w   dc . Clear   TODO   理解 还 很深 ， 只 用来 清空 背景 画刷 。   brush   =   wx   .   Brush   (   \" white \"   )   dc   .   SetBackground   (   brush   )   dc   .   Clear   ( )   style 管理   常数 状态 不用 说 ， 说 下 wxpython style 管理 ， 定义 常数 ， 比如说   A   =   0b1   B   =   0b10   C   =   0b100   说 定义 一个 状态 ： style   =   A   |   B   ，   执行 逻辑 操作 即可 。 想要 测试 style 包含 B 态则   style   &   B   即可 。 style 态只 占 一个 二进制位 ， 目标 style 逻辑 操作 ， 包含 返回 非 0 值 ， 返回 0 值则 不 包含 目标 style 态 。   一个 程序 实例 运行   利用   wx . SingleInstanceChecker   很 ， 更 信息 请 参看 文档     。 做法 确保 操作系统 用户 一个 程序 实例 运行 。   import   wx   class   SingleAppFrame   (   wx   .   Frame   ) :   def   __ init __   (     ,   parent   ,   title   ) :   wx   .   Frame   .   __ init __   (     ,   parent   ,   title   =   title   ,   size   =   (   300   ,   300   ) )     .   Centre   ( )   class   SingleApp   (   wx   .   App   ) :   def   OnInit   (     ) :     .     =   \" SingleApp -   % s   \"   %   wx   .   GetUserId   ( )     .   instance   =   wx   .   SingleInstanceChecker   (     .     )       .   instance   .   IsAnotherRunning   ( ) :   wx   .   MessageBox   (   \" Another   instance     running \"   ,   \" ERROR \"   )   return   False   frame   =   SingleAppFrame   (   None   ,   \" SingleApp \"   )   frame   .   Show   ( )   return   True   app   =   SingleApp   (   redirect   =   False   )   app   .   MainLoop   ( )   页面   利用 wx . adv . SplashScreen   很 制作 出 一个 页面 ， 读者 还 看 demo 案例 中 提到   wx . lib . agw . advancedsplash     AS   ，   SplashScreen   类比 定制 选项 。     gui . mainFrame   import   ChaoShengHuo   class   ChaoShengHuoApp   (   wx   .   App   ) :   img _ base   =   g _ var   .   img _ base   def   OnInit   (     ) :     .     =   \" SingleApp -   % s   \"   %   wx   .   GetUserId   ( )     .   instance   =   wx   .   SingleInstanceChecker   (     .     )       .   instance   .   IsAnotherRunning   ( ) :   wx   .   MessageBox   (   \" 一个 潮 生活 发票 助手 程序 运行 ！ \"   ,   \" Do     Panic \"   )   return   False     :   #   页面   bitmap   =   wx   .   Bitmap   (     .   img _ base   +   ' . png '   ,   wx   .   BITMAP _ TYPE _ PNG   )   wx   .   adv   .   SplashScreen   (   bitmap   ,   wx   .   adv   .   SPLASH _ CENTRE _ ON _ SCREEN   |   wx   .   adv   .   SPLASH _ TIMEOUT   ,   3000   ,   None   ,   -   1   ,   wx   .   DefaultPosition   ,   wx   .   DefaultSize   ,   wx   .   BORDER _ SIMPLE   |   wx   .   STAY _ ON _ TOP   )   wx   .   Yield   ( )   _ frame   =   ChaoShengHuo   (   None   ,   -   1   )   _ frame   .   Show   (   True   )   return   True   程序 最小化 托盘   主 界面 关闭 事件 ：   def   MinimizeWindow ( ,   event ) :   . Iconize ( True )   def   CloseWindow ( ,   event ) :   . Hide ( )   event . Skip ( )   import   wx   import   wx . adv   class   TaskBarIcon   (   wx   .   adv   .   TaskBarIcon   ) :   ID _ About   =   wx   .   NewId   ( )   ID _ Minshow   =   wx   .   NewId   ( )   ID _ Maxshow   =   wx   .   NewId   ( )   ID _ Closeshow   =   wx   .   NewId   ( )   def   __ init __   (     ,   frame   ) :   wx   .   adv   .   TaskBarIcon   .   __ init __   (     )     .   frame   =   frame     .   SetIcon   (   wx   .   Icon   (     =   ' favicon . ico '   ,   type   =   wx   .   BITMAP _ TYPE _ ICO   ) ,   ' 潮 生活 发票 助手 '   )     .   Bind   (   wx   .   adv   .   EVT _ TASKBAR _ LEFT _ DCLICK   ,     .   OnTaskBarLeftDClick   )   #   定义 左键 双击     .   Bind   (   wx   .   EVT _ MENU   ,     .   OnAbout   ,   id   =     .   ID _ About   )     .   Bind   (   wx   .   EVT _ MENU   ,     .   OnMinshow   ,   id   =     .   ID _ Minshow   )     .   Bind   (   wx   .   EVT _ MENU   ,     .   OnMaxshow   ,   id   =     .   ID _ Maxshow   )     .   Bind   (   wx   .   EVT _ MENU   ,     .   OnCloseshow   ,   id   =     .   ID _ Closeshow   )   def   OnTaskBarLeftDClick   (     ,   event   ) :       .   frame   .   IsIconized   ( ) :     .   frame   .   Iconize   (   False   )         .   frame   .   IsShown   ( ) :     .   frame   .   Show   (   True   )     .   frame   .   Raise   ( )   def   OnAbout   (     ,   event   ) :   wx   .   MessageBox   (   ' 潮 生活 发票 助手 V3.0 '   ,   ' '   )   def   OnMinshow   (     ,   event   ) :     .   frame   .   Iconize   (   True   )   def   OnMaxshow   (     ,   event   ) :       .   frame   .   IsIconized   ( ) :     .   frame   .   Iconize   (   False   )         .   frame   .   IsShown   ( ) :     .   frame   .   Show   (   True   )     .   frame   .   Raise   ( )   def   OnCloseshow   (     ,   event   ) :     .   RemoveIcon   ( )     .   Destroy   ( )     .   frame   .   Destroy   ( )   def   CreatePopupMenu   (     ) :   menu   =   wx   .   Menu   ( )   menu   .   Append   (     .   ID _ Minshow   ,   ' 最小化 '   )   menu   .   Append   (     .   ID _ Maxshow   ,   ' 最大化 '   )   menu   .   Append   (     .   ID _ About   ,   ' '   )   menu   .   Append   (     .   ID _ Closeshow   ,   ' 退出 '   )   return   menu   图片 重画   一个 抹 去 事件 发送 ， 窗体 背景 重画 。   An   erase   event         a   window ' s   background         repainted .   dc   =   event . GetDC ( )   wx . ClientDC ： 用于 一个 窗口 对象 上 绘画 。 想 窗口 部件 主 区域 上 （ 不 包括   边框 装饰 ） 绘画 时 。 主 区域 称为 客户 区 。 wx . ClientDC 类 应临   时 创建 。 该类 仅 wx . PaintEvent 之外 。   参考 网页   import   wx   class   Frame ( wx . Frame ) :   def   __ init __ ( ) :   wx . Frame .__ init __ ( , None , - 1 , \" My   Frame \" , size = ( 400 , 300 ) ,   style   =   wx . DEFAULT _ FRAME _ STYLE )   . panel   =   wx . Panel ( )   . panel . Bind ( wx . EVT _ ERASE _ BACKGROUND , . OnEraseBack )   def   OnEraseBack ( , event ) :   dc   =   event . GetDC ( )       dc :   dc   =   wx . ClientDC ( )   rect   =   . GetUpdateRegion ( ) . GetBox ( )   dc . SetClippingRect ( rect )   dc . Clear ( )   bmp   =   wx . Bitmap ( \" background . jpg \" )   dc . DrawBitmap ( bmp ,   0 ,   0 )     __ __   = =   ' __ main __ ' :   app   =   wx . App ( )   frame   =   Frame ( )   frame . Show ( )   app . MainLoop ( )   窗体 拖动   想要 窗体 拖动 ， 事件 绑定 ， 拖动 事件 执行 方法 主 窗体 上 ， 主 窗体 绑定 。 原因 还 很 明白 。     .   Bind   (   wx   .   EVT _ LEFT _ DOWN   ,     .   OnLeftDown   )   #   左键 点击 按下     .   Bind   (   wx   .   EVT _ LEFT _ UP   ,     .   OnLeftUp   )   #   左键 释放     .   Bind   (   wx   .   EVT _ MOTION   ,     .   OnMouseMove   )   #   鼠标   #   拖动 相关   def   OnLeftDown   (     ,   event   ) :   logger   .   debug   (   f   ' GUI 事件 :   { event }   -   OnLeftDown '   )     .   CaptureMouse   ( )   #   捕获 鼠标   pos   =     .   ClientToScreen   (   event   .   GetPosition   ( ) )   origin   =     .   GetPosition   ( )     .   delta   =   wx   .   Point   (   pos   .   x   -   origin   .   x   ,   pos   .   y   -   origin   .   y   )   def   OnLeftUp   (     ,   event   ) :   logger   .   debug   (   f   ' GUI 事件 :   { event }   -   OnLeftUp '   )       .   HasCapture   ( ) :     .   ReleaseMouse   ( )   #   释放 鼠标   def   OnMouseMove   (     ,   event   ) :   logger   .   debug   (   f   ' GUI 事件 :   { event }   -   OnMouseMove '   )     event   .   Dragging   ( )     event   .   LeftIsDown   ( ) :   pos   =     .   ClientToScreen   (   event   .   GetPosition   ( ) )   newPos   =   (   pos   .   x   -     .   delta   .   x   ,   pos   .   y   -     .   delta   .   y   )     .   Move   (   newPos   )   扩充 颜色 定义   wxpython 内部 一套 颜色 定义 库 ， 还 利用 进一步 扩充 颜色 定义 库 ：   aquamarine ： 海蓝色   black ： 黑色   blue ： 蓝色   brown ： 褐色   coral ： 珊瑚 色   cyan ： 青色   firebrick ： 火砖 色   gold ： 金色   gray ： 灰色   green ： 绿色   khaki ： 土黄色   magenta ： 绛红色   maroon ： 栗色   navy ： 藏青色   orange ： 橙色   orchid ： 淡紫色   pink ： 粉红色   plum ： 梅 红色   purple ： 紫色   red ： 红色   salmon ： 鲜肉 色   sienna ： 红褐色   tan ： 浅棕色   thistle ： 蓟色   turquoise ： 青绿色   violet ： 紫罗兰色   wheat ： 浅黄色   white ： 白色   yellow ： 黄色   更 颜色 请 参看   demo     ColourDB   。   app   OnInit   加载 定义 颜色 ， 请 看 官方 代码 片段 ， 做 ：   def   updateColourDB   ( ) :   \" \" \"   Updates     : class : ` wx . ColourDatabase `     adding     colour   names     RGB   values .   \" \" \"   global   _ haveUpdated       _ haveUpdated   :   import   wx   assert   wx   .   GetApp   ( )       None   ,   \" You       a   wx . App   object             colour   database . \"   cl   =   getColourInfoList   ( )     info     cl   :     ,   colour   =   info   [   0   ] ,   wx   .   Colour   (   *   info   [   1   : ] )   wx   .   TheColourDatabase   .   AddColour   (     ,   colour   )   _ haveUpdated   =   True   wxpython 项目 骨架   笔者 钻研 wxpython 桌面 编程 一段时间 ， 样例 请 参见   项目   。   查看 wxpython demo 程序 API 文档 。   剩下 编程 需求 ， 思考 界面设计 。   编写 项目 ， wxpython 一个 通用 骨架 参考 ， 编程 需求 或者说 业务 很 相关 。   读者 参考   项目   几个 commit 。 简要 下 。   图片 文件 管理   图片 文件 都 放在 一个 文件夹 ， 编写   encode _ bitmaps . py   文件 ， 项目   import   images   images   .   Favicon   获取 图片 对象 。   程序 主 入口   编写 一个 程序 主 入口 文件 ，   image _ process _ tool . py   ， 平时 测试运行 ， 利用   pyinstaller   编译 exe 文件 ， 一个 脚本 文件 入口 。   编写 pyinstaller spec 文件   实践经验 来看 ， 推荐 手工 编写 pyinstaller spec 文件 。   编写 一个 全局变量 文件   参数 全局变量 推荐 编写 一个   global _ var . py   文件 ， 程序 中   import   global _ var     g _ var   调用 ， 很多 情况 下 很 。   MVC 分离 架构   源码 中 分为   gui   视图 层 ，   models   模型 层 ，   controllers   控制 层 ， 小 图形界面 中 ， 控制 层 模型 层 代码 ， MVC 分离 架构 推荐 保留 。   常数 配置 统一 管理   桌面 GUI 程序 ， 很 小型 桌面 GUI 程序 都 很多 const 常数 ， 推荐 统一 管理 。   自定义 颜色   请 参看   app . py     update _ _ defined _ color   操作 ， 建立 颜色 定义 库来 规范化 程序代码 。   应用程序 启动 唯一性   情况 下 会 桌面 程序 多开 ， 绝大部分 情况 都 一个 应用程序 一个 界面 ， 应用程序 ， 点击 应用程序 图标 ， 会自 动弹 创建 应用程序 实例 。   请 参看   app . py   解决方案 。   异常 信息 更好   利用 pubsub 操作 更好 异常 信息 捕捉 ， 桌面 程序代码 变得 庞大 ， 异常 定位 ， 将会 调试 变得 困难 。 请 参看   exception _ utils . py   文件 。   参考资料   zetcode   wxpython 教程   wxpython 官方 参考 文档   wxpython     action   ,   Author     Harri   Pasanen     Robin   Dunn",
            "tags":"archived",
            "url":"articles/wxpython-learning-notes.html"
        },
        {
            "title":"emacs的org模式学习笔记",
            "text":"WARNING   警告 ， 笔者 不怎么 emacs ， 文档 归档 ， 缺少 新 内容 ， 旧 内容 错误 ， 放在 权做 参考 。   org 转 tex 初步 配置   ; latex 设置   (   setq   org - latex - default - packages - alist   '   ( (   \" \"   \" \"   nil   ) ) )   . emacs 文件 加上 一句 ，   org - latex - default - packages - alist   列表 存储 org 文件 生成 tex 文件 默认 加载 宏包 。 列表 一系列 三个 元素 列表 ， 第一个 元素 加载 宏包 选项 ， 第二个 参数 加载 宏包 名字 ， 第三个 选项 设置 t nil ， 加载 不 加载 。 简单   org - latex - export - - latex   命令 默认 加载 一系列 宏包 都 清空 ， 宏包会 接下来 要用 xelatex 不 匹配 ， 学习 文档 配置 ， 简单 文档 配置 加进来 即可 。   #+ LATEX _ CLASS :   book   #+ LATEX _ CLASS _ OPTIONS : [ 11pt , oneside ]   #+ LATEX _ HEADER :   \\ usepackage { book }   org 文档   #+ LATEX _ CLASS   用来 设置 目标 tex 文档 documentclass ，   #+ LATEX _ CLASS _ OPTIONS   documentclass 命令 可选项 ， 目标 代码 ：   \\ documentclass   [ 11pt , oneside ]   {   article   }     #+ LATEX _ HEADER :   \\ usepackage { article }   tex 文档 代码 ：   \\ usepackage   {   article   }   article . sty 文件 正是 文档 配置 。   xelatex 命令 生成 tex 文档 ， 会 发现 配置文件 都 刷 ， 页面 布局 ， 字体 都 ， 生成 pdf 很 美观 。 面对 ， 第一个 org 输入 模式 latex ， 第二个 好 自建 命令 自建 环境 。   title 命令   默认 title 命令 填 org 文件 文件名 ， title ：   #+ TITLE :   mytitle   配置 。   类似 AUTHOR ， DATE tex 文档 author date 命令 ， 命令 org 文档 生成 html 兼容性 很 好 。   设置 目录 深度   org 文档 上 OPTIONS 配置 ：   #+ OPTIONS :   toc : 2   此即 相当于 tex 文档 上 代码 ：   \\ setcounter   {   tocdepth   } {   2   }   org 模式 latex 命令 详解   emacs 编辑器 ， 打开 org 后缀 文件 emacs org 模式 ， 并不需要 额外 配置 。 更 信息 请参阅   org 模式 官网   。   ， org 文档 定义 latex class article ， 一个 星号 section ， 两个 星号 subsection ， 三个 星 subsubsection 。 latex class book ， 一个 星号 latex 命令 part ， 接下来 依次 chapter section 。   四个 星 情况 默认 转成 列表 形式 ， 想要 。 org 文件 上 设置   #+ OPTIONS :   H : 4   article 支持 subsubsection ， book 支持 subsection ， 四级 结构 命令 。   ，   org - export - headline - levels   设置 一个 很大 数字 ， 5 级 结构 ， 五颗星 够用 ， article subparagraph ， book subsubsection 。   ( setq   org - export - headline - levels   5 )   . emacs 文件 生效   好 ， 修改 . emacs 插件 ， 重新启动 emacs 使 生效 厌倦 。   org 文件 基本操作   org 文件 基本操作 很 简单 ， 视图 控制 ， 光标 落 一个 标题 上 ， 按下 Tab 键 试试 ， 一个 按键   Shift + Tab   ， 不 光标 落 标题 上 ， 全局 性质 展开 折叠 。 按键 操作 emacs 按键 操作 先 暂时 不予考虑 ， 鼠标 操作 。   org latex 基础   编写 最 简单 带有 文档 结构 org 文件 ， 写 上 一段 文字 ， 会 发现 ， 标记 语言 之间 内部 相似性 ， org 上 一段 文字 tex 文档 上 一段 文字 ， html 文档 上   包围 一部分 一个 段落 ， org 文档 上 空格 空行 都 会 保留 目标 tex 文档 html 文档 上 ， 如同 往常 ， 多余 空行 视作 一个 空行 ， 多余 空格 视作 一个 空格 可行 （ html 文档 多个 空格 只 视作 一个 空格 ） 。 恩 ， ， 很 满意 。   页面 布局 控制 ， 利用 自定义 article . sty book . sty 加载 geometry 宏包 设置 ， 都 工作 很 好 ， html 文档 生成 干扰 ， 很 好 。   想要 xelatex 引擎 ， 生成 tex 文档 sty 配置文件 ， 所说 设置 好 字体 配置 ， xelatex ， 中文 显示 解决 ， 都 很 好 。   ， 目标 tex 文档 中 ， 额外 命令 环境 ， 利用 宏包 sty 文件 上 配置 ， ， 都 工作 很 好   。   接下来 一个 很 紧要 ： tex 文档 特殊符号 。   符号 （ org 模式 中 ）   利用 org 文档 生成 目标 tex 文档 html 文档 ， 三个 文档 内部 各有 原生 语义 癖好 ， 特殊符号 显示 大 。   第一个 # 符号 ， 接触 类似   #+ TITLE   配置 写法 ， 符号 org 文档 中是 注释 ， 不尽然 。 一行 开头 # 符号 ， 内容 不 加 额外 空格 ， # 符号 内容 都 会 顺利 显示 （ 包括 html 文档 中 ） ， 唯一 一行 开头 # 符号 ， 跟着 空格 ， 这一 整行 都 会 视作 org 文档 内 注释 内容 ， 这一 整行 都 生成 目标 tex 文档 html 文档 中 。   接下来 tex 文档 中 特殊符号 org 文档 中 都 写 上 ， 输出 时 都 会 所示 转换 ：   $   \\ $   &   \\ &   %   \\ %   &# 94 ;   \\ &# 94 ; { }   {   \\ {   }   \\ }   ~   \\ textasciitilde { }   \\   $ \\ backslash $   转换 空格 很 理想 ， \\ 符号   \\ textbackslash { }   命令 （ 字体 ） ， 条 线路 更 关注 内容 ， 小 细节 先 略过 。   值得一提的是 符号 显示 生成 目标 html 会 方案 ， 显示 很 好 。   连字号   tex 文档 中 一个 两个 连字号 生成 pdf 时会 字符 ， 不 担心 ， 测试 ， org 文档 一个 两个 三个 连字号 原样 保留 tex 文档 中 ， html 文档 中 unicode 符号 ， 谈论 pdf 显示 效果 。   更 符号 中 文化   sty 配置文件 中 设置 好 即可 ， 输入法 输入 ， 没什么 好 担心 。 中 文化 sty 配置文件 中 配置 好 ， 不用 操心 。   \\ 符号   \\ 符号 还 讨论一下 ， 希望 输入 单独 符号 输入 即可 ， \\ 符号 紧跟着 字符 符号 ， 类似 tex 文档 中 命令 形式 ：   \\ test   \\ test   { }   \\ test   [ ]   { }   代码 将会 原样 送入 tex 文档 中 ， \\ 符号 发生 （ \\ 符号 跟着 中文 字符 不 讨论 情况 中 ， \\ 符号 。 ） 。   很 ， org 文档 无缝 对接 tex 文档 ， html 上 会 很多 奇怪   \\ test   命令 ， org 文档 ， 还 tex 文档 第一 编辑 代码 源 。 上 tex 文档 命令 环境 org 文档 中 都 不 推荐 （ 还会 详细 讨论 自定义 命令 对接 ） ， 一个 情况 例外 ， 请 数学 环境 。   数学 环境   接下来 讲 意义 上 org 模式 关系不大 ， org 文档 中 添加 原生 数学 环境   大多   原样 存放 目标 tex 文档 目标 html 文档 上 ， tex 文档 不用说 ， 目标 html 文档 正确 显示 数学 环境 tex 代码 是因为 org 生成 html 目标 文档 配置   mathjax   工具 。   mathjax 支持 数学 环境 tex 代码 原 latex tex 代码 细微 差异 ， 命令 环境 支持 ：   $   $   行内 数学 环境   $ $   $ $   单行 数学 环境   \\ [   \\ ]   单行 数学 环境 ， 编号     \\ [   \\ ]   环境 支持 ， displaymath 不 支持 ， 古怪 ， 估计 org 生成 配置 还 没 优化 好 mathjax 工具 无关 。   来自 amsmath 宏包 equation equation * 环境 支持 ， equation 显示 编号 ， 估计 mathjax 配置 关系 。   多行 数学 环境 ，   \\ \\   换行 多行 数学 环境 ， gather gather * align align * 都 支持 ， 编号 正确 显示 ， 估计 org 生成 目标 html 文档 mathjax 配置 。   数学 环境 命令 可用 命令 不好 一一 讨论 ， 常用 tex 原生 数学 命令 amsmath 宏包 数学 命令 （ 数学 环境 ） 都 支持 。   换行 命令   \\ \\   命令 html 会 转换   < br   / >   命令 ， org 文档 中 自如 加上 换行   \\ \\   命令 。   \\ \\ [ 10pt ]   命令 ， html 上 概念 。 换行 命令 算是 一个 tex 命令 org 中 特例 。   插入 列表   插入 列表 org 模式 解决 完美 ， 无序 列表 项以 ' - ' 、 ' + ' ' * ' 开头 ， latex itemize 环境 ； 序列表 ' 1 . ' ' 1 ) ' 开头 ， latex enumerate 环境 ，   description 环境 org 生成 html 文档 css 额外 ， org 上 简单 输入 即可 ：   -     bold   font   : :     test   进一步 深度 定义 推荐 都 sty 文件 定制 。   插入 引用   org 模式 上 插入 引用 很 ， label 命令 格式 ：   < < targetname > >   ：   \\ label   {   targetname   }   引用 目标 地点 语法 ：   [ [ targetname ] ]   [ [ targetname ] [ shownname ] ]   targetname 定义 地点 名字 ， shownname 页面 显示 链接 文本 ， 第一种 形式 不 设置 shownname ， 生成 tex 代码 ref 命令 ， 形式 ：   \\ ref   {   targetname   }   加上 shownname hyperref 宏包 提供 hyperref 命令 ， ：   \\ hyperref   [ targetname ]   {   showname   }   提醒 读者 ：   targetname 中文   ， shownname 中文 。   外部 链接 类似 语法 ：   [ [ http : / / www . google . ] [ 谷歌 ] ]   tex 代码 ：   \\ href   {   http : / / www . google .   } {   谷歌   }   形式 ：   file : papers / . pdf   mailto : adent @ galaxy . net   格式 ， 讨论 略过 。 链接 颜色 hyperref 宏包 配置 ， 请 sty 文件 上 。   生成 html 文档 代码 很 好 ， 无需 多言 。   插入 脚注   pdf html 显示 风格 ， 实际上 脚注 好 协调 ， html 上 脚注 更 确切 不 脚注 尾注 。 org 模式 提供 两种 插入 脚注 语法 ：       a   test   line [ fn : :     a   footnote ]       a   test   line [ fn : ]   [ fn : ]       a   footnote   两种 写法 html 上 显示 稍微 区别 ， 无关紧要 。 更 推荐 第一种 写法 ， 脚注 内容 写进去 不用 命名 编号 细节 ， 第二种 写法 还要 花心思 去 脚注 名字 ， 浪费 脑力 ， 选择 org 模式 不 重视 内容 快速 写作 ， 第二种 脚注 写法 分散 写作者 注意力 嫌疑 。   文字 环境   粗体   粗体 斜体 作用 ， 字符 空 一个 空格 。   * bold *   两个 星号 包围 字体 加粗 ， 生成 tex 代码 ：   \\ textbf   {   bold   }   生成 html 代码 ：   <   b   >   bold   < /   b   >   斜体 emph 命令   org 模式 下 ， 两个 / 符号 包围 字符 信息   / 环境 /   输出 html 文档 上将 ：   <   i   >   环境   < /   i   >   两个 / 符号 包围 环境 称作 斜体 环境 ， tex 代码 ：   \\ emph   {   环境   }   tex 原始 代码 确实 emph 内 字体 italic 字形 ， 命令 换成 形式 ， ulem 会 换成 下划线 ， 喜欢 换成 红色 ， 更 效果 。 html i 环境 稍作 调整 效果 ， ：   i {   font - style : normal ;   color : red ; }   简单 理解 两个 / 符号 包围 字符 文字 功能 。   下划线   一段时间 ulem 宏包 ， 除开 花里胡哨 命令 ， uline uwave 命令 最 。 uwave 命令 去 ， uline 命令 org 模式 很 好 支持 。   org 文档 中   _ 下划线 环境 _   将会 tex 文档 中 代码 ：   \\ uline   {   下划线 环境   }   html 代码 所示 ：   <   span   class   =   \" underline \"   >   下划线 环境   < /   span   >   underline   class ， org 生成 html 定义 好 ， 文字 加上 下划线 效果 。   短 代码 环境   org 文档   = verbatim 环境 =   ~ verbatim 环境 ～   输出 html 文档 都 会 code 标签 包围 ， 短 代码 环境 。 tex 文档 下 差异 。   第一种 情况 ttfamily 字族 情况 ：   \\ texttt   {   verbatim 环境   }   第二种 情况 verb 命令 ：   \\ verb   ~ verbatim 环境 ~   不得不 承认 \\ ~ { } 符号 选得 很 好 ， 代码 内 干扰 。 更 细节 参见 插入 代码 小节 讨论 。   verse 诗歌 环境   诗歌 环境 org 模式 很 好 ， 会 自动 一行 加上   \\ \\   换行 。 只 输入 ：   #+ BEGIN _ VERSE   放着   诗歌   #+ END _ VERSE   生成 tex 代码 ：   \\ begin   {   verse   }   放着   \\ \\   诗歌   \\ \\   \\ end   {   verse   }   更进一步 定制 sty 文件 配置 verse 环境 即可 。   HTML 代码 ：   <   p   class   =   \" verse \"   >   放着   <   br   / >   诗歌   <   br   / >   < /   p   >   p . verse   class 自动 生成 html 文档 很 粗糙 定义 好 — — 简单 缩进 下 ， 满意 。   quote 引用 环境   类似 quote 语录 环境 ：   #+ BEGIN _ QUOTE   放着 quote   引用 环境   #+ END _ QUOTE   tex 代码 quote 环境 ， 改动 。 html 代码 一个 特定 代码 ：   <   blockquote   >   <   p   >   放着 quote   引用 环境   < /   p   >   < /   blockquote   >   blockquote 标签 第一次 简单 ， html 文档 做 配置 ， 标签 环境 默认 缩进 举动 ， 一点 引用 环境 。   居中 环境   讨论 情况 类似 ， 不 赘述 。   #+ BEGIN _ CENTER   文本 居中 环境   #+ END _ CENTER   插入 横线   - - - - -   上 所示 ， org 文档 中 连接号 大于 等于 5 ， 输出 横线 ， tex 代码 ：   \\ rule   {   \\ linewidth   } {   0.5 pt   }   html 代码 熟悉 hr 标签 。   插入 图片   插入 图片 谈及 插入 引用 语法 ， 最 简单 形式 所示 ：   [ [ file : images / test . jpg ] ]   生成 tex 代码 ：   \\ includegraphics   [ width = . 9 \\ linewidth ]   {   images / test . jpg   }   figure 环境 ， html 代码 ：   <   div   class   =   \" figure \"   >   <   p   > <   img   src   =   \" images / test . jpg \"   alt   =   \" test . jpg \"   / >   < /   p   >   < /   div   >   引入 figure   class 。   ：   插入 图片 形式 ：   [ [ file : images / test . jpg ] [ test ] ]   讨论 插入 引用 形式 ， tex 文档 href 命令 ， html a 标签 。   加上 标题   图片 加上 标题 所示 ：   #+ CAPTION :   女金刚 狼   [ [ file : images / test . jpg ] ]   生成 tex 代码 形式 ， 引入 figure 环境 ：   \\ begin   {   figure   }   [ htb ]   \\ centering   \\ includegraphics   [ width = . 9 \\ linewidth ]   {   images / test . jpg   }   \\ caption   {   女金刚 狼   }   \\ end   {   figure   }   加上 标签   #+ CAPTION :   女金刚 狼   #+ NAME :   fig : test   [ [ file : images / test . jpg ] ]   生成 tex 代码 所示 ：   \\ begin   {   figure   }   [ htb ]   \\ centering   \\ includegraphics   [ width = . 9 \\ linewidth ]   {   images / test . jpg   }   \\ caption   {   \\ label   {   fig : test   }   女金刚 狼   }   \\ end   {   figure   }   遗憾 ， 插入 引用 小节 提及 ， label 中文名 标签 不 支持 ， 只好 随便 取 一个 名字 。   值得一提的是 ：   #+ NAME :   CAPTION ， 单独 — — CAPTION 命令 。   简单 优化   网页 情况 居中 尺寸 控制 ， 推荐 css 设置 即可 ：   img   {   margin - left   :   - 2   em   ;   max - width   :   700   px   ;   }   figure   {   text - align   :   center   ;   }     max - width   控制 图片 尺寸 ，   figure 设置 图片 居中 。   LaTeX 图片 控制 图片 尺寸 概念 ， 参考 [ 代写 ， 引用 缺失 ， 下次 翻到 补上 ] 网站 ， 给出 解决方案 。   \\ RequirePackage   [ export ]   {   adjustbox   }   %   ' export '     needed   \\ newenvironment   {   fig   }   [ 2 ] [ 1 ]   {   \\ begin   {   figure   }   [ H ]   \\ centering   \\ includegraphics   [ scale = # 1   ,   keepaspectratio , max   width = 0.95 \\ linewidth ]   {   # 2   } }   {   \\ end   {   figure   } }   定义 fig 环境 读者 写 LaTeX 文档 时 快速 输入 图片 。 核心 设置 第一行 引入 adjustbox 宏包 ， 选项 export 。 还   . emacs   上 加上 设置 ：   (   setq   org - latex - image - default - option   \" keepaspectratio , max   width = 0.95 \\ \\ linewidth \"   )   (   setq   org - latex - image - default - width   \" \"   )   (   setq   org - latex - default - figure - position   \" H \"   )   代码 第一行 includegraphics 命令 默认 选项 ，   max   width   关键 ， 控制 图片 不 超过 行宽 0.95 倍 ， 图片 原始 图片 显示 ， 超过 ， 图片 宽度 行宽 0.95 倍 。   第二行 情况 原 width 设置 ， 不 做 ， 设置 都 会 失效 ， 第三行 设置 浮动 H ， float 宏包 控制 。   设置 图片 显示 大致 差不多 ， css sty 样式 优化 读者 随意 。   上标 下标   上标 下标 org 文档 中 ：   这是 &# 94 ; { 上标 } ， 这是 _ { 下标 } ， 。   敢 是因为 html 文档 中 标签 即能 很 好地解决 上标 下标 ， 生成 tex 代码 ：   这是 $ &# 94 ; { \\ text { 上表 } } $ ， 这是 $ _ { \\ text { 下表 } } $ ， 。   自动 加上 数学 环境 。 推荐 读者 . emacs 上 选项 加进去   1   ：   (   setq   org - export - - - superscripts   ' { }   )   org 上 自如 书写 a &# 94 ; b a _ b ，   a &# 94 ; { b }   a _ { b }   a &# 94 ; { b }   a _ { b }   标 模式 。   插入 表格   接下来 插入 表格 插入 代码 ， 最 简单 内容 ， 单独 提出 一章 ， 是因为 org 模式 emacs 编辑器 下 ， 表格 ， 生成 表格 ， 运算 ， 代码 ， 运算 代码 ， 加载 文件 运算 生成 表格 ， 加载 文件 代码 内容 。 这部分 内容 算是 高级 东西 ， 拖 单独 一章 。   最   |   开头 ， 表格 开头 元素 ，   |   分开 ，   Tab   键 ， 填充 会 自动 跟进 。   首 行 标题 开头 元素 内容 之间 加上   | - - + - - |   形式 分开 ， 只 开头 写 上   | -     Tab   键 即可 。   LaTeX 情况   表格 显示 这一下 反倒 LaTeX 简单 些 ， 只 . emacs 上 设置 ：   (   setq   org - latex - tables - booktabs   t   )   启用 booktabs 宏包 模式 ， 生成 很漂亮 三线 表了 。 表格 环境 还 支持 额外 插入 属性 设置 ， 最 对齐 属性 ， booktabs 模式 下 tabular 环境 对齐 设置 。   例子 ：   #+ ATTR _ LATEX :   : align   p { 0.18 \\ linewidth } | p { 0.72 \\ linewidth }   #+ CAPTION :   表格   |   x   |   y   |   | - - - + - - - - |   |   1   |   2   |   |   2   |   4   |   |   3   |   5   |   |   4   |   6   |   将会 生成 LaTeX 代码 ：   \\ begin   {   table   }   [ H ]   \\ caption   {   表格   }   \\ centering   \\ begin   {   tabular   } {   p   {   0.18   \\ linewidth   }   | p   {   0.72   \\ linewidth   } }   \\ toprule   x   &   amp ;   y   \\ \\   \\ midrule   1   &   amp ;   2   \\ \\   2   &   amp ;   4   \\ \\   3   &   amp ;   5   \\ \\   4   &   amp ;   6   \\ \\   \\ bottomrule   \\ end   {   tabular   }   \\ end   {   table   }   （ 推荐 读者 网页 布局 中央 核心 区域 宽度 生成 pdf 中央 核心 区域 宽度 保持一致 相差 很 远 。 ）   网页 情况   网页 情况 实际上 css 设置 ， 对此 很 熟 ， 给出 摸索 一种 三线 表 样式 ：   table   ,     ,   td   {   margin   :   0   auto   ;   min - width   :   2   em   ;   text - align   :   center   ! important   ;   padding   :   5   px   ;   }   table   {   border - top   :   2   px   solid   ;   border - bottom   :   2   px   solid   ;   }   thead   {   border - bottom   :   1   px   solid   ;   }   实在 想 加上 竖线 ， 额外 表格 前 加上   #+ ATTR _ HTML :   : rules   cols   table rules 属性 。 说 html5 ， 不 推荐 做 ， 推荐 css 调整 。 三线 表 样式 ， 表格 特别 长 ， 临时 加上 rules 属性 ， rows 。   长 表格   网页 下 倒 表格 过长 显示 ， 这是 pdf 分页 。   #+ ATTR _ LATEX :     : environment   tabular 环境 换成 longtable 环境 ， 加载 longtable 宏包 ， 对齐 参数 推荐 一个 新 参数   x   ， 既有 p 参数 控制 宽度 对齐 。 设置 引入 （ [ 参考 网站 ， 引用   代写   ] ） ：   \\ RequirePackage   {   longtable   }   \\ RequirePackage   {   array   }   \\ newcolumntype   {   x   }   [ 1 ]   { &   gt ;   {   \\ centering \\ arraybackslash \\ hspace   {   0pt   } }   p   {   # 1   } }   ， 例子 ：   #+ ATTR _ LATEX :   : environment   longtable   : align   x { 0.2 \\ linewidth } x { 0.2 \\ linewidth }   #+ CAPTION :   表格   |   x   |   y   |   | - - - + - - - - |   |   1   |   2   |   |   2   |   4   |   ......   生成 LaTeX 代码 ：   \\ begin   {   longtable   } {   x   {   0.2   \\ linewidth   }   x   {   0.2   \\ linewidth   } }   \\ caption   {   表格   }   \\ \\   \\ toprule   x   &   amp ;   y   \\ \\   \\ midrule   \\ endhead   \\ midrule \\ multicolumn   {   2   } {   r   } {   Continued       page   }   \\ \\   \\ endfoot   \\ endlastfoot   1   &   amp ;   2   \\ \\   2   &   amp ;   4   \\ \\   ......   显示 效果 很 好 。   表格 数据 导出   org 模式 下 表格 数据 做 很多 运算 ， 比如说 光标 停留 表格 中 一列 ， 输入   M - x   ， 输入   org - table - sum   ， minibuffer 下会 显示 一列 总和 。 很多 功能 ， 都 不感兴趣 ， 最 感兴趣 表格 数据 导出来 ， 导出 脚本 程序处理 ， 作图 。 输入   M - x   ， 输入   org - table - export   ， 会 提示 。   org 转 html tex 协调   org 转 html tex 文档 协调 很 好 解决 ，   #+ LATEX :   \\ appendix   一行 内容 ， 只 原样 输入 进 tex 文档 中 ， 不 html 文档 中 。 类似 命令 ：   #+ HTML :   类似   #+ BEGIN _ LATEX   原封不动 放入 tex 文档   #+ END _ LATEX   选择 org 模式 ， 不 过多 添加 tex 原始 代码 。 html tex 代码 越多 org 文档 越 （ 最 糟糕 情况 等于 编写 两边 文档 ） ， 要用 ， 推荐   #+ LATEX :   \\ appendix   一行 修正 。   命令 基于 tex 文档 结构 ， 加进去 ， 加进去 反而 更好 提醒 写作者 此处 写些 。   \\ mainmatter   \\ appendix   \\ backmatter   mainmatter 命令 放在 文档 内容 ， appendix 放在 附录 标题 ， backmatter 放在 参考文献 标题 。 内容 照旧 ， html 页码 自然 不用 。   命令 都 针对 book 类   。   参考文献 协调性 太 简单 列表 表达 即可 。   原有 环境 命令 属性 修正   只 表格 ， 图片 ， 列表 ， 源代码 区块 。   #+ ATTR _ LATEX :   文档 内非 自定义 命令   基于 简单 原则 ， sty 配置文件 引入 额外 自定义 命令 环境 ， 实在 不得不 自定义 命令 环境 ， 内容 html pdf 都 共享 （ 正是 org 模式 本身 ） ， 接下来 工作 会 变得 很多 ， 讨论 。   讨论 情况 中 ， org 模式 针对 tex 代码 html 代码 特定 环境 命令 class ， 推荐 进一步 定制 环境 命令 class 即可 。 讨论 情况 除开 特定 环境 命令 class ， 环境 命令 class ， org 文档 中 ，   #+ BEGIN _ WHAT   #+ END _ WHAT   都 输出 tex 文档 格式 ：   \\ begin   {     }   \\ end   {     }   html 文档 代码 ：   <   div   class   =   \" \"   >   <   p   >     < /   p   >   读者 tex 文档 环境 （ sty 文件 中 ） 配置 好 html   class （ css 文件 中 ） 配置 好 即可 。   插入 代码   小 代码 讲过 ， 两个 号 两个 波浪 号 包围 tex 文档 中 一个 ttfamily 字体 ， 一个 verb 命令 。   简单 代码   简单 代码 所示 ， tex 文档 verbatim 环境 。   #+ BEGIN _ EXAMPLE   THIS   IS   A   EXAMPLE   ENVIRONMENT   #+ END _ EXAMPLE   不 华丽 表现 不 染色 简单 代码 推荐 EXAMPLE 环境 ， verbatim 环境 不太 满意 ， 分割 直线 ， 代码 文本 清晰 分开 。 fancyvrb Verbatim 环境 ， org 模式 EXAMPLE 环境 输出 Verbatim 环境 ？   本来 会 很 简单 ， 效果 还 麻烦 ， （ 2015 - 01 - 22 ） org 模式 EXAMPLE 选项 打开 ， 参考   网站   情况 下 ， 大致 一个 解决方案 ：   手工 编译 emacs ， [ lisp ] → [ org ] 文件夹 里 找到 ox - latex . el 文件 ， 文件 里   org - latex - - block   函数 ， format ， 明白 默认 输出 verbatim 环境 。 两行 删除 ， 改动 ：   -   ( format   \" \\ \\ begin { verbatim } \\ n% s \\ \\ end { verbatim } \"   -   ( org - export - format - code - default   - block   info ) ) ) ) )   +   ( format   \" \\ \\ begin { % s } \\ n% s \\ \\ end { % s } \"   +   org - latex - verbatim - env   +   ( org - export - format - code - default   - block   info )   +   org - latex - verbatim - env ) ) ) )   简单 % s 类似 编程语言 字符串 方式 即可 ， 环境 改为   org - latex - verbatim - env   定义 。 编译 emacs 。   编译 emacs ， 方式 ， 提及 更新 org 宏包 方式 。   . emacs 文件 代码 ：   ;   package   ( require   ' package )   ; ;   You           line   ( add - - list   ' package - archives   ' ( \" melpa \"   .   \" http : / / melpa . org / packages / \" )   t )   emacs 宏包 管理 提供 更 可用 宏包 ， 宏包 melpa 提供 。 打开 emacs ， 打开 options 宏包 管理 ， 更 宏包 选项 ， 最新 org ， 安装 即可 。 宏包 都 放在 主 文件夹   . emacs . d   文件夹 。   顺便 提 宏包 管理 插件 删除 安装 宏包 ， 光标 想 删除 宏包 名字 ， 字母   d   键 ， 有个 标记 D ， 光标 位置 ， 按下   x   键 会 minibuffer 提示   2   。   . emacs . d 文件夹 elpa 文件夹 ， 会 org 宏包 相关 文件夹 ， 打开 找到 ox - latex . el 文件 ， 类似 谈及 做出 修改 ， 更新 elc 文件 。 emacs 打开 文件 ， emacs - lisp byte - compile     file 选项 。   接下来 修改 . emacs 文件 ， 修改 好 接口   org - latex - verbatim - env   变量 定义 好 ：   ( setq   org - latex - verbatim - env   \" Verbatim \" )   好 ， 测试 效果 。   更 华丽 代码   org 模式 还 提供 SRC 环境 ， latex 更 华丽 代码 环境 ：   #+ BEGIN _ SRC   python   print ( ' ' )   #+ END _ SRC   输出 调成 listings 环境 ：   (   setq   org - export - latex - listings   t   )   不 太 喜欢 listings 环境 ， minted 环境 输出 支持 很 好 （ 将要 谈到 选项 支持 ） ：   (   setq   org - latex - listings   ' minted   )   minted 环境 有个 ， 加上 背景色 分页 会 ， 介绍 xelatex 基础 语法 中 插入 代码 小节 里 谈到 自定义 命令 tcbpython tcbbash 引入 进来 ， tcolorbox minted 显示 代码 一块 很 完美 人 满意 。   . emacs 文件 里 设置 ：   (   setq   org - latex - custom - lang - environments   '   ( (   python   \" tcbpython \"   )   (   bash   \" tcbbash \"   )   ) )   ， SRC 环境 跟着 bash ，   #+ BEGIN _ SRC   bash   sudo   pip3   install   pygments   #+ END _ SRC   会 输入 tex 代码 ：   \\ begin   {   tcbbash   }   sudo   pip3   install   pygments   \\ end   {   tcbbash   }   类似 还 定义 python tcbpython ， 会 成 tcbpython 环境 。 自定义 语言 ， 设置 minted 默认 引擎 ，   情况 ：   #+ BEGIN _ SRC   emacs - lisp     code   #+ END _ SRC   生成 tex 代码 ：   \\ begin   {   minted   }   [ ]   {   common - lisp   }     code   \\ end   {   minted   }   很 好 。 html 情况 ， 代码 都 显示 ， 染色 ， 安装 emacs htmlize 宏包来 某种 染色 效果 。 。 真的 好 丑陋 ， 情况 还 不太熟悉 ， 略过 不 做 讨论 。   SRC 环境 选项   SRC 环境 跟着 程序语言 种类 还 很多 选项 ， 选项 很 ， 设置 很 底层 。 兴趣 慢慢 研究 手册 。   暂时 介绍 一个 选项   - n   ：   #+ BEGIN _ SRC   emacs - lisp   - n   def   main ( args ) :   return   0   #+ END _ SRC   SRC 环境 选择 minted 环境 输出 ， 参数 会 设置 进去 ：   \\ begin   {   minted   }   [ linenos , firstnumber = 1 ]   {   common - lisp   }   def   main ( args ) :   return   0   \\ end   {   minted   }   listings 环境 会 支持 很 好 ， 谈及 自定义 tcbpython 环境 tcbbash 环境 ， 代码 一行 都 加上 数字 ：   1   def   main ( args ) :   2   return   0   很 美观 ， 更好 做法 ， 喜欢 加上 数字 ， sty 配置文件 tcbpython （ 定义 名字 ） 定义 里 加上 ：   minted   options = { linenos , numbersep = 3mm }   即可 。   假设 定义 python 环境 没 ， 反正 不 涉及 html ， sty 文件 配置 好 环境 即可 。   无 参数 环境 形式 。   \\ begin { }   \\ end { }   插入 代码 文件   废话 不多 说 ， 插入 代码 文件格式 ：   #+ INCLUDE :   \" ~ / . emacs \"   src   emacs - lisp   不 形式 ， INCLUDE 命令 放在 SRC 环境 ， 执行 视作 代码 。 插入 代码 文件 只能 形式 ， 跟着 src ， 可能性 ， 接下来 程序语言 ， 提及 SRC 环境 选项 加上 去 。   项目管理   emacs org 模式 项目管理 都   org - publish - project - alist   参数 配置 。 其有 很多 花俏 参数 配置 ， 给出 一种 简单 解决方案 。 心目 中 理想 方案 输出 html 输出 pdf 之间 协调 ， 一个 书籍 都 一个 独立 文件夹 ， 内部 图片 文件 环境 ， 引用 逻辑 会 很 简单 。   下 ， emacs 只 做 简单 配置 ：   ; publish   (   setq   org - publish - project - alist   '   ( (   \" website \"   : base - directory   \" ~ / 工作 空间 / website \"   : exclude   \" templates / . * \"   : recursive   t   : publishing - directory   \" ~ / 工作 空间 / website / \"   : publishing - function   org - html - publish - - html   )   ) )   website 项目 名字   ， 下   org - mode   下   运行 命令   org - publish - project   ， 输入 名字 ， org 项目 pulish 操作 。   base - directory   参数 org 文件 放置 根目录 ，   exclude   排除 templates 文件夹 （ 文件夹 会 放置 项目 都 会 模板 文件 图片 文件 。 ） 。   recursive   参数设置   t   ， 很 关键 ，   base - directory   ， 再 加上 递归 支持 ， 会 保留 原 项目 文件目录 系统 ， 简单 来说 文件夹 文件夹 下 org 文件 ， 其会 原地 输出 html 文件 ， 正是 喜欢 效果 。     publishing - function   设置 publish 执行 函数 动作 ， 只 加上 输出 html 文件 动作 。 tex 一块 还 很 不 完美 ， （ minted 宏包 代码 路径 管理 ， 提交 一个 bug 说 最新版 修复 ubuntu texlive 还 没 发布 。 ） ， pdf 制作 放在 做成 完美 形式 合情合理 ， 不 加进去 。   项目 文档 强制 刷 一遍   参考   网页   。   不 org 模式 ， M - x ， 输入   ielm   elisp 交互 环境 ， 输入 命令 即可 。 t 都 强制 刷 ， project _ 设置 项目 名字 。   ( org - publish   \" project _ \"   t )   org 模式 额外 特性   快速 输入   emacs 深度 定制 开发 出 很多 快速 输入 技术 ， org 模式 自带 快速 输入 方法 ， 很 好 。 快速 输入 EXAMPLE 环境 ， 先 输入 一个   <   符号 ， 再 输入 一个 小写字母   e   ， 按下 Tab 键 ， 快速 输入 EXAMPLE 环境 ， 类似 ：   c :   CENTER 环境   e :   EXAMPLE 环境   h :   HTML 环境   H :   HTML 单行 命令 ，   #+ HTML :   I :   INCLUDE 单行 命令 ，   #+ INCLUDE :   l :   LATEX 环境   L :   LATEX 单行 命令 ，   #+ LATEX :   q :   QUOTE 环境   s :   SRC 环境   v :   VERSE 环境   定义 快速 输入   小节 参考   网页   。   提及 快速 输入 之外 ， 还 定义 快速 输入 方法 。     org - structure - template - alist   列表 值 添加 内容 :   (   add - - list   ' org - structure - template - alist   '   (   \" C \"   \" #+ CAPTION :   \"   ) )   (   add - - list   ' org - structure - template - alist   '   (   \" f \"   \" #+ BEGIN _ FRAMED \\ n \\ n #+ END _ FRAMED \"   ) )   add - - list 函数 元素 添加 目标 列表 值中 去 ， 元素 一个 元组 ， 第一个 快速 输入 字母 ， 第二个 输入 字符 。 第二个 例子 ，   \\ n   换行 ，     下 光标 停留 地方 。   org 输出 markdown 文档   pandoc 不 支持 org 输出 markdown 文档 ， markdown 输出 org 文档 ， 看不出来 这有 ， 都 懂得 ， emacs org 模式 强大 ， 快乐 模式 下 编辑 工作 ， 还 markdown 文档 输出 org 文档 ？   希望 走 这条 路线 ， org 文档 输出 markdown 文档 ， markdown 文档 放入 静态 动态 网站 框架 下 ， 既有 内容 层 表现 层 分离 灵活 ， emacs org 模式 强大 内容 编辑 能力 。 org 支持 输出 markdown 文档 后台 ， 输出 命令   org - md - export - - markdown   。 即可 ， 并不需要 配置 。   ？ 不太 ， 配置文件 加上 一句 :   (   add - - list   ' org - export - backends   ' md   )   输出 markdown 文档 src 区块 区块 都 输出 缩进 代码 形式 ， 推荐 安装   ox - gfm   宏包来 生成 github 更 友好 markdown 文档 ， src 区块 三个 斜点   ` ` `   符号 封装 环境 ， 加上 语言 标明 。   github 项目 地址     。 常规 其装 上 :   ; ; ;   ox - gfm   (   add - - list   ' load - path   \" ~ / 工作 空间 / myemacs / myorg / ox - gfm \"   )   (   require   ' ox - gfm   )     org - gfm - export - - markdown   命令 生成 结构 更好 一点 markdown 文档 。   Footnotes :   1   参考 网站   2   参考   网站",
            "tags":"archived",
            "url":"articles/emacs-orgmode-learning-notes.html"
        },
        {
            "title":"makefile",
            "text":"NOTICE   本文 已 归档 ， makefile 只能 linux 环境 下 运行 ， 加上 类似 makefile 工具 很多 替代品 ， 嫌 麻烦 随便 写个 python 脚本 管理 下 项目 插入 一个 makefile 文件 好 。   简单 下 makefile   makefile 只能 Linux 环境 下 运行 ， 更 确切 来说 gnu   make 工具 去 运行 Makefile 文件 。   makefile 内容 很 ， 实际上 过于 。 简单 基本功能 很 便利 。   project   =   helloworld   cflags   =   - g   - Wall   $ {   CCFLAGS   }   $ { project }   :   $ {   CC   }   helloworld . c   - o   $ @   $ {   cflags   }   clean   :   rm   $ {   project   }   install   :   cp   $ {   project   }   / usr / local / bin   uninstall   :   rm   / usr / local / bin /   $ {   project   }   . PHONY   :   clean   uninstall   install   便于 理解 ， makefile 有意 采用 一种 bash   shell 接近 风格 。   project =   一个 定义 变量 。 project 变量 脚本 名字 。 makefile 主体 格式 :   target   :   prerequisites     command   生成 target 文件 ， 确保 prerequisites 依赖 文件 都 最新 ， 不 最新 查找 目标 生成 规则 生成 。 target 生成 执行 bash 命令 。 例子 讲解 信息 :   特别 ， 命令 请   Tab 键   隔开   。   变量 读者 例子 ， 有意 采用 类似 bash 脚本 语法 。 写 支持 。   $ @   符号 神秘 东西 ， 目标 文件名 ， 例子 中 目标   $ { target }   ， helloworld ，   $ @     \" helloworld \"   。   . PHONY   跟着 生成 目标 ， 生成 目标 伪 目标 ， 或者说 生成 文件 ， 执行 命令 。     $ { CC }     $ { CCFLAGS }   用户 定义 ， 其是 make 命令 默认 变量 。   $ ( CC )   调用 系统 默认 c 编译器 ， gcc 。   make   命令 不 输入 子 命令 时 ， 默认 执行 输出 第一个 目标 命令 ， 项目 目标 。   makefile 命令 都 一个 独立 终端 ， 终端 不 共享 变量 ， 多个 命令 连接 一个 命令 ， 好 一个 shell 执行 共享 变量 。 （ export 共享 ？ ）   makefile 扫描 两边 ， 第一遍 变量 替换 ， 第二遍 依赖 关系 。 变量 声明 跟着 规则 ， 保证 变量 声明 改变 。   强制 目标 更新   参考   网页   。   大致 所示 ， 设置 一个   FORCE   目标 ， 凡是 依赖 FORCE 目标 都 强制 没 都 再 更新 一遍 ， 原因 FORCE 目标 不 不 依赖 目标 ， makefile 目标 不 ， 每次 都 会 再 更新 生成 一遍 。   $ { project } . org   :   FORCE   python3   make _   $ {   project   }   org . py   FORCE   :",
            "tags":"archived",
            "url":"articles/makefile.html"
        },
        {
            "title":"emacs学习笔记",
            "text":"WARNING   警告 ， 笔者 不怎么 emacs ， 文档 归档 ， 缺少 新 内容 ， 旧 内容 错误 ， 放在 权做 参考 。   前言   打开 emacs 输入 文本 一刻起 ， 入门 。 emacs 说到底 一个 功能 特别 强大 文本编辑 器 ， 角色 文本编辑 器 ， 一切都是 围绕 展开 。   术语   frame :   emacs 图形界面 终端 界面   menu :   frame 上方 菜单栏   tool :   菜单栏 工具栏   echo :   主 编辑 窗口 响应 信息 ， minibuffer 显示 。   window :   tool echo 主 区域 window 区域 ， emacs 分出 很多 window ， 指 window 选中 window ， emacs 很多 buffer ， 选中 window buffer current   buffer 。   buffer :   一个 window 编辑 一个 buffer   scroll   bar :   window 一个 scroll   bar   mode   line :   window 一行 mode   line   格式 :   point :   window 下 cursor 位置 point ， emacs 光标 覆盖 frob o 上 ， point 位置 r o 之间 。   快捷键 操作   快捷键 最 C M 两个 字母 ， C Control 键 ， M Alt 键 。   C - w   按下 Control 键 w 字母 。   C - x   C - c   有个 空格 ， 先 Ctrl + 字母 x ， 再 停顿 ， 再 Ctrl + 字母 c — — 这是 退出 emacs 命令 。   S Shift 键 ， 小写 s Super 键 下 ，   C - x   0   关闭 窗口 ，   C - x   1   只留 一个 窗口 ，   C - x   2   新开 一个 窗口 ，   C - x   3   右边 新开 一个 窗口 。   M + x   执行 emacs   lisp 内部 命令 ，   C - g   取消 minibuff 中 输入 ， 都 很 ， 读者 请 记住 。   M + x   shell   shell ， shell 输入 命令 。   文件 操作   C - x   C - f   新建 一个 文件   C - x   C - s   保存 文件   . emacs 文件 放在   利用 新建 文件 保存 文件 操作 大概 揣测 emacs 系统 【   Portacle   emacs 配置文件 】 ， 新建 一个   ~ / test . txt   即可 。   buffer 操作   C - x   k   关闭 buffer   查找 替换   查找 替换 操作 用到 ， 快捷键 记住 。 后 查找 按键   C - s   ， 看 快捷键 简短 ， 这是 一个 很 快捷键 。 向前 查找   C - r   。 向前 后 查找   C - s     C - r   。   替换 操作 按键   M - %   , 先 输入 匹配 字符串 ， 输入 替换成 ， 接下来   按键   y   替换 ， 按键   n   不 替换 ， 按键   !   替换 。   lisp 语法 简介   接下来 讨论 ， 先 简单 介绍 下 lisp 语法 ， 读者 学会 lisp 语言 ， 接下来 接触 最 emacs   lisp 语法 感到恐惧 。   例子 读者 兴趣 elisp 交互 环境 试验 ， 按键 ：   M - x   ielm   lisp 语言 一大 特色 程序 数据 都 列表 ，   ' ( 1 ,   2 ,   3 )   形式 。   引号 很 关键 ， 输入 lisp 字符串 都 会 eval ， 加个 引号 ， 东西 eval 成 ( 1 ,   2 ,   3 ) 形式 （ 去掉 引号 ） ， 列表 数据 。   ？   x   ' x   x 送入 eval ， 将会 发生 寻址 操作 ， 成 变量 ； 第二个 x 加上 引号 ， eval ， 去掉 引号 ， x 形式 ， x 看作 字符串 ， 送入 eval ， x 字符串 变量 。   lisp 中 程序 结构 一系列 数学 结构 类似 括号 ， 学过 数学 括号 结构 都 ， 先算 再 算 外面 … … . ， 最终 算成 形式   ( +   1   1 )   lisp 实际上 类似 运算 ， ( +   1   1 ) 送入 lisp 运算 会 2 。 lisp 结构 一个 原则 ， 总 括号 第一个 元素 一个 函数 ， ， 将会 发生 错误 。 东西 都 一系列 管他什么 参数 。   再 讲讲 设置 变量 定义 函数 。   设置 变量   设置 变量 两个 方法 ， 方便使用 setq 。   ( set   ' x   1 )   ( setq   x   1 )   set setq 区别 引号 ， setq 不 加上 引号 ， 第一个 元素 字符 形式 总 视作 变量 。   定义 函数   最 简单 形式 所示 ：   (   defun   add   (   x   y   )   (   +   x   y   ) )   定义 一个 add 函数 ， ( add   x   y ) 实际上 执行 ( +   x   y   ) 。   最 简单 lisp 语法 简介 ， 还会 接触 ， 内容 还 很 ， 够 探索 。   配置 简介     . emacs   elisp 语句 emacs 配置 。   protacle   配置 推荐   C : \\ Users \\ wz - game \\ portacle \\ config \\ user . el   配置 。   set - default - font :   设置 默认 字体   set - frame - attribute :   设置 默认 字体大小   两个 命令 放入 . emacs 文件 中 ， 配置 全局 配置 。   (   set - default - font   \" DejaVu   Sans   Mono \"   )   ; 设置 默认 字体   (   set - frame - attribute   ' default   nil   : height   110   )   ; 设置 默认 字体大小 11pt   窗口 最大化   toggle - frame - maximized :   窗口 最大化   . emacs 文件 emacs 打开 窗口 最大化 。   命令 只 emacs24.4 + 版本 。   (   toggle - frame - maximized   )   emacs24.4 版本 想 启动 窗口 最大化 ， 参考   网站   ， emacs 初始化 脚本 上 加上 一句 即可 ：   (   add - - list   ' default - frame - alist   '   (   fullscreen   .   maximized   ) )   复制粘贴 快捷键   复制粘贴 快捷键 改成 常见   Ctrl + C     Ctrl + V   快捷键 ：   (   cua - mode   t   )   更 信息 参见 emacs   CUA 模式   。   global - visual - line - mode :   显示 段落 自动 换行   . emacs 文件 中 emacs 显示 文件 段落 会 自动 换行 。   (   global - visual - line - mode   t   )   - - tutorial :   默认 按键 \" C - h   t \" ， 打开 新手 教程   describe - key :   默认 按键 \" C - h   k \" ， 描述 按键   describe - function :   默认 按键 \" C - h   f \" ，   描述 函数   describe - variable :   默认 按键 \" C - h   v \" ， 描述 变量   三个 函数 学习 emacs   lisp 很多 内部 知识 ， 一条 不错 获取信息 来源   1   。   \" C - x   1 \" 按键 命令 ：   delete - - windows :   默认 按键 \" C - x   1 \" ， 关闭 窗口   split - window - :   默认 按键 \" C - x   2 \" ， 新开 一个 窗口   split - window - :   默认 按键 \" C - x   3 \" ， 右边 新开 一个 窗口   delete - window :   默认 按键 \" C - x   0 \" ， 删除 窗口   global - linum - mode :   左侧 显示 行号   【 portacle 不 推荐 】   . emacs 文件 中 emacs 左侧 永远 显示 行号 ， 参考   网页   。   (   global - linum - mode   t   )   自定义 命令   几个 命令 很 常用 ， 定义 简短 一点 命令   kill - buffer :   默认 按键 \" C - x   k \" ， 关闭 buffer 。   switch - - buffer :   默认 按键 \" C - x   b \" ， 切换 buffer 。   find - file :   默认 按键 \" C - x   C - f \" ， 打开 文件   save - buffer :   默认 按键 \" C - x   C - s \" ， 保存 buffer ， 或者说 意义 上 保存 文件 。   save - - buffers :   默认 按键 \" C - x   s \" ， 保存 buffer ， 或者说 保存 文件 。   save - buffers - kill - terminal :   默认 按键 \" C - x   C - c \" ， 退出 emacs 。   defun 定义新 函数 ， 采用 一种 简单 机制 defalias 原函数 取 一个 新 名字 ：   (   defalias   ' open   ' find - file   )   (   defalias   ' save   ' save - buffer   )   (   defalias   ' saveall   ' save - - buffers   )   (   defalias   ' kill   ' kill - buffer   )   (   defalias   ' buffer   ' switch - - buffer   )   再 emacs ， 发现 smex 一个 open 命令 ， ， 原有 find - file 命令 还 。   CLISP 开发 环境 搭建   推荐   protacle   。   利用 quicklisp 安装 cl - project   slime - repl 输入 ：   (   ql : quickload   : quickproject   )   (   quickproject : make - project   \" wanze _ clisp _ project \"   )   一个 快速 创建 lisp 项目 模板 项目 ， 参考 即可 。   quicklisp   大概 操作 ：   (   ql : quickload   \" vecto \"   )   (   ql : uninstall   system -   )   加载 编写 项目   新建 项目   protacle   安装 目录   projects 文件夹 下 ， 调用 ：   (   ql : quickload   \" wanze _ clisp _ project \"   )   加载 还 东西 都 ， package . lisp   下如要 加上 内容 ：   ; ; ; ;   package . lisp   (   defpackage   # : wanze _ clisp _ project   (   :   # : cl   )   (   : export   # :   ) )   (   - package   wanze _ clisp _ project   )   函数 加   wanze _ clisp _ project . lisp   文件 去 。   (   defun     ( )   (   print   \" \"   ) )   slime   repr   做 ：   CL - USER >   ( ql : quickload   : wanze _ clisp _ project )   To   load   \" wanze _ clisp _ project \" :   Load   1   ASDF   system :   wanze _ clisp _ project   ;   Loading   \" wanze _ clisp _ project \"   ( : WANZE _ CLISP _ PROJECT )   CL - USER >   ( wanze _ clisp _ project : )   \" \"   \" \"   CL - USER >   这是 一种 做法 ， 还 emacs 打开 文件 ， 编写 函数 slime   repr 测试 。   slime   repr 加载 目标 项目 ， 运行 ：   (   - package   wanze _ clisp _ project   )   slime   repr 运行 ：   (     )   打开 主 lisp 文件 编写 函数 ， 光标 放在 函数 ， 执行   Ctrl + c   Ctrl + c   ， 编译 函数 。   再 slime   repr   运行   (     )   会 发现 函数 新 修改 立马 生效 。   读者 情况 阅读 。   smex 插件   smex 插件 用处 ， 打开 emacs ， 按下 M - x ， 会 很多 选项 ， 正是 smex 插件 功能 ， 输入法 ， 很 有用 。   common - lisp 流行 集成 开发 环境   protacle   emacs 命令行 提示 功能 ， 不 安装 smex 插件 ， 讨论 参考 学习 价值 。   smex 官方 github 站     , 看 介绍 大致 差不多 。   git   clone ， 很小 一个 文件 ， 单独 下载 smex . el 文件 ， 文件 放在 一个 喜欢 地方 上 ， 放在 \" ~ / 工作 空间 / emacs / \" 。   . emacs 文件 中 代码 ：   ; smex 插件 设置   ; 新 搜索 路径   (   add - - list   ' load - path   \" ~ / 工作 空间 / emacs / smex \"   )   (   require   ' smex   )   ; 加载 模块   (   global - set - key   (   kbd   \" M - x \"   )   ' smex   )   (   global - set - key   (   kbd   \" M - X \"   )   ' smex - major - mode - commands   )   ; ;   This         M - x .   (   global - set - key   (   kbd   \" C - c   C - c   M - x \"   )   ' execute - extended - command   )   详细 讲解 。   add - - list   一个 函数 ， 接受 一个 列表 变量 ， 一个 元素 列表 中 。   请 看 例子 ，   nil   一个 空 列表 ：   ELISP >   (   set   ' x   nil   )   nil   ELISP >   x   nil   ELISP >   (   add - - list   ' x   1   )   (   1   )   ELISP >   (   add - - list   ' x   2   )   (   2   1   )   ELISP >   (   add - - list   ' x   3   )   (   3   2   1   )     load - path   变量 放着 emacs 加载 插件 时 搜索 路径 ， 一个 新 smex 插件 所在 路径 加进来 ， 路径 放着 目标 el 文件 。   加载 新 插件 \" \" ， 大致 类似 配置 语句 ：   (   add - - list   ' load - path   \" ~ / 工作 空间 / emacs / \"   )   . el 放入 emacs 文件夹 里 文件夹 即可 。   接下来 加载 插件 ：   (   require   ' smex   )   ; 加载 模块   require   函数 跟着 插件 名字 ， smex . el 文件 。   自定义 按键 配置   接下来 进一步 按键 配置 ：   (   global - set - key   (   kbd   \" M - x \"   )   ' smex   )   (   global - set - key   (   kbd   \" M - X \"   )   ' smex - major - mode - commands   )   ; ;   This         M - x .   (   global - set - key   (   kbd   \" C - c   C - c   M - x \"   )   ' execute - extended - command   )   自定义 按键 配置 方式 用来 随意 配置 学到 命令 。   global - set - key   函数 跟着   kbd   函数 按键 字符 封装 ， 第一个 元素 看作 按键 ， 第二个 元素 看作 调用 命令 。   第一个 命令 ， 下 Alt + x 按键 ， 将会 触发 smex 命令 。 谈及 Alt + x 命令 实际上   execute - extended - command   ， 配置 ， 按键 才能 激活 ， 等于 打入冷宫 。   tab 都 自动 换成 space   参考 网页 ：   NoTabs   . emacs 文件 里 代码 ：   (   setq - default   indent - tabs - mode   nil   )   80 列 规则   控制 代码 不 超过 80 列是 一个 好 习惯 ， 起到 控制 写出 缩进 过于 代码 冲动 ， 写 代码 复制粘贴 很 好 网页 pdf 文档 上 显示 。   配置文件 ：   (   add - - list   ' load - path   \" ~ / 工作 空间 / myemacs / fill - column - indicator \"   )   (   require   ' fill - column - indicator   )   (   define - globalized - minor - mode   global - fci - mode   fci - mode   (   lambda   ( )   (   fci - mode   1   ) ) )   (   global - fci - mode   t   )   (   setq   fci - rule - column   80   )   (   setq   fci - rule - color   \" light   green \"   )   该宏包 github 地址     ， 该宏包 emacswiki 地址     。 代码 第五 行是 设置 列宽 80 ， 第六 行是 设置 竖线 颜色 。   第三行 第四行 配置 模式 下 都 会 显示 竖线 ， 看 作业 文档 ， python 脚本 编程语言 ， 设置 没什么 不妥 。 作业 文档 是非 编程语言 org 模式 ， 推荐 单独 设置 。   (   add - hook   ' c - mode - hook   ' fci - mode   )   (   add - hook   ' c++ - mode - hook   ' fci - mode   )   (   add - hook   ' python - mode - hook   ' fci - mode   )   (   add - hook   ' emacs - lisp - mode - hook   ' fci - mode   )   python 模式   python 模式 推荐   python - mode   宏包 内置   python . el   。 宏包 下载     ， 简单 设置   C - c   C - c   运行 python 文件 交互 模式 ， 很 。 这次 默认 python3 ， 很 满意 。 不 python 文件 第一行   # ! / usr / bin / env   python3   python - mode . el 猜到 ， 简单 默认 调用 python3 。 设置 设置 python2 ， 该宏包 github 地址     ， 再 网络 搜索 找寻 答案 。   (   add - - list   ' load - path   \" ~ / 工作 空间 / myemacs / python - mode \"   )   ; 新 搜索 路径   (   require   ' python - mode   )   分 窗口 控制   参考   网页   ， 希望 运行   C - c   C - c   ， 弹出 窗口 平行 模式 ， 模式 ， 设置 :   (   setq - default   py - split - windows - - execute - function   ' split - window - horizontally   )   效果 图 所示 :   快速 启动 emacs   先   emacs   - - daemon   命令 启动 一个 后台 服务器 ， 命令 . bashrc 文件 中 每次 启动 自动 运行 。   系统 desktop 文件 （   / usr / share / applications   找到 ， 用户 主 文件夹   . local / share / applications   再 新建 一个 。   ） 修改 :   Exec = / usr / bin / emacsclient   - c   - a   \" \"   % F   本来   emacs   % F   ， 改为 emacsclient ，   - c   参数 启动 图形界面 。 - a 参数设置 为空 字符串 ， 建立 一个 emacs 后台 服务器 ， 会 自动 创建 一个 。 双击 emacs 关联 文件 自动 快速 emacsclient 打开 。 读者 尝试 ， emacs 打开 文件 确实 很快 ， 带来 。   关闭 frame   emacs   daemon 一个 后台 进程 ，   ps   aux   | grep   emacs   查看 ， emacsclient 建立 frame 窗口 都 关闭 ， emacs 后台 daemon 。   emacsclient 编辑 一个 文件 ， 保存 提示 关闭 ， 没什么 ， emacsclient 打开 buffer 都 ， 编辑 内容 丢失 ， 很 不 符合 用户 习惯 。   查看 进程 号 kill emacs   daemon 进程 做法 ， emacs 输入 命令   kill - emacs   关闭 emacs 后台 服务 进程 ， 方法 。 手工 kill   emacs 后台 服务 进程 操作 ， 调试 ，   emacs   test . org   方式 启动 一个 meacs 进程 调试 。   接下来 不 emacs ， 正确 关闭 emacs 做法 快捷键   C - x   C - c   ， 函数   save - buffers - kill - terminal   ， 快捷键 接触 ， 一个 完整 emacs 进程 中 ， 退出 emacs 命令 ， 确保 buffer 都 保存 ， 退出 。 值得一提的是 函数 关闭 emacs 后台 服务 进程 ， 实际上 熟悉 emacsclient 操作 ， 去 emacs   daemon 概念 ，   C - x   C - c   退出 emacs 命令 即可 。   关闭 buffer 操作 ， 简单 点击 窗口 关闭 图标 ， 关闭 frame ， buffer 。 编辑 完 想要 关闭 buffer ， 执行   kill - buffer   即可 ， 文档 保存 其会 提示 ， 还会 提示 关闭 frame 。   字体   emacs   daemon 启动 图形界面 ， 字体 设置 失效 ， 设置   2   :   ; ;   解决 client 模式 下 字体   (   defun   myfontset   ( )   (   interactive   )   (   set - default - font   \" DejaVu   Sans   Mono \"   )   ; 设置 默认 字体   (   set - face - attribute   ' default   nil   : height   110   )   ; 设置 默认 字体大小 11pt   )   (   add - hook   ' - make - frame - functions   (   lambda   (   frame   )   (   select - frame   frame   )   ;   (   myfontset   ) ) )   思路 frame 加载 再 加载 字体 配置 。   左侧 文件 树 面板   IDE 一个 特色 左侧 一个 文件 树 面板 ， 快速 切换 文件 ， emacs 下 neotree 宏包 类似 功能 。 该项 目的 github 地址     。   很 简单 ， 常规 加载 :   (   add - - list   ' load - path   \" / / path / neotree \"   )   (   require   ' neotree   )   (   global - set - key   [ f8 ]   ' neotree - toggle   )   按下 F8 快速 切换 文件 树 面板 。   pdf 文件 打开 卡住   emacs docview 功能 看 pdf 文件 ， 会 带来 很大 便利 ， 打开 pdf 文件 卡 ，   doc - view - continuous   设置 nil 稍微 缓和 。   (   custom - set - variables   '   (   doc - view - continuous   nil   )   )     neotree 项目 看得出来 很多 地方 进一步 完善 ， 比如说 emacsclient 模式 下 根目录 读取 。   多个 窗口 之间 编号 切换   window - numbering 宏包 不错 ， github 项目 地址     。 该宏包 窗口 编号 ，   M - 1   快速 切换 窗口 焦点 。   官方 推荐 一个 配置 所示 :   (   setq   window - numbering - assign - func   (   lambda   ( )   (     (   equal   (   buffer -   )   \" * Calculator * \"   )   9   ) ) )   还 加上 一句 :   (   window - numbering - mode   )   开启 编号 模式 ， 效果 图 所示 :   更 多窗口 操作 知识 请 参看   网页   ， 介绍 挺 好 。   markdown 模式   markdown - mode 宏包 emacs markdown 渲染 ， 类似 org 模式 折叠 功能 。 github 项目 地址     。   简单 配置 即可 :   (   add - - list   ' load - path   \" ~ / 工作 空间 / myemacs / markdown - mode \"   )   (   autoload   ' markdown - mode   \" markdown - mode \"   \" Major   mode     editing   Markdown   files \"   t   )   (   add - - list   ' auto - mode - alist   '   (   \" \\ \\ . text \\ \\ ' \"   .   markdown - mode   ) )   (   add - - list   ' auto - mode - alist   '   (   \" \\ \\ . markdown \\ \\ ' \"   .   markdown - mode   ) )   (   add - - list   ' auto - mode - alist   '   (   \" \\ \\ . md \\ \\ ' \"   .   markdown - mode   ) )   用法 Tab 折叠 功能 外 ， 再 慢慢 ， 会 不到 ， 介绍 重头戏 ， markdowon 实时 预览 功能 。   markdown 实时 预览   emacs - livedown 宏包 利用 nodejs livedown 模块 功能 ， markdown 文档 实时 显示 网页 端 。 github 项目 地址     。   安装 npm ， npm 安装 livedown 。   sudo   npm   install   livedown   做 配置 :   (   custom - set - variables   '   (   livedown : autostart   t   )   ;   automatically   open   preview     opening   markdown   files   '   (   livedown : port   1337   ) )   ;   port     livedown   server   ; nodejs 服务 端口   (   add - - list   ' load - path   \" ~ / 工作 空间 / myemacs / emacs - livedown \"   )   (   require   ' livedown   )   emacs 双击 一个 md 文件 ， 网页 端 显示 渲染 好 网页 ， livedown 本身 支持 实时 md 文件 实时 更新 。 上 图片吧 :   emacsclient 下 开启 一个 frame 还 执行 命令   livedown : preview   网页 才 会 切换 md 预览 。   文字 模式 下 emacs 操作   ssh 远程 主机 上用 emacs 编辑 文件 ， 文字 模块 下 操作 emacs ， 带来 新 。   光标   参考   网页   。   键盘 上 方向键 辅助 搜索 跳转 很快 ， 不知 方向键 会 出 。 这是 只好 借助 快捷键 。   C - f   一个 字符   C - b   后退 一个 字符   C - p   上移 一行   C - n   下移 一行   M - f   一个 单词   M - b   后退 一个 单词   C - a   行首   C - e   行尾   切换 窗口 焦点   提过 ， 一个 ， 再次 。   C - x   o   切换 窗口 操作 。   Footnotes :   1   参考   mastering - emacs - - - year - guide   2   参考   网页   。",
            "tags":"archived",
            "url":"articles/emacs-learning-notes.html"
        },
        {
            "title":"2019随笔",
            "text":"12 - 20   想 死 ， 活着 ， 类似 薛定谔 猫 ， 处于 一种 死或生 状态 。 无 区别 ， ， 死 。   12 - 19   外部 世界 意义 ， 意义 一个 精神 领域 东西 只 内心世界 。   目的 ， 凡 想 做 事情 这件 事情 意义 所在 。   外 物质 世界 一个 很 令人 沮丧 特性 ， 人 快感 都 易逝 多变 ， 越来越 人 乏味 厌倦 。 人 内在 精神 世界 扎根 物质 世界 之上 ， 人生 都 显得 令人 乏味 厌倦 。 仅仅 内在 精神 需求 赋予 意义 兴奋 活着 人 ， 我愿 称之为 天才 。 人 ， 精神 世界 需求 冲动 都 某种程度 上 物质 世界 发生 关系 ， 我会 辩解 说 ， 生存 ， 就算 生存 无忧 达 不到 境界 。 天才 未来 公民 。   如果说 人类 社会 还 一种 过渡阶段 ， 一个 金字塔 社会 过渡阶段 ， 一时期 内 ， 选拔 手段 天才 选拔 ， 给予 发挥 才能 条件 环境 。 如果说 抨击 中国 高考制度 国外 差 ， 一点 上 ， 高考 只 关心 人 智力 ， 不 关心 天才 内在 精神 世界 。 天才 智力 不差 ， 智力 高 不 天才 。   12 - 16   人 一种 可爱 动物 ， 一百种 方式 忘记 现实 世界 无 意义 。   如果说 一百个 人 十个 人 坦然 接受 生死 ， 很难说 一个 人 坦然 接受 现实 世界 无 意义 。   文学 小说 故事 都 一个 核心 价值 ， 主人公 脱离 世界 无 意义 苦恼 ， 一个 充满 邪恶 造物 世界 ， 一个 邪恶 野心 大 魔王 世界 。 最 现实 文学 ， 文学 世界 主人公 面临 生存 亦 面临 世界 无 意义 苦恼 ， 都 做 之事 。 最 糟糕 文学 故事 套 上 一个 大 设定 ， 会 显出 某种 迷人 成分 ； 文学 亦 基础 上 手段 世界 显得 真实 。   看 工作狂 ， 看 痴迷 TODO 计划 人 ， 一个 痴迷 文学 世界 人 。 评判 任何一方 ， ， 正是 现实 世界 无 意义 本质 ， 才 人 创造 显出 一种 可爱 成分 。 太 极端 病态 东西 【 极端 病态 东西 是因为 拒不承认 现实 世界 无 意义 本质 ， 非得 强 现实 世界 某种意义 ， 头脑 中 创造 世界 现实 世界 混淆 】 ， 想 说 一切都在 淡淡地 显出 一种 美 。 ， 未来 ， 怀疑 人工智能 发展 出 东西 。   站 议会 大厅 下 ， 大声 慷慨激昂 说道 ： 尊敬 天马 星人 ， 也许 地球 人 眼中 都 ， 如同 一只 蚂蚁 捏死 。 想过 ， 地球 上 一百二十 亿人 也许 一百二十 亿 无 意义 ， 人 都 生活 故事 ， 地球 上 至少 一百二十 亿个 故事 ， 残忍 一百二十 亿个 故事 宇宙 中 清除 ？   议会 里 天马 星人 东张西望 ， 更 人 注视 眼前 屏幕 若有所思 ， 打着 字 。   一会儿 ， 议长 说道 ： earth   man ,     made     point .   老实 说 地球 人 不感兴趣 ， 天马 星人 最爱 一个 好 故事 ， 刚才 说 一百二十 亿 故事 真的 。   千真万确 ， 如假包换 。   天马 星人 一致同意 不 消灭 太阳系 ， 从今天起 ， 都 进贡 一个 好 故事 ， 拖 更 ， 立马 地球 扔进 黑洞 去 ， 做 。   喜出望外 鞠 一躬 ， ， ， 尊敬 天马 星 议长 。   12 - 03   写作技巧 学习 ， 一个 作者 最 写作 欲望 冲动 。   更 作家 称为 建筑师 ， 理念 世界 建筑师 。 谈论 梦 东西 ， 在我看来 并不比 现实 世界 缺少 真实性 性 。 柏拉图 来说 ， 理念 世界 。 流动 世界 中 ， 内在 外部 同等 地位 【 理念 世界 高于 现实 世界 ， 艺术 高于 生活 ， 此持 保留意见 】 。   写作 第一 要义 真诚 ， 忠于 内心 。 ， 无规则 。   12 - 8   若论 ， 中心 必 先是 我心 。 若论 ， 必 先是 我心 再有 外 物 。 若论 喧嚣 ， 尘世 再 喧嚣 归于 我心 。 外物 皆 不 ， 我心 必 。 外 物 ， 时间 变化 常理 ， 我心 必 永远 拥有 。 尘世 喧嚣 终归于 平淡 宁静 ， 心不变 。 问 人生意义 人 拥有 外 物 ， 盛名 ， 永存 ， 内心 还 ， 永远 都 。   我心 ， 感受 一个点 阴暗 悲观 ， 潜藏在 内心 ， 想要 自杀 ， 想要 远离 ， 想要 否定一切 。 更 ， 光明 ， 平和 。 我心 ， 做 别人 看 哀伤 ， 做 别人 看 欢快 。   一般来说 心 很 受外物 影响 ， 最起码 心会 某种程度 上 身体 血液 流动 激素 分泌 影响 。 说起 故事 ， 王阳明 临死 之际 ， 那种 身体 状态 下 ， 说道 ， 吾 心 光明 ， 亦 复何言 。 王阳明 说 一生 光明磊落 大话 ， 简单 说 ， 心 光明 ， 也许 下 一刻 王阳明 会 浮现 出 阴暗 黑暗 想法 ， ？ 故事 震撼 心灵 。   还 法国 贵妇 摇尾乞怜 卢梭 写 《 忏悔录 真诚 性 ， 晚年 孤独 山路 间 遐想 漫步 卢梭 写 一个 孤独 漫步者 遐想 真诚 性 。   9 - 19   老师 学生 犯下 罪 内心 一种 执念 ， 世间 事 都 一个 标准答案 。 父母 孩子 犯下 罪 内心 一种 执念 ， 一件 事情 没 预期 发展 ， 还 努力 ， 做 还 好 。   9 - 13   人 不知 人 ， 不知 天 。 除去 内心 人 喜好 感情 ， 人 不 石头 更 感 。 人 也许 不知 人 ， 天 必定 知 。 最 荒诞 虚无主义 表达 人 石头 区别 ， 从不 影响 上天 ， 上天 赋予 感 意义 感 。 如同 石头 ， 世间 一块 石头 ， 上天 照看 中 。   4 - 12   闲暇 时光 人生 精华 。 — — 叔本华 ， 人生 智慧   3 - 21   生命 意义 一书 作者 品味 道理 关进 集中营 ， 精神 满满的 理 好 胡须 。 犹太民族 优秀 在于 。 太多装 逼 大师 ， 拉比 老师 ， 整天 教导 ， 饭前 先 洗手 简单 生活 道理 。",
            "tags":"essay",
            "url":"articles/2019-essay.html"
        }
    ]
}